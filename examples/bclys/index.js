(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
module.exports = { // This file generated by gulp-imagine-64 at 2:02:38 PM on 11/30/2015
	"1-abs-down": {
		type: "image/png",
		data: "iVBORw0KGgoAAAANSUhEUgAAAA4AAAAKCAYAAACE2W/HAAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAAOwgAADsIBFShKgAAAABh0RVh0U29mdHdhcmUAcGFpbnQubmV0IDQuMC41ZYUyZQAAAFFJREFUKFNjQAL/oTTD////CWJkgFMjEAgD8Q4gLkMSgwOsGoGgDCQExcRrRFJImo1ICqmnEUSiYJgkMgYCrDYia8TQBFVIJ6cCAXJ0QDGDDQD67OYX9wdp0wAAAABJRU5ErkJggg=="
	},
	"1-abs-up": {
		type: "image/png",
		data: "iVBORw0KGgoAAAANSUhEUgAAAA4AAAAKCAYAAACE2W/HAAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAAOwgAADsIBFShKgAAAABh0RVh0U29mdHdhcmUAcGFpbnQubmV0IDQuMC41ZYUyZQAAAExJREFUKFPtjYEJACAIBN2hdZqr2dqu3tB8C5qghzPxlAQZJ4iWJ9E8DpACOmh7ZkLLwoWDNPJxSMONSwa5fzSBJy8z/9B6RpfVZaRO2oo/zJVRDvIAAAAASUVORK5CYII="
	},
	"1-down": {
		type: "image/png",
		data: "iVBORw0KGgoAAAANSUhEUgAAAA4AAAAKCAYAAACE2W/HAAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAAOwgAADsIBFShKgAAAABh0RVh0U29mdHdhcmUAcGFpbnQubmV0IDQuMC41ZYUyZQAAAGtJREFUKFOtjoEJgDAQA6uiC7iOc3U2t3sT6Uu+XxDBwFliEtoisnYWM3vFtQG6mWZQ2sEJqvy7tQC6FUzdqLaMpCH1OB1KcXgjBZ8HDhSHEuCIZeW/IcRvwEMFyjey7HjQA317KsvMIuW4AFTUEgvs+3wkAAAAAElFTkSuQmCC"
	},
	"1-up": {
		type: "image/png",
		data: "iVBORw0KGgoAAAANSUhEUgAAAA4AAAAKCAYAAACE2W/HAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAadEVYdFNvZnR3YXJlAFBhaW50Lk5FVCB2My41LjExR/NCNwAAAFBJREFUKFPtjdsNQCEIQ93BdZzL2dwOjw9CuV93AEmOJbYNxcw2DHL2P5wHcdR0mAoDuvxFyXHzBrp4UZQAEoUvTL4oBpLDyiveXVnh5WVKm6iPR8RbHxLhAAAAAElFTkSuQmCC"
	},
	"2-abs-down": {
		type: "image/png",
		data: "iVBORw0KGgoAAAANSUhEUgAAAA4AAAAKCAYAAACE2W/HAAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAAOwgAADsIBFShKgAAAABh0RVh0U29mdHdhcmUAcGFpbnQubmV0IDQuMC41ZYUyZQAAAH5JREFUKFOVkAsNgDAMROcBBxjAAEJwgAMcYGGmsIAGLJS7piE3FjJ2yRvpxus+SWLxTWbWRFOJyAgyuDgNDjD9EWewAzZgvElTVCJshLJfXED3jjwu77pG7UKBCvHTAPgwWeY8Kn5KLN4i81SyyOOdgHfzqMixQBb9FWvSdgNN871AHwblVAAAAABJRU5ErkJggg=="
	},
	"2-abs-up": {
		type: "image/png",
		data: "iVBORw0KGgoAAAANSUhEUgAAAA4AAAAKCAYAAACE2W/HAAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAAOwgAADsIBFShKgAAAABh0RVh0U29mdHdhcmUAcGFpbnQubmV0IDQuMC41ZYUyZQAAAJVJREFUKFN9kAEVgzAMRPEwBzOAgQnBwRzgYBZqCgtowAL7l6VtILB77zc01yttB7SfQRr+0j8uAugJBTb5sMBoni/QYNSQ91/wAW0g2Sbu9VAlhisubcSUeTCscYdrgt8fg0HJgQrScXXXt82DQckBgR6ghymtF0zKMSBQC2nS+mEBJYV0vBV0N1PzwiJKCtorZob5Cy2RFvXFQAKlAAAAAElFTkSuQmCC"
	},
	"2-down": {
		type: "image/png",
		data: "iVBORw0KGgoAAAANSUhEUgAAAA4AAAAKCAYAAACE2W/HAAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAAOwgAADsIBFShKgAAAABh0RVh0U29mdHdhcmUAcGFpbnQubmV0IDQuMC41ZYUyZQAAAJtJREFUKFOFkAsNAjEQRAsXMIADDJwBhOAABzjAwpnCAhqwUN4s2zJQCJO8bGa3018x1ayl1vqXpi3IrWVsuIcF7mrDFWYPTiC3gZUFD3ABbSDFJh6UumtBJ6WNsB/BtugbqSM8T7QBZQw0kK6rt57C24AyBgTagT5msV687Y02zAU9JNP7OfwV0vVuoLeF+swWUV6h7MUvjpTzA6fM6SVV2CbgAAAAAElFTkSuQmCC"
	},
	"2-up": {
		type: "image/png",
		data: "iVBORw0KGgoAAAANSUhEUgAAAA4AAAAKCAYAAACE2W/HAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAadEVYdFNvZnR3YXJlAFBhaW50Lk5FVCB2My41LjExR/NCNwAAAIxJREFUKFOVkFsRgDAMBOsBBxjAAEJwgAMcYAFTWEADFspe+iDQH8jMcrSX6yvEGA0KSf9fSB+k8DBD6GGDUx7sMGTvDhVccIQVtIDKFjHPNSH3bm9yaSGG/4MT/N5Rx9VdZxs7A2kDgupAD7PVOWciz4CgakiDOu8akCak4x2gu1lVzzUhTdBesSUsF/uHHu110bZRAAAAAElFTkSuQmCC"
	},
	"3-abs-down": {
		type: "image/png",
		data: "iVBORw0KGgoAAAANSUhEUgAAAA4AAAAKCAYAAACE2W/HAAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAAOwgAADsIBFShKgAAAABh0RVh0U29mdHdhcmUAcGFpbnQubmV0IDQuMC41ZYUyZQAAAJVJREFUKFONkQENhDAMRecBB2cAAyhAwTnAAQ6wgAa8nIXTcBbGf6NduiyEe8ljadlfOkiBbGvKOT8a6YLiJXf5oy2/8v1PcJKb5ABYJS+8LnTBqMFBFGOpjKfgIBl7t7pyGxQ+InecPcizMYZ8kzFLGnXUGLwLOTS5a6XuCqFFMib3A2p+Tfmq7GgMQU4+vC8/Vy+lEzGdowwHiWM2AAAAAElFTkSuQmCC"
	},
	"3-abs-up": {
		type: "image/png",
		data: "iVBORw0KGgoAAAANSUhEUgAAAA4AAAAKCAYAAACE2W/HAAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAAOwgAADsIBFShKgAAAABh0RVh0U29mdHdhcmUAcGFpbnQubmV0IDQuMC41ZYUyZQAAAJtJREFUKFOFkQERwjAMResBBzOAgSmYAhzgAAdYmAa8YAENWID3SgM5soN/95om6e+lW0OPb5DLTz6bDQOaYIW7fbjBoffGAZdOmEZ9hjN4gTqBjZ6/TUE2B0NeZLLPDUI1BGgHjr32PDUI1SAoRvSNS6+lJqGaJGkBC/9H3ZDFOR8gFNMRHNP3KXN/zZQPEYrRr3ixN7i+aq09ARE7/LLO8L26AAAAAElFTkSuQmCC"
	},
	"3-down": {
		type: "image/png",
		data: "iVBORw0KGgoAAAANSUhEUgAAAA4AAAAKCAYAAACE2W/HAAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAAOwgAADsIBFShKgAAAABh0RVh0U29mdHdhcmUAcGFpbnQubmV0IDQuMC41ZYUyZQAAAKdJREFUKFN1kQERwjAMRQscGMDBDGBgCqYABzjAARamAS9YQAMWyn8hodlt/Xfv0p80uXQrSdXjX7XWLqGTwO3NNQ1iFh9B/S2uufEgcEexI+EaxUMwAN0F98Kb2hjXxmoMwlzMuVRfviMjnQVrz+ZTQWHdAFKsyBsny6WiwroJkiZBwlblsKDTFCI5RrHXdBOsyfsQnl8z5EsKrclzfMUnNef1y5XyBYgdtwl+Lm+LAAAAAElFTkSuQmCC"
	},
	"3-up": {
		type: "image/png",
		data: "iVBORw0KGgoAAAANSUhEUgAAAA4AAAAKCAYAAACE2W/HAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAadEVYdFNvZnR3YXJlAFBhaW50Lk5FVCB2My41LjExR/NCNwAAAJpJREFUKFONkQsRwjAQBeMBBzWAgSqoAhzgAAdYqAa8YAENWAi7+cAx6UDfzPaae32ZS5pyzgVEqe97qA9K58tMaYIVnnrwgFPzPqFOCM5wBTdQF9CY4u7vwBZNbuTiGA3KGOigAzj2WtbBoIwBQX1Ez7iUXjApY0iCFrDxf9QN2ZzjB5QhdAbH9HzKtb/m960ib/Gm17jXXkov3zEEuQ7h10oAAAAASUVORK5CYII="
	},
	"add-column": {
		type: "image/png",
		data: "iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAAOwQAADsEBuJFr7QAAABh0RVh0U29mdHdhcmUAcGFpbnQubmV0IDQuMC41ZYUyZQAAAPVJREFUOE9jUKtncAbi/0RgZwZsACQBUlDwOhwrJtqA3OehyIrBGE0MvwFZj4OwYqjmc9rN7Ft1mtknQ9WLQLUjDEi/749sGxiDxLSb2N6giwMNOwOkIYYAGTjDQLOR5RNME0wMxgcafAxIi+AMA3Q+ugFQ7Iw3DEDiMI3oGMMA9DCA8bFpBmGoOoQBybd8MDBUEYpByGJAjDAg/poniiSIDwzErzA+ugHazWwngDQiEGMuuWHFWk2sH2CaYBiYHs4BadRojDjrjKIITew8UNNO3RbOWUB2LRBjJqTQkw5YMUgOivEn5aCjtlgx0QYQgbEYwMAAAEqqlSGCjw+bAAAAAElFTkSuQmCC"
	},
	"back": {
		type: "image/png",
		data: "iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAD8GlDQ1BJQ0MgUHJvZmlsZQAAOI2NVd1v21QUP4lvXKQWP6Cxjg4Vi69VU1u5GxqtxgZJk6XpQhq5zdgqpMl1bhpT1za2021Vn/YCbwz4A4CyBx6QeEIaDMT2su0BtElTQRXVJKQ9dNpAaJP2gqpwrq9Tu13GuJGvfznndz7v0TVAx1ea45hJGWDe8l01n5GPn5iWO1YhCc9BJ/RAp6Z7TrpcLgIuxoVH1sNfIcHeNwfa6/9zdVappwMknkJsVz19HvFpgJSpO64PIN5G+fAp30Hc8TziHS4miFhheJbjLMMzHB8POFPqKGKWi6TXtSriJcT9MzH5bAzzHIK1I08t6hq6zHpRdu2aYdJYuk9Q/881bzZa8Xrx6fLmJo/iu4/VXnfH1BB/rmu5ScQvI77m+BkmfxXxvcZcJY14L0DymZp7pML5yTcW61PvIN6JuGr4halQvmjNlCa4bXJ5zj6qhpxrujeKPYMXEd+q00KR5yNAlWZzrF+Ie+uNsdC/MO4tTOZafhbroyXuR3Df08bLiHsQf+ja6gTPWVimZl7l/oUrjl8OcxDWLbNU5D6JRL2gxkDu16fGuC054OMhclsyXTOOFEL+kmMGs4i5kfNuQ62EnBuam8tzP+Q+tSqhz9SuqpZlvR1EfBiOJTSgYMMM7jpYsAEyqJCHDL4dcFFTAwNMlFDUUpQYiadhDmXteeWAw3HEmA2s15k1RmnP4RHuhBybdBOF7MfnICmSQ2SYjIBM3iRvkcMki9IRcnDTthyLz2Ld2fTzPjTQK+Mdg8y5nkZfFO+se9LQr3/09xZr+5GcaSufeAfAww60mAPx+q8u/bAr8rFCLrx7s+vqEkw8qb+p26n11Aruq6m1iJH6PbWGv1VIY25mkNE8PkaQhxfLIF7DZXx80HD/A3l2jLclYs061xNpWCfoB6WHJTjbH0mV35Q/lRXlC+W8cndbl9t2SfhU+Fb4UfhO+F74GWThknBZ+Em4InwjXIyd1ePnY/Psg3pb1TJNu15TMKWMtFt6ScpKL0ivSMXIn9QtDUlj0h7U7N48t3i8eC0GnMC91dX2sTivgloDTgUVeEGHLTizbf5Da9JLhkhh29QOs1luMcScmBXTIIt7xRFxSBxnuJWfuAd1I7jntkyd/pgKaIwVr3MgmDo2q8x6IdB5QH162mcX7ajtnHGN2bov71OU1+U0fqqoXLD0wX5ZM005UHmySz3qLtDqILDvIL+iH6jB9y2x83ok898GOPQX3lk3Itl0A+BrD6D7tUjWh3fis58BXDigN9yF8M5PJH4B8Gr79/F/XRm8m241mw/wvur4BGDj42bzn+Vmc+NL9L8GcMn8F1kAcXgSteGGAAABUUlEQVQ4EWNgGLQgZY12e9oa/S/YHIgsx4JNQdwirXaG/4zljEyMjOjy6HJM6ArCJmr0CQjyVBgr2DH++fMXRRqbHIoLfOpU5nELMyfKCasy/Pv/h+H3d4QBuOTgLnDIkl/CI8aSqCCtyPDmywuGb78+Mfz6+g/sAnxyYBdYREs/4pNklRVX4Gd49u4Jw////xk4WTkZfn35x4BPDmQ62AW/f/y/+Pvbf4YfP38y/Prxh+HX9z8MX359ZvgJdAE+ObgBZ98+C3xx7dva+8c/MTCzMTL8+/ef4fvPbww/P/1hwCcHN4DhAMOf8xufh7y8/m3Vw2NfGFjYmRi+//gBDMT/DHjlgCagxMLFrS/C9f5I/Pz393+srCk3PBBBNuGSQzEApPDSzhdxmn8k/v37yxD/+wckFkDiIIBPDqICidR0EJ2t7y0J9AMmwCeHqZrWIgAZ4PYDxftGYgAAAABJRU5ErkJggg=="
	},
	"checked": {
		type: "image/png",
		data: "iVBORw0KGgoAAAANSUhEUgAAAA0AAAAPCAYAAAA/I0V3AAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAAOwgAADsIBFShKgAAAABh0RVh0U29mdHdhcmUAcGFpbnQubmV0IDQuMC41ZYUyZQAAAYJJREFUOE+NkstLglEQxf0fahG0iFrUxm2ElFDYLohCqCDaCAkWPaxIRbFFEJEaGEKLDCoMETRFUAMLyaIHBUG6sSKIMtKFqEhLT818ZUgmDhzu3DPn9z0uV1RrmUwmyGQyqNVqfFvViwBxu5RFPZuLSyGMKhz/qlEsRV19K8xm6y+w7bpBPFnAferjj3bdQX6DpHcAUwavAHUN2RGIZxBJZHH2mC/TUeydwwTZvBegLENNgw7sX6Wh1FswNmPEmjPCDyGRRwCtW9E3tMgdAtQw7GZjYcNX+gza2wJ3ZXsSZUuQ0vWCOV8SHfJJ/uluhbHUj1v8PKNMszIoQNRMHCShD6Wh8zyhrbOPwz8w+STKlCCJ7oRNUzQH63kBs5thBghePXxlj2aUoSxDPcuXPNiLAc5EEZ6HIkbmV2DYiXBPHs0o079+K0DTVj/s11mE00A0L+g4VcDp10qKZMAzytBhMaTRaPmYg885DlcSzSij0eoEiIouoUqlqqqaL2rlEok+Ad4vlfzPoVDsAAAAAElFTkSuQmCC"
	},
	"collapse": {
		type: "image/png",
		data: "iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAAOwQAADsEBuJFr7QAAABh0RVh0U29mdHdhcmUAcGFpbnQubmV0IDQuMC41ZYUyZQAAAPNJREFUOE9jcIoq/Y+MGXCACUc6/4MwlIsAyJrwGaA3UeE/CEO5CECMAYEL3f4HHLCG4AWuqGpAmpAxVBgOQM42X6L2v+B1OBiD2H0H27FahAFAmjUnSP1Pv+//P/d5KBin3fP/r94vgREecA6ya/Q7lf+HnrD/n/U4CAWDxKym6mJ3BcwbhZsz/iu0C8ExyBUgjCxWsDEdbgiMgRIOMDZIcfItHzAGscGSuADM+TAMEgNpir/mCca4DMBrKkhTzCU3MCbbBRFnncGYkAvgmkAA2YDQkw5gTJQLoEwUA4KO2oIxUQYgY5AYSBMyBiscJICBAQCpROGZ6kqHfwAAAABJRU5ErkJggg=="
	},
	"down-arrow": {
		type: "image/png",
		data: "iVBORw0KGgoAAAANSUhEUgAAAAUAAAAKCAYAAAB8OZQwAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAYdEVYdFNvZnR3YXJlAHBhaW50Lm5ldCA0LjAuNWWFMmUAAAA+SURBVBhXhYvRCgAgCAOtqP//4+WWhtBDB1duqBUQ/2W5LLtSMFyW020skuecwOGj6QzfkuExt1LlcqICgG3S7z/SL/jVpgAAAABJRU5ErkJggg=="
	},
	"down-rectangle": {
		type: "image/png",
		data: "iVBORw0KGgoAAAANSUhEUgAAAAkAAAAECAYAAABcDxXOAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAadEVYdFNvZnR3YXJlAFBhaW50Lk5FVCB2My41LjExR/NCNwAAABpJREFUGFdjgIL/eDAKIKgABggqgAE0BQwMAPTlD/Fpi0JfAAAAAElFTkSuQmCC"
	},
	"down": {
		type: "image/png",
		data: "iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAD8GlDQ1BJQ0MgUHJvZmlsZQAAOI2NVd1v21QUP4lvXKQWP6Cxjg4Vi69VU1u5GxqtxgZJk6XpQhq5zdgqpMl1bhpT1za2021Vn/YCbwz4A4CyBx6QeEIaDMT2su0BtElTQRXVJKQ9dNpAaJP2gqpwrq9Tu13GuJGvfznndz7v0TVAx1ea45hJGWDe8l01n5GPn5iWO1YhCc9BJ/RAp6Z7TrpcLgIuxoVH1sNfIcHeNwfa6/9zdVappwMknkJsVz19HvFpgJSpO64PIN5G+fAp30Hc8TziHS4miFhheJbjLMMzHB8POFPqKGKWi6TXtSriJcT9MzH5bAzzHIK1I08t6hq6zHpRdu2aYdJYuk9Q/881bzZa8Xrx6fLmJo/iu4/VXnfH1BB/rmu5ScQvI77m+BkmfxXxvcZcJY14L0DymZp7pML5yTcW61PvIN6JuGr4halQvmjNlCa4bXJ5zj6qhpxrujeKPYMXEd+q00KR5yNAlWZzrF+Ie+uNsdC/MO4tTOZafhbroyXuR3Df08bLiHsQf+ja6gTPWVimZl7l/oUrjl8OcxDWLbNU5D6JRL2gxkDu16fGuC054OMhclsyXTOOFEL+kmMGs4i5kfNuQ62EnBuam8tzP+Q+tSqhz9SuqpZlvR1EfBiOJTSgYMMM7jpYsAEyqJCHDL4dcFFTAwNMlFDUUpQYiadhDmXteeWAw3HEmA2s15k1RmnP4RHuhBybdBOF7MfnICmSQ2SYjIBM3iRvkcMki9IRcnDTthyLz2Ld2fTzPjTQK+Mdg8y5nkZfFO+se9LQr3/09xZr+5GcaSufeAfAww60mAPx+q8u/bAr8rFCLrx7s+vqEkw8qb+p26n11Aruq6m1iJH6PbWGv1VIY25mkNE8PkaQhxfLIF7DZXx80HD/A3l2jLclYs061xNpWCfoB6WHJTjbH0mV35Q/lRXlC+W8cndbl9t2SfhU+Fb4UfhO+F74GWThknBZ+Em4InwjXIyd1ePnY/Psg3pb1TJNu15TMKWMtFt6ScpKL0ivSMXIn9QtDUlj0h7U7N48t3i8eC0GnMC91dX2sTivgloDTgUVeEGHLTizbf5Da9JLhkhh29QOs1luMcScmBXTIIt7xRFxSBxnuJWfuAd1I7jntkyd/pgKaIwVr3MgmDo2q8x6IdB5QH162mcX7ajtnHGN2bov71OU1+U0fqqoXLD0wX5ZM005UHmySz3qLtDqILDvIL+iH6jB9y2x83ok898GOPQX3lk3Itl0A+BrD6D7tUjWh3fis58BXDigN9yF8M5PJH4B8Gr79/F/XRm8m241mw/wvur4BGDj42bzn+Vmc+NL9L8GcMn8F1kAcXgSteGGAAABV0lEQVQ4EWNgGGjAiM0BItl8/7mFGBh+fWdg+A/EMPBi6icM9SwwSWRa1oyHITbKjuHem9sQ4a8MDHtXPmB4gawIysZqwK/v/xk4v3Iw/ABqBAEOIP71A8zEIJgwRIACbJyMDJxcIG2EAVYXQLRxgm0Gs7nZGdhwmIfdAC5WBk5WTgYGoEYQALIYfoNZmATcAIuFxv9ffr/NwArULCbLxnD3z3UGLi52hv/ffjKAIoKHk41BvpXvP8gIQU5ZhgtFV8ExghIthgtV/3fHpTE8YbjLcPfTTYafQMUgA2CAA2jguuX3GK5mPITrgzNgitQWSv2fFlfIcOrPMYYP3z7AhBlAnlm5/AbDrYznKHowYuFW/DPGrEX9DGYszgwCQBtBGkH0yg03MTTDTcfG0N0i9f/o/yn/F/xP+K++Wgrsd2zq8Io5nND57w7EeBURkqy5UEmZAYQsAADbOWDTAxBmkQAAAABJRU5ErkJggg=="
	},
	"empty": {
		type: "image/png",
		data: "iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAYdEVYdFNvZnR3YXJlAHBhaW50Lm5ldCA0LjAuNWWFMmUAAAANSURBVBhXY/j//z8DAAj8Av6IXwbgAAAAAElFTkSuQmCC"
	},
	"expand": {
		type: "image/png",
		data: "iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAAOwgAADsIBFShKgAAAABh0RVh0U29mdHdhcmUAcGFpbnQubmV0IDQuMC41ZYUyZQAAAQ9JREFUOE9jcIoq/Y+MgYCBFAw2AMahmQEK7UL/kTGyHFFeAGkKOmoLxhgGIHNwYZCm0JMOYIzVACCAC2JzEUhTxFlnMCboAmRvIBsQc8kNjPG6AETjMiD+micYE+UCZAwSA2lKvuUDxnhdgIwLNqWDFcNw+n1/MEYWK9iYjqoJhGE2O8QU/FdplPsfesL+f9bjIBQMErOaqgtUjuYCEA1zNghbpyT815wgBbY570Xo/9znof/T7vn/V++X+N93sB2iB6YYhpENALFBCs2XqP0veB0OxiA2TDMIo2gGYZgXYBgkFrjQ7X/AAWsIXuAKFoNhFM34sN5Ehf8g/Pj9QyAXIY6iCB8GORvZ6RD8nwEA/ZSbmLCRhEoAAAAASUVORK5CYII="
	},
	"filter-off": {
		type: "image/png",
		data: "iVBORw0KGgoAAAANSUhEUgAAAA4AAAAMCAYAAABSgIzaAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAYdEVYdFNvZnR3YXJlAHBhaW50Lm5ldCA0LjAuNWWFMmUAAAChSURBVChTzZHBCoUgFET9TqEiskgyWoutQvRLRIr+cR7XQAjiJW/1BgZmMUevXsY5xy9OoDEGMcYiUzeB67qibVuwQjVNA6311V+WBeM4vsLDMEApde/1fY9pmtI453neHEKAlBJd1z0fXtc16PbjODK07zvmeUZVVd8nooc75zJIOX3Gm6i0bVsGKf8xKIRIuyJTLgJJ3nvQzsjW2geIsQ/pr9hMVrSncAAAAABJRU5ErkJggg=="
	},
	"filter-on": {
		type: "image/png",
		data: "iVBORw0KGgoAAAANSUhEUgAAAA4AAAAMCAYAAABSgIzaAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAYdEVYdFNvZnR3YXJlAHBhaW50Lm5ldCA0LjAuNWWFMmUAAACoSURBVChTY3BqfP2fHAzWmDbj7f8p294RhVOBasEa02e+/e/VBmQQCTxaX/9PnvYGoj5ywpv/Qd2ENft3vv4f1gfVBAP+nW/+h/a+ATtn1q73KHjytvdgg3070DTBgHvL6/8g22fsQGiaDmSHA21xaybgIpDHixa8hWssnA8NDEIApCh3LkIjiD2INYJCL2X6W3B8gdhEaQQBUOCA4gyE8+e9xaKJgQEA/74BNE3cElkAAAAASUVORK5CYII="
	},
	"forth": {
		type: "image/png",
		data: "iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAAB3RJTUUH1wkbCxU7wwzUCQAAAAlwSFlzAAAewQAAHsEBw2lUUwAAAARnQU1BAACxjwv8YQUAAACcUExURQAAADhUH3CvOHa3O2igNDZRHl2OLzhUHztYIFF7Kj5dIUBgIkNlJEhtJXi4Pna2Oz1cIUNlJEhtJk94KVF8KlN/K1SBK1WCLFaELVqJLlyOL1+SMGOYMmmiNGmjNG+sN2+tN3GvOHKwOHKxOXOzOXS0OnS1OnW2O3e3PXi4Pn28RH+9RoC+R4bCUInDVJHHXpvMa5zNbqTReabSfVhfgkQAAAAQdFJOUwAEh4eOm56goqSprLPi9P64yPeoAAAAZklEQVQY043FRwKCMAAAwUVAqVYUpAjYY6P9/29eAuSmcxn4ba6rAWIxUQIu3dMYA/K2OU6HgEP9qTK7D0iru3glvgyI3+VJ7D0ZsHsUt8jVZMDmeg6dIWBdbq0xYBXMlIClqfaHL3HSC6GZKibEAAAAAElFTkSuQmCC"
	},
	"pause": {
		type: "image/png",
		data: "iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAB3klEQVQ4jX2Tz0sbURzE3wY8xH+j3i1evBSrUhpRQUwURfxZIirEEiF4k1iqYC/VFjwI4smYlBaClqIHqTFojKmmZq2godgWvejBQgV/RqZvNuERYtYHA8PM7Of0XSH4LFIeKZ/UXEb0rx7IC0XWK5XyC6vm14KWgHZlyG8JSlnlRzm5ls5rswFlBr3bFq7Ez9QW/qR+oCZsAzOqJlwlsz3ZbYMbI7fnAvxiyK33IHm3gV93OxjU3ZCZl6L/LTN2br2X+ZBwZAOepgEv9W7s3YaQTEXh0fvTgIDw0idTm7JbBTcGoCEPwJXoQvx6EbvXXzGQ6FMA+t2bFaNzJV6YA3q/t2H94iNilwvo33EqAH3s8jMiF5/AjSnAGW/G8r8ZhM5n0RdvVwD60LnP6LgxBXRu2TF/No4vfyfh3G5WAHpm82cT4MYU0Bqrhe/Ei8DJCDq+1SsA/YfTUdkNgxtTQFP0OaaO3Jg+9qAlWq0A9MzYcXMfkLkDR6Qcbw87MXHoRGPkmboDembsHJGKPHeQAdStPcHrAztGDxpRv1amAPTM2HGTHyDPs3jpEcb22/Bmvx2Pl4rUKdMzY8fN/VMuMQBWSQ5qAXFF0fMHM81tIud1SL2Tep8RveuBvCD92X9NeXkWOHF72gAAAABJRU5ErkJggg=="
	},
	"play": {
		type: "image/png",
		data: "iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABGdBTUEAANjr9RwUqgAAACBjSFJNAACHDwAAjA0AAPmTAACE5QAAe4IAAOt1AAA/tAAAIlh1a16cAAAD8GlDQ1BJQ0MgUHJvZmlsZQAASMeNVd1v21QUP4lvXKQWP6Cxjg4Vi69VU1u5GxqtxgZJk6XpQhq5zdgqpMl1bhpT1za2021Vn/YCbwz4A4CyBx6QeEIaDMT2su0BtElTQRXVJKQ9dNpAaJP2gqpwrq9Tu13GuJGvfznndz7v0TVAx1ea45hJGWDe8l01n5GPn5iWO1YhCc9BJ/RAp6Z7TrpcLgIuxoVH1sNfIcHeNwfa6/9zdVappwMknkJsVz19HvFpgJSpO64PIN5G+fAp30Hc8TziHS4miFhheJbjLMMzHB8POFPqKGKWi6TXtSriJcT9MzH5bAzzHIK1I08t6hq6zHpRdu2aYdJYuk9Q/881bzZa8Xrx6fLmJo/iu4/VXnfH1BB/rmu5ScQvI77m+BkmfxXxvcZcJY14L0DymZp7pML5yTcW61PvIN6JuGr4halQvmjNlCa4bXJ5zj6qhpxrujeKPYMXEd+q00KR5yNAlWZzrF+Ie+uNsdC/MO4tTOZafhbroyXuR3Df08bLiHsQf+ja6gTPWVimZl7l/oUrjl8OcxDWLbNU5D6JRL2gxkDu16fGuC054OMhclsyXTOOFEL+kmMGs4i5kfNuQ62EnBuam8tzP+Q+tSqhz9SuqpZlvR1EfBiOJTSgYMMM7jpYsAEyqJCHDL4dcFFTAwNMlFDUUpQYiadhDmXteeWAw3HEmA2s15k1RmnP4RHuhBybdBOF7MfnICmSQ2SYjIBM3iRvkcMki9IRcnDTthyLz2Ld2fTzPjTQK+Mdg8y5nkZfFO+se9LQr3/09xZr+5GcaSufeAfAww60mAPx+q8u/bAr8rFCLrx7s+vqEkw8qb+p26n11Aruq6m1iJH6PbWGv1VIY25mkNE8PkaQhxfLIF7DZXx80HD/A3l2jLclYs061xNpWCfoB6WHJTjbH0mV35Q/lRXlC+W8cndbl9t2SfhU+Fb4UfhO+F74GWThknBZ+Em4InwjXIyd1ePnY/Psg3pb1TJNu15TMKWMtFt6ScpKL0ivSMXIn9QtDUlj0h7U7N48t3i8eC0GnMC91dX2sTivgloDTgUVeEGHLTizbf5Da9JLhkhh29QOs1luMcScmBXTIIt7xRFxSBxnuJWfuAd1I7jntkyd/pgKaIwVr3MgmDo2q8x6IdB5QH162mcX7ajtnHGN2bov71OU1+U0fqqoXLD0wX5ZM005UHmySz3qLtDqILDvIL+iH6jB9y2x83ok898GOPQX3lk3Itl0A+BrD6D7tUjWh3fis58BXDigN9yF8M5PJH4B8Gr79/F/XRm8m241mw/wvur4BGDj42bzn+Vmc+NL9L8GcMn8F1kAcXhLu7iPAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAAGHRFWHRTb2Z0d2FyZQBwYWludC5uZXQgNC4wLjVlhTJlAAABPElEQVQ4T2MAgaoTYuJgBrmg+rhcXupCmf9Fe2TDoUKkgYpDChkgA+pOKf4v2il3qWC3pCZUijhQBjUg6Kjt/9CTDv+rDiv8z9skuzRhPgMHVAl+ULwX1YCIs87/Yy65/S/erfA/Z71MGVQZblC4SxarAfHXPP8n3/IBukbudfY6KVeockxQuBm/Aen3/f9nPQ76n7VK+nDGKmFpqDYEyNlInAG5z0P/F7wO/5+5VHomSvjkrJQmyYDURdJbY3eKc0O1MzCkLyfOgKT50rdSl0obQLUhANBEvAakLJD+mTRbIg6qHBMATcZqQMoimf+x0yX7oMpwg4RZkigGgNgxkyX3J0wVlYAqwQ8SZkAMSFsi8z96otSz2EkS9lAp4kDcNKncuKlS/8N7JPOhQqSB6ElCMm4lSNFCNGBgAAAY+v7rj5j+SgAAAABJRU5ErkJggg=="
	},
	"rectangle-spacer": {
		type: "image/png",
		data: "iVBORw0KGgoAAAANSUhEUgAAAAkAAAAECAYAAABcDxXOAAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAAOwQAADsEBuJFr7QAAABh0RVh0U29mdHdhcmUAcGFpbnQubmV0IDQuMC41ZYUyZQAAAA1JREFUGFdjGHSAgQEAAJQAAY8LvLEAAAAASUVORK5CYII="
	},
	"reset": {
		type: "image/png",
		data: "iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAYdEVYdFNvZnR3YXJlAHBhaW50Lm5ldCA0LjAuNWWFMmUAAAL8SURBVDhPbZLZTxNRFMbnDzD65BsurC2tSFlENiG4EARBguzIGkBDwKAsIqA+EAIE45JgogaCxrdqgiQmxhAVjWIEpEioChRKUGmZTpeZaSlQ6OedoVYxnOSXe893vnPvzcml/o+V4WGJrbOmgm+tVLJN+UqeYL1Zp+TbLpy1qz7ud9m2D+u9tjq+qYTmLmbZuUvZIOsmNTnCauOvlWuX77dHuux/wzQ6sIvrbOziKrPBlqa64ZsrwF8u26Jxl4pg7WppxuSbHa52iuJry9rZgtOwZCdsUpgKC8nXtRqsDQ2SxgxY8pPddZbU2drSarHZdqsjxXTqqNl8MhYCXEkO1j59AFeeD6fFDMcXFazkQseECmxBuugROZMwtXKrQ0KxRdl95mPRMMdFgi3KxYZuEWtjn2FJT4HTTA4YHwN7rgTr8/PkkHFYUhNFrzkhjryssIgyRkWOmYKDYAoLxUr/MziNRmI6DUFzmkxwjI6Ie0tWJpwMA+5KA0whwaJmSkrqpgwSuZqRyGAMjyY3q2BXPgEjkRNkZAZarL56Le4FbfXlAGw9vTAGKETNKA1QUkxolJX28IEhOAJr4xOwPeiBkAswMSfAhMe6c/vTPtgePgbtLRdzY0o6Tem85WrdHl/opYFYffeevGIc+n1+ELR/ETTHt+/gWjug85SKGq0IU1K/5CFvf+71gwDXcQNO+wrMDVfF/F+4ztvYIPMxZOS6taX45BZKn5Z1d8HLf32BCAv+Clifv8A6TYO9cxd0TiEMBaWwkadvsBzY7l4s+MgheH/Igux0Wk4ixdTXe8wdDBvS7JdCYE4WDH1tA5aHR+AwMHDo9eDJ8HTnqzArVYgeAW1QhJKpur5T/EyWnkfHZ8mwpkhBYNpLhpkDIdAoDovMyIIw5envrs8eIcN90BsuNv+JxZor6dOHorWTPnKnmgxpO776HnBoYuJVS7e7ol1tW2O++JxsNiOvcTIkYlBNbp7w8seEtwzfImKhDjzUr8nMq14srtrtspOgqN9wa0YvcwzUuQAAAABJRU5ErkJggg=="
	},
	"sortable": {
		type: "image/png",
		data: "iVBORw0KGgoAAAANSUhEUgAAAA4AAAAKCAYAAACE2W/HAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAYdEVYdFNvZnR3YXJlAHBhaW50Lm5ldCA0LjAuNWWFMmUAAAAxSURBVChTY8AD/kNpkgBIEwwTDZA1Ea0ZmyYYHmQAmxNhmCAgSxMMkKUJBvBoYmAAAJCXH+FU1T8+AAAAAElFTkSuQmCC"
	},
	"swap": {
		type: "image/png",
		data: "iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAABGdBTUEAAK/INwWK6QAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAI9SURBVDjLpZNBS9RhEMZ/u60aZAdNSXdLrcxNS82DaRQVRBCUGngwwkOnvkB0yEt0qy/QKSrq5DUSQgLTSi01d80gcrXSTTdTViTU//+ded8ORihFYD4wl+FhYOY3T8A5x2YU3Ij54qOmp833zmX+14CWh431vm9OGs+8W9sPXOm49HsHqxarFhXbZ9W2EQxeECNnxUh0W2Y2kdwIcwtzJCbHY8+uvagBCAG0Vl3G4XDOYZ1jbPbj0ffJ0S6xQrT4AFszsxC1qFPycvJYXl45fOxG7ctXNweOB51zWBzW2V+l7MnbS21JLemFNBmhDIwIxhqMGowKxgjGNxkAISuWB2/uoqIE7Rb255dxMHKInO07CLkMxpMTpOZnmE7NEN4ZQUVITIyPDNyK1wEE1mJsud+QLUavl4cr2o5E64glhumJ9ag629TV1ttRd7VGNWQ/Dd6Ol/6VgguCDTjiYzGWvCWiReX4Pwxe2gPAX/Lx5rx1dAKt7c1OjCBGcOIoyC1kMb1IWTjKvqJSJqbGGR6Nk0gkOBitQMQyNDg0kmj/XA0QMr7hRPkp1ClqBbHKXNY88Q9xineVEC6IUFgQwZ62qFUsFm/Fq9p9Pvx66sl0XdD46y8sKiwuLZL6/o3nvd3Mp+cRJ4gVxCliFRFFjBqAQMOdM06MYHxB/FVEYqRPPG3z0/7qI/kazc/Pp7K6kuSXJEP9b2MznbM1f1D4l4oaI/Uq2qViJ1Ods9ENZ2Hy8dd+NdqtRivXUdhsnH8Cn6RstCM01H4AAAAASUVORK5CYII="
	},
	"unchecked": {
		type: "image/png",
		data: "iVBORw0KGgoAAAANSUhEUgAAAA0AAAAPCAYAAAA/I0V3AAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAAOwgAADsIBFShKgAAAABh0RVh0U29mdHdhcmUAcGFpbnQubmV0IDQuMC41ZYUyZQAAARBJREFUOE+9krtug1AQRPldSio7FQ1tZImOkoKOBomGT0EURC5ino54yTw90WywQhTkIkVWGoF2zuxdrlD+t0zThKZpT0Vmxb8CQRCg6zr0fb8rer7vfwcPxxdcrx+YpgnzPGNZlh9ibxxHlGUJshLSdV0at9tNpg7DIBrX5+OkPM9BVkKGYSBJEtR1jbZrBdiqbVtUVYU0TUFWQq+nE+I4xvvlImGaW7FHjwxZCVmWhbfzGVmWoSgKWXUr9uiRISshx3FkEldomubXauzRI0NWQp7nyUR+NG/rfr/jUXxnjx5vmKyEbNuWox9Xvid6ZMhK6HA4wnVdhGGIKIp2RY8MWQmx+JuoqvpUZFb8L6UonyYL3uOtrFH+AAAAAElFTkSuQmCC"
	},
	"up-arrow": {
		type: "image/png",
		data: "iVBORw0KGgoAAAANSUhEUgAAAAUAAAAKCAYAAAB8OZQwAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAYdEVYdFNvZnR3YXJlAHBhaW50Lm5ldCA0LjAuNWWFMmUAAAA9SURBVBhXbYvRCgAgCAOtqP//Y9tElw8NDrcDzd0DBCd7iSL3E0IvGOpf2fKXeZUFKDcYFMwBlDNWS76bXUM5P9In5AzyAAAAAElFTkSuQmCC"
	},
	"up-down-spin": {
		type: "image/png",
		data: "iVBORw0KGgoAAAANSUhEUgAAAA4AAAAPCAYAAADUFP50AAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAAOwQAADsEBuJFr7QAAABh0RVh0U29mdHdhcmUAcGFpbnQubmV0IDQuMC41ZYUyZQAAAGJJREFUOE+lkwEKACEIBH2Zb/PnHsoGeaVJDUjGOgRRpKpkiIj+y4MME3eDR7kaKOVNsJyMNjIHzGy9YnW6J7qIcrriQimeCqORNABd0fpRTkt8uVUj7EsxC6vs/q3e/Q6iD2bwnByjPXHNAAAAAElFTkSuQmCC"
	},
	"up-down": {
		type: "image/png",
		data: "iVBORw0KGgoAAAANSUhEUgAAAA4AAAAPCAYAAADUFP50AAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAAOwQAADsEBuJFr7QAAABh0RVh0U29mdHdhcmUAcGFpbnQubmV0IDQuMC41ZYUyZQAAAGFJREFUOE+lkkEKQCEIRD2ZJ3Ph3iN4WD9GflpYhj0YYowpGgJmbikd3gjMDFokwbuT1iAiurG5nomgqo5QaPo9ERQRI6Jf7sfGjudy2je23+i0Wl2oQ85TOdlfrJQOazF8br+rqTXQKn0AAAAASUVORK5CYII="
	},
	"up-rectangle": {
		type: "image/png",
		data: "iVBORw0KGgoAAAANSUhEUgAAAAkAAAAECAYAAABcDxXOAAAABGdBTUEAALGPC/xhBQAAAAlwSFlzAAAOwgAADsIBFShKgAAAABp0RVh0U29mdHdhcmUAUGFpbnQuTkVUIHYzLjUuMTFH80I3AAAAHklEQVQYV2PAAv5DaZwApACGsQJkBVgVYlMAxQwMABOrD/GvP+EWAAAAAElFTkSuQmCC"
	},
	"up": {
		type: "image/png",
		data: "iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAD8GlDQ1BJQ0MgUHJvZmlsZQAAOI2NVd1v21QUP4lvXKQWP6Cxjg4Vi69VU1u5GxqtxgZJk6XpQhq5zdgqpMl1bhpT1za2021Vn/YCbwz4A4CyBx6QeEIaDMT2su0BtElTQRXVJKQ9dNpAaJP2gqpwrq9Tu13GuJGvfznndz7v0TVAx1ea45hJGWDe8l01n5GPn5iWO1YhCc9BJ/RAp6Z7TrpcLgIuxoVH1sNfIcHeNwfa6/9zdVappwMknkJsVz19HvFpgJSpO64PIN5G+fAp30Hc8TziHS4miFhheJbjLMMzHB8POFPqKGKWi6TXtSriJcT9MzH5bAzzHIK1I08t6hq6zHpRdu2aYdJYuk9Q/881bzZa8Xrx6fLmJo/iu4/VXnfH1BB/rmu5ScQvI77m+BkmfxXxvcZcJY14L0DymZp7pML5yTcW61PvIN6JuGr4halQvmjNlCa4bXJ5zj6qhpxrujeKPYMXEd+q00KR5yNAlWZzrF+Ie+uNsdC/MO4tTOZafhbroyXuR3Df08bLiHsQf+ja6gTPWVimZl7l/oUrjl8OcxDWLbNU5D6JRL2gxkDu16fGuC054OMhclsyXTOOFEL+kmMGs4i5kfNuQ62EnBuam8tzP+Q+tSqhz9SuqpZlvR1EfBiOJTSgYMMM7jpYsAEyqJCHDL4dcFFTAwNMlFDUUpQYiadhDmXteeWAw3HEmA2s15k1RmnP4RHuhBybdBOF7MfnICmSQ2SYjIBM3iRvkcMki9IRcnDTthyLz2Ld2fTzPjTQK+Mdg8y5nkZfFO+se9LQr3/09xZr+5GcaSufeAfAww60mAPx+q8u/bAr8rFCLrx7s+vqEkw8qb+p26n11Aruq6m1iJH6PbWGv1VIY25mkNE8PkaQhxfLIF7DZXx80HD/A3l2jLclYs061xNpWCfoB6WHJTjbH0mV35Q/lRXlC+W8cndbl9t2SfhU+Fb4UfhO+F74GWThknBZ+Em4InwjXIyd1ePnY/Psg3pb1TJNu15TMKWMtFt6ScpKL0ivSMXIn9QtDUlj0h7U7N48t3i8eC0GnMC91dX2sTivgloDTgUVeEGHLTizbf5Da9JLhkhh29QOs1luMcScmBXTIIt7xRFxSBxnuJWfuAd1I7jntkyd/pgKaIwVr3MgmDo2q8x6IdB5QH162mcX7ajtnHGN2bov71OU1+U0fqqoXLD0wX5ZM005UHmySz3qLtDqILDvIL+iH6jB9y2x83ok898GOPQX3lk3Itl0A+BrD6D7tUjWh3fis58BXDigN9yF8M5PJH4B8Gr79/F/XRm8m241mw/wvur4BGDj42bzn+Vmc+NL9L8GcMn8F1kAcXgSteGGAAABVUlEQVQ4EWNgoDWouVD5H58dTPgkHU7o/D/9YzM+JbjldLdI/T/6f8r/Bf8T/quvlsLpCkZsRqgtlPo/La6K4dSfLQzfv/1k4ORiZ1iw7BLDrfhnGOoxBCCaC4GajzF8+PYBbj47kLVy+Q2GWxnPUfSghIHhQlWgzYUMTxjuAm2GaP4PdAEI/wDi8EgNBu0Z8ijegZtmsdD4/8vvtxlYuVgZFNWEGOyNdcAuAGn+DrT9yPL7DO+/fwW7SJBTluFC0VWwXhaYG0/En4Ubxr2a57+yuSbD4W8HwNKcQPLL918MD6s/gdU8ZLgK08aA4gW46LffDN9/A+39+hOMQS5ghUuiMrAbAFbzneEHkAZhkEG/wAywBAqB1YBf3/8DAxGHDhTtDAzwMEAWZ+NkZPjO/YOBA+R2EACGHRsHhIlOYjXg8akvDBPvbGP4BTTgP8wQdJ2Dhg8A9SSD4ETIHK4AAAAASUVORK5CYII="
	},
};

},{}],2:[function(require,module,exports){
'use strict';

/* eslint-env browser */

(function (module) {  // eslint-disable-line no-unused-expressions

    // This closure supports NodeJS-less client side includes with <script> tags. See https://github.com/joneit/mnm.

    /**
     * @summary Insert base stylesheet into DOM
     * @desc Creates a new `<style>...</style>` element from the named text string(s) and inserts it.
     * @param {string|string[]} cssRules
     * @param {string} [ID]
     * @param {string|Element|undefined|null} [referenceElement]
     * * `undefined` type (or omitted): injects stylesheet at top of `<head...</head>` element
     * * `null` value: injects stylesheet at bottom of `<head>...</head>` element
     * * `Element` type: injects stylesheet immediately before given element
     */
    function cssInjector(cssRules, ID, referenceElement) {
        if (ID) {
            ID = cssInjector.idPrefix + ID;

            if (document.getElementById(ID)) {
                return; // stylesheet already in DOM
            }
        }

        if (typeof referenceElement === 'string') {
            referenceElement = document.querySelector(referenceElement);
            if (!referenceElement) {
                throw 'Cannot find reference element for CSS injection.';
            }
        } else if (referenceElement && !(referenceElement instanceof Element)) {
            throw 'Given value not a reference element.';
        }

        var style = document.createElement('style');
        style.type = 'text/css';
        if (ID) {
            style.id = ID;
        }
        if (cssRules instanceof Array) {
            cssRules = cssRules.join('\n');
        }
        cssRules = '\n' + cssRules + '\n';
        if (style.styleSheet) {
            style.styleSheet.cssText = cssRules;
        } else {
            style.appendChild(document.createTextNode(cssRules));
        }

        var container = referenceElement && referenceElement.parentNode || document.head || document.getElementsByTagName('head')[0];

        if (referenceElement === undefined) {
            referenceElement = container.firstChild;
        }

        container.insertBefore(style, referenceElement);
    }

    cssInjector.idPrefix = 'injected-stylesheet-';

    // Interface
    module.exports = cssInjector;
})(
    typeof module === 'object' && module || (window.cssInjector = {}),
    typeof module === 'object' && module.exports || (window.cssInjector.exports = {})
) || (
    typeof module === 'object' || (window.cssInjector = window.cssInjector.exports)
);

/* About the above IIFE:
 * This file is a "modified node module." It functions as usual in Node.js *and* is also usable directly in the browser.
 * 1. Node.js: The IIFE is superfluous but innocuous.
 * 2. In the browser: The IIFE closure serves to keep internal declarations private.
 * 2.a. In the browser as a global: The logic in the actual parameter expressions + the post-invocation expression
 * will put your API in `window.cssInjector`.
 * 2.b. In the browser as a module: If you predefine a `window.module` object, the results will be in `module.exports`.
 * The bower component `mnm` makes this easy and also provides a global `require()` function for referencing your module
 * from other closures. In either case, this works with both NodeJs-style export mechanisms -- a single API assignment,
 * `module.exports = yourAPI` *or* a series of individual property assignments, `module.exports.property = property`.
 *
 * Before the IIFE runs, the actual parameter expressions are executed:
 * 1. If `module` object defined, we're in NodeJs so assume there is a `module` object with an `exports` object
 * 2. If `module` object undefined, we're in browser so define a `window.cssInjector` object with an `exports` object
 *
 * After the IIFE returns:
 * Because it always returns undefined, the expression after the || will always execute:
 * 1. If `module` object defined, then we're in NodeJs so we're done
 * 2. If `module` object undefined, then we're in browser so redefine`window.cssInjector` as its `exports` object
 */

},{}],3:[function(require,module,exports){
'use strict';

/** @namespace extend-me **/

/** @summary Extends an existing constructor into a new constructor.
 *
 * @returns {ChildConstructor} A new constructor, extended from the given context, possibly with some prototype additions.
 *
 * @desc Extends "objects" (constructors), with optional additional code, optional prototype additions, and optional prototype member aliases.
 *
 * > CAVEAT: Not to be confused with Underscore-style .extend() which is something else entirely. I've used the name "extend" here because other packages (like Backbone.js) use it this way. You are free to call it whatever you want when you "require" it, such as `var inherits = require('extend')`.
 *
 * Provide a constructor as the context and any prototype additions you require in the first argument.
 *
 * For example, if you wish to be able to extend `BaseConstructor` to a new constructor with prototype overrides and/or additions, basic usage is:
 *
 * ```javascript
 * var Base = require('extend-me').Base;
 * var BaseConstructor = Base.extend(basePrototype); // mixes in .extend
 * var ChildConstructor = BaseConstructor.extend(childPrototypeOverridesAndAdditions);
 * var GrandchildConstructor = ChildConstructor.extend(grandchildPrototypeOverridesAndAdditions);
 * ```
 *
 * This function (`extend()`) is added to the new extended object constructor as a property `.extend`, essentially making the object constructor itself easily "extendable." (Note: This is a property of each constructor and not a method of its prototype!)
 *
 * @param {string} [extendedClassName] - This is simply added to the prototype as $$CLASS_NAME. Useful for debugging because all derived constructors appear to have the same name ("Constructor") in the debugger. This property is ignored unless `extend.debug` is explicitly set to a truthy value.
 *
 * @param {extendedPrototypeAdditionsObject} [prototypeAdditions] - Object with members to copy to new constructor's prototype. Most members will be copied to the prototype. Some members, however, have special meanings as explained in the {@link extendedPrototypeAdditionsObject|type definition} (and may or may not be copied to the prototype).
 *
 * @property {boolean} [debug] - See parameter `extendedClassName` _(above)_.
 *
 * @property {object} Base - A convenient base class from which all other classes can be extended.
 *
 * @memberOf extend-me
 */
function extend(extendedClassName, prototypeAdditions) {
    switch (arguments.length) {
        case 0:
            prototypeAdditions = {};
            break;
        case 1:
            prototypeAdditions = extendedClassName;
            if (typeof prototypeAdditions !== 'object') {
                throw 'Single parameter overload must be object.';
            }
            extendedClassName = undefined;
            break;
        case 2:
            if (typeof extendedClassName !== 'string' || typeof prototypeAdditions !== 'object') {
                throw 'Two parameter overload must be string, object.';
            }
            break;
        default:
            throw 'Too many parameters';
    }

    function Constructor() {
        if (prototypeAdditions.preInitialize) {
            prototypeAdditions.preInitialize.apply(this, arguments);
        }

        initializePrototypeChain.apply(this, arguments);

        if (prototypeAdditions.postInitialize) {
            prototypeAdditions.postInitialize.apply(this, arguments);
        }
    }

    Constructor.extend = extend;

    var prototype = Constructor.prototype = Object.create(this.prototype);
    prototype.constructor = Constructor;

    if (extendedClassName && extend.debug) {
        prototype.$$CLASS_NAME = extendedClassName;
    }

    for (var key in prototypeAdditions) {
        if (prototypeAdditions.hasOwnProperty(key)) {
            var value = prototypeAdditions[key];
            switch (key) {
                case 'initializeOwn':
                    // already called above; not needed in prototype
                    break;
                case 'aliases':
                    for (var alias in value) {
                        if (value.hasOwnProperty(alias)) {
                            makeAlias(value[alias], alias);
                        }
                    }
                    break;
                default:
                    if (typeof value === 'string' && value[0] === '#') {
                        makeAlias(value, key.substr(1));
                    } else {
                        prototype[key] = value;
                    }
            }
        }
    }

    return Constructor;

    function makeAlias(value, key) { // eslint-disable-line no-shadow
        prototype[key] = prototypeAdditions[value];
    }
}

extend.Base = function () {};
extend.Base.extend = extend;

/** @typedef {function} extendedConstructor
 * @property prototype.super - A reference to the prototype this constructor was extended from.
 * @property [extend] - If `prototypeAdditions.extendable` was truthy, this will be a reference to {@link extend.extend|extend}.
 */

/** @typedef {object} extendedPrototypeAdditionsObject
 * @property {function} [initialize] - Additional constructor code for new object. This method is added to the new constructor's prototype. Gets passed new object as context + same args as constructor itself. Called on instantiation after similar function in all ancestors called with same signature.
 * @property {function} [initializeOwn] - Additional constructor code for new object. This method is added to the new constructor's prototype. Gets passed new object as context + same args as constructor itself. Called on instantiation after (all) the `initialize` function(s).
 * @property {object} [aliases] - Hash of aliases for prototype members in form `{ key: 'member', ... }` where `key` is the name of an alieas and `'member'` is the name of an existing member in the prototype. Each such key is added to the prototype as a reference to the named member. (The `aliases` object itself is *not* added to prototype.) Alternatively:
 * @property {string} [keys] - Arbitrary property names defined here with string values starting with a `#` character will alias the actual properties named in the strings (following the `#`). This is an alternative to providing an `aliases` hash, perhaps simpler (though subtler). (Use arbitrary identifiers here; don't use the name `keys`!)
 * @property {*} [arbitraryProperties] - Any additional arbitrary properties defined here will be added to the new constructor's prototype. (Use arbitrary identifiers here; don't use the name `aribitraryProperties`!)
 */

/** @summary Call all `initialize` methods found in prototype chain.
 * @desc This recursive routine is called by the constructor.
 * 1. Walks back the prototype chain to `Object`'s prototype
 * 2. Walks forward to new object, calling any `initialize` methods it finds along the way with the same context and arguments with which the constructor was called.
 * @private
 * @memberOf extend-me
 */
function initializePrototypeChain() {
    var term = this,
        args = arguments;
    recur(term);

    function recur(obj) {
        var proto = Object.getPrototypeOf(obj);
        if (proto.constructor !== Object) {
            recur(proto);
            if (proto.initialize) {
                proto.initialize.apply(term, args);
            }
        }
    }
}

module.exports = extend;

},{}],4:[function(require,module,exports){
'use strict';

/* eslint-env node, browser */

var cssInjector = require('css-injector');

/**
 * @constructor FinBar
 * @summary Create a scrollbar object.
 * @desc Creating a scrollbar is a three-step process:
 *
 * 1. Instantiate the scrollbar object by calling this constructor function. Upon instantiation, the DOM element for the scrollbar (with a single child element for the scrollbar "thumb") is created but is not insert it into the DOM.
 * 2. After instantiation, it is the caller's responsibility to insert the scrollbar, {@link FinBar#bar|this.bar}, into the DOM.
 * 3. After insertion, the caller must call {@link FinBar#resize|resize()} at least once to size and position the scrollbar and its thumb. After that, `resize()` should also be called repeatedly on resize events (as the content element is being resized).
 *
 * Suggested configurations:
 * * _**Unbound**_<br/>
 * The scrollbar serves merely as a simple range (slider) control. Omit both `options.onchange` and `options.content`.
 * * _**Bound to virtual content element**_<br/>
 * Virtual content is projected into the element using a custom event handler supplied by the programmer in `options.onchange`. A typical use case would be to handle scrolling of the virtual content. Other use cases include data transformations, graphics transformations, _etc._
 * * _**Bound to real content**_<br/>
 * Set `options.content` to the "real" content element but omit `options.onchange`. This will cause the scrollbar to use the built-in event handler (`this.scrollRealContent`) which implements smooth scrolling of the content element within the container.
 *
 * @param {finbarOptions} [options={}] - Options object. See the type definition for member details.
 */
function FinBar(options) {

    // make bound versions of all the mouse event handler
    var bound = this._bound = {};
    for (key in handlersToBeBound) {
        bound[key] = handlersToBeBound[key].bind(this);
    }

    /**
     * @name thumb
     * @summary The generated scrollbar thumb element.
     * @desc The thumb element's parent element is always the {@link FinBar#bar|bar} element.
     *
     * This property is typically referenced internally only. The size and position of the thumb element is maintained by `_calcThumb()`.
     * @type {Element}
     * @memberOf FinBar.prototype
     */
    var thumb = document.createElement('div');
    thumb.classList.add('thumb');
    thumb.onclick = bound.shortStop;
    thumb.onmouseover = bound.onmouseover;
    this.thumb = thumb;

    /**
     * @name bar
     * @summary The generated scrollbar element.
     * @desc The caller inserts this element into the DOM (typically into the content container) and then calls its {@link FinBar#resize|resize()} method.
     *
     * Thus the node tree is typically:
     * * A **content container** element, which contains:
     *    * The content element(s)
     *    * This **scrollbar element**, which in turn contains:
     *        * The **thumb element**
     *
     * @type {Element}
     * @memberOf FinBar.prototype
     */
    var bar = document.createElement('div');

    bar.classList.add('finbar-vertical');

    bar.appendChild(thumb);
    if (this.paging) {
        bar.onclick = bound.onclick;
    }
    this.bar = bar;

    options = options || {};

    // presets
    this.orientation = 'vertical';
    this._min = this._index = 0;
    this._max = 100;

    // options
    for (var key in options) {
        if (options.hasOwnProperty(key)) {
            var option = options[key];
            switch (key) {

            case 'index':
                this._index = option;
                break;

            case 'range':
                validRange(option);
                this._min = option.min;
                this._max = option.max;
                this.contentSize = option.max - option.min + 1;
                break;

            default:
                if (
                    key.charAt(0) !== '_' &&
                    typeof FinBar.prototype[key] !== 'function'
                ) {
                    // override prototype defaults for standard ;
                    // extend with additional properties (for use in onchange event handlers)
                    this[key] = option;
                }
                break;

            }
        }
    }

    cssInjector(cssFinBars, 'finbar-base', options.cssStylesheetReferenceElement);
}

FinBar.prototype = {

    /**
     * @summary The scrollbar orientation.
     * @desc Set by the constructor to either `'vertical'` or `'horizontal'`. See the similarly named property in the {@link finbarOptions} object.
     *
     * Useful values are `'vertical'` (the default) or `'horizontal'`.
     *
     * Setting this property resets `this.oh` and `this.deltaProp` and changes the class names so as to reposition the scrollbar as per the CSS rules for the new orientation.
     * @default 'vertical'
     * @type {string}
     * @memberOf FinBar.prototype
     */
    set orientation(orientation) {
        if (orientation === this._orientation) {
            return;
        }

        this._orientation = orientation;

        /**
         * @readonly
         * @name oh
         * @summary <u>O</u>rientation <u>h</u>ash for this scrollbar.
         * @desc Set by the `orientation` setter to either the vertical or the horizontal orientation hash. The property should always be synchronized with `orientation`; do not update directly!
         *
         * This object is used internally to access scrollbars' DOM element properties in a generalized way without needing to constantly query the scrollbar orientation. For example, instead of explicitly coding `this.bar.top` for a vertical scrollbar and `this.bar.left` for a horizontal scrollbar, simply code `this.bar[this.oh.leading]` instead. See the {@link orientationHashType} definition for details.
         *
         * This object is useful externally for coding generalized {@link finbarOnChange} event handler functions that serve both horizontal and vertical scrollbars.
         * @type {orientationHashType}
         * @memberOf FinBar.prototype
         */
        this.oh = orientationHashes[this._orientation];

        if (!this.oh) {
            error('Invalid value for `options._orientation.');
        }

        /**
         * @name deltaProp
         * @summary The name of the `WheelEvent` property this scrollbar should listen to.
         * @desc Set by the constructor. See the similarly named property in the {@link finbarOptions} object.
         *
         * Useful values are `'deltaX'`, `'deltaY'`, or `'deltaZ'`. A value of `null` means to ignore mouse wheel events entirely.
         *
         * The mouse wheel is one-dimensional and only emits events with `deltaY` data. This property is provided so that you can override the default of `'deltaX'` with a value of `'deltaY'` on your horizontal scrollbar primarily to accommodate certain "panoramic" interface designs where the mouse wheel should control horizontal rather than vertical scrolling. Just give `{ deltaProp: 'deltaY' }` in your horizontal scrollbar instantiation.
         *
         * Caveat: Note that a 2-finger drag on an Apple trackpad emits events with _both_ `deltaX ` and `deltaY` data so you might want to delay making the above adjustment until you can determine that you are getting Y data only with no X data at all (which is a sure bet you on a mouse wheel rather than a trackpad).

         * @type {object|null}
         * @memberOf FinBar.prototype
         */
        this.deltaProp = this.oh.delta;

        this.bar.className = this.bar.className.replace(/(vertical|horizontal)/g, orientation);

        if (this.bar.style.cssText || this.thumb.style.cssText) {
            this.bar.removeAttribute('style');
            this.thumb.removeAttribute('style');
            this.resize();
        }
    },
    get orientation() {
        return this._orientation;
    },

    /**
     * @summary Callback for scroll events.
     * @desc Set by the constructor via the similarly named property in the {@link finbarOptions} object. After instantiation, `this.onchange` may be updated directly.
     *
     * This event handler is called whenever the value of the scrollbar is changed through user interaction. The typical use case is when the content is scrolled. It is called with the `FinBar` object as its context and the current value of the scrollbar (its index, rounded) as the only parameter.
     *
     * Set this property to `null` to stop emitting such events.
     * @type {function(number)|null}
     * @memberOf FinBar.prototype
     */
    onchange: null,

    /**
     * @summary Add a CSS class name to the bar element's class list.
     * @desc Set by the constructor. See the similarly named property in the {@link finbarOptions} object.
     *
     * The bar element's class list will always include `finbar-vertical` (or `finbar-horizontal` based on the current orientation). Whenever this property is set to some value, first the old prefix+orientation is removed from the bar element's class list; then the new prefix+orientation is added to the bar element's class list. This property causes _an additional_ class name to be added to the bar element's class list. Therefore, this property will only add at most one additional class name to the list.
     *
     * To remove _classname-orientation_ from the bar element's class list, set this property to a falsy value, such as `null`.
     *
     * > NOTE: You only need to specify an additional class name when you need to have mulltiple different styles of scrollbars on the same page. If this is not a requirement, then you don't need to make a new class; you would just create some additional rules using the same selectors in the built-in stylesheet (../css/finbars.css):
     * *`div.finbar-vertical` (or `div.finbar-horizontal`) for the scrollbar
     * *`div.finbar-vertical > div` (or `div.finbar-horizontal > div`) for the "thumb."
     *
     * Of course, your rules should come after the built-ins.
     * @type {string}
     * @memberOf FinBar.prototype
     */
    set classPrefix(prefix) {
        if (this._classPrefix) {
            this.bar.classList.remove(this._classPrefix + this.orientation);
        }

        this._classPrefix = prefix;

        if (prefix) {
            this.bar.classList.add(prefix + '-' + this.orientation);
        }
    },
    get classPrefix() {
        return this._classPrefix;
    },

    /**
     * @name increment
     * @summary Number of scrollbar index units representing a pageful. Used exclusively for paging up and down and for setting thumb size relative to content size.
     * @desc Set by the constructor. See the similarly named property in the {@link finbarOptions} object.
     *
     * Can also be given as a parameter to the {@link FinBar#resize|resize} method, which is pertinent because content area size changes affect the definition of a "pageful." However, you only need to do this if this value is being used. It not used when:
     * * you define `paging.up` and `paging.down`
     * * your scrollbar is using `scrollRealContent`
     * @type {number}
     * @memberOf FinBar.prototype
     */
    increment: 1,

    /**
     * @name barStyles
     * @summary Scrollbar styles to be applied by {@link FinBar#resize|resize()}.
     * @desc Set by the constructor. See the similarly named property in the {@link finbarOptions} object.
     *
     * This is a value to be assigned to {@link FinBar#styles|styles} on each call to {@link FinBar#resize|resize()}. That is, a hash of values to be copied to the scrollbar element's style object on resize; or `null` for none.
     *
     * @see {@link FinBar#style|style}
     * @type {finbarStyles|null}
     * @memberOf FinBar.prototype
     */
    barStyles: null,

    /**
     * @name style
     * @summary Additional scrollbar styles.
     * @desc See type definition for more details. These styles are applied directly to the scrollbar's `bar` element.
     *
     * Values are adjusted as follows before being applied to the element:
     * 1. Included "pseudo-property" names from the scrollbar's orientation hash, {@link FinBar#oh|oh}, are translated to actual property names before being applied.
     * 2. When there are margins, percentages are translated to absolute pixel values because CSS ignores margins in its percentage calculations.
     * 3. If you give a value without a unit (a raw number), "px" unit is appended.
     *
     * General notes:
     * 1. It is always preferable to specify styles via a stylesheet. Only set this property when you need to specifically override (a) stylesheet value(s).
     * 2. Can be set directly or via calls to the {@link FinBar#resize|resize} method.
     * 3. Should only be set after the scrollbar has been inserted into the DOM.
     * 4. Before applying these new values to the element, _all_ in-line style values are reset (by removing the element's `style` attribute), exposing inherited values (from stylesheets).
     * 5. Empty object has no effect.
     * 6. Falsey value in place of object has no effect.
     *
     * > CAVEAT: Do not attempt to treat the object you assign to this property as if it were `this.bar.style`. Specifically, changing this object after assigning it will have no effect on the scrollbar. You must assign it again if you want it to have an effect.
     *
     * @see {@link FinBar#barStyles|barStyles}
     * @type {finbarStyles}
     * @memberOf FinBar.prototype
     */
    set style(styles) {
        var keys = Object.keys(styles = extend({}, styles, this._auxStyles));

        if (keys.length) {
            var bar = this.bar,
                barRect = bar.getBoundingClientRect(),
                container = this.container || bar.parentElement,
                containerRect = container.getBoundingClientRect(),
                oh = this.oh;

            // Before applying new styles, revert all styles to values inherited from stylesheets
            bar.removeAttribute('style');

            keys.forEach(function (key) {
                var val = styles[key];

                if (key in oh) {
                    key = oh[key];
                }

                if (!isNaN(Number(val))) {
                    val = (val || 0) + 'px';
                } else if (/%$/.test(val)) {
                    // When bar size given as percentage of container, if bar has margins, restate size in pixels less margins.
                    // (If left as percentage, CSS's calculation will not exclude margins.)
                    var oriented = axis[key],
                        margins = barRect[oriented.marginLeading] + barRect[oriented.marginTrailing];
                    if (margins) {
                        val = parseInt(val, 10) / 100 * containerRect[oriented.size] - margins + 'px';
                    }
                }

                bar.style[key] = val;
            });
        }
    },

    /**
     * @readonly
     * @name paging
     * @summary Enable page up/dn clicks.
     * @desc Set by the constructor. See the similarly named property in the {@link finbarOptions} object.
     *
     * If truthy, listen for clicks in page-up and page-down regions of scrollbar.
     *
     * If an object, call `.paging.up()` on page-up clicks and `.paging.down()` will be called on page-down clicks.
     *
     * Changing the truthiness of this value after instantiation currently has no effect.
     * @type {boolean|object}
     * @memberOf FinBar.prototype
     */
    paging: true,

    /**
     * @name range
     * @summary Setter for the minimum and maximum scroll values.
     * @desc Set by the constructor. These values are the limits for {@link FooBar#index|index}.
     *
     * The setter accepts an object with exactly two numeric properties: `.min` which must be less than `.max`. The values are extracted and the object is discarded.
     *
     * The getter returns a new object with `.min` and '.max`.
     *
     * @type {rangeType}
     * @memberOf FinBar.prototype
     */
    set range(range) {
        validRange(range);
        this._min = range.min;
        this._max = range.max;
        this.contentSize = range.max - range.min + 1;
        this.index = this.index; // re-clamp
    },
    get range() {
        return {
            min: this._min,
            max: this._max
        };
    },

    /**
     * @summary Index value of the scrollbar.
     * @desc This is the position of the scroll thumb.
     *
     * Setting this value clamps it to {@link FinBar#min|min}..{@link FinBar#max|max}, scroll the content, and moves thumb.
     *
     * Getting this value returns the current index. The returned value will be in the range `min`..`max`. It is intentionally not rounded.
     *
     * Use this value as an alternative to (or in addition to) using the {@link FinBar#onchange|onchange} callback function.
     *
     * @see {@link FinBar#_setScroll|_setScroll}
     * @type {number}
     * @memberOf FinBar.prototype
     */
    set index(idx) {
        idx = Math.min(this._max, Math.max(this._min, idx)); // clamp it
        this._setScroll(idx);
        // this._setThumbSize();
    },
    get index() {
        return this._index;
    },

    /**
     * @private
     * @summary Move the thumb.
     * @desc Also displays the index value in the test panel and invokes the callback.
     * @param idx - The new scroll index, a value in the range `min`..`max`.
     * @param [scaled=f(idx)] - The new thumb position in pixels and scaled relative to the containing {@link FinBar#bar|bar} element, i.e., a proportional number in the range `0`..`thumbMax`. When omitted, a function of `idx` is used.
     * @memberOf FinBar.prototype
     */
    _setScroll: function (idx, scaled) {
        this._index = idx;

        // Display the index value in the test panel
        if (this.testPanelItem && this.testPanelItem.index instanceof Element) {
            this.testPanelItem.index.innerHTML = Math.round(idx);
        }

        // Call the callback
        if (this.onchange) {
            this.onchange.call(this, Math.round(idx));
        }

        // Move the thumb
        if (scaled === undefined) {
            scaled = (idx - this._min) / (this._max - this._min) * this._thumbMax;
        }
        this.thumb.style[this.oh.leading] = scaled + 'px';
    },

    scrollRealContent: function (idx) {
        var containerRect = this.content.parentElement.getBoundingClientRect(),
            sizeProp = this.oh.size,
            maxScroll = Math.max(0, this.content[sizeProp] - containerRect[sizeProp]),
            //scroll = Math.min(idx, maxScroll);
            scroll = (idx - this._min) / (this._max - this._min) * maxScroll;
        //console.log('scroll: ' + scroll);
        this.content.style[this.oh.leading] = -scroll + 'px';
    },

    /**
     * @summary Recalculate thumb position.
     *
     * @desc This method recalculates the thumb size and position. Call it once after inserting your scrollbar into the DOM, and repeatedly while resizing the scrollbar (which typically happens when the scrollbar's parent is resized by user.
     *
     * > This function shifts args if first arg omitted.
     *
     * @param {number} [increment=this.increment] - Resets {@link FooBar#increment|increment} (see).
     *
     * @param {finbarStyles} [barStyles=this.barStyles] - (See type definition for details.) Scrollbar styles to be applied to the bar element.
     *
     * Only specify a `barStyles` object when you need to override stylesheet values. If provided, becomes the new default (`this.barStyles`), for use as a default on subsequent calls.
     *
     * It is generally the case that the scrollbar's new position is sufficiently described by the current styles. Therefore, it is unusual to need to provide a `barStyles` object on every call to `resize`.
     *
     * @returns {FinBar} Self for chaining.
     * @memberOf FinBar.prototype
     */
    resize: function (increment, barStyles) {
        var bar = this.bar;

        if (!bar.parentNode) {
            return; // not in DOM yet so nothing to do
        }

        var container = this.container || bar.parentElement,
            containerRect = container.getBoundingClientRect();

        // shift args if if 1st arg omitted
        if (typeof increment === 'object') {
            barStyles = increment;
            increment = undefined;
        }

        this.style = this.barStyles = barStyles || this.barStyles;

        // Bound to real content: Content was given but no onchange handler.
        // Set up .onchange, .containerSize, and .increment.
        // Note this only makes sense if your index unit is pixels.
        if (this.content) {
            if (!this.onchange) {
                this.onchange = this.scrollRealContent;
                this.contentSize = this.content[this.oh.size];
                this._min = 0;
                this._max = this.contentSize - 1;
            }
        }
        if (this.onchange === this.scrollRealContent) {
            this.containerSize = containerRect[this.oh.size];
            this.increment = this.containerSize / (this.contentSize - this.containerSize) * (this._max - this._min);
        } else {
            this.containerSize = 1;
            this.increment = increment || this.increment;
        }

        var index = this.index;
        this.testPanelItem = this.testPanelItem || this._addTestPanelItem();
        this._setThumbSize();
        this.index = index;

        if (this.deltaProp !== null) {
            container.addEventListener('wheel', this._bound.onwheel);
        }

        return this;
    },

    /**
     * @summary Shorten trailing end of scrollbar by thickness of some other scrollbar.
     * @desc In the "classical" scenario where vertical scroll bar is on the right and horizontal scrollbar is on the bottom, you want to shorten the "trailing end" (bottom and right ends, respectively) of at least one of them so they don't overlay.
     *
     * This convenience function is an programmatic alternative to hardcoding the correct style with the correct value in your stylesheet; or setting the correct style with the correct value in the {@link FinBar#barStyles|barStyles} object.
     *
     * @see {@link FinBar#foreshortenBy|foreshortenBy}.
     *
     * @param {FinBar|null} otherFinBar - Other scrollbar to avoid by shortening this one; `null` removes the trailing space
     * @returns {FinBar} For chaining
     */
    shortenBy: function (otherFinBar) { return this.shortenEndBy('trailing', otherFinBar); },

    /**
     * @summary Shorten leading end of scrollbar by thickness of some other scrollbar.
     * @desc Supports non-classical scrollbar scenarios where vertical scroll bar may be on left and horizontal scrollbar may be on top, in which case you want to shorten the "leading end" rather than the trailing end.
     * @see {@link FinBar#shortenBy|shortenBy}.
     * @param {FinBar|null} otherFinBar - Other scrollbar to avoid by shortening this one; `null` removes the trailing space
     * @returns {FinBar} For chaining
     */
    foreshortenBy: function (otherFinBar) { return this.shortenEndBy('leading', otherFinBar); },

    /**
     * @summary Generalized shortening function.
     * @see {@link FinBar#shortenBy|shortenBy}.
     * @see {@link FinBar#foreshortenBy|foreshortenBy}.
     * @param {string} whichEnd - a CSS style property name or an orientation hash name that translates to a CSS style property name.
     * @param {FinBar|null} otherFinBar - Other scrollbar to avoid by shortening this one; `null` removes the trailing space
     * @returns {FinBar} For chaining
     */
    shortenEndBy: function (whichEnd, otherFinBar) {
        if (!otherFinBar) {
            delete this._auxStyles;
        } else if (otherFinBar instanceof FinBar && otherFinBar.orientation !== this.orientation) {
            var otherStyle = window.getComputedStyle(otherFinBar.bar),
                ooh = orientationHashes[otherFinBar.orientation];
            this._auxStyles = {};
            this._auxStyles[whichEnd] = otherStyle[ooh.thickness];
        }
        return this; // for chaining
    },

    /**
     * @private
     * @summary Sets the proportional thumb size and hides thumb when 100%.
     * @desc The thumb size has an absolute minimum of 20 (pixels).
     * @memberOf FinBar.prototype
     */
    _setThumbSize: function () {
        var oh = this.oh,
            thumbComp = window.getComputedStyle(this.thumb),
            thumbMarginLeading = parseInt(thumbComp[oh.marginLeading]),
            thumbMarginTrailing = parseInt(thumbComp[oh.marginTrailing]),
            thumbMargins = thumbMarginLeading + thumbMarginTrailing,
            barSize = this.bar.getBoundingClientRect()[oh.size],
            thumbSize = Math.max(20, barSize * this.containerSize / this.contentSize);

        if (this.containerSize < this.contentSize) {
            this.bar.style.visibility = 'visible';
            this.thumb.style[oh.size] = thumbSize + 'px';
        } else {
            this.bar.style.visibility = 'hidden';
        }

        /**
         * @private
         * @name _thumbMax
         * @summary Maximum offset of thumb's leading edge.
         * @desc This is the pixel offset within the scrollbar of the thumb when it is at its maximum position at the extreme end of its range.
         *
         * This value takes into account the newly calculated size of the thumb element (including its margins) and the inner size of the scrollbar (the thumb's containing element, including _its_ margins).
         *
         * NOTE: Scrollbar padding is not taken into account and assumed to be 0 in the current implementation and is assumed to be `0`; use thumb margins in place of scrollbar padding.
         * @type {number}
         * @memberOf FinBar.prototype
         */
        this._thumbMax = barSize - thumbSize - thumbMargins;

        this._thumbMarginLeading = thumbMarginLeading; // used in mousedown
    },

    /**
     * @summary Remove the scrollbar.
     * @desc Unhooks all the event handlers and then removes the element from the DOM. Always call this method prior to disposing of the scrollbar object.
     * @memberOf FinBar.prototype
     */
    remove: function () {
        this._removeEvt('mousedown');
        this._removeEvt('mousemove');
        this._removeEvt('mouseup');

        (this.container || this.bar.parentElement)._removeEvt('wheel', this._bound.onwheel);

        this.bar.onclick =
            this.thumb.onclick =
                this.thumb.onmouseover =
                    this.thumb.transitionend =
                        this.thumb.onmouseout = null;

        this.bar.remove();
    },

    /**
     * @private
     * @function _addTestPanelItem
     * @summary Append a test panel element.
     * @desc If there is a test panel in the DOM (typically an `<ol>...</ol>` element) with class names of both `this.classPrefix` and `'test-panel'` (or, barring that, any element with class name `'test-panel'`), an `<li>...</li>` element will be created and appended to it. This new element will contain a span for each class name given.
     *
     * You should define a CSS selector `.listening` for these spans. This class will be added to the spans to alter their appearance when a listener is added with that class name (prefixed with 'on').
     *
     * (This is an internal function that is called once by the constructor on every instantiation.)
     * @returns {Element|undefined} The appended `<li>...</li>` element or `undefined` if there is no test panel.
     * @memberOf FinBar.prototype
     */
    _addTestPanelItem: function () {
        var testPanelItem,
            testPanelElement = document.querySelector('.' + this._classPrefix + '.test-panel') || document.querySelector('.test-panel');

        if (testPanelElement) {
            var testPanelItemPartNames = [ 'mousedown', 'mousemove', 'mouseup', 'index' ],
                item = document.createElement('li');

            testPanelItemPartNames.forEach(function (partName) {
                item.innerHTML += '<span class="' + partName + '">' + partName.replace('mouse', '') + '</span>';
            });

            testPanelElement.appendChild(item);

            testPanelItem = {};
            testPanelItemPartNames.forEach(function (partName) {
                testPanelItem[partName] = item.getElementsByClassName(partName)[0];
            });
        }

        return testPanelItem;
    },

    _addEvt: function (evtName) {
        var spy = this.testPanelItem && this.testPanelItem[evtName];
        if (spy) { spy.classList.add('listening'); }
        window.addEventListener(evtName, this._bound['on' + evtName]);
    },

    _removeEvt: function (evtName) {
        var spy = this.testPanelItem && this.testPanelItem[evtName];
        if (spy) { spy.classList.remove('listening'); }
        window.removeEventListener(evtName, this._bound['on' + evtName]);
    }
};

function extend(obj) {
    for (var i = 1; i < arguments.length; ++i) {
        var objn = arguments[i];
        if (objn) {
            for (var key in objn) {
                obj[key] = objn[key];
            }
        }
    }
    return obj;
}

function validRange(range) {
    var keys = Object.keys(range),
        valid =  keys.length === 2 &&
            typeof range.min === 'number' &&
            typeof range.max === 'number' &&
            range.min <= range.max;

    if (!valid) {
        error('Invalid .range object.');
    }
}

/**
 * @private
 * @name handlersToBeBound
 * @type {object}
 * @desc The functions defined in this object are all DOM event handlers that are bound by the FinBar constructor to each new instance. In other words, the `this` value of these handlers, once bound, refer to the FinBar object and not to the event emitter. "Do not consume raw."
 */
var handlersToBeBound = {
    shortStop: function (evt) {
        evt.stopPropagation();
    },

    onwheel: function (evt) {
        this.index += evt[this.deltaProp];
        evt.stopPropagation();
        evt.preventDefault();
    },

    onclick: function (evt) {
        var thumbBox = this.thumb.getBoundingClientRect(),
            goingUp = evt[this.oh.coordinate] < thumbBox[this.oh.leading];

        if (typeof this.paging === 'object') {
            this.index = this.paging[goingUp ? 'up' : 'down'](Math.round(this.index));
        } else {
            this.index += goingUp ? -this.increment : this.increment;
        }

        // make the thumb glow momentarily
        this.thumb.classList.add('hover');
        var self = this;
        this.thumb.addEventListener('transitionend', function waitForIt() {
            this.removeEventListener('transitionend', waitForIt);
            self._bound.onmouseup(evt);
        });

        evt.stopPropagation();
    },

    onmouseover: function () {
        this.thumb.classList.add('hover');
        this.thumb.onmouseout = this._bound.onmouseout;
        this._addEvt('mousedown');
    },

    onmouseout: function () {
        this._removeEvt('mousedown');
        this.thumb.onmouseover = this._bound.onmouseover;
        this.thumb.classList.remove('hover');
    },

    onmousedown: function (evt) {
        this._removeEvt('mousedown');
        this.thumb.onmouseover = this.thumb.onmouseout = null;

        var thumbBox = this.thumb.getBoundingClientRect();
        this.pinOffset = evt[this.oh.axis] - thumbBox[this.oh.leading] + this.bar.getBoundingClientRect()[this.oh.leading] + this._thumbMarginLeading;
        document.documentElement.style.cursor = 'default';

        this._addEvt('mousemove');
        this._addEvt('mouseup');

        evt.stopPropagation();
        evt.preventDefault();
    },

    onmousemove: function (evt) {
        var scaled = Math.min(this._thumbMax, Math.max(0, evt[this.oh.axis] - this.pinOffset));
        var idx = scaled / this._thumbMax * (this._max - this._min) + this._min;

        this._setScroll(idx, scaled);

        evt.stopPropagation();
        evt.preventDefault();
    },

    onmouseup: function (evt) {
        this._removeEvt('mousemove');
        this._removeEvt('mouseup');

        document.documentElement.style.cursor = 'auto';

        var thumbBox = this.thumb.getBoundingClientRect();
        if (
            thumbBox.left <= evt.clientX && evt.clientX <= thumbBox.right &&
            thumbBox.top <= evt.clientY && evt.clientY <= thumbBox.bottom
        ) {
            this._bound.onmouseover(evt);
        } else {
            this._bound.onmouseout(evt);
        }

        evt.stopPropagation();
        evt.preventDefault();
    }
};

var orientationHashes = {
    vertical: {
        coordinate:     'clientY',
        axis:           'pageY',
        size:           'height',
        outside:        'right',
        inside:         'left',
        leading:        'top',
        trailing:       'bottom',
        marginLeading:  'marginTop',
        marginTrailing: 'marginBottom',
        thickness:      'width',
        delta:          'deltaY'
    },
    horizontal: {
        coordinate:     'clientX',
        axis:           'pageX',
        size:           'width',
        outside:        'bottom',
        inside:         'top',
        leading:        'left',
        trailing:       'right',
        marginLeading:  'marginLeft',
        marginTrailing: 'marginRight',
        thickness:      'height',
        delta:          'deltaX'
    }
};

var axis = {
    top:    'vertical',
    bottom: 'vertical',
    height: 'vertical',
    left:   'horizontal',
    right:  'horizontal',
    width:  'horizontal'
};

var cssFinBars; // definition inserted by gulpfile between following comments
/* inject:css */
cssFinBars = 'div.finbar-horizontal,div.finbar-vertical{position:absolute;margin:3px}div.finbar-horizontal>.thumb,div.finbar-vertical>.thumb{position:absolute;background-color:#d3d3d3;-webkit-box-shadow:0 0 1px #000;-moz-box-shadow:0 0 1px #000;box-shadow:0 0 1px #000;border-radius:4px;margin:2px;opacity:.4;transition:opacity .5s}div.finbar-horizontal>.thumb.hover,div.finbar-vertical>.thumb.hover{opacity:1;transition:opacity .5s}div.finbar-vertical{top:0;bottom:0;right:0;width:11px}div.finbar-vertical>.thumb{top:0;right:0;width:7px}div.finbar-horizontal{left:0;right:0;bottom:0;height:11px}div.finbar-horizontal>.thumb{left:0;bottom:0;height:7px}';
/* endinject */

function error(msg) {
    throw 'finbars: ' + msg;
}

// Interface
module.exports = FinBar;

},{"css-injector":2}],5:[function(require,module,exports){
/* eslint-env browser */

'use strict';

var rectangular = require('rectangular');

var gestures = require('./js/polymergestures.dev.js');
var GraphicsContext = require('./js/GraphicsContext.js');

var RESIZE_POLLING_INTERVAL = 200,
    paintables = [],
    resizables = [],
    paintLoopRunning = true,
    resizeLoopRunning = true,
    charMap = makeCharMap();

function Canvas(div, component) {
    var self = this;

    this.div = div;
    this._component = component;

    this.dragEndtime = Date.now();

    this.canvas = document.createElement('canvas');
    this.div.appendChild(this.canvas);

    this.canvas.style.outline = 'none';

    // this.focuser = document.createElement('button');
    // this.focuser.style.position = 'absolute';
    // this.focuser.style.top = '0px';
    // this.focuser.style.left = '0px';
    // this.focuser.style.zIndex = '-1';
    // this.focuser.style.outline = 'none';
    // this.div.appendChild(this.focuser);

    this.canvasCTX = this.canvas.getContext('2d');
    this.gc = new GraphicsContext(this.canvasCTX);

    this.buffer = document.createElement('canvas');
    this.bufferCTX = this.buffer.getContext('2d');
    this.bufferGC = new GraphicsContext(this.bufferCTX);

    this.mouseLocation = new rectangular.Point(-1, -1);
    this.dragstart = new rectangular.Point(-1, -1);
    //this.origin = new rectangular.Point(0, 0);
    this.bounds = new rectangular.Rectangle(0, 0, 0, 0);
    this.hasMouse = false;

    document.addEventListener('mousemove', function(e) {
        if (self.hasMouse || self.isDragging()) {
            self.finmousemove(e);
        }
    });
    document.addEventListener('mouseup', function(e) {
        self.finmouseup(e);
    });
    document.addEventListener('wheel', function(e) {
        self.finwheelmoved(e);
    });
    document.addEventListener('keydown', function(e) {
        self.finkeydown(e);
    });
    document.addEventListener('keyup', function(e) {
        self.finkeyup(e);
    });

    this.canvas.onmouseover = function() {
        self.hasMouse = true;
    };
    this.canvas.addEventListener('focus', function(e) {
        self.finfocusgained(e);
    });
    this.canvas.addEventListener('blur', function(e) {
        self.finfocuslost(e);
    });
    this.canvas.addEventListener('mousedown', function(e) {
        self.finmousedown(e);
    });
    this.canvas.addEventListener('mouseout', function(e) {
        self.hasMouse = false;
        self.finmouseout(e);
    });
    this.canvas.addEventListener('click', function(e) {
        self.finclick(e);
    });
    this.canvas.addEventListener('contextmenu', function(e) {
        self.fincontextmenu(e);
        e.preventDefault();
        return false;
    });

    gestures.addEventListener(this.canvas, 'tap', function(e) {
        self.fintap(e);
    });
    gestures.addEventListener(this.canvas, 'holdpulse', function(e) {
        self.finholdpulse(e);
    });
    gestures.addEventListener(this.canvas, 'flick', function(e) {
        self.finflick(e);
    });
    gestures.addEventListener(this.canvas, 'release', function(e) {
        self.finrelease(e);
    });
    gestures.addEventListener(this.canvas, 'trackstart', function(e) {
        self.fintrackstart(e);
    });
    gestures.addEventListener(this.canvas, 'track', function(e) {
        self.fintrack(e);
    });
    gestures.addEventListener(this.canvas, 'trackend', function(e) {
        self.fintrackend(e);
    });

    this.canvas.setAttribute('tabindex', 0);
    this.canvas.contentEditable = true;

    this.resize();

    this.beginResizing();
    this.beginPainting();
}

Canvas.prototype = {
    constructor: Canvas.prototype.constructor,
    div: null,
    _component: null,
    gestures: gestures, // TODO: why do we need this? (was previously at bottom of file)
    canvas: null,
    canvasCTX: null,
    focuser: null,
    buffer: null,
    ctx: null,
    mouseLocation: null,
    holdPulseCount: -1,
    dragstart: null,
    origin: null,
    bounds: null,
    dirty: false,
    size: null,
    mousedown: false,
    dragging: false,
    repeatKeyCount: 0,
    repeatKey: null,
    repeatKeyStartTime: 0,
    currentKeys: [],
    hasMouse: false,
    lastDoubleClickTime: 0,
    dragEndTime: 0,
    lastRepaintTime: 0,

    addEventListener: function(name, callback) {
        this.canvas.addEventListener(name, callback);
    },

    stopPaintLoop: function() {
        paintLoopRunning = false;
    },

    restartPaintLoop: function() {
        if (paintLoopRunning) {
            return; // already running
        }
        paintLoopRunning = true;
        requestAnimationFrame(paintLoopFunction);
    },

    stopResizeLoop: function() {
        resizeLoopRunning = false;
    },

    restartResizeLoop: function() {
        if (resizeLoopRunning) {
            return; // already running
        }
        resizeLoopRunning = true;
        setInterval(resizablesLoopFunction, 200);
    },

    detached: function() {
        this.stopPainting();
        this.stopResizing();
    },

    useHiDPI: function() {
        return this._component.resolveProperty('useHiDPI');
    },

    useBitBlit: function() {
        return this._component.resolveProperty('useBitBlit');
    },

    getFPS: function() {
        var fps = this._component.resolveProperty('repaintIntervalRate');
        return fps ? parseInt(fps) : 0;
    },

    tickPaint: function(now) {
        var fps = this.getFPS();
        if (fps === 0) {
            return;
        }
        var interval = 1000 / fps;

        var elapsed = now - this.lastRepaintTime;
        if (elapsed > interval && this.dirty) {
            this.lastRepaintTime = now - (elapsed % interval);
            this.paintNow();
        }
    },

    beginPainting: function() {
        var self = this;
        this.dirty = true;
        this.tickPainter = function(now) {
            self.tickPaint(now);
        };
        paintables.push(this);
    },

    stopPainting: function() {
        paintables.splice(paintables.indexOf(this), 1);
    },

    beginResizing: function() {
        var self = this;
        this.tickResizer = function() {
            self.checksize();
        };
        resizables.push(this);
    },

    stopResizing: function() {
        resizables.splice(resizables.indexOf(this), 1);
    },

    start: function() {
        this.beginPainting();
        this.beginResizing();
    },

    stop: function() {
        this.stopPainting();
        this.stopResizing();
    },

    checksize: function() {
        //this is expensive lets do it at some modulo
        var sizeNow = this.div.getBoundingClientRect();
        if (sizeNow.width !== this.size.width || sizeNow.height !== this.size.height) {
            this.sizeChangedNotification();
        }
    },

    sizeChangedNotification: function() {
        this.resize();
    },

    resize: function() {
        var box = this.size = this.div.getBoundingClientRect();

        this.canvas.width = this.buffer.width = box.width;
        this.canvas.height = this.buffer.height = box.height;

        //fix ala sir spinka, see
        //http://www.html5rocks.com/en/tutorials/canvas/hidpi/
        //just add 'hdpi' as an attribute to the fin-canvas tag
        var ratio = 1;
        var useBitBlit = this.useBitBlit();
        var isHIDPI = window.devicePixelRatio && this.useHiDPI();
        if (isHIDPI) {
            var devicePixelRatio = window.devicePixelRatio || 1;
            var backingStoreRatio = this.canvasCTX.webkitBackingStorePixelRatio ||
                this.canvasCTX.mozBackingStorePixelRatio ||
                this.canvasCTX.msBackingStorePixelRatio ||
                this.canvasCTX.oBackingStorePixelRatio ||
                this.canvasCTX.backingStorePixelRatio || 1;

            ratio = devicePixelRatio / backingStoreRatio;
            //this.canvasCTX.scale(ratio, ratio);
        }
        var width = this.canvas.getAttribute('width');
        var height = this.canvas.getAttribute('height');
        this.canvas.width = width * ratio;
        this.canvas.height = height * ratio;
        this.buffer.width = width * ratio;
        this.buffer.height = height * ratio;

        this.canvas.style.width = width + 'px';
        this.canvas.style.height = height + 'px';
        this.buffer.style.width = width + 'px';
        this.buffer.style.height = height + 'px';

        this.bufferCTX.scale(ratio, ratio);
        if (isHIDPI && !useBitBlit) {
            this.canvasCTX.scale(ratio, ratio);
        }

        //this.origin = new rectangular.Point(Math.round(this.size.left), Math.round(this.size.top));
        this.bounds = new rectangular.Rectangle(0, 0, box.width, box.height);
        //setTimeout(function() {
        var comp = this._component;
        if (comp) {
            comp.setBounds(this.bounds);
        }
        this.resizeNotification();
        this.paintNow();
        //});
    },

    resizeNotification: function() {
        //to be overridden
    },

    getBounds: function() {
        return this.bounds;
    },

    paintNow: function() {
        var self = this;
        this.safePaintImmediately(function(gc) {
            gc.clearRect(0, 0, self.canvas.width, self.canvas.height);

            var comp = self._component;
            if (comp) {
                comp._paint(gc);
            }

            self.dirty = false;
        });
    },

    safePaintImmediately: function(paintFunction) {
        var useBitBlit = this.useBitBlit(),
            gc = useBitBlit ? this.bufferGC : this.gc;
        try {
            gc.save();
            paintFunction(gc);
        } catch (e) {
            console.error(e);
        } finally {
            gc.restore();
        }
        if (useBitBlit) {
            this.flushBuffer();
        }
    },

    flushBuffer: function() {
        if (this.buffer.width > 0 && this.buffer.height > 0) {
            this.canvasCTX.drawImage(this.buffer, 0, 0);
        }
    },

    dispatchNewEvent: function(event, name, detail) {
        detail = {
            detail: detail || {}
        };
        detail.detail.primitiveEvent = event;
        return this.canvas.dispatchEvent(new CustomEvent(name, detail));
    },

    dispatchNewMouseKeysEvent: function(event, name, detail) {
        detail = detail || {};
        detail.mouse = this.mouseLocation;
        detail.keys = this.currentKeys;
        return this.dispatchNewEvent(event, name, detail);
    },

    finmousemove: function(e) {
        if (!this.isDragging() && this.mousedown) {
            this.beDragging();
            this.dispatchNewMouseKeysEvent(e, 'fin-canvas-dragstart', {
                isRightClick: this.isRightClick(e)
            });
            this.dragstart = new rectangular.Point(this.mouseLocation.x, this.mouseLocation.y);
        }
        this.mouseLocation = this.getLocal(e);
        //console.log(this.mouseLocation);
        if (this.isDragging()) {
            this.dispatchNewMouseKeysEvent(e, 'fin-canvas-drag', {
                dragstart: this.dragstart,
                isRightClick: this.isRightClick(e)
            });
        }
        if (this.bounds.contains(this.mouseLocation)) {
            this.dispatchNewMouseKeysEvent(e, 'fin-canvas-mousemove');
        }
    },

    finmousedown: function(e) {
        this.mouseLocation = this.getLocal(e);
        this.mousedown = true;

        this.dispatchNewMouseKeysEvent(e, 'fin-canvas-mousedown', {
            isRightClick: this.isRightClick(e)
        });
        this.takeFocus();
    },

    finmouseup: function(e) {
        if (this.isDragging()) {
            this.dispatchNewMouseKeysEvent(e, 'fin-canvas-dragend', {
                dragstart: this.dragstart,
                isRightClick: this.isRightClick(e)
            });
            this.beNotDragging();
            this.dragEndtime = Date.now();
        }
        this.mousedown = false;
        this.dispatchNewMouseKeysEvent(e, 'fin-canvas-mouseup', {
            isRightClick: this.isRightClick(e)
        });
        //this.mouseLocation = new rectangular.Point(-1, -1);
    },

    finmouseout: function(e) {
        if (!this.mousedown) {
            this.mouseLocation = new rectangular.Point(-1, -1);
        }
        this.dispatchNewMouseKeysEvent(e, 'fin-canvas-mouseout');
    },

    finwheelmoved: function(e) {
        if (this.isDragging() || !this.hasFocus()) {
            return;
        }
        e.preventDefault();
        this.dispatchNewMouseKeysEvent(e, 'fin-canvas-wheelmoved', {
            isRightClick: this.isRightClick(e)
        });
    },

    finclick: function(e) {
        if (Date.now() - this.lastClickTime < 250) {
            //this is a double click...
            this.findblclick(e);
            return;
        }
        this.mouseLocation = this.getLocal(e);
        this.dispatchNewMouseKeysEvent(e, 'fin-canvas-click', {
            isRightClick: this.isRightClick(e)
        });
        this.lastClickTime = Date.now();
    },

    finrelease: function(e) {
        this.holdPulseCount = 0;
        this.mouseLocation = this.getLocal(e);
        this.dispatchNewMouseKeysEvent(e, 'fin-canvas-release');
    },

    finflick: function(e) {
        if (!this.hasFocus()) {
            return;
        }
        this.mouseLocation = this.getLocal(e);
        this.dispatchNewMouseKeysEvent(e, 'fin-canvas-flick', {
            isRightClick: this.isRightClick(e)
        });
    },

    fintrackstart: function(e) {
        if (!this.hasFocus()) {
            return;
        }
        this.mouseLocation = this.getLocal(e);
        this.dispatchNewMouseKeysEvent(e, 'fin-canvas-trackstart');
    },

    fintrack: function(e) {
        if (!this.hasFocus()) {
            return;
        }
        this.mouseLocation = this.getLocal(e);
        this.dispatchNewMouseKeysEvent(e, 'fin-canvas-track');
    },

    fintrackend: function(e) {
        this.mouseLocation = this.getLocal(e);
        this.dispatchNewMouseKeysEvent(e, 'fin-canvas-trackend');
    },

    finhold: function(e) {
        this.mouseLocation = this.getLocal(e);
        this.dispatchNewMouseKeysEvent(e, 'fin-canvas-hold', {
            isRightClick: this.isRightClick(e)
        });
    },

    finholdpulse: function(e) {
        this.mouseLocation = this.getLocal(e);
        this.dispatchNewMouseKeysEvent(e, 'fin-canvas-holdpulse', {
            count: this.holdPulseCount++
        });
    },

    fintap: function(e) {
        //this nonsense is to hold a tap if it's really a double click
        var self = this;
        var now = Date.now();
        var dif = now - this.lastDoubleClickTime;
        if (dif < 300) {
            return;
        }
        //dragend is also causing a tap
        //lets fix this here
        if (now - this.dragEndtime < 100) {
            return;
        }
        setTimeout(function() {
            self._fintap(e);
        }, 180);
    },

    _fintap: function(e) {
        //this nonsense is to hold a tap if it's really a double click
        var now = Date.now();
        var dif = now - this.lastDoubleClickTime;
        if (dif < 300) {
            return;
        }
        //this.mouseLocation = this.getLocal(e);
        this.dispatchNewMouseKeysEvent(e, 'fin-canvas-tap', {
            isRightClick: this.isRightClick(e)
        });
    },

    findblclick: function(e) {
        this.mouseLocation = this.getLocal(e);
        this.lastDoubleClickTime = Date.now();
        this.dispatchNewMouseKeysEvent(e, 'fin-canvas-dblclick', {
            isRightClick: this.isRightClick(e)
        });
        //console.log('dblclick', this.currentKeys);
    },

    getCharMap: function() { //TODO: This is static. Make it a property of the constructor.
        return charMap;
    },

    finkeydown: function(e) {
        if (!this.hasFocus()) {
            return;
        }

        //e.preventDefault();
        var keyChar = e.shiftKey ? charMap[e.keyCode][1] : charMap[e.keyCode][0];
        if (e.repeat) {
            if (this.repeatKey === keyChar) {
                this.repeatKeyCount++;
            } else {
                this.repeatKey = keyChar;
                this.repeatKeyStartTime = Date.now();
            }
        } else {
            this.repeatKey = null;
            this.repeatKeyCount = 0;
            this.repeatKeyStartTime = 0;
        }
        if (this.currentKeys.indexOf(keyChar) === -1) {
            this.currentKeys.push(keyChar);
        }
        //console.log(keyChar, e.keyCode);
        this.dispatchNewEvent(e, 'fin-canvas-keydown', {
            alt: e.altKey,
            ctrl: e.ctrlKey,
            char: keyChar,
            code: e.charCode,
            key: e.keyCode,
            meta: e.metaKey,
            repeatCount: this.repeatKeyCount,
            repeatStartTime: this.repeatKeyStartTime,
            shift: e.shiftKey,
            identifier: e.keyIdentifier,
            currentKeys: this.currentKeys.slice(0)
        });
    },

    finkeyup: function(e) {
        var keyChar = e.shiftKey ? charMap[e.keyCode][1] : charMap[e.keyCode][0];
        this.currentKeys.splice(this.currentKeys.indexOf(keyChar), 1);
        if (!this.hasFocus()) {
            return;
        }
        this.repeatKeyCount = 0;
        this.repeatKey = null;
        this.repeatKeyStartTime = 0;
        this.dispatchNewEvent(e, 'fin-canvas-keyup', {
            alt: e.altKey,
            ctrl: e.ctrlKey,
            char: keyChar,
            code: e.charCode,
            key: e.keyCode,
            meta: e.metaKey,
            repeat: e.repeat,
            shift: e.shiftKey,
            identifier: e.keyIdentifier,
            currentKeys: this.currentKeys.slice(0)
        });
    },

    finfocusgained: function(e) {
        this.dispatchNewEvent(e, 'fin-canvas-focus-gained');
    },

    finfocuslost: function(e) {
        this.dispatchNewEvent(e, 'fin-canvas-focus-lost');
    },

    fincontextmenu: function(e) {
        if (e.ctrlKey && this.currentKeys.indexOf('CTRL') === -1) {
            this.currentKeys.push('CTRL');
        }
        if (Date.now() - this.lastClickTime < 250) {
            //this is a double click...
            this.findblclick(e);
            return;
        }
        this.dispatchNewMouseKeysEvent(e, 'fin-canvas-context-menu', {
            isRightClick: this.isRightClick(e)
        });
        this.lastClickTime = Date.now();
    },

    repaint: function() {
        var fps = this.getFPS();
        this.dirty = true;
        if (!paintLoopRunning || fps === 0) {
            this.paintNow();
        }
    },

    getMouseLocation: function() {
        return this.mouseLocation;
    },

    getOrigin: function() {
        var rect = this.canvas.getBoundingClientRect();
        var p = new rectangular.Point(rect.left, rect.top);
        return p;
    },

    getLocal: function(e) {
        var rect = this.canvas.getBoundingClientRect();
        var p = new rectangular.Point(e.clientX - rect.left, e.clientY - rect.top);
        return p;
    },

    hasFocus: function() {
        return document.activeElement === this.canvas;
    },

    takeFocus: function() {
        var self = this;
        if (!this.hasFocus()) {
            setTimeout(function() {
                self.canvas.focus();
            }, 10);
        }
    },

    beDragging: function() {
        this.dragging = true;
        this.disableDocumentElementSelection();
    },

    beNotDragging: function() {
        this.dragging = false;
        this.enableDocumentElementSelection();
    },

    isDragging: function() {
        return this.dragging;
    },

    disableDocumentElementSelection: function() {
        var style = document.body.style;
        style.cssText = style.cssText + '-webkit-user-select: none';
    },

    enableDocumentElementSelection: function() {
        var style = document.body.style;
        style.cssText = style.cssText.replace('-webkit-user-select: none', '');
    },

    setFocusable: function(truthy) {
        this.focuser.style.display = truthy ? '' : 'none';
    },

    isRightClick: function(e) {
        var isRightMB;
        e = e || window.event;

        if ('which' in e) { // Gecko (Firefox), WebKit (Safari/Chrome) & Opera
            isRightMB = e.which === 3;
        } else if ('button' in e) { // IE, Opera
            isRightMB = e.button === 2;
        }
        return isRightMB;
    },

    dispatchEvent: function(e) {
        return this.canvas.dispatchEvent(e);
    }
};

function paintLoopFunction(now) {
    if (!paintLoopRunning) {
        return;
    }
    for (var i = 0; i < paintables.length; i++) {
        try {
            paintables[i].tickPainter(now);
        } catch (e) {
            console.error(e);
        }
    }
    requestAnimationFrame(paintLoopFunction);
}
requestAnimationFrame(paintLoopFunction);

function resizablesLoopFunction(now) {
    if (!resizeLoopRunning) {
        return;
    }
    for (var i = 0; i < resizables.length; i++) {
        try {
            resizables[i].tickResizer(now);
        } catch (e) {
            console.error(e);
        }
    }
}
setInterval(resizablesLoopFunction, RESIZE_POLLING_INTERVAL);

function makeCharMap() {
    var map = [];

    var empty = ['', ''];

    for (var i = 0; i < 256; i++) {
        map[i] = empty;
    }

    map[27] = ['ESC', 'ESCSHIFT'];
    map[192] = ['`', '~'];
    map[49] = ['1', '!'];
    map[50] = ['2', '@'];
    map[51] = ['3', '#'];
    map[52] = ['4', '$'];
    map[53] = ['5', '%'];
    map[54] = ['6', '^'];
    map[55] = ['7', '&'];
    map[56] = ['8', '*'];
    map[57] = ['9', '('];
    map[48] = ['0', ')'];
    map[189] = ['-', '_'];
    map[187] = ['=', '+'];
    map[8] = ['DELETE', 'DELETESHIFT'];
    map[9] = ['TAB', 'TABSHIFT'];
    map[81] = ['q', 'Q'];
    map[87] = ['w', 'W'];
    map[69] = ['e', 'E'];
    map[82] = ['r', 'R'];
    map[84] = ['t', 'T'];
    map[89] = ['y', 'Y'];
    map[85] = ['u', 'U'];
    map[73] = ['i', 'I'];
    map[79] = ['o', 'O'];
    map[80] = ['p', 'P'];
    map[219] = ['[', '{'];
    map[221] = [']', '}'];
    map[220] = ['\\', '|'];
    map[220] = ['CAPSLOCK', 'CAPSLOCKSHIFT'];
    map[65] = ['a', 'A'];
    map[83] = ['s', 'S'];
    map[68] = ['d', 'D'];
    map[70] = ['f', 'F'];
    map[71] = ['g', 'G'];
    map[72] = ['h', 'H'];
    map[74] = ['j', 'J'];
    map[75] = ['k', 'K'];
    map[76] = ['l', 'L'];
    map[186] = [';', ':'];
    map[222] = ['\'', '|'];
    map[13] = ['RETURN', 'RETURNSHIFT'];
    map[16] = ['SHIFT', 'SHIFT'];
    map[90] = ['z', 'Z'];
    map[88] = ['x', 'X'];
    map[67] = ['c', 'C'];
    map[86] = ['v', 'V'];
    map[66] = ['b', 'B'];
    map[78] = ['n', 'N'];
    map[77] = ['m', 'M'];
    map[188] = [',', '<'];
    map[190] = ['.', '>'];
    map[191] = ['/', '?'];
    map[16] = ['SHIFT', 'SHIFT'];
    map[17] = ['CTRL', 'CTRLSHIFT'];
    map[18] = ['ALT', 'ALTSHIFT'];
    map[91] = ['COMMANDLEFT', 'COMMANDLEFTSHIFT'];
    map[32] = ['SPACE', 'SPACESHIFT'];
    map[93] = ['COMMANDRIGHT', 'COMMANDRIGHTSHIFT'];
    map[18] = ['ALT', 'ALTSHIFT'];
    map[38] = ['UP', 'UPSHIFT'];
    map[37] = ['LEFT', 'LEFTSHIFT'];
    map[40] = ['DOWN', 'DOWNSHIFT'];
    map[39] = ['RIGHT', 'RIGHTSHIFT'];

    map[33] = ['PAGEUP', 'PAGEUPSHIFT'];
    map[34] = ['PAGEDOWN', 'PAGEDOWNSHIFT'];
    map[35] = ['PAGERIGHT', 'PAGERIGHTSHIFT'];
    map[36] = ['PAGELEFT', 'PAGELEFTSHIFT'];

    return map;
}

module.exports = Canvas;

},{"./js/GraphicsContext.js":6,"./js/polymergestures.dev.js":8,"rectangular":29}],6:[function(require,module,exports){
'use strict';

var consoleLogger = require('./gc-console-logger');

/**
 * @constructor
 * @param gc - The 2-D graphics context from your canvas
 * @param {boolean|apiLogger} [logger=true]
 * * `true` uses `gc-console-logger` function bound to 'gc.' as prefix
 * * string uses `gc-console-logger` function bound to string
 * * function used as is
 */
function GraphicsContext(gc, logger) {
    this.gc = gc;

    var self = this;
    var reWEBKIT = /^webkit/;

    switch (typeof logger) {

        case 'string':
            logger =  consoleLogger.bind(undefined, logger + '.');
            break;

        case 'boolean':
            if (logger === true) {
                logger = consoleLogger.bind(undefined, 'gc.');
            }
            break;

        case 'function':
            if (logger.length !== 3) {
                throw 'GraphicsContext: User-supplied API logger function does not accept three parameters.';
            }
            break;

        default:
            logger = false;
    }

    // Stub out all the prototype members of the canvas 2D graphics context:
    Object.keys(Object.getPrototypeOf(gc)).forEach(MakeStub);

    // Some older browsers (e.g., Chrome 40) did not have all members of canvas
    // 2D graphics context in the prototype so we make this additional call:
    Object.keys(gc).forEach(MakeStub);

    function MakeStub(key) {
        if (key in GraphicsContext.prototype || reWEBKIT.test(key)) {
            return;
        }
        if (typeof gc[key] === 'function') {
            self[key] = !logger ? gc[key].bind(gc) : function() {
                return logger(key, arguments, gc[key].apply(gc, arguments));
            };
        } else {
            Object.defineProperty(self, key, {
                get: function() {
                    var result = gc[key];
                    return logger ? logger(key, 'getter', result) : result;
                },
                set: function(value) {
                    gc[key] = logger ? logger(key, 'setter', value) : value;
                }
            });
        }
    }
}

module.exports = GraphicsContext;

},{"./gc-console-logger":7}],7:[function(require,module,exports){
'use strict';

var YIELDS = '\u27F9'; // LONG RIGHTWARDS DOUBLE ARROW

function consoleLogger(prefix, name, args, value) {
    var result = value;

    if (typeof value === 'string') {
        result = '"' + result + '"';
    }

    name = prefix + name;

    switch (args) {
        case 'getter':
            console.log(name, '=', result);
            break;

        case 'setter':
            console.log(name, YIELDS, result);
            break;

        default: // method call
            name += '(' + Array.prototype.slice.call(args).join(', ') + ')';
            if (result === undefined) {
                console.log(name);
            } else {
                console.log(name, YIELDS, result);
            }
    }

    return value;
}

module.exports = consoleLogger;

},{}],8:[function(require,module,exports){
/* eslint-disable */

/**
 * @license
 * Copyright (c) 2014 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
 */
//module.exports = {};

(function(scope) {
    var hasFullPath = false;

    // test for full event path support
    var pathTest = document.createElement('meta');
    if (pathTest.createShadowRoot) {
        var sr = pathTest.createShadowRoot();
        var s = document.createElement('span');
        sr.appendChild(s);
        pathTest.addEventListener('testpath', function(ev) {
            if (ev.path) {
                // if the span is in the event path, then path[0] is the real source for all events
                hasFullPath = ev.path[0] === s;
            }
            ev.stopPropagation();
        });
        var ev = new CustomEvent('testpath', {
            bubbles: true
        });
        // must add node to DOM to trigger event listener
        document.head.appendChild(pathTest);
        s.dispatchEvent(ev);
        pathTest.parentNode.removeChild(pathTest);
        sr = s = null;
    }
    pathTest = null;

    var target = {
        shadow: function(inEl) {
            if (inEl) {
                return inEl.shadowRoot || inEl.webkitShadowRoot;
            }
        },
        canTarget: function(shadow) {
            return shadow && Boolean(shadow.elementFromPoint);
        },
        targetingShadow: function(inEl) {
            var s = this.shadow(inEl);
            if (this.canTarget(s)) {
                return s;
            }
        },
        olderShadow: function(shadow) {
            var os = shadow.olderShadowRoot;
            if (!os) {
                var se = shadow.querySelector('shadow');
                if (se) {
                    os = se.olderShadowRoot;
                }
            }
            return os;
        },
        allShadows: function(element) {
            var shadows = [],
                s = this.shadow(element);
            while (s) {
                shadows.push(s);
                s = this.olderShadow(s);
            }
            return shadows;
        },
        searchRoot: function(inRoot, x, y) {
            var t, st, sr, os;
            if (inRoot) {
                t = inRoot.elementFromPoint(x, y);
                if (t) {
                    // found element, check if it has a ShadowRoot
                    sr = this.targetingShadow(t);
                } else if (inRoot !== document) {
                    // check for sibling roots
                    sr = this.olderShadow(inRoot);
                }
                // search other roots, fall back to light dom element
                return this.searchRoot(sr, x, y) || t;
            }
        },
        owner: function(element) {
            if (!element) {
                return document;
            }
            var s = element;
            // walk up until you hit the shadow root or document
            while (s.parentNode) {
                s = s.parentNode;
            }
            // the owner element is expected to be a Document or ShadowRoot
            if (s.nodeType != Node.DOCUMENT_NODE && s.nodeType != Node.DOCUMENT_FRAGMENT_NODE) {
                s = document;
            }
            return s;
        },
        findTarget: function(inEvent) {
            if (hasFullPath && inEvent.path && inEvent.path.length) {
                return inEvent.path[0];
            }
            var x = inEvent.clientX,
                y = inEvent.clientY;
            // if the listener is in the shadow root, it is much faster to start there
            var s = this.owner(inEvent.target);
            // if x, y is not in this root, fall back to document search
            if (!s.elementFromPoint(x, y)) {
                s = document;
            }
            return this.searchRoot(s, x, y);
        },
        findTouchAction: function(inEvent) {
            var n;
            if (hasFullPath && inEvent.path && inEvent.path.length) {
                var path = inEvent.path;
                for (var i = 0; i < path.length; i++) {
                    n = path[i];
                    if (n.nodeType === Node.ELEMENT_NODE && n.hasAttribute('touch-action')) {
                        return n.getAttribute('touch-action');
                    }
                }
            } else {
                n = inEvent.target;
                while (n) {
                    if (n.nodeType === Node.ELEMENT_NODE && n.hasAttribute('touch-action')) {
                        return n.getAttribute('touch-action');
                    }
                    n = n.parentNode || n.host;
                }
            }
            // auto is default
            return "auto";
        },
        LCA: function(a, b) {
            if (a === b) {
                return a;
            }
            if (a && !b) {
                return a;
            }
            if (b && !a) {
                return b;
            }
            if (!b && !a) {
                return document;
            }
            // fast case, a is a direct descendant of b or vice versa
            if (a.contains && a.contains(b)) {
                return a;
            }
            if (b.contains && b.contains(a)) {
                return b;
            }
            var adepth = this.depth(a);
            var bdepth = this.depth(b);
            var d = adepth - bdepth;
            if (d >= 0) {
                a = this.walk(a, d);
            } else {
                b = this.walk(b, -d);
            }
            while (a && b && a !== b) {
                a = a.parentNode || a.host;
                b = b.parentNode || b.host;
            }
            return a;
        },
        walk: function(n, u) {
            for (var i = 0; n && (i < u); i++) {
                n = n.parentNode || n.host;
            }
            return n;
        },
        depth: function(n) {
            var d = 0;
            while (n) {
                d++;
                n = n.parentNode || n.host;
            }
            return d;
        },
        deepContains: function(a, b) {
            var common = this.LCA(a, b);
            // if a is the common ancestor, it must "deeply" contain b
            return common === a;
        },
        insideNode: function(node, x, y) {
            var rect = node.getBoundingClientRect();
            return (rect.left <= x) && (x <= rect.right) && (rect.top <= y) && (y <= rect.bottom);
        },
        path: function(event) {
            var p;
            if (hasFullPath && event.path && event.path.length) {
                p = event.path;
            } else {
                p = [];
                var n = this.findTarget(event);
                while (n) {
                    p.push(n);
                    n = n.parentNode || n.host;
                }
            }
            return p;
        }
    };
    scope.targetFinding = target;
    /**
     * Given an event, finds the "deepest" node that could have been the original target before ShadowDOM retargetting
     *
     * @param {Event} Event An event object with clientX and clientY properties
     * @return {Element} The probable event origninator
     */
    scope.findTarget = target.findTarget.bind(target);
    /**
     * Determines if the "container" node deeply contains the "containee" node, including situations where the "containee" is contained by one or more ShadowDOM
     * roots.
     *
     * @param {Node} container
     * @param {Node} containee
     * @return {Boolean}
     */
    scope.deepContains = target.deepContains.bind(target);

    /**
     * Determines if the x/y position is inside the given node.
     *
     * Example:
     *
     *     function upHandler(event) {
     *       var innode = PolymerGestures.insideNode(event.target, event.clientX, event.clientY);
     *       if (innode) {
     *         // wait for tap?
     *       } else {
     *         // tap will never happen
     *       }
     *     }
     *
     * @param {Node} node
     * @param {Number} x Screen X position
     * @param {Number} y screen Y position
     * @return {Boolean}
     */
    scope.insideNode = target.insideNode;

})(exports);

(function() {
    function shadowSelector(v) {
        return 'html /deep/ ' + selector(v);
    }

    function selector(v) {
        return '[touch-action="' + v + '"]';
    }

    function rule(v) {
        return '{ -ms-touch-action: ' + v + '; touch-action: ' + v + ';}';
    }
    var attrib2css = [
        'none',
        'auto',
        'pan-x',
        'pan-y', {
            rule: 'pan-x pan-y',
            selectors: [
                'pan-x pan-y',
                'pan-y pan-x'
            ]
        },
        'manipulation'
    ];
    var styles = '';
    // only install stylesheet if the browser has touch action support
    var hasTouchAction = typeof document.head.style.touchAction === 'string';
    // only add shadow selectors if shadowdom is supported
    var hasShadowRoot = !window.ShadowDOMPolyfill && document.head.createShadowRoot;

    if (hasTouchAction) {
        attrib2css.forEach(function(r) {
            if (String(r) === r) {
                styles += selector(r) + rule(r) + '\n';
                if (hasShadowRoot) {
                    styles += shadowSelector(r) + rule(r) + '\n';
                }
            } else {
                styles += r.selectors.map(selector) + rule(r.rule) + '\n';
                if (hasShadowRoot) {
                    styles += r.selectors.map(shadowSelector) + rule(r.rule) + '\n';
                }
            }
        });

        var el = document.createElement('style');
        el.textContent = styles;
        document.head.appendChild(el);
    }
})();

/**
 * This is the constructor for new PointerEvents.
 *
 * New Pointer Events must be given a type, and an optional dictionary of
 * initialization properties.
 *
 * Due to certain platform requirements, events returned from the constructor
 * identify as MouseEvents.
 *
 * @constructor
 * @param {String} inType The type of the event to create.
 * @param {Object} [inDict] An optional dictionary of initial event properties.
 * @return {Event} A new PointerEvent of type `inType` and initialized with properties from `inDict`.
 */
(function(scope) {

    var MOUSE_PROPS = [
        'bubbles',
        'cancelable',
        'view',
        'detail',
        'screenX',
        'screenY',
        'clientX',
        'clientY',
        'ctrlKey',
        'altKey',
        'shiftKey',
        'metaKey',
        'button',
        'relatedTarget',
        'pageX',
        'pageY'
    ];

    var MOUSE_DEFAULTS = [
        false,
        false,
        null,
        null,
        0,
        0,
        0,
        0,
        false,
        false,
        false,
        false,
        0,
        null,
        0,
        0
    ];

    var NOP_FACTORY = function() {
        return function() {};
    };

    var eventFactory = {
        // TODO(dfreedm): this is overridden by tap recognizer, needs review
        preventTap: NOP_FACTORY,
        makeBaseEvent: function(inType, inDict) {
            var e = document.createEvent('Event');
            e.initEvent(inType, inDict.bubbles || false, inDict.cancelable || false);
            e.preventTap = eventFactory.preventTap(e);
            return e;
        },
        makeGestureEvent: function(inType, inDict) {
            inDict = inDict || Object.create(null);

            var e = this.makeBaseEvent(inType, inDict);
            for (var i = 0, keys = Object.keys(inDict), k; i < keys.length; i++) {
                k = keys[i];
                if (k !== 'bubbles' && k !== 'cancelable') {
                    e[k] = inDict[k];
                }
            }
            return e;
        },
        makePointerEvent: function(inType, inDict) {
            inDict = inDict || Object.create(null);

            var e = this.makeBaseEvent(inType, inDict);
            // define inherited MouseEvent properties
            for (var i = 2, p; i < MOUSE_PROPS.length; i++) {
                p = MOUSE_PROPS[i];
                e[p] = inDict[p] || MOUSE_DEFAULTS[i];
            }
            e.buttons = inDict.buttons || 0;

            // Spec requires that pointers without pressure specified use 0.5 for down
            // state and 0 for up state.
            var pressure = 0;
            if (inDict.pressure) {
                pressure = inDict.pressure;
            } else {
                pressure = e.buttons ? 0.5 : 0;
            }

            // add x/y properties aliased to clientX/Y
            e.x = e.clientX;
            e.y = e.clientY;

            // define the properties of the PointerEvent interface
            e.pointerId = inDict.pointerId || 0;
            e.width = inDict.width || 0;
            e.height = inDict.height || 0;
            e.pressure = pressure;
            e.tiltX = inDict.tiltX || 0;
            e.tiltY = inDict.tiltY || 0;
            e.pointerType = inDict.pointerType || '';
            e.hwTimestamp = inDict.hwTimestamp || 0;
            e.isPrimary = inDict.isPrimary || false;
            e._source = inDict._source || '';
            return e;
        }
    };

    scope.eventFactory = eventFactory;
})(exports);

/**
 * This module implements an map of pointer states
 */
(function(scope) {
    var USE_MAP = window.Map && window.Map.prototype.forEach;
    var POINTERS_FN = function() {
        return this.size;
    };

    function PointerMap() {
        if (USE_MAP) {
            var m = new Map();
            m.pointers = POINTERS_FN;
            return m;
        } else {
            this.keys = [];
            this.values = [];
        }
    }

    PointerMap.prototype = {
        set: function(inId, inEvent) {
            var i = this.keys.indexOf(inId);
            if (i > -1) {
                this.values[i] = inEvent;
            } else {
                this.keys.push(inId);
                this.values.push(inEvent);
            }
        },
        has: function(inId) {
            return this.keys.indexOf(inId) > -1;
        },
        'delete': function(inId) {
            var i = this.keys.indexOf(inId);
            if (i > -1) {
                this.keys.splice(i, 1);
                this.values.splice(i, 1);
            }
        },
        get: function(inId) {
            var i = this.keys.indexOf(inId);
            return this.values[i];
        },
        clear: function() {
            this.keys.length = 0;
            this.values.length = 0;
        },
        // return value, key, map
        forEach: function(callback, thisArg) {
            this.values.forEach(function(v, i) {
                callback.call(thisArg, v, this.keys[i], this);
            }, this);
        },
        pointers: function() {
            return this.keys.length;
        }
    };

    scope.PointerMap = PointerMap;
})(exports);

(function(scope) {
    var CLONE_PROPS = [
        // MouseEvent
        'bubbles',
        'cancelable',
        'view',
        'detail',
        'screenX',
        'screenY',
        'clientX',
        'clientY',
        'ctrlKey',
        'altKey',
        'shiftKey',
        'metaKey',
        'button',
        'relatedTarget',
        // DOM Level 3
        'buttons',
        // PointerEvent
        'pointerId',
        'width',
        'height',
        'pressure',
        'tiltX',
        'tiltY',
        'pointerType',
        'hwTimestamp',
        'isPrimary',
        // event instance
        'type',
        'target',
        'currentTarget',
        'which',
        'pageX',
        'pageY',
        'timeStamp',
        // gesture addons
        'preventTap',
        'tapPrevented',
        '_source'
    ];

    var CLONE_DEFAULTS = [
        // MouseEvent
        false,
        false,
        null,
        null,
        0,
        0,
        0,
        0,
        false,
        false,
        false,
        false,
        0,
        null,
        // DOM Level 3
        0,
        // PointerEvent
        0,
        0,
        0,
        0,
        0,
        0,
        '',
        0,
        false,
        // event instance
        '',
        null,
        null,
        0,
        0,
        0,
        0,
        function() {},
        false
    ];

    var HAS_SVG_INSTANCE = (typeof SVGElementInstance !== 'undefined');

    var eventFactory = scope.eventFactory;

    // set of recognizers to run for the currently handled event
    var currentGestures;

    /**
     * This module is for normalizing events. Mouse and Touch events will be
     * collected here, and fire PointerEvents that have the same semantics, no
     * matter the source.
     * Events fired:
     *   - pointerdown: a pointing is added
     *   - pointerup: a pointer is removed
     *   - pointermove: a pointer is moved
     *   - pointerover: a pointer crosses into an element
     *   - pointerout: a pointer leaves an element
     *   - pointercancel: a pointer will no longer generate events
     */
    var dispatcher = {
        IS_IOS: false,
        pointermap: new scope.PointerMap(),
        requiredGestures: new scope.PointerMap(),
        eventMap: Object.create(null),
        // Scope objects for native events.
        // This exists for ease of testing.
        eventSources: Object.create(null),
        eventSourceList: [],
        gestures: [],
        // map gesture event -> {listeners: int, index: gestures[int]}
        dependencyMap: {
            // make sure down and up are in the map to trigger "register"
            down: {
                listeners: 0,
                index: -1
            },
            up: {
                listeners: 0,
                index: -1
            }
        },
        gestureQueue: [],
        /**
         * Add a new event source that will generate pointer events.
         *
         * `inSource` must contain an array of event names named `events`, and
         * functions with the names specified in the `events` array.
         * @param {string} name A name for the event source
         * @param {Object} source A new source of platform events.
         */
        registerSource: function(name, source) {
            var s = source;
            var newEvents = s.events;
            if (newEvents) {
                newEvents.forEach(function(e) {
                    if (s[e]) {
                        this.eventMap[e] = s[e].bind(s);
                    }
                }, this);
                this.eventSources[name] = s;
                this.eventSourceList.push(s);
            }
        },
        registerGesture: function(name, source) {
            var obj = Object.create(null);
            obj.listeners = 0;
            obj.index = this.gestures.length;
            for (var i = 0, g; i < source.exposes.length; i++) {
                g = source.exposes[i].toLowerCase();
                this.dependencyMap[g] = obj;
            }
            this.gestures.push(source);
        },
        register: function(element, initial) {
            var l = this.eventSourceList.length;
            for (var i = 0, es;
                (i < l) && (es = this.eventSourceList[i]); i++) {
                // call eventsource register
                es.register.call(es, element, initial);
            }
        },
        unregister: function(element) {
            var l = this.eventSourceList.length;
            for (var i = 0, es;
                (i < l) && (es = this.eventSourceList[i]); i++) {
                // call eventsource register
                es.unregister.call(es, element);
            }
        },
        // EVENTS
        down: function(inEvent) {
            this.requiredGestures.set(inEvent.pointerId, currentGestures);
            this.fireEvent('down', inEvent);
        },
        move: function(inEvent) {
            // pipe move events into gesture queue directly
            inEvent.type = 'move';
            this.fillGestureQueue(inEvent);
        },
        up: function(inEvent) {
            this.fireEvent('up', inEvent);
            this.requiredGestures.delete(inEvent.pointerId);
        },
        cancel: function(inEvent) {
            inEvent.tapPrevented = true;
            this.fireEvent('up', inEvent);
            this.requiredGestures.delete(inEvent.pointerId);
        },
        addGestureDependency: function(node, currentGestures) {
            var gesturesWanted = node._pgEvents;
            if (gesturesWanted && currentGestures) {
                var gk = Object.keys(gesturesWanted);
                for (var i = 0, r, ri, g; i < gk.length; i++) {
                    // gesture
                    g = gk[i];
                    if (gesturesWanted[g] > 0) {
                        // lookup gesture recognizer
                        r = this.dependencyMap[g];
                        // recognizer index
                        ri = r ? r.index : -1;
                        currentGestures[ri] = true;
                    }
                }
            }
        },
        // LISTENER LOGIC
        eventHandler: function(inEvent) {
            // This is used to prevent multiple dispatch of events from
            // platform events. This can happen when two elements in different scopes
            // are set up to create pointer events, which is relevant to Shadow DOM.

            var type = inEvent.type;

            // only generate the list of desired events on "down"
            if (type === 'touchstart' || type === 'mousedown' || type === 'pointerdown' || type === 'MSPointerDown') {
                if (!inEvent._handledByPG) {
                    currentGestures = {};
                }

                // in IOS mode, there is only a listener on the document, so this is not re-entrant
                if (this.IS_IOS) {
                    var ev = inEvent;
                    if (type === 'touchstart') {
                        var ct = inEvent.changedTouches[0];
                        // set up a fake event to give to the path builder
                        ev = {
                            target: inEvent.target,
                            clientX: ct.clientX,
                            clientY: ct.clientY,
                            path: inEvent.path
                        };
                    }
                    // use event path if available, otherwise build a path from target finding
                    var nodes = inEvent.path || scope.targetFinding.path(ev);
                    for (var i = 0, n; i < nodes.length; i++) {
                        n = nodes[i];
                        this.addGestureDependency(n, currentGestures);
                    }
                } else {
                    this.addGestureDependency(inEvent.currentTarget, currentGestures);
                }
            }

            if (inEvent._handledByPG) {
                return;
            }
            var fn = this.eventMap && this.eventMap[type];
            if (fn) {
                fn(inEvent);
            }
            inEvent._handledByPG = true;
        },
        // set up event listeners
        listen: function(target, events) {
            for (var i = 0, l = events.length, e;
                (i < l) && (e = events[i]); i++) {
                this.addEvent(target, e);
            }
        },
        // remove event listeners
        unlisten: function(target, events) {
            for (var i = 0, l = events.length, e;
                (i < l) && (e = events[i]); i++) {
                this.removeEvent(target, e);
            }
        },
        addEvent: function(target, eventName) {
            target.addEventListener(eventName, this.boundHandler);
        },
        removeEvent: function(target, eventName) {
            target.removeEventListener(eventName, this.boundHandler);
        },
        // EVENT CREATION AND TRACKING
        /**
         * Creates a new Event of type `inType`, based on the information in
         * `inEvent`.
         *
         * @param {string} inType A string representing the type of event to create
         * @param {Event} inEvent A platform event with a target
         * @return {Event} A PointerEvent of type `inType`
         */
        makeEvent: function(inType, inEvent) {
            var e = eventFactory.makePointerEvent(inType, inEvent);
            e.preventDefault = inEvent.preventDefault;
            e.tapPrevented = inEvent.tapPrevented;
            e._target = e._target || inEvent.target;
            return e;
        },
        // make and dispatch an event in one call
        fireEvent: function(inType, inEvent) {
            var e = this.makeEvent(inType, inEvent);
            return this.dispatchEvent(e);
        },
        /**
         * Returns a snapshot of inEvent, with writable properties.
         *
         * @param {Event} inEvent An event that contains properties to copy.
         * @return {Object} An object containing shallow copies of `inEvent`'s
         *    properties.
         */
        cloneEvent: function(inEvent) {
            var eventCopy = Object.create(null),
                p;
            for (var i = 0; i < CLONE_PROPS.length; i++) {
                p = CLONE_PROPS[i];
                eventCopy[p] = inEvent[p] || CLONE_DEFAULTS[i];
                // Work around SVGInstanceElement shadow tree
                // Return the <use> element that is represented by the instance for Safari, Chrome, IE.
                // This is the behavior implemented by Firefox.
                if (p === 'target' || p === 'relatedTarget') {
                    if (HAS_SVG_INSTANCE && eventCopy[p] instanceof SVGElementInstance) {
                        eventCopy[p] = eventCopy[p].correspondingUseElement;
                    }
                }
            }
            // keep the semantics of preventDefault
            eventCopy.preventDefault = function() {
                inEvent.preventDefault();
            };
            return eventCopy;
        },
        /**
         * Dispatches the event to its target.
         *
         * @param {Event} inEvent The event to be dispatched.
         * @return {Boolean} True if an event handler returns true, false otherwise.
         */
        dispatchEvent: function(inEvent) {
            var t = inEvent._target;
            if (t) {
                t.dispatchEvent(inEvent);
                // clone the event for the gesture system to process
                // clone after dispatch to pick up gesture prevention code
                var clone = this.cloneEvent(inEvent);
                clone.target = t;
                this.fillGestureQueue(clone);
            }
        },
        gestureTrigger: function() {
            // process the gesture queue
            for (var i = 0, e, rg; i < this.gestureQueue.length; i++) {
                e = this.gestureQueue[i];
                rg = e._requiredGestures;
                if (rg) {
                    for (var j = 0, g, fn; j < this.gestures.length; j++) {
                        // only run recognizer if an element in the source event's path is listening for those gestures
                        if (rg[j]) {
                            g = this.gestures[j];
                            fn = g[e.type];
                            if (fn) {
                                fn.call(g, e);
                            }
                        }
                    }
                }
            }
            this.gestureQueue.length = 0;
        },
        fillGestureQueue: function(ev) {
            // only trigger the gesture queue once
            if (!this.gestureQueue.length) {
                requestAnimationFrame(this.boundGestureTrigger);
            }
            ev._requiredGestures = this.requiredGestures.get(ev.pointerId);
            this.gestureQueue.push(ev);
        }
    };
    dispatcher.boundHandler = dispatcher.eventHandler.bind(dispatcher);
    dispatcher.boundGestureTrigger = dispatcher.gestureTrigger.bind(dispatcher);
    scope.dispatcher = dispatcher;

    /**
     * Listen for `gesture` on `node` with the `handler` function
     *
     * If `handler` is the first listener for `gesture`, the underlying gesture recognizer is then enabled.
     *
     * @param {Element} node
     * @param {string} gesture
     * @return Boolean `gesture` is a valid gesture
     */
    scope.activateGesture = function(node, gesture) {
        var g = gesture.toLowerCase();
        var dep = dispatcher.dependencyMap[g];
        if (dep) {
            var recognizer = dispatcher.gestures[dep.index];
            if (!node._pgListeners) {
                dispatcher.register(node);
                node._pgListeners = 0;
            }
            // TODO(dfreedm): re-evaluate bookkeeping to avoid using attributes
            if (recognizer) {
                var touchAction = recognizer.defaultActions && recognizer.defaultActions[g];
                var actionNode;
                switch (node.nodeType) {
                    case Node.ELEMENT_NODE:
                        actionNode = node;
                        break;
                    case Node.DOCUMENT_FRAGMENT_NODE:
                        actionNode = node.host;
                        break;
                    default:
                        actionNode = null;
                        break;
                }
                if (touchAction && actionNode && !actionNode.hasAttribute('touch-action')) {
                    actionNode.setAttribute('touch-action', touchAction);
                }
            }
            if (!node._pgEvents) {
                node._pgEvents = {};
            }
            node._pgEvents[g] = (node._pgEvents[g] || 0) + 1;
            node._pgListeners++;
        }
        return Boolean(dep);
    };

    /**
     *
     * Listen for `gesture` from `node` with `handler` function.
     *
     * @param {Element} node
     * @param {string} gesture
     * @param {Function} handler
     * @param {Boolean} capture
     */
    scope.addEventListener = function(node, gesture, handler, capture) {
        if (handler) {
            scope.activateGesture(node, gesture);
            node.addEventListener(gesture, handler, capture);
        }
    };

    /**
     * Tears down the gesture configuration for `node`
     *
     * If `handler` is the last listener for `gesture`, the underlying gesture recognizer is disabled.
     *
     * @param {Element} node
     * @param {string} gesture
     * @return Boolean `gesture` is a valid gesture
     */
    scope.deactivateGesture = function(node, gesture) {
        var g = gesture.toLowerCase();
        var dep = dispatcher.dependencyMap[g];
        if (dep) {
            if (node._pgListeners > 0) {
                node._pgListeners--;
            }
            if (node._pgListeners === 0) {
                dispatcher.unregister(node);
            }
            if (node._pgEvents) {
                if (node._pgEvents[g] > 0) {
                    node._pgEvents[g]--;
                } else {
                    node._pgEvents[g] = 0;
                }
            }
        }
        return Boolean(dep);
    };

    /**
     * Stop listening for `gesture` from `node` with `handler` function.
     *
     * @param {Element} node
     * @param {string} gesture
     * @param {Function} handler
     * @param {Boolean} capture
     */
    scope.removeEventListener = function(node, gesture, handler, capture) {
        if (handler) {
            scope.deactivateGesture(node, gesture);
            node.removeEventListener(gesture, handler, capture);
        }
    };
})(exports);

(function(scope) {
    var dispatcher = scope.dispatcher;
    var pointermap = dispatcher.pointermap;
    // radius around touchend that swallows mouse events
    var DEDUP_DIST = 25;

    var WHICH_TO_BUTTONS = [0, 1, 4, 2];

    var currentButtons = 0;

    var FIREFOX_LINUX = /Linux.*Firefox\//i;

    var HAS_BUTTONS = (function() {
        // firefox on linux returns spec-incorrect values for mouseup.buttons
        // https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent.buttons#See_also
        // https://codereview.chromium.org/727593003/#msg16
        if (FIREFOX_LINUX.test(navigator.userAgent)) {
            return false;
        }
        try {
            return new MouseEvent('test', {
                buttons: 1
            }).buttons === 1;
        } catch (e) {
            return false;
        }
    })();

    // handler block for native mouse events
    var mouseEvents = {
        POINTER_ID: 1,
        POINTER_TYPE: 'mouse',
        events: [
            'mousedown',
            'mousemove',
            'mouseup'
        ],
        exposes: [
            'down',
            'up',
            'move'
        ],
        register: function(target) {
            dispatcher.listen(target, this.events);
        },
        unregister: function(target) {
            if (target.nodeType === Node.DOCUMENT_NODE) {
                return;
            }
            dispatcher.unlisten(target, this.events);
        },
        lastTouches: [],
        // collide with the global mouse listener
        isEventSimulatedFromTouch: function(inEvent) {
            var lts = this.lastTouches;
            var x = inEvent.clientX,
                y = inEvent.clientY;
            for (var i = 0, l = lts.length, t; i < l && (t = lts[i]); i++) {
                // simulated mouse events will be swallowed near a primary touchend
                var dx = Math.abs(x - t.x),
                    dy = Math.abs(y - t.y);
                if (dx <= DEDUP_DIST && dy <= DEDUP_DIST) {
                    return true;
                }
            }
        },
        prepareEvent: function(inEvent) {
            var e = dispatcher.cloneEvent(inEvent);
            e.pointerId = this.POINTER_ID;
            e.isPrimary = true;
            e.pointerType = this.POINTER_TYPE;
            e._source = 'mouse';
            if (!HAS_BUTTONS) {
                var type = inEvent.type;
                var bit = WHICH_TO_BUTTONS[inEvent.which] || 0;
                if (type === 'mousedown') {
                    currentButtons |= bit;
                } else if (type === 'mouseup') {
                    currentButtons &= ~bit;
                }
                e.buttons = currentButtons;
            }
            return e;
        },
        mousedown: function(inEvent) {
            if (!this.isEventSimulatedFromTouch(inEvent)) {
                var p = pointermap.has(this.POINTER_ID);
                var e = this.prepareEvent(inEvent);
                e.target = scope.findTarget(inEvent);
                pointermap.set(this.POINTER_ID, e.target);
                dispatcher.down(e);
            }
        },
        mousemove: function(inEvent) {
            if (!this.isEventSimulatedFromTouch(inEvent)) {
                var target = pointermap.get(this.POINTER_ID);
                if (target) {
                    var e = this.prepareEvent(inEvent);
                    e.target = target;
                    // handle case where we missed a mouseup
                    if ((HAS_BUTTONS ? e.buttons : e.which) === 0) {
                        if (!HAS_BUTTONS) {
                            currentButtons = e.buttons = 0;
                        }
                        dispatcher.cancel(e);
                        this.cleanupMouse(e.buttons);
                    } else {
                        dispatcher.move(e);
                    }
                }
            }
        },
        mouseup: function(inEvent) {
            if (!this.isEventSimulatedFromTouch(inEvent)) {
                var e = this.prepareEvent(inEvent);
                e.relatedTarget = scope.findTarget(inEvent);
                e.target = pointermap.get(this.POINTER_ID);
                dispatcher.up(e);
                this.cleanupMouse(e.buttons);
            }
        },
        cleanupMouse: function(buttons) {
            if (buttons === 0) {
                pointermap.delete(this.POINTER_ID);
            }
        }
    };

    scope.mouseEvents = mouseEvents;
})(exports);

(function(scope) {
    var dispatcher = scope.dispatcher;
    var allShadows = scope.targetFinding.allShadows.bind(scope.targetFinding);
    var pointermap = dispatcher.pointermap;
    var touchMap = Array.prototype.map.call.bind(Array.prototype.map);
    // This should be long enough to ignore compat mouse events made by touch
    var DEDUP_TIMEOUT = 2500;
    var DEDUP_DIST = 25;
    var CLICK_COUNT_TIMEOUT = 200;
    var HYSTERESIS = 20;
    var ATTRIB = 'touch-action';
    // TODO(dfreedm): disable until http://crbug.com/399765 is resolved
    // var HAS_TOUCH_ACTION = ATTRIB in document.head.style;
    var HAS_TOUCH_ACTION = false;

    // handler block for native touch events
    var touchEvents = {
        IS_IOS: false,
        events: [
            'touchstart',
            'touchmove',
            'touchend',
            'touchcancel'
        ],
        exposes: [
            'down',
            'up',
            'move'
        ],
        register: function(target, initial) {
            if (this.IS_IOS ? initial : !initial) {
                dispatcher.listen(target, this.events);
            }
        },
        unregister: function(target) {
            if (!this.IS_IOS) {
                dispatcher.unlisten(target, this.events);
            }
        },
        scrollTypes: {
            EMITTER: 'none',
            XSCROLLER: 'pan-x',
            YSCROLLER: 'pan-y',
        },
        touchActionToScrollType: function(touchAction) {
            var t = touchAction;
            var st = this.scrollTypes;
            if (t === st.EMITTER) {
                return 'none';
            } else if (t === st.XSCROLLER) {
                return 'X';
            } else if (t === st.YSCROLLER) {
                return 'Y';
            } else {
                return 'XY';
            }
        },
        POINTER_TYPE: 'touch',
        firstTouch: null,
        isPrimaryTouch: function(inTouch) {
            return this.firstTouch === inTouch.identifier;
        },
        setPrimaryTouch: function(inTouch) {
            // set primary touch if there no pointers, or the only pointer is the mouse
            if (pointermap.pointers() === 0 || (pointermap.pointers() === 1 && pointermap.has(1))) {
                this.firstTouch = inTouch.identifier;
                this.firstXY = {
                    X: inTouch.clientX,
                    Y: inTouch.clientY
                };
                this.firstTarget = inTouch.target;
                this.scrolling = null;
                this.cancelResetClickCount();
            }
        },
        removePrimaryPointer: function(inPointer) {
            if (inPointer.isPrimary) {
                this.firstTouch = null;
                this.firstXY = null;
                this.resetClickCount();
            }
        },
        clickCount: 0,
        resetId: null,
        resetClickCount: function() {
            var fn = function() {
                this.clickCount = 0;
                this.resetId = null;
            }.bind(this);
            this.resetId = setTimeout(fn, CLICK_COUNT_TIMEOUT);
        },
        cancelResetClickCount: function() {
            if (this.resetId) {
                clearTimeout(this.resetId);
            }
        },
        typeToButtons: function(type) {
            var ret = 0;
            if (type === 'touchstart' || type === 'touchmove') {
                ret = 1;
            }
            return ret;
        },
        findTarget: function(touch, id) {
            if (this.currentTouchEvent.type === 'touchstart') {
                if (this.isPrimaryTouch(touch)) {
                    var fastPath = {
                        clientX: touch.clientX,
                        clientY: touch.clientY,
                        path: this.currentTouchEvent.path,
                        target: this.currentTouchEvent.target
                    };
                    return scope.findTarget(fastPath);
                } else {
                    return scope.findTarget(touch);
                }
            }
            // reuse target we found in touchstart
            return pointermap.get(id);
        },
        touchToPointer: function(inTouch) {
            var cte = this.currentTouchEvent;
            var e = dispatcher.cloneEvent(inTouch);
            // Spec specifies that pointerId 1 is reserved for Mouse.
            // Touch identifiers can start at 0.
            // Add 2 to the touch identifier for compatibility.
            var id = e.pointerId = inTouch.identifier + 2;
            e.target = this.findTarget(inTouch, id);
            e.bubbles = true;
            e.cancelable = true;
            e.detail = this.clickCount;
            e.buttons = this.typeToButtons(cte.type);
            e.width = inTouch.webkitRadiusX || inTouch.radiusX || 0;
            e.height = inTouch.webkitRadiusY || inTouch.radiusY || 0;
            e.pressure = inTouch.webkitForce || inTouch.force || 0.5;
            e.isPrimary = this.isPrimaryTouch(inTouch);
            e.pointerType = this.POINTER_TYPE;
            e._source = 'touch';
            // forward touch preventDefaults
            var self = this;
            e.preventDefault = function() {
                self.scrolling = false;
                self.firstXY = null;
                cte.preventDefault();
            };
            return e;
        },
        processTouches: function(inEvent, inFunction) {
            var tl = inEvent.changedTouches;
            this.currentTouchEvent = inEvent;
            for (var i = 0, t, p; i < tl.length; i++) {
                t = tl[i];
                p = this.touchToPointer(t);
                if (inEvent.type === 'touchstart') {
                    pointermap.set(p.pointerId, p.target);
                }
                if (pointermap.has(p.pointerId)) {
                    inFunction.call(this, p);
                }
                if (inEvent.type === 'touchend' || inEvent._cancel) {
                    this.cleanUpPointer(p);
                }
            }
        },
        // For single axis scrollers, determines whether the element should emit
        // pointer events or behave as a scroller
        shouldScroll: function(inEvent) {
            if (this.firstXY) {
                var ret;
                var touchAction = scope.targetFinding.findTouchAction(inEvent);
                var scrollAxis = this.touchActionToScrollType(touchAction);
                if (scrollAxis === 'none') {
                    // this element is a touch-action: none, should never scroll
                    ret = false;
                } else if (scrollAxis === 'XY') {
                    // this element should always scroll
                    ret = true;
                } else {
                    var t = inEvent.changedTouches[0];
                    // check the intended scroll axis, and other axis
                    var a = scrollAxis;
                    var oa = scrollAxis === 'Y' ? 'X' : 'Y';
                    var da = Math.abs(t['client' + a] - this.firstXY[a]);
                    var doa = Math.abs(t['client' + oa] - this.firstXY[oa]);
                    // if delta in the scroll axis > delta other axis, scroll instead of
                    // making events
                    ret = da >= doa;
                }
                return ret;
            }
        },
        findTouch: function(inTL, inId) {
            for (var i = 0, l = inTL.length, t; i < l && (t = inTL[i]); i++) {
                if (t.identifier === inId) {
                    return true;
                }
            }
        },
        // In some instances, a touchstart can happen without a touchend. This
        // leaves the pointermap in a broken state.
        // Therefore, on every touchstart, we remove the touches that did not fire a
        // touchend event.
        // To keep state globally consistent, we fire a
        // pointercancel for this "abandoned" touch
        vacuumTouches: function(inEvent) {
            var tl = inEvent.touches;
            // pointermap.pointers() should be < tl.length here, as the touchstart has not
            // been processed yet.
            if (pointermap.pointers() >= tl.length) {
                var d = [];
                pointermap.forEach(function(value, key) {
                    // Never remove pointerId == 1, which is mouse.
                    // Touch identifiers are 2 smaller than their pointerId, which is the
                    // index in pointermap.
                    if (key !== 1 && !this.findTouch(tl, key - 2)) {
                        var p = value;
                        d.push(p);
                    }
                }, this);
                d.forEach(function(p) {
                    this.cancel(p);
                    pointermap.delete(p.pointerId);
                }, this);
            }
        },
        touchstart: function(inEvent) {
            this.vacuumTouches(inEvent);
            this.setPrimaryTouch(inEvent.changedTouches[0]);
            this.dedupSynthMouse(inEvent);
            if (!this.scrolling) {
                this.clickCount++;
                this.processTouches(inEvent, this.down);
            }
        },
        down: function(inPointer) {
            dispatcher.down(inPointer);
        },
        touchmove: function(inEvent) {
            if (HAS_TOUCH_ACTION) {
                // touchevent.cancelable == false is sent when the page is scrolling under native Touch Action in Chrome 36
                // https://groups.google.com/a/chromium.org/d/msg/input-dev/wHnyukcYBcA/b9kmtwM1jJQJ
                if (inEvent.cancelable) {
                    this.processTouches(inEvent, this.move);
                }
            } else {
                if (!this.scrolling) {
                    if (this.scrolling === null && this.shouldScroll(inEvent)) {
                        this.scrolling = true;
                    } else {
                        this.scrolling = false;
                        inEvent.preventDefault();
                        this.processTouches(inEvent, this.move);
                    }
                } else if (this.firstXY) {
                    var t = inEvent.changedTouches[0];
                    var dx = t.clientX - this.firstXY.X;
                    var dy = t.clientY - this.firstXY.Y;
                    var dd = Math.sqrt(dx * dx + dy * dy);
                    if (dd >= HYSTERESIS) {
                        this.touchcancel(inEvent);
                        this.scrolling = true;
                        this.firstXY = null;
                    }
                }
            }
        },
        move: function(inPointer) {
            dispatcher.move(inPointer);
        },
        touchend: function(inEvent) {
            this.dedupSynthMouse(inEvent);
            this.processTouches(inEvent, this.up);
        },
        up: function(inPointer) {
            inPointer.relatedTarget = scope.findTarget(inPointer);
            dispatcher.up(inPointer);
        },
        cancel: function(inPointer) {
            dispatcher.cancel(inPointer);
        },
        touchcancel: function(inEvent) {
            inEvent._cancel = true;
            this.processTouches(inEvent, this.cancel);
        },
        cleanUpPointer: function(inPointer) {
            pointermap['delete'](inPointer.pointerId);
            this.removePrimaryPointer(inPointer);
        },
        // prevent synth mouse events from creating pointer events
        dedupSynthMouse: function(inEvent) {
            var lts = scope.mouseEvents.lastTouches;
            var t = inEvent.changedTouches[0];
            // only the primary finger will synth mouse events
            if (this.isPrimaryTouch(t)) {
                // remember x/y of last touch
                var lt = {
                    x: t.clientX,
                    y: t.clientY
                };
                lts.push(lt);
                var fn = (function(lts, lt) {
                    var i = lts.indexOf(lt);
                    if (i > -1) {
                        lts.splice(i, 1);
                    }
                }).bind(null, lts, lt);
                setTimeout(fn, DEDUP_TIMEOUT);
            }
        }
    };

    // prevent "ghost clicks" that come from elements that were removed in a touch handler
    var STOP_PROP_FN = Event.prototype.stopImmediatePropagation || Event.prototype.stopPropagation;
    document.addEventListener('click', function(ev) {
        var x = ev.clientX,
            y = ev.clientY;
        // check if a click is within DEDUP_DIST px radius of the touchstart
        var closeTo = function(touch) {
            var dx = Math.abs(x - touch.x),
                dy = Math.abs(y - touch.y);
            return (dx <= DEDUP_DIST && dy <= DEDUP_DIST);
        };
        // if click coordinates are close to touch coordinates, assume the click came from a touch
        var wasTouched = scope.mouseEvents.lastTouches.some(closeTo);
        // if the click came from touch, and the touchstart target is not in the path of the click event,
        // then the touchstart target was probably removed, and the click should be "busted"
        var path = scope.targetFinding.path(ev);
        if (wasTouched) {
            for (var i = 0; i < path.length; i++) {
                if (path[i] === touchEvents.firstTarget) {
                    return;
                }
            }
            ev.preventDefault();
            STOP_PROP_FN.call(ev);
        }
    }, true);

    scope.touchEvents = touchEvents;
})(exports);

(function(scope) {
    var dispatcher = scope.dispatcher;
    var pointermap = dispatcher.pointermap;
    var HAS_BITMAP_TYPE = window.MSPointerEvent && typeof window.MSPointerEvent.MSPOINTER_TYPE_MOUSE === 'number';
    var msEvents = {
        events: [
            'MSPointerDown',
            'MSPointerMove',
            'MSPointerUp',
            'MSPointerCancel',
        ],
        register: function(target) {
            dispatcher.listen(target, this.events);
        },
        unregister: function(target) {
            if (target.nodeType === Node.DOCUMENT_NODE) {
                return;
            }
            dispatcher.unlisten(target, this.events);
        },
        POINTER_TYPES: [
            '',
            'unavailable',
            'touch',
            'pen',
            'mouse'
        ],
        prepareEvent: function(inEvent) {
            var e = inEvent;
            e = dispatcher.cloneEvent(inEvent);
            if (HAS_BITMAP_TYPE) {
                e.pointerType = this.POINTER_TYPES[inEvent.pointerType];
            }
            e._source = 'ms';
            return e;
        },
        cleanup: function(id) {
            pointermap['delete'](id);
        },
        MSPointerDown: function(inEvent) {
            var e = this.prepareEvent(inEvent);
            e.target = scope.findTarget(inEvent);
            pointermap.set(inEvent.pointerId, e.target);
            dispatcher.down(e);
        },
        MSPointerMove: function(inEvent) {
            var target = pointermap.get(inEvent.pointerId);
            if (target) {
                var e = this.prepareEvent(inEvent);
                e.target = target;
                dispatcher.move(e);
            }
        },
        MSPointerUp: function(inEvent) {
            var e = this.prepareEvent(inEvent);
            e.relatedTarget = scope.findTarget(inEvent);
            e.target = pointermap.get(e.pointerId);
            dispatcher.up(e);
            this.cleanup(inEvent.pointerId);
        },
        MSPointerCancel: function(inEvent) {
            var e = this.prepareEvent(inEvent);
            e.relatedTarget = scope.findTarget(inEvent);
            e.target = pointermap.get(e.pointerId);
            dispatcher.cancel(e);
            this.cleanup(inEvent.pointerId);
        }
    };

    scope.msEvents = msEvents;
})(exports);

(function(scope) {
    var dispatcher = scope.dispatcher;
    var pointermap = dispatcher.pointermap;
    var pointerEvents = {
        events: [
            'pointerdown',
            'pointermove',
            'pointerup',
            'pointercancel'
        ],
        prepareEvent: function(inEvent) {
            var e = dispatcher.cloneEvent(inEvent);
            e._source = 'pointer';
            return e;
        },
        register: function(target) {
            dispatcher.listen(target, this.events);
        },
        unregister: function(target) {
            if (target.nodeType === Node.DOCUMENT_NODE) {
                return;
            }
            dispatcher.unlisten(target, this.events);
        },
        cleanup: function(id) {
            pointermap['delete'](id);
        },
        pointerdown: function(inEvent) {
            var e = this.prepareEvent(inEvent);
            e.target = scope.findTarget(inEvent);
            pointermap.set(e.pointerId, e.target);
            dispatcher.down(e);
        },
        pointermove: function(inEvent) {
            var target = pointermap.get(inEvent.pointerId);
            if (target) {
                var e = this.prepareEvent(inEvent);
                e.target = target;
                dispatcher.move(e);
            }
        },
        pointerup: function(inEvent) {
            var e = this.prepareEvent(inEvent);
            e.relatedTarget = scope.findTarget(inEvent);
            e.target = pointermap.get(e.pointerId);
            dispatcher.up(e);
            this.cleanup(inEvent.pointerId);
        },
        pointercancel: function(inEvent) {
            var e = this.prepareEvent(inEvent);
            e.relatedTarget = scope.findTarget(inEvent);
            e.target = pointermap.get(e.pointerId);
            dispatcher.cancel(e);
            this.cleanup(inEvent.pointerId);
        }
    };

    scope.pointerEvents = pointerEvents;
})(exports);

/**
 * This module contains the handlers for native platform events.
 * From here, the dispatcher is called to create unified pointer events.
 * Included are touch events (v1), mouse events, and MSPointerEvents.
 */
(function(scope) {

    var dispatcher = scope.dispatcher;
    var nav = window.navigator;

    if (window.PointerEvent) {
        dispatcher.registerSource('pointer', scope.pointerEvents);
    } else if (nav.msPointerEnabled) {
        dispatcher.registerSource('ms', scope.msEvents);
    } else {
        dispatcher.registerSource('mouse', scope.mouseEvents);
        if (window.ontouchstart !== undefined) {
            dispatcher.registerSource('touch', scope.touchEvents);
        }
    }

    // Work around iOS bugs https://bugs.webkit.org/show_bug.cgi?id=135628 and https://bugs.webkit.org/show_bug.cgi?id=136506
    var ua = navigator.userAgent;
    var IS_IOS = ua.match(/iPad|iPhone|iPod/) && 'ontouchstart' in window;

    dispatcher.IS_IOS = IS_IOS;
    scope.touchEvents.IS_IOS = IS_IOS;

    dispatcher.register(document, true);
})(exports);

/**
 * This event denotes the beginning of a series of tracking events.
 *
 * @module PointerGestures
 * @submodule Events
 * @class trackstart
 */
/**
 * Pixels moved in the x direction since trackstart.
 * @type Number
 * @property dx
 */
/**
 * Pixes moved in the y direction since trackstart.
 * @type Number
 * @property dy
 */
/**
 * Pixels moved in the x direction since the last track.
 * @type Number
 * @property ddx
 */
/**
 * Pixles moved in the y direction since the last track.
 * @type Number
 * @property ddy
 */
/**
 * The clientX position of the track gesture.
 * @type Number
 * @property clientX
 */
/**
 * The clientY position of the track gesture.
 * @type Number
 * @property clientY
 */
/**
 * The pageX position of the track gesture.
 * @type Number
 * @property pageX
 */
/**
 * The pageY position of the track gesture.
 * @type Number
 * @property pageY
 */
/**
 * The screenX position of the track gesture.
 * @type Number
 * @property screenX
 */
/**
 * The screenY position of the track gesture.
 * @type Number
 * @property screenY
 */
/**
 * The last x axis direction of the pointer.
 * @type Number
 * @property xDirection
 */
/**
 * The last y axis direction of the pointer.
 * @type Number
 * @property yDirection
 */
/**
 * A shared object between all tracking events.
 * @type Object
 * @property trackInfo
 */
/**
 * The element currently under the pointer.
 * @type Element
 * @property relatedTarget
 */
/**
 * The type of pointer that make the track gesture.
 * @type String
 * @property pointerType
 */
/**
 *
 * This event fires for all pointer movement being tracked.
 *
 * @class track
 * @extends trackstart
 */
/**
 * This event fires when the pointer is no longer being tracked.
 *
 * @class trackend
 * @extends trackstart
 */

(function(scope) {
    var dispatcher = scope.dispatcher;
    var eventFactory = scope.eventFactory;
    var pointermap = new scope.PointerMap();
    var track = {
        events: [
            'down',
            'move',
            'up',
        ],
        exposes: [
            'trackstart',
            'track',
            'trackx',
            'tracky',
            'trackend'
        ],
        defaultActions: {
            'track': 'none',
            'trackx': 'pan-y',
            'tracky': 'pan-x'
        },
        WIGGLE_THRESHOLD: 4,
        clampDir: function(inDelta) {
            return inDelta > 0 ? 1 : -1;
        },
        calcPositionDelta: function(inA, inB) {
            var x = 0,
                y = 0;
            if (inA && inB) {
                x = inB.pageX - inA.pageX;
                y = inB.pageY - inA.pageY;
            }
            return {
                x: x,
                y: y
            };
        },
        fireTrack: function(inType, inEvent, inTrackingData) {
            var t = inTrackingData;
            var d = this.calcPositionDelta(t.downEvent, inEvent);
            var dd = this.calcPositionDelta(t.lastMoveEvent, inEvent);
            if (dd.x) {
                t.xDirection = this.clampDir(dd.x);
            } else if (inType === 'trackx') {
                return;
            }
            if (dd.y) {
                t.yDirection = this.clampDir(dd.y);
            } else if (inType === 'tracky') {
                return;
            }
            var gestureProto = {
                bubbles: true,
                cancelable: true,
                trackInfo: t.trackInfo,
                relatedTarget: inEvent.relatedTarget,
                pointerType: inEvent.pointerType,
                pointerId: inEvent.pointerId,
                _source: 'track'
            };
            if (inType !== 'tracky') {
                gestureProto.x = inEvent.x;
                gestureProto.dx = d.x;
                gestureProto.ddx = dd.x;
                gestureProto.clientX = inEvent.clientX;
                gestureProto.pageX = inEvent.pageX;
                gestureProto.screenX = inEvent.screenX;
                gestureProto.xDirection = t.xDirection;
            }
            if (inType !== 'trackx') {
                gestureProto.dy = d.y;
                gestureProto.ddy = dd.y;
                gestureProto.y = inEvent.y;
                gestureProto.clientY = inEvent.clientY;
                gestureProto.pageY = inEvent.pageY;
                gestureProto.screenY = inEvent.screenY;
                gestureProto.yDirection = t.yDirection;
            }
            var e = eventFactory.makeGestureEvent(inType, gestureProto);
            t.downTarget.dispatchEvent(e);
        },
        down: function(inEvent) {
            if (inEvent.isPrimary && (inEvent.pointerType === 'mouse' ? inEvent.buttons === 1 : true)) {
                var p = {
                    downEvent: inEvent,
                    downTarget: inEvent.target,
                    trackInfo: {},
                    lastMoveEvent: null,
                    xDirection: 0,
                    yDirection: 0,
                    tracking: false
                };
                pointermap.set(inEvent.pointerId, p);
            }
        },
        move: function(inEvent) {
            var p = pointermap.get(inEvent.pointerId);
            if (p) {
                if (!p.tracking) {
                    var d = this.calcPositionDelta(p.downEvent, inEvent);
                    var move = d.x * d.x + d.y * d.y;
                    // start tracking only if finger moves more than WIGGLE_THRESHOLD
                    if (move > this.WIGGLE_THRESHOLD) {
                        p.tracking = true;
                        p.lastMoveEvent = p.downEvent;
                        this.fireTrack('trackstart', inEvent, p);
                    }
                }
                if (p.tracking) {
                    this.fireTrack('track', inEvent, p);
                    this.fireTrack('trackx', inEvent, p);
                    this.fireTrack('tracky', inEvent, p);
                }
                p.lastMoveEvent = inEvent;
            }
        },
        up: function(inEvent) {
            var p = pointermap.get(inEvent.pointerId);
            if (p) {
                if (p.tracking) {
                    this.fireTrack('trackend', inEvent, p);
                }
                pointermap.delete(inEvent.pointerId);
            }
        }
    };
    dispatcher.registerGesture('track', track);
})(exports);

/**
 * This event is fired when a pointer is held down for 200ms.
 *
 * @module PointerGestures
 * @submodule Events
 * @class hold
 */
/**
 * Type of pointer that made the holding event.
 * @type String
 * @property pointerType
 */
/**
 * Screen X axis position of the held pointer
 * @type Number
 * @property clientX
 */
/**
 * Screen Y axis position of the held pointer
 * @type Number
 * @property clientY
 */
/**
 * Type of pointer that made the holding event.
 * @type String
 * @property pointerType
 */
/**
 * This event is fired every 200ms while a pointer is held down.
 *
 * @class holdpulse
 * @extends hold
 */
/**
 * Milliseconds pointer has been held down.
 * @type Number
 * @property holdTime
 */
/**
 * This event is fired when a held pointer is released or moved.
 *
 * @class release
 */

(function(scope) {
    var dispatcher = scope.dispatcher;
    var eventFactory = scope.eventFactory;
    var hold = {
        // wait at least HOLD_DELAY ms between hold and pulse events
        HOLD_DELAY: 200,
        // pointer can move WIGGLE_THRESHOLD pixels before not counting as a hold
        WIGGLE_THRESHOLD: 16,
        events: [
            'down',
            'move',
            'up',
        ],
        exposes: [
            'hold',
            'holdpulse',
            'release'
        ],
        heldPointer: null,
        holdJob: null,
        pulse: function() {
            var hold = Date.now() - this.heldPointer.timeStamp;
            var type = this.held ? 'holdpulse' : 'hold';
            this.fireHold(type, hold);
            this.held = true;
        },
        cancel: function() {
            clearInterval(this.holdJob);
            if (this.held) {
                this.fireHold('release');
            }
            this.held = false;
            this.heldPointer = null;
            this.target = null;
            this.holdJob = null;
        },
        down: function(inEvent) {
            if (inEvent.isPrimary && !this.heldPointer) {
                this.heldPointer = inEvent;
                this.target = inEvent.target;
                this.holdJob = setInterval(this.pulse.bind(this), this.HOLD_DELAY);
            }
        },
        up: function(inEvent) {
            if (this.heldPointer && this.heldPointer.pointerId === inEvent.pointerId) {
                this.cancel();
            }
        },
        move: function(inEvent) {
            if (this.heldPointer && this.heldPointer.pointerId === inEvent.pointerId) {
                var x = inEvent.clientX - this.heldPointer.clientX;
                var y = inEvent.clientY - this.heldPointer.clientY;
                if ((x * x + y * y) > this.WIGGLE_THRESHOLD) {
                    this.cancel();
                }
            }
        },
        fireHold: function(inType, inHoldTime) {
            var p = {
                bubbles: true,
                cancelable: true,
                pointerType: this.heldPointer.pointerType,
                pointerId: this.heldPointer.pointerId,
                x: this.heldPointer.clientX,
                y: this.heldPointer.clientY,
                _source: 'hold'
            };
            if (inHoldTime) {
                p.holdTime = inHoldTime;
            }
            var e = eventFactory.makeGestureEvent(inType, p);
            this.target.dispatchEvent(e);
        }
    };
    dispatcher.registerGesture('hold', hold);
})(exports);

/**
 * This event is fired when a pointer quickly goes down and up, and is used to
 * denote activation.
 *
 * Any gesture event can prevent the tap event from being created by calling
 * `event.preventTap`.
 *
 * Any pointer event can prevent the tap by setting the `tapPrevented` property
 * on itself.
 *
 * @module PointerGestures
 * @submodule Events
 * @class tap
 */
/**
 * X axis position of the tap.
 * @property x
 * @type Number
 */
/**
 * Y axis position of the tap.
 * @property y
 * @type Number
 */
/**
 * Type of the pointer that made the tap.
 * @property pointerType
 * @type String
 */
(function(scope) {
    var dispatcher = scope.dispatcher;
    var eventFactory = scope.eventFactory;
    var pointermap = new scope.PointerMap();
    var tap = {
        events: [
            'down',
            'up'
        ],
        exposes: [
            'tap'
        ],
        down: function(inEvent) {
            if (inEvent.isPrimary && !inEvent.tapPrevented) {
                pointermap.set(inEvent.pointerId, {
                    target: inEvent.target,
                    buttons: inEvent.buttons,
                    x: inEvent.clientX,
                    y: inEvent.clientY
                });
            }
        },
        shouldTap: function(e, downState) {
            var tap = true;
            if (e.pointerType === 'mouse') {
                // only allow left click to tap for mouse
                tap = (e.buttons ^ 1) && (downState.buttons & 1);
            }
            return tap && !e.tapPrevented;
        },
        up: function(inEvent) {
            var start = pointermap.get(inEvent.pointerId);
            if (start && this.shouldTap(inEvent, start)) {
                // up.relatedTarget is target currently under finger
                var t = scope.targetFinding.LCA(start.target, inEvent.relatedTarget);
                if (t) {
                    var e = eventFactory.makeGestureEvent('tap', {
                        bubbles: true,
                        cancelable: true,
                        x: inEvent.clientX,
                        y: inEvent.clientY,
                        detail: inEvent.detail,
                        pointerType: inEvent.pointerType,
                        pointerId: inEvent.pointerId,
                        altKey: inEvent.altKey,
                        ctrlKey: inEvent.ctrlKey,
                        metaKey: inEvent.metaKey,
                        shiftKey: inEvent.shiftKey,
                        _source: 'tap'
                    });
                    t.dispatchEvent(e);
                }
            }
            pointermap.delete(inEvent.pointerId);
        }
    };
    // patch eventFactory to remove id from tap's pointermap for preventTap calls
    eventFactory.preventTap = function(e) {
        return function() {
            e.tapPrevented = true;
            pointermap.delete(e.pointerId);
        };
    };
    dispatcher.registerGesture('tap', tap);
})(exports);

/*
 * Basic strategy: find the farthest apart points, use as diameter of circle
 * react to size change and rotation of the chord
 */

/**
 * @module pointer-gestures
 * @submodule Events
 * @class pinch
 */
/**
 * Scale of the pinch zoom gesture
 * @property scale
 * @type Number
 */
/**
 * Center X position of pointers causing pinch
 * @property centerX
 * @type Number
 */
/**
 * Center Y position of pointers causing pinch
 * @property centerY
 * @type Number
 */

/**
 * @module pointer-gestures
 * @submodule Events
 * @class rotate
 */
/**
 * Angle (in degrees) of rotation. Measured from starting positions of pointers.
 * @property angle
 * @type Number
 */
/**
 * Center X position of pointers causing rotation
 * @property centerX
 * @type Number
 */
/**
 * Center Y position of pointers causing rotation
 * @property centerY
 * @type Number
 */
(function(scope) {
    var dispatcher = scope.dispatcher;
    var eventFactory = scope.eventFactory;
    var pointermap = new scope.PointerMap();
    var RAD_TO_DEG = 180 / Math.PI;
    var pinch = {
        events: [
            'down',
            'up',
            'move',
            'cancel'
        ],
        exposes: [
            'pinchstart',
            'pinch',
            'pinchend',
            'rotate'
        ],
        defaultActions: {
            'pinch': 'none',
            'rotate': 'none'
        },
        reference: {},
        down: function(inEvent) {
            pointermap.set(inEvent.pointerId, inEvent);
            if (pointermap.pointers() == 2) {
                var points = this.calcChord();
                var angle = this.calcAngle(points);
                this.reference = {
                    angle: angle,
                    diameter: points.diameter,
                    target: scope.targetFinding.LCA(points.a.target, points.b.target)
                };

                this.firePinch('pinchstart', points.diameter, points);
            }
        },
        up: function(inEvent) {
            var p = pointermap.get(inEvent.pointerId);
            var num = pointermap.pointers();
            if (p) {
                if (num === 2) {
                    // fire 'pinchend' before deleting pointer
                    var points = this.calcChord();
                    this.firePinch('pinchend', points.diameter, points);
                }
                pointermap.delete(inEvent.pointerId);
            }
        },
        move: function(inEvent) {
            if (pointermap.has(inEvent.pointerId)) {
                pointermap.set(inEvent.pointerId, inEvent);
                if (pointermap.pointers() > 1) {
                    this.calcPinchRotate();
                }
            }
        },
        cancel: function(inEvent) {
            this.up(inEvent);
        },
        firePinch: function(type, diameter, points) {
            var zoom = diameter / this.reference.diameter;
            var e = eventFactory.makeGestureEvent(type, {
                bubbles: true,
                cancelable: true,
                scale: zoom,
                centerX: points.center.x,
                centerY: points.center.y,
                _source: 'pinch'
            });
            this.reference.target.dispatchEvent(e);
        },
        fireRotate: function(angle, points) {
            var diff = Math.round((angle - this.reference.angle) % 360);
            var e = eventFactory.makeGestureEvent('rotate', {
                bubbles: true,
                cancelable: true,
                angle: diff,
                centerX: points.center.x,
                centerY: points.center.y,
                _source: 'pinch'
            });
            this.reference.target.dispatchEvent(e);
        },
        calcPinchRotate: function() {
            var points = this.calcChord();
            var diameter = points.diameter;
            var angle = this.calcAngle(points);
            if (diameter != this.reference.diameter) {
                this.firePinch('pinch', diameter, points);
            }
            if (angle != this.reference.angle) {
                this.fireRotate(angle, points);
            }
        },
        calcChord: function() {
            var pointers = [];
            pointermap.forEach(function(p) {
                pointers.push(p);
            });
            var dist = 0;
            // start with at least two pointers
            var points = {
                a: pointers[0],
                b: pointers[1]
            };
            var x, y, d;
            for (var i = 0; i < pointers.length; i++) {
                var a = pointers[i];
                for (var j = i + 1; j < pointers.length; j++) {
                    var b = pointers[j];
                    x = Math.abs(a.clientX - b.clientX);
                    y = Math.abs(a.clientY - b.clientY);
                    d = x + y;
                    if (d > dist) {
                        dist = d;
                        points = {
                            a: a,
                            b: b
                        };
                    }
                }
            }
            x = Math.abs(points.a.clientX + points.b.clientX) / 2;
            y = Math.abs(points.a.clientY + points.b.clientY) / 2;
            points.center = {
                x: x,
                y: y
            };
            points.diameter = dist;
            return points;
        },
        calcAngle: function(points) {
            var x = points.a.clientX - points.b.clientX;
            var y = points.a.clientY - points.b.clientY;
            return (360 + Math.atan2(y, x) * RAD_TO_DEG) % 360;
        }
    };
    dispatcher.registerGesture('pinch', pinch);
})(exports);
},{}],9:[function(require,module,exports){
'use strict';

var Base = require('extend-me').Base;

var DataNodeBase = Base.extend('DataNodeBase', {

    isNullObject: false,

    INDENT: '   ', // 3 spaces

    initialize: function(key) {
        this.label = key;
        this.data = ['']; // TODO: Why is this first element needed?
        this.index = []; // TODO: formerly rowIndex
        this.hasChildren = false; // TODO: Where/how is this used?
        this.depth = 0;
        this.height = 1;
        this.expanded = false;
    },

    getValue: function(x) {
        return this.data[x];
    },

    prune: function(depth) {
        this.depth = depth;
        this.data[0] = this.computeDepthString();
    },

    computeDepthString: function() {
        return Array(this.depth + 1).join(this.INDENT) + '  ' + this.label;
    },

    computeHeight: function() {
        return 1;
    },

    getIndex: function() { // TODO: formerly getAllRowIndexes
        return this.index;
    },

    computeAggregates: function(aggregator) {
        var index = this.getIndex();

        if (index.length) {
            var groupsOffset = Number(aggregator.hasGroups());

            // redimension the data
            var data = this.data;
            data.length = groupsOffset + aggregator.aggregates.length;

            var sorter = aggregator.sorterInstance;
            sorter.index = index;

            aggregator.aggregates.forEach(function(aggregate, i) {
                data[groupsOffset + i] = aggregate(sorter);
            });
        }
    },

    buildView: function(aggregator) {
        aggregator.addView(this);
    },

    toggleExpansionState: function() { /* aggregator */
        //do nothing by default
    }

});

//DataNodeBase.prototype.applyAggregates = DataNodeBase.prototype.computeAggregates;

module.exports = DataNodeBase;
},{"extend-me":3}],10:[function(require,module,exports){
'use strict';

var Map = require('./util/Mappy');
var DataNodeBase = require('./DataNodeBase');

var expandedMap = {
    true: '\u25be', // '▾'
    false: '\u25b8' // '▸'
};

var DataNodeGroup = DataNodeBase.extend('DataNodeGroup', {

    extendable: true,

    initialize: function(key) {
        this.children = new Map();
    },

    prune: function(depth) {
        this.depth = depth;
        this.children = this.children.values; // TODO: why?
        this.children.forEach(function(child) {
            child.prune(depth + 1);
        });
        this.data[0] = this.computeDepthString();
    },

    computeDepthString: function() {
        return Array(this.depth + 1).join(this.INDENT) +
            expandedMap[this.expanded] + ' ' +
            this.label;
    },

    getIndex: function() {
        if (this.index.length === 0) {
            this.index = this.computeIndex();
        }
        return this.index;
    },

    computeIndex: function() { // TODO: formerly computerAllRowIndexes
        var result = [];
        result.append = append;
        this.children.forEach(function(child) {
            result.append(child.getIndex());
        });
        return result;
    },

    toggleExpansionState: function(aggregator) { /* aggregator */
        this.expanded = !this.expanded;
        this.data[0] = this.computeDepthString();
        if (this.expanded) {
            this.computeAggregates(aggregator);
        }
    },

    computeAggregates: function(aggregator) {
        DataNodeBase.prototype.computeAggregates.call(this, aggregator); // call base class's version
        if (this.expanded) {
            this.children.forEach(function(child) {
                child.computeAggregates(aggregator);
            });
        }
    },

    buildView: function(aggregator) {
        aggregator.view.push(this);
        if (this.expanded) {
            this.children.forEach(function(child) {
                child.buildView(aggregator);
            });
        }
    },

    computeHeight: function() {
        var height = 1;

        if (this.expanded) {
            this.children.forEach(function(child) {
                height = height + child.computeHeight();
            });
        }

        return (this.height = height);
    }

});

/**
 * @summary Array mixin to append another array to end of `this` one.
 * @desc Appends in place, unlike `this.concat()` which creates a new array.
 * Uses less memory than concat, important when `appendix` is huge.
 * > CAUTION: Mutates `this` array!
 * @param {Array} appendix
 * @returns {Array} Reference to `this` (for convenience)
 */
function append(appendix) {
    this.splice.bind(this, this.length, 0).apply(this, appendix);
    return this;
}

module.exports = DataNodeGroup;
},{"./DataNodeBase":9,"./util/Mappy":21}],11:[function(require,module,exports){
'use strict';

var DataNodeBase = require('./DataNodeBase');

var DataNodeLeaf = DataNodeBase.extend('DataNodeLeaf', {

    prune: function(depth) {
        this.depth = depth;
        this.data[0] = this.computeDepthString();
    },

    getIndex: function() {
        return this.index;
    },

    buildView: function(aggregator) {
        aggregator.addView(this);
    },

    computeHeight: function() {
        return 1;
    }

});

module.exports = DataNodeLeaf;
},{"./DataNodeBase":9}],12:[function(require,module,exports){
'use strict';

var DataNodeGroup = require('./DataNodeGroup');

var DataNodeTree = DataNodeGroup.extend('DataNodeTree', {

    initialize: function(key) {
        this.height = 0;
        this.expanded = true;
    },

    prune: function() {
        this.children = this.children.values;
        this.children.forEach(function(child) {
            child.prune(0);
        });
    },

    buildView: function(aggregator) {
        this.children.forEach(function(child) {
            child.buildView(aggregator);
        });
    },

    computeHeight: function() {
        var height = 1;

        this.children.forEach(function(child) {
            height = height + child.computeHeight();
        });

        return (this.height = height);
    }

});

module.exports = DataNodeTree;
},{"./DataNodeGroup":10}],13:[function(require,module,exports){
'use strict';

var headerify = require('./util/headerify');

function DataSource(data, fields) {
    this.fields = fields || computeFieldNames(data[0]);
    this.data = data;
}

DataSource.prototype = {
    constructor: DataSource.prototype.constructor, // preserve constructor

    isNullObject: false,

    getRow: function(y) {
        return this.data[y];
    },

    getValue: function(x, y) {
        var row = this.getRow(y);
        if (!row) {
            return null;
        }
        return row[this.fields[x]];
    },

    setValue: function(x, y, value) {
        this.getRow(y)[this.fields[x]] = value;
    },

    getRowCount: function() {
        return this.data.length;
    },

    getColumnCount: function() {
        return this.getFields().length;
    },

    getFields: function() {
        return this.fields;
    },

    getHeaders: function() {
        return (
            this.headers = this.headers ||
            this.getDefaultHeaders().map(function(each) {
                return headerify(each);
            })
        );
    },

    getDefaultHeaders: function() {
        return this.getFields();
    },

    setFields: function(fields) {
        this.fields = fields;
    },

    setHeaders: function(headers) {
        if (!(headers instanceof Array)) {
            error('setHeaders', 'param #1 `headers` not array');
        }
        this.headers = headers;
    },

    getGrandTotals: function() {
        //nothing here
        return;
    },

    setData: function(arrayOfUniformObjects) {
        this.data = arrayOfUniformObjects;
    }
};

function error(methodName, message) {
    throw new Error('DataSource.' + methodName + ': ' + message);
}

function computeFieldNames(object) {
    if (!object) {
        return [];
    }
    var fields = [].concat(Object.getOwnPropertyNames(object).filter(function(e) {
        return e.substr(0, 2) !== '__';
    }));
    return fields;
}

module.exports = DataSource;
},{"./util/headerify":23}],14:[function(require,module,exports){
'use strict';

var _ = require('object-iterators');

var DataSourceSorter = require('./DataSourceSorter');
var DataNodeTree = require('./DataNodeTree');
var DataNodeGroup = require('./DataNodeGroup');
var DataNodeLeaf = require('./DataNodeLeaf');
var headerify = require('./util/headerify');

//?[t,c,b,a]
// t is a dataSource,
// a is a dictionary of aggregates,  columnName:function
// b is a dictionary of groupbys, columnName:sourceColumnName
// c is a list of constraints,

function DataSourceAggregator(dataSource) {
    this.dataSource = dataSource;
    this.tree = new DataNodeTree('Totals');
    this.index = [];
    this.aggregates = [];
    this.headers = [];
    this.groupBys = [];
    this.view = [];
    this.sorterInstance = {};
    this.presortGroups = true;
    this.lastAggregate = {};
    this.setAggregates({});
}

DataSourceAggregator.prototype = {
    constructor: DataSourceAggregator.prototype.constructor, // preserve constructor

    isNullObject: false,

    setAggregates: function(aggregations) {
        this.lastAggregate = aggregations;
        this.clearAggregations();
        this.headers.length = 0;

        if (this.hasGroups()) {
            this.headers.push('Tree');
        }

        var self = this;
        _(aggregations).each(function(aggregation, key) {
            self.addAggregate(key, aggregation);
        });
    },

    addAggregate: function(label, func) {
        this.headers.push(headerify(label));
        this.aggregates.push(func);
    },

    setGroupBys: function(columnIndexArray) {
        var groupBys = this.groupBys;
        groupBys.length = 0;
        columnIndexArray.forEach(function(columnIndex) {
            groupBys.push(columnIndex);
        });
        this.setAggregates(this.lastAggregate);
    },

    addGroupBy: function(index) {
        this.groupBys.push(index);
    },

    hasGroups: function() {
        return !!this.groupBys.length;
    },

    hasAggregates: function() {
        return !!this.aggregates.length;
    },

    apply: function() {
        this.buildGroupTree();
    },

    clearGroups: function() {
        this.groupBys.length = 0;
    },

    clearAggregations: function() {
        this.aggregates.length = 0;
        this.headers.length = 0;
    },

    buildGroupTree: function() {
        var groupBys = this.groupBys,
            leafDepth = groupBys.length - 1,
            source = this.dataSource,
            rowCount = source.getRowCount(),
            tree = this.tree = new DataNodeTree('Totals');

        // first sort data
        if (this.presortGroups) {
            groupBys.reverse().forEach(function(groupBy) {
                source = new DataSourceSorter(source);
                source.sortOn(groupBy);
            });
        }

        for (var r = 0; r < rowCount; r++) {
            var path = tree;

            groupBys.forEach(function(g, c) { // eslint-disable-line no-loop-func
                var key = source.getValue(g, r),
                    terminalNode = (c === leafDepth),
                    Constructor = terminalNode ? DataNodeLeaf : DataNodeGroup,
                    ifAbsentFunc = createNode.bind(this, Constructor);
                path = path.children.getIfAbsent(key, ifAbsentFunc);
            });

            path.index.push(r);
        }

        this.sorterInstance = new DataSourceSorter(source);
        tree.prune();
        tree.computeAggregates(this);
        this.buildView();
    },

    addView: function(dataNode) {
        this.view.push(dataNode);
    },

    buildView: function() {
        this.view.length = 0;
        this.tree.computeHeight();
        this.tree.buildView(this);
    },

    viewMakesSense: function() {
        return this.hasAggregates();
    },

    getValue: function(x, y) {
        if (!this.viewMakesSense()) {
            return this.dataSource.getValue(x, y);
        }
        var row = this.view[y];
        if (!row) {
            return null;
        }
        return row.getValue(x); // TODO: what kind of object is row... ? should it be unfiltred?
    },

    setValue: function(x, y, value) {
        if (!this.viewMakesSense()) {
            return this.dataSource.setValue(x, y, value);
        }
    },

    getColumnCount: function() {
        if (!this.viewMakesSense()) {
            return this.dataSource.getColumnCount();
        }
        return this.getHeaders().length;
    },

    getRowCount: function() {
        if (!this.viewMakesSense()) {
            return this.dataSource.getRowCount();
        }
        return this.view.length; //header column
    },

    click: function(y) {
        var group = this.view[y];
        group.toggleExpansionState(this);
        this.buildView();
    },

    getHeaders: function() {
        if (!this.viewMakesSense()) {
            return this.dataSource.getHeaders();
        }
        return this.headers; // TODO: Views override dataSource headers with their own headers?
    },

    setHeaders: function(headers) {
        this.dataSource.setHeaders(headers);
    },

    getFields: function() {
        return this.dataSource.getFields();
    },

    setFields: function(fields) {
        return this.dataSource.setFields(fields);
    },

    getGrandTotals: function() {
        var view = this.tree;
        return [view.data];
    },

    getRow: function(y) {
        if (!this.viewMakesSense()) {
            return this.dataSource.getRow(y);
        }

        var rollups = this.view[y];

        return rollups ? rollups : this.tree;
    },

    setData: function(arrayOfUniformObjects) {
        this.dataSource.setData(arrayOfUniformObjects);
        this.apply();
    }
};

function createNode(DataNodeConstructor, key, map) {
    var value = new DataNodeConstructor(key);
    map.set(key, value);
    return value;
}

module.exports = DataSourceAggregator;
},{"./DataNodeGroup":10,"./DataNodeLeaf":11,"./DataNodeTree":12,"./DataSourceSorter":18,"./util/headerify":23,"object-iterators":28}],15:[function(require,module,exports){
'use strict';

var DataSourceIndexed = require('./DataSourceIndexed');

var DataSourceFilter = DataSourceIndexed.extend('DataSourceFilter', {

    initialize: function() {
        this.filters = [];
    },

    add: function(columnIndex, filter) {
        filter.columnIndex = columnIndex;
        this.filters.push(filter);
    },

    clearAll: function() {
        this.filters.length = 0;
        this.clearIndex();
    },

    applyAll: function() {
        if (!this.filters.length) {
            this.clearIndex();
        } else {
            this.buildIndex(applyFilters);
        }
    },

    getRowCount: function() {
        return this.filters.length ? this.index.length : this.dataSource.getRowCount();
    },

    aliases: {
        set: 'add'
    }
});

function applyFilters(r, rowObject) { // called in context from .buildIndex()
    var self = this;

    if (Array.prototype.find) {
        // double negative here means "no filter fails" (i.e., row passes all filters)
        return !this.filters.find(function(filter) {
            return !filter(self.dataSource.getValue(filter.columnIndex, r), rowObject, r);
        });
    } else {
        return this.filters.reduce(function(isFiltered, filter) {
            return isFiltered && filter(self.dataSource.getValue(filter.columnIndex, r), rowObject, r);
        }, true);
    }
}

module.exports = DataSourceFilter;

},{"./DataSourceIndexed":17}],16:[function(require,module,exports){
'use strict';

var DataSourceIndexed = require('./DataSourceIndexed');

var DataSourceGlobalFilter = DataSourceIndexed.extend('DataSourceGlobalFilter', {

    set: function(filter) {
        this.filter = filter;
    },

    clear: function() {
        delete this.filter;
        this.clearIndex();
    },

    apply: function() {
        if (!this.filter) {
            this.clearIndex();
        } else {
            this.buildIndex(applyFilter);
        }
    },

    getRowCount: function() {
        return this.filter ? this.index.length : this.dataSource.getRowCount();
    }
});

function applyFilter(r, rowObject) { // called in context from .buildIndex()
    var self = this;
    return this.getFields().find(function(columnIndex) {
        var cellValue = self.dataSource.getValue(columnIndex, r);
        return self.filter(cellValue, rowObject, r);
    });
}

module.exports = DataSourceGlobalFilter;
},{"./DataSourceIndexed":17}],17:[function(require,module,exports){
'use strict';

var Base = require('extend-me').Base;

var DataSourceIndexed = Base.extend('DataSourceIndexed', {

    isNullObject: false,

    initialize: function(dataSource) {
        this.dataSource = dataSource;
        this.index = [];
    },

    transposeY: function(y) {
        return this.index.length ? this.index[y] : y;
    },

    getRow: function(y) {
        return this.dataSource.getRow(this.transposeY(y));
    },

    getValue: function(x, y) {
        return this.dataSource.getValue(x, this.transposeY(y));
    },

    setValue: function(x, y, value) {
        this.dataSource.setValue(x, this.transposeY(y), value);
    },

    getRowCount: function() {
        return this.index.length || this.dataSource.getRowCount();
    },

    getColumnCount: function() {
        return this.dataSource.getColumnCount();
    },

    getFields: function() {
        return this.dataSource.getFields();
    },

    setFields: function(fields) {
        return this.dataSource.setFields(fields);
    },

    getDefaultHeaders: function() {
        return this.dataSource.getFields();
    },

    setHeaders: function(headers) {
        return this.dataSource.setHeaders(headers);
    },

    getHeaders: function() {
        return this.dataSource.getHeaders();
    },

    getGrandTotals: function() {
        return this.dataSource.getGrandTotals();
    },

    setData: function(arrayOfUniformObjects) {
        return this.dataSource.setData(arrayOfUniformObjects);
    },

    clearIndex: function() {
        this.index.length = 0;
    },

    buildIndex: function(predicate) {
        var rowCount = this.dataSource.getRowCount(),
            index = this.index;

        index.length = 0;

        for (var r = 0; r < rowCount; r++) {
            if (!predicate || predicate.call(this, r, this.dataSource.getRow(r))) {
                index.push(r);
            }
        }

        return index;
    }

});

module.exports = DataSourceIndexed;

},{"extend-me":3}],18:[function(require,module,exports){
'use strict';

var DataSourceIndexed = require('./DataSourceIndexed');
var stableSort = require('./util/stableSort');

var DataSourceSorter = DataSourceIndexed.extend('DataSourceSorter', {
    initialize: function() {
        this.descendingSort = false; // TODO: this does not seem to be in use
    },

    sortOn: function(colIdx, direction) {
        switch (direction) {
            case 0:
                this.clearIndex();
                break;

            case undefined:
            case 1:
            case -1:
                var self = this; // for use in getValue
                stableSort.sort(this.buildIndex(), getValue, direction);
                break;
        }

        function getValue(rowIdx) {
            return valOrFuncCall(self.dataSource.getValue(colIdx, rowIdx));
        }
    }
});

function valOrFuncCall(valOrFunc) {
    return typeof valOrFunc === 'function' ? valOrFunc() : valOrFunc;
}

module.exports = DataSourceSorter;
},{"./DataSourceIndexed":17,"./util/stableSort":24}],19:[function(require,module,exports){
'use strict';

var DataSourceIndexed = require('./DataSourceIndexed');
var DataSourceSorter = require('./DataSourceSorter');

var DataSourceSorterComposite = DataSourceIndexed.extend('DataSourceSorterComposite', {
    initialize: function() {
        this.sorts = [];
        this.last = this.dataSource;
    },

    // Caveats regarding this.sorts:
    // 1. Columns should be uniquely represented (i.e., no repeats with same columnIndex)
    // 2. Columns should be added low- to high-order (i.e., most grouped columns come last)
    sortOn: function(columnIndex, direction) {
        this.sorts.push([columnIndex, direction]);
    },

    applySorts: function() {
        var each = this.dataSource;

        this.sorts.forEach(function(sort) {
            each = new DataSourceSorter(each);
            each.sortOn.apply(each, sort);
        });

        this.last = each;
    },

    clearSorts: function() {
        this.sorts.length = 0;
        this.last = this.dataSource;
    },

    getValue: function(x, y) {
        return this.last.getValue(x, y);
    },

    setValue: function(x, y, value) {
        this.last.setValue(x, y, value);
    }
});

module.exports = DataSourceSorterComposite;
},{"./DataSourceIndexed":17,"./DataSourceSorter":18}],20:[function(require,module,exports){
'use strict';

module.exports = {
    JSDataSource: require('./DataSource'),
    DataSourceSorter: require('./DataSourceSorter'),
    DataSourceSorterComposite: require('./DataSourceSorterComposite'),
    DataSourceFilter: require('./DataSourceFilter'),
    DataSourceGlobalFilter: require('./DataSourceGlobalFilter'),
    DataSourceAggregator: require('./DataSourceAggregator'),
    util: {
        aggregations: require('./util/aggregations')
    }
};
},{"./DataSource":13,"./DataSourceAggregator":14,"./DataSourceFilter":15,"./DataSourceGlobalFilter":16,"./DataSourceSorter":18,"./DataSourceSorterComposite":19,"./util/aggregations":22}],21:[function(require,module,exports){
'use strict';

function Mappy() {
    this.keys = [];
    this.data = {};
    this.values = [];
}

Mappy.prototype = {

    constructor: Mappy.prototype.constructor, // preserve constructor

    set: function(key, value) {
        var hashCode = hash(key);
        if (!(hashCode in this.data)) {
            this.keys.push(key);
            this.values.push(value);
        }
        this.data[hashCode] = value;
    },

    get: function(key) {
        var hashCode = hash(key);
        return this.data[hashCode];
    },

    getIfAbsent: function(key, ifAbsentFunc) {
        var value = this.get(key);
        if (value === undefined) {
            value = ifAbsentFunc(key, this);
        }
        return value;
    },

    size: function() {
        return this.keys.length;
    },

    clear: function() {
        this.keys.length = 0;
        // TODO: Is there a reason why this.values is not being truncated here as well?
        this.data = {};
    },

    delete: function(key) {
        var hashCode = hash(key);
        if (this.data[hashCode] !== undefined) {
            var index = betterIndexOf(this.keys, key);
            this.keys.splice(index, 1);
            this.values.splice(index, 1);
            delete this.data[hashCode];
        }
    },

    forEach: function(func) {
        var keys = this.keys,
            self = this;
        keys.forEach(function(key) {
            var value = self.get(key);
            func(value, key, self);
        });
    },

    map: function(func) {
        var keys = this.keys,
            newMap = new Mappy(),
            self = this;
        keys.forEach(function(key) {
            var value = self.get(key),
                transformed = func(value, key, self);
            newMap.set(key, transformed);
        });
        return newMap;
    },

    copy: function() {
        var keys = this.keys,
            newMap = new Mappy(),
            self = this;
        keys.forEach(function(key) {
            var value = self.get(key);
            newMap.set(key, value);
        });
        return newMap;
    }

};

var OID_PREFIX = '.~.#%_'; //this should be something we never will see at the beginning of a string
var counter = 0;

function hash(key) {
    var typeOf = typeof key;

    switch (typeOf) {
        case 'number':
        case 'string':
        case 'boolean':
        case 'symbol':
            return OID_PREFIX + typeOf + '_' + key;

        case 'undefined':
            return OID_PREFIX + 'undefined';

        case 'object':
            // TODO: what about handling null (special case of object)?
        case 'function':
            return (key.___finhash = key.___finhash || OID_PREFIX + counter++); // eslint-disable-line
    }
}

// Object.is polyfill, courtesy of @WebReflection
var is = Object.is || function(a, b) {
    return a === b ? a !== 0 || 1 / a == 1 / b : a != a && b != b; // eslint-disable-line
};

// More reliable indexOf, courtesy of @WebReflection
function betterIndexOf(arr, value) {
    if (value != value || value === 0) { // eslint-disable-line
        for (var i = arr.length; i-- && !is(arr[i], value);) { // eslint-disable-line
        }
    } else {
        i = [].indexOf.call(arr, value);
    }
    return i;
}

module.exports = Mappy;
},{}],22:[function(require,module,exports){
'use strict';

function count(group) {
    return group.getRowCount();
}

function sum(columnIndex, group) {
    var r = group.getRowCount(),
        n = 0;

    while (r--) {
        n += group.getValue(columnIndex, r);
    }

    return n;
}

function minmax(columnIndex, method, n, group) {
    var r = group.getRowCount();

    while (r--) {
        n = method(n, group.getValue(columnIndex, r));
    }

    return n;
}

function avg(columnIndex, group) {
    return sum(columnIndex, group) / group.getRowCount();
}

function first(columnIndex, group) {
    return group.getValue(columnIndex, 0);
}

function last(columnIndex, group) {
    return group.getValue(columnIndex, group.getRowCount() - 1);
}

function stddev(columnIndex, group) {
    var rows = group.getRowCount(),
        mean = avg(columnIndex, group);

    for (var dev, r = rows, variance = 0; r--; variance += dev * dev) {
        dev = group.getValue(columnIndex, r) - mean;
    }

    return Math.sqrt(variance / rows);
}

module.exports = {
    count: function(columnIndex) {
        return count;
    },
    sum: function(columnIndex) {
        return sum.bind(this, columnIndex);
    },
    min: function(columnIndex) {
        return minmax.bind(this, columnIndex, Math.min, Infinity);
    },
    max: function(columnIndex) {
        return minmax.bind(this, columnIndex, Math.max, -Infinity);
    },
    avg: function(columnIndex) {
        return avg.bind(this, columnIndex);
    },
    first: function(columnIndex) {
        return first.bind(this, columnIndex);
    },
    last: function(columnIndex) {
        return last.bind(this, columnIndex);
    },
    stddev: function(columnIndex) {
        return stddev.bind(this, columnIndex);
    }
};
},{}],23:[function(require,module,exports){
'use strict';

function headerify(string) {
    return (/[a-z]/.test(string) ? string : string.toLowerCase())
        .replace(/[\s\-_]*([^\s\-_])([^\s\-_]+)/g, replacer)
        .replace(/[A-Z]/g, ' $&')
        .trim();
}

function replacer(a, b, c) {
    return b.toUpperCase() + c;
}

module.exports = headerify;
},{}],24:[function(require,module,exports){
'use strict';

function stabilize(comparator, descending, arr1, arr2) { // eslint-disable-line no-shadow
    var x = arr1[0];
    var y = arr2[0];

    if (x === y) {
        x = descending ? arr2[1] : arr1[1];
        y = descending ? arr1[1] : arr2[1];
    } else {
        if (y === null) {
            return -1;
        }
        if (x === null) {
            return 1;
        }
    }

    return comparator(x, y);
}

function ascendingNumbers(x, y) {
    return x - y;
}

function descendingNumbers(x, y) {
    return y - x;
}

function ascendingAllOthers(x, y) {
    return x < y ? -1 : 1;
}

function descendingAllOthers(x, y) {
    return y < x ? -1 : 1;
}

function ascending(typeOfData) {
    return stabilize.bind(this, typeOfData === 'number' ? ascendingNumbers : ascendingAllOthers, false);
}

function descending(typeOfData) {
    return stabilize.bind(this, typeOfData === 'number' ? descendingNumbers : descendingAllOthers, true);
}

function sort(index, getValue, direction) {

    var compare, i;

    // apply defaults
    if (direction === undefined) {
        direction = 1;
    }

    if (index.length) { // something to do
        switch (direction) {
            case 0:
                return; // bail: nothing to sort

            case undefined: // eslint-disable-line no-fallthrough
                direction = 1;
            case 1:
                compare = ascending(typeof getValue(0));
                break;

            case -1:
                compare = descending(typeof getValue(0));
                break;
        }

        // set up the sort.....
        var tmp = new Array(index.length);

        // add the index for "stability"
        for (i = 0; i < index.length; i++) {
            tmp[i] = [getValue(i), i];
        }

        // do the actual sort
        tmp.sort(compare);

        // copy the sorted values into our index vector
        for (i = 0; i < index.length; i++) {
            index[i] = tmp[i][1];
        }
    }

}

exports.sort = sort;
},{}],25:[function(require,module,exports){
// list-dragon node module
// https://github.com/openfin/list-dragon

'use strict';

/* eslint-env node, browser */

(function (module) {  // eslint-disable-line no-unused-expressions

    // This closure supports NodeJS-less client side includes with <script> tags. See notes at bottom of this file.

    var format = window.templex || require('templex');

    var REVERT_TO_STYLESHEET_VALUE = null;  // null removes the style

    var body, transform, timer, scrollVelocity;

    /* inject:css */
    (function(){var a="div.dragon-list{position:relative;background-color:#fff}div.dragon-list>div,div.dragon-list>ul{position:absolute;left:0;right:0}div.dragon-list>div{text-align:center;background-color:#00796b;color:#fff;box-shadow:0 3px 6px rgba(0,0,0,.16),0 3px 6px rgba(0,0,0,.23);overflow:hidden;white-space:nowrap}div.dragon-list>ul{overflow-y:auto;bottom:0;margin:0;padding:0;box-shadow:0 1px 3px rgba(0,0,0,.12),0 1px 2px rgba(0,0,0,.24)}div.dragon-list>ul>li,li.dragon-pop{white-space:nowrap;list-style-type:none;border:0 solid #f4f4f4;border-bottom:1px solid #e0e0e0;cursor:move;transition:border-top-width .2s}div.dragon-list>ul>li:last-child{height:0;border-bottom:none}li.dragon-pop{position:fixed;background-color:#fff;border:1px solid #e0e0e0;left:0;top:0;overflow-x:hidden;box-shadow:rgba(0,0,0,.188235) 0 10px 20px,rgba(0,0,0,.227451) 0 6px 6px}",b=document.createElement("style"),head=document.head||document.getElementsByTagName("head")[0];b.type="text/css";if(b.styleSheet)b.styleSheet.cssText=a;else b.appendChild(document.createTextNode(a));head.insertBefore(b,head.firstChild)})();
    /* endinject */

    /**
     * @constructor ListDragon
     *
     * @desc This object services a set of item lists that allow dragging and dropping items within and between lists in a set.
     *
     * Two strategies are supported:
     *
     * 1. Supply your own HTML markup and let the API build the item models for you.
     *    To use this strategy, script your HTML and provide one of these:
     *    * an array of all the list item (`<li>`) tags
     *    * a CSS selector that points to all the list item tags
     * 2. Supply your own item models and let the API build the HTML markup for you.
     *    To use this strategy, provide an array of model lists.
     *
     * The new ListDragon object's `modelLists` property references the array of model lists the API constructed for you in strategy #1 or the array of model lists you supplied for strategy #2.
     *
     * After the user performs a successful drag-and-drop operation, the position of the model references within the `modelLists` array is rearranged. (The models themselves are the original objects as supplied in the model lists; they are not rebuilt or altered in any way. Just the references to them are moved around.)
     *
     * @param {string|Element[]|modelListType[]} selectorOrModelLists - You must supply one of the items in **bold** below:
     *
     * 1. _For strategy #1 above (API creates models from supplied elements):_ All the list item (`<li>`) DOM elements of all the lists you want the new object to manage, as either:
     *    1. **A CSS selector;** _or_
     *    2. **An array of DOM elements**
     * 2. _For strategy #2 above (API creates elements from supplied models):_ **An array of model lists,** each of which is in one of the following forms:
     *    1. An array of item models (with various option properties hanging off of it); _and/or_
     *    2. A {@link modelListType} object with those same various option properties including the required `models` property containing that same array of item models.
     *
     * In either case (2.1 or 2.2), each element of such arrays of item models may take the form of:
     * * A string primitive; _or_
     * * A {@link itemModelType} object with a various option properties including the required `label` property containing a string primitive.
     *
     * Regarding these string primitives, each is either:
     * * A string to be displayed in the list item; _or_
     * * A format string with other property values merged in, the result of which is to be displayed in the list item.
     *
     * @param {object} [options={}] - There are no formal options, but you can supply "global" template variables here, representing the "outer scope," after first searching each model and then each model list.
     */
    function ListDragon(selectorOrModelLists, options) {

        if (!(this instanceof ListDragon)) {
            throw error('Not called with "new" keyword.');
        }

        var self = this, modelLists, items;

        options = options || {};

        if (typeof selectorOrModelLists === 'string') {
            items = toArray(document.querySelectorAll(selectorOrModelLists));
            modelLists = createModelListsFromListElements(items);
        } else if (selectorOrModelLists[0] instanceof Element) {
            items = toArray(selectorOrModelLists);
            modelLists = createModelListsFromListElements(items);
        } else {
            // param is array of model lists
            // build new <ul> element(s) for each list and put in `.modelLists`;
            // fill `.items` array with <li> elements from these new <ul> elements
            items = [];
            modelLists = createListElementsFromModelLists(selectorOrModelLists, options);
            modelLists.forEach(function (list) {
                items = items.concat(toArray(list.element.querySelectorAll('li')));
            });
        }

        items.forEach(function (itemElement, index) {
            var item = (itemElement !== itemElement.parentElement.lastElementChild)
                ? self.addEvt(itemElement, 'mousedown', itemElement, true)
                : { element: itemElement };

            /* `item.model` not currently needed so commented out here.
             * (Originally used for rebuilding modelLists for final
             * reporting, modelLists are now spliced on every successful
             * drag-and-drop operation so they're always up to date.)

             var origin = this.itemCoordinates(itemElement);
             item.model = this.modelLists[origin.list].models[origin.item];

             */

            items[index] = item;
        });

        body = body || document.getElementsByTagName('body')[0];

        transform = 'transform' in items[0].element.style
            ? 'transform' // Chrome 45 and Firefox 40
            : '-webkit-transform'; // Safari 8

        // set up the new object
        this.modelLists = modelLists;
        this.items = items;
        this.bindings = {};
        this.callback = {};

    }

    ListDragon.prototype = {

        addEvt: function (target, type, listener, doNotBind) {
            var binding = {
                handler: handlers[type].bind(target, this),
                element: listener || window
            };

            if (!doNotBind) {
                this.bindings[type] = binding;
            }

            binding.element.addEventListener(type, binding.handler);

            return binding;
        },

        removeEvt: function (type) {
            var binding = this.bindings[type];
            delete this.bindings[type];
            binding.element.removeEventListener(type, binding.handler);
        },

        removeAllEventListeners: function () {
            // remove drag & drop events (mousemove, mouseup, and transitionend)
            for (var type in this.bindings) {
                var binding = this.bindings[type];
                binding.element.removeEventListener(type, binding.handler);
            }
            // remove the mousedown events from all list items
            this.items.forEach(function (item) {
                if (item.handler) {
                    item.element.removeEventListener('mousedown', item.handler);
                }
            });
        },

        pointInListRects: function (point) {
            return this.modelLists.find(function (modelList) {
                var rect = modelList.element.getBoundingClientRect();

                rect = {
                    left:   window.scrollX + rect.left,
                    top:    window.scrollY + rect.top,
                    right:  window.scrollX + rect.right,
                    bottom: window.scrollY + rect.bottom,
                    width:  rect.width,
                    height: rect.height
                };

                modelList.rect = rect;

                if (pointInRect(point, rect)) {
                    modelList.rect = rect;
                    return true; // found
                } else {
                    return false;
                }
            });
        },

        pointInItemRects: function (point, except1, except2) {
            return this.items.find(function (item) {
                var element = item.element;
                return (
                    element !== except1 &&
                    element !== except2 &&
                    pointInRect(point, item.rect)
                );
            });
        },

        // get positions of all list items in page coords (normalized for window and list scrolling)
        getAllItemBoundingRects: function () {
            var modelLists = this.modelLists, height;
            this.items.forEach(function (item) {
                var itemElement = item.element,
                    listElement = itemElement.parentElement,
                    list = modelLists.find(function (list) { return list.element === listElement; });

                if (
                    // omitted: default to true
                    list.isDropTarget === undefined ||

                    // function: use return value
                    typeof list.isDropTarget === 'function' && list.isDropTarget() ||

                    // otherwise: use truthiness of given value
                    list.isDropTarget
                ) {
                    var rect = itemElement.getBoundingClientRect(),
                        bottom = rect.bottom;

                    if (itemElement === listElement.lastElementChild) {
                        bottom = listElement.getBoundingClientRect().bottom;
                        if (bottom < rect.top) {
                            bottom = rect.top + (height || 50);
                        }
                    } else {
                        height = rect.height;
                    }

                    rect = {
                        left:   window.scrollX + rect.left,
                        right:  window.scrollX + rect.right,
                        top:    window.scrollY + rect.top    + listElement.scrollTop,
                        bottom: window.scrollY + bottom + listElement.scrollTop
                    };

                    item.rect = rect;
                }
            });
        },

        reinsert: function (target) {
            var style = target.style;
            style.width = style[transform] = style.transition = REVERT_TO_STYLESHEET_VALUE;

            target.classList.remove('dragon-pop');

            this.drop.style.transitionDuration = '0s';
            this.drop.style.borderTopWidth = REVERT_TO_STYLESHEET_VALUE;
            this.drop.parentElement.insertBefore(target, this.drop);

            delete this.drop;
        },

        // return an object { item: <item index within list>, list: <list index within list of lists> }
        itemCoordinates: function (item) {
            var listElement = item.parentElement,
                coords = { item: 0 };

            while ((item = item.previousElementSibling)) {
                ++coords.item;
            }

            this.modelLists.find(function (list, index) {
                coords.list = index;
                return list.element === listElement; // stop when we find the one we belong to
            });

            return coords;
        }

    };

    var handlers = {
        mousedown: function (dragon, evt) {

            evt.stopPropagation();
            evt.preventDefault();  //prevents user selection of rendered nodes during drag

            if (dragon.drop) {
                return;
            }

            var rect = this.getBoundingClientRect();

            dragon.rect = rect = {
                left:   Math.round(rect.left - 1),
                top:    Math.round(rect.top - 1),
                right:  Math.round(rect.right),
                bottom: Math.round(rect.bottom),
                width:  Math.round(rect.width),
                height: Math.round(rect.height)
            };

            dragon.pin = {
                x: window.scrollX + evt.clientX,
                y: window.scrollY + evt.clientY
            };

            dragon.origin = dragon.itemCoordinates(this);

            if (dragon.callback.grabbed) {
                dragon.callback.grabbed.call(this, dragon);
            }

            dragon.getAllItemBoundingRects();

            dragon.drop = this.nextElementSibling;
            dragon.drop.style.transitionDuration = '0s';
            dragon.drop.style.borderTopWidth = rect.height + 'px';

            this.style.width = rect.width + 'px';
            this.style.transitionDuration = '0s';
            this.style[transform] = translate(
                rect.left - window.scrollX,
                rect.top  - window.scrollY
            );
            this.classList.add('dragon-pop');
            this.style.zIndex = window.getComputedStyle(dragon.modelLists[0].container.parentElement).zIndex;

            body.appendChild(this);

            rect.left   += window.scrollX;
            rect.top    += window.scrollY;
            rect.right  += window.scrollX;
            rect.bottom += window.scrollY;

            dragon.addEvt(this, 'mousemove');
            dragon.addEvt(this, 'mouseup');
        },

        mousemove: function (dragon, evt) {
            dragon.drop.style.transition = REVERT_TO_STYLESHEET_VALUE;

            var hoverList = dragon.pointInListRects({ x: evt.clientX, y: evt.clientY }) || dragon.mostRecentHoverList;

            if (hoverList) {
                var dx = evt.clientX - dragon.pin.x,
                    dy = evt.clientY - dragon.pin.y;

                dragon.mostRecentHoverList = hoverList;

                var maxScrollY = hoverList.element.scrollHeight - hoverList.rect.height,
                    y = evt.clientY + window.scrollY,
                    magnitude;

                if (maxScrollY > 0) {
                    // list is scrollable (is taller than rect)
                    if (hoverList.element.scrollTop > 0 && (magnitude = y - (hoverList.rect.top + 5)) < 0) {
                        // mouse near or above top and list is not scrolled to top yet
                        resetAutoScrollTimer(magnitude, 0, hoverList.element);
                    } else if (hoverList.element.scrollTop < maxScrollY && (magnitude = y - (hoverList.rect.bottom - 1 - 5)) > 0) {
                        // mouse near or below bottom and list not scrolled to bottom yet
                        resetAutoScrollTimer(magnitude, maxScrollY, hoverList.element);
                    } else {
                        // mouse inside
                        resetAutoScrollTimer();
                    }
                }

                var other = dragon.pointInItemRects({
                    x: evt.clientX,
                    y: dragon.rect.bottom + window.scrollY + dy + hoverList.element.scrollTop
                }, this, dragon.drop);

                this.style[transform] = translate(
                    dragon.rect.left - window.scrollX + dx,
                    dragon.rect.top - window.scrollY + dy
                );

                if (other) {
                    var element = other.element;
                    element.style.transition = REVERT_TO_STYLESHEET_VALUE;
                    element.style.borderTopWidth = dragon.drop.style.borderTopWidth;
                    dragon.drop.style.borderTopWidth = null;
                    dragon.drop = element;
                }
            }
        },

        mouseup: function (dragon, evt) {
            resetAutoScrollTimer();
            dragon.removeEvt('mousemove');
            dragon.removeEvt('mouseup');

            evt.stopPropagation();

            var newRect = this.getBoundingClientRect();

            if (
                window.scrollX + newRect.left === dragon.rect.left &&
                window.scrollY + newRect.top === dragon.rect.top
            ) {
                dragon.reinsert(this);
            } else {
                var dropRect = dragon.drop.getBoundingClientRect();

                dragon.addEvt(this, 'transitionend', this);
                this.style.transitionDuration = REVERT_TO_STYLESHEET_VALUE; //reverts to 200ms
                this.style.transitionProperty = transform;
                this.style[transform] = translate(
                    dropRect.left - window.scrollX,
                    dropRect.top - window.scrollY
                );
            }
        },

        transitionend: function (dragon, evt) {
            if (evt.propertyName === transform) {
                dragon.removeEvt('transitionend');
                dragon.reinsert(this);

                this.style.transitionProperty = REVERT_TO_STYLESHEET_VALUE; //reverts to border-top-width

                var model = dragon.modelLists[dragon.origin.list].splice(dragon.origin.item, 1)[0];
                var destination = dragon.itemCoordinates(this);
                dragon.modelLists[destination.list].splice(destination.item, 0, model);

                if (dragon.callback.dropped) {
                    dragon.callback.dropped.call(this, dragon);
                }
            }
        }
    };

    function resetAutoScrollTimer(magnitude, limit, element) {
        if (!magnitude) {
            clearInterval(timer);
            scrollVelocity = 0;
        } else {
            var changeDirection =
                scrollVelocity  <  0 && magnitude  >= 0 ||
                scrollVelocity === 0 && magnitude !== 0 ||
                scrollVelocity  >  0 && magnitude  <= 0;
            scrollVelocity = magnitude > 0 ? Math.min(50, magnitude) : Math.max(-50, magnitude);
            if (changeDirection) {
                clearInterval(timer);
                timer = setInterval(function (limit) {
                    var scrollTop = element.scrollTop + scrollVelocity;
                    if (scrollVelocity < 0 && scrollTop < limit || scrollVelocity > 0 && scrollTop > limit) {
                        element.scrollTop = limit;
                        clearInterval(timer);
                    } else {
                        element.scrollTop = scrollTop;
                    }
                }, 125);
            }
        }
    }

    function toArray(arrayLikeObject) {
        return Array.prototype.slice.call(arrayLikeObject);
    }

    function pointInRect(point, rect) {
        return rect.top <= point.y && point.y <= rect.bottom
            && rect.left <= point.x && point.x <= rect.right;
    }

    function translate(left, top) {
        return 'translate('
            + Math.floor(left + window.scrollX) + 'px,'
            + Math.floor(top + window.scrollY) + 'px)';
    }

    function htmlEncode(string) {
        var textNode = document.createTextNode(string);

        return document
            .createElement('a')
            .appendChild(textNode)
            .parentNode
            .innerHTML;
    }

    /**
     * Creates `<ul>...</ul>` elements and inserts them into an `element` property on each model.
     * @param {object} modelLists
     * @returns `modelLists`
     */
    function createListElementsFromModelLists(modelLists, options) {
        var templateLabel = options.label || '{label}';

        modelLists.forEach(function (modelList, listIndex) {
            var listLabel = modelList.label || templateLabel,
                listHtmlEncode = modelList.htmlEncode !== undefined && modelList.htmlEncode || options.htmlEncode,
                container = document.createElement('div'),
                listElement = document.createElement('ul');

            if (modelList.models) {
                Object.keys(modelList).forEach(function (key) {
                    if (key !== 'models') {
                        modelList.models[key] = modelList[key];
                    }
                });
                modelLists[listIndex] = modelList = modelList.models;
            } else if (modelList instanceof Array) {
                modelList.models = modelList; // point to self
            } else {
                throw error('List [{1}] not an array of models (with or without additional properties) OR ' +
                    'an object (with a `models` property containing an array of models).', listIndex);
            }

            modelList.forEach(function (model) {
                var modelLabel = model.label || listLabel,
                    modelHtmlEncode = model.htmlEncode !== undefined && model.htmlEncode || listHtmlEncode,
                    modelObject = typeof model === 'object' ? model : { label: model},
                    label = format.call([modelObject, modelList, options], modelLabel),
                    itemElement = document.createElement('li');

                itemElement.innerHTML = modelHtmlEncode ? htmlEncode(label) : label;

                listElement.appendChild(itemElement);
            });

            // append the final "fencepost" item -- drop target at bottom of list after all items
            var itemElement = document.createElement('li');
            itemElement.innerHTML = '&nbsp;';
            listElement.appendChild(itemElement);

            // append header to container
            if (modelList.title) {
                var header = document.createElement('div');
                header.innerHTML = listHtmlEncode ? htmlEncode(modelList.title) : modelList.title;
                container.appendChild(header);
            }

            container.appendChild(listElement);
            container.className = modelList.cssClassNames || options.cssClassNames || 'dragon-list';
            modelList.element = listElement;
            modelList.container = container;
        });

        return modelLists;
    }

    /**
     * Create a `.modelLists` array with these <li> elements' parent <ul> elements
     * @param {Element[]} listItemElements
     * @returns {Array}
     */
    function createModelListsFromListElements(listItemElements) {
        var modelLists = [];

        listItemElements.forEach(function (itemElement) {
            var listElement = itemElement.parentElement,
                container = listElement.parentElement,
                models = [];
            if (!modelLists.find(function (list) { return list.element === listElement; })) {
                toArray(listElement.querySelectorAll('li')).forEach(function (itemElement) {
                    if (itemElement !== listElement.lastElementChild) {
                        models.push(itemElement.innerHTML);
                    }
                });
                models.element = listElement;
                models.container = container;
                modelLists.push(models);
            }
        });

        return modelLists;
    }

    function error() {
        return 'list-dragon: ' + format.apply(this, Array.prototype.slice.call(arguments));
    }

    // this interface consists solely of the prototypal object constructor
    module.exports = ListDragon;

})(
    typeof module === 'object' && module || (window.ListDragon = {}),
    typeof module === 'object' && module.exports || (window.ListDragon.exports = {})
) || (
    typeof module === 'object' || (window.ListDragon = window.ListDragon.exports)
);

/* About the above IIFE:
 * This file is a "modified node module." It functions as usual in Node.js *and* is also usable directly in the browser.
 * 1. Node.js: The IIFE is superfluous but innocuous.
 * 2. In the browser: The IIFE closure serves to keep internal declarations private.
 * 2.a. In the browser as a global: The logic in the actual parameter expressions + the post-invocation expression
 * will put your API in `window.ListDragon`.
 * 2.b. In the browser as a module: If you predefine a `window.module` object, the results will be in `module.exports`.
 * The bower component `mnm` makes this easy and also provides a global `require()` function for referencing your module
 * from other closures. In either case, this works with both NodeJs-style export mechanisms -- a single API assignment,
 * `module.exports = yourAPI` *or* a series of individual property assignments, `module.exports.property = property`.
 *
 * Before the IIFE runs, the actual parameter expressions are executed:
 * 1. If `window` object undefined, we're in NodeJs so assume there is a `module` object with an `exports` property
 * 2. If `window` object defined, we're in browser
 * 2.a. If `module` object predefined, use it
 * 2.b. If `module` object undefined, create a `ListDragon` object
 *
 * After the IIFE returns:
 * Because it always returns undefined, the expression after the || will execute:
 * 1. If `window` object undefined, then we're in NodeJs so we're done
 * 2. If `window` object defined, then we're in browser
 * 2.a. If `module` object predefined, we're done; results are in `moudule.exports`
 * 2.b. If `module` object undefined, redefine`ListDragon` to be the `ListDragon.exports` object
 */

},{"templex":31}],26:[function(require,module,exports){
;(function () { // closure for web browsers

if (typeof module === 'object' && module.exports) {
  module.exports = LRUCache
} else {
  // just set the global for non-node platforms.
  this.LRUCache = LRUCache
}

function hOP (obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key)
}

function naiveLength () { return 1 }

var didTypeWarning = false
function typeCheckKey(key) {
  if (!didTypeWarning && typeof key !== 'string' && typeof key !== 'number') {
    didTypeWarning = true
    console.error(new TypeError("LRU: key must be a string or number. Almost certainly a bug! " + typeof key).stack)
  }
}

function LRUCache (options) {
  if (!(this instanceof LRUCache))
    return new LRUCache(options)

  if (typeof options === 'number')
    options = { max: options }

  if (!options)
    options = {}

  this._max = options.max
  // Kind of weird to have a default max of Infinity, but oh well.
  if (!this._max || !(typeof this._max === "number") || this._max <= 0 )
    this._max = Infinity

  this._lengthCalculator = options.length || naiveLength
  if (typeof this._lengthCalculator !== "function")
    this._lengthCalculator = naiveLength

  this._allowStale = options.stale || false
  this._maxAge = options.maxAge || null
  this._dispose = options.dispose
  this.reset()
}

// resize the cache when the max changes.
Object.defineProperty(LRUCache.prototype, "max",
  { set : function (mL) {
      if (!mL || !(typeof mL === "number") || mL <= 0 ) mL = Infinity
      this._max = mL
      if (this._length > this._max) trim(this)
    }
  , get : function () { return this._max }
  , enumerable : true
  })

// resize the cache when the lengthCalculator changes.
Object.defineProperty(LRUCache.prototype, "lengthCalculator",
  { set : function (lC) {
      if (typeof lC !== "function") {
        this._lengthCalculator = naiveLength
        this._length = this._itemCount
        for (var key in this._cache) {
          this._cache[key].length = 1
        }
      } else {
        this._lengthCalculator = lC
        this._length = 0
        for (var key in this._cache) {
          this._cache[key].length = this._lengthCalculator(this._cache[key].value)
          this._length += this._cache[key].length
        }
      }

      if (this._length > this._max) trim(this)
    }
  , get : function () { return this._lengthCalculator }
  , enumerable : true
  })

Object.defineProperty(LRUCache.prototype, "length",
  { get : function () { return this._length }
  , enumerable : true
  })


Object.defineProperty(LRUCache.prototype, "itemCount",
  { get : function () { return this._itemCount }
  , enumerable : true
  })

LRUCache.prototype.forEach = function (fn, thisp) {
  thisp = thisp || this
  var i = 0
  var itemCount = this._itemCount

  for (var k = this._mru - 1; k >= 0 && i < itemCount; k--) if (this._lruList[k]) {
    i++
    var hit = this._lruList[k]
    if (isStale(this, hit)) {
      del(this, hit)
      if (!this._allowStale) hit = undefined
    }
    if (hit) {
      fn.call(thisp, hit.value, hit.key, this)
    }
  }
}

LRUCache.prototype.keys = function () {
  var keys = new Array(this._itemCount)
  var i = 0
  for (var k = this._mru - 1; k >= 0 && i < this._itemCount; k--) if (this._lruList[k]) {
    var hit = this._lruList[k]
    keys[i++] = hit.key
  }
  return keys
}

LRUCache.prototype.values = function () {
  var values = new Array(this._itemCount)
  var i = 0
  for (var k = this._mru - 1; k >= 0 && i < this._itemCount; k--) if (this._lruList[k]) {
    var hit = this._lruList[k]
    values[i++] = hit.value
  }
  return values
}

LRUCache.prototype.reset = function () {
  if (this._dispose && this._cache) {
    for (var k in this._cache) {
      this._dispose(k, this._cache[k].value)
    }
  }

  this._cache = Object.create(null) // hash of items by key
  this._lruList = Object.create(null) // list of items in order of use recency
  this._mru = 0 // most recently used
  this._lru = 0 // least recently used
  this._length = 0 // number of items in the list
  this._itemCount = 0
}

LRUCache.prototype.dump = function () {
  var arr = []
  var i = 0

  for (var k = this._mru - 1; k >= 0 && i < this._itemCount; k--) if (this._lruList[k]) {
    var hit = this._lruList[k]
    if (!isStale(this, hit)) {
      //Do not store staled hits
      ++i
      arr.push({
        k: hit.key,
        v: hit.value,
        e: hit.now + (hit.maxAge || 0)
      });
    }
  }
  //arr has the most read first
  return arr
}

LRUCache.prototype.dumpLru = function () {
  return this._lruList
}

LRUCache.prototype.set = function (key, value, maxAge) {
  maxAge = maxAge || this._maxAge
  typeCheckKey(key)

  var now = maxAge ? Date.now() : 0
  var len = this._lengthCalculator(value)

  if (hOP(this._cache, key)) {
    if (len > this._max) {
      del(this, this._cache[key])
      return false
    }
    // dispose of the old one before overwriting
    if (this._dispose)
      this._dispose(key, this._cache[key].value)

    this._cache[key].now = now
    this._cache[key].maxAge = maxAge
    this._cache[key].value = value
    this._length += (len - this._cache[key].length)
    this._cache[key].length = len
    this.get(key)

    if (this._length > this._max)
      trim(this)

    return true
  }

  var hit = new Entry(key, value, this._mru++, len, now, maxAge)

  // oversized objects fall out of cache automatically.
  if (hit.length > this._max) {
    if (this._dispose) this._dispose(key, value)
    return false
  }

  this._length += hit.length
  this._lruList[hit.lu] = this._cache[key] = hit
  this._itemCount ++

  if (this._length > this._max)
    trim(this)

  return true
}

LRUCache.prototype.has = function (key) {
  typeCheckKey(key)
  if (!hOP(this._cache, key)) return false
  var hit = this._cache[key]
  if (isStale(this, hit)) {
    return false
  }
  return true
}

LRUCache.prototype.get = function (key) {
  typeCheckKey(key)
  return get(this, key, true)
}

LRUCache.prototype.peek = function (key) {
  typeCheckKey(key)
  return get(this, key, false)
}

LRUCache.prototype.pop = function () {
  var hit = this._lruList[this._lru]
  del(this, hit)
  return hit || null
}

LRUCache.prototype.del = function (key) {
  typeCheckKey(key)
  del(this, this._cache[key])
}

LRUCache.prototype.load = function (arr) {
  //reset the cache
  this.reset();

  var now = Date.now()
  //A previous serialized cache has the most recent items first
  for (var l = arr.length - 1; l >= 0; l-- ) {
    var hit = arr[l]
    typeCheckKey(hit.k)
    var expiresAt = hit.e || 0
    if (expiresAt === 0) {
      //the item was created without expiration in a non aged cache
      this.set(hit.k, hit.v)
    } else {
      var maxAge = expiresAt - now
      //dont add already expired items
      if (maxAge > 0) this.set(hit.k, hit.v, maxAge)
    }
  }
}

function get (self, key, doUse) {
  typeCheckKey(key)
  var hit = self._cache[key]
  if (hit) {
    if (isStale(self, hit)) {
      del(self, hit)
      if (!self._allowStale) hit = undefined
    } else {
      if (doUse) use(self, hit)
    }
    if (hit) hit = hit.value
  }
  return hit
}

function isStale(self, hit) {
  if (!hit || (!hit.maxAge && !self._maxAge)) return false
  var stale = false;
  var diff = Date.now() - hit.now
  if (hit.maxAge) {
    stale = diff > hit.maxAge
  } else {
    stale = self._maxAge && (diff > self._maxAge)
  }
  return stale;
}

function use (self, hit) {
  shiftLU(self, hit)
  hit.lu = self._mru ++
  self._lruList[hit.lu] = hit
}

function trim (self) {
  while (self._lru < self._mru && self._length > self._max)
    del(self, self._lruList[self._lru])
}

function shiftLU (self, hit) {
  delete self._lruList[ hit.lu ]
  while (self._lru < self._mru && !self._lruList[self._lru]) self._lru ++
}

function del (self, hit) {
  if (hit) {
    if (self._dispose) self._dispose(hit.key, hit.value)
    self._length -= hit.length
    self._itemCount --
    delete self._cache[ hit.key ]
    shiftLU(self, hit)
  }
}

// classy, since V8 prefers predictable objects.
function Entry (key, value, lu, length, now, maxAge) {
  this.key = key
  this.value = value
  this.lu = lu
  this.length = length
  this.now = now
  if (maxAge) this.maxAge = maxAge
}

})()

},{}],27:[function(require,module,exports){
/*!
 * mustache.js - Logic-less {{mustache}} templates with JavaScript
 * http://github.com/janl/mustache.js
 */

/*global define: false Mustache: true*/

(function defineMustache (global, factory) {
  if (typeof exports === 'object' && exports && typeof exports.nodeName !== 'string') {
    factory(exports); // CommonJS
  } else if (typeof define === 'function' && define.amd) {
    define(['exports'], factory); // AMD
  } else {
    global.Mustache = {};
    factory(Mustache); // script, wsh, asp
  }
}(this, function mustacheFactory (mustache) {

  var objectToString = Object.prototype.toString;
  var isArray = Array.isArray || function isArrayPolyfill (object) {
    return objectToString.call(object) === '[object Array]';
  };

  function isFunction (object) {
    return typeof object === 'function';
  }

  /**
   * More correct typeof string handling array
   * which normally returns typeof 'object'
   */
  function typeStr (obj) {
    return isArray(obj) ? 'array' : typeof obj;
  }

  function escapeRegExp (string) {
    return string.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, '\\$&');
  }

  /**
   * Null safe way of checking whether or not an object,
   * including its prototype, has a given property
   */
  function hasProperty (obj, propName) {
    return obj != null && typeof obj === 'object' && (propName in obj);
  }

  // Workaround for https://issues.apache.org/jira/browse/COUCHDB-577
  // See https://github.com/janl/mustache.js/issues/189
  var regExpTest = RegExp.prototype.test;
  function testRegExp (re, string) {
    return regExpTest.call(re, string);
  }

  var nonSpaceRe = /\S/;
  function isWhitespace (string) {
    return !testRegExp(nonSpaceRe, string);
  }

  var entityMap = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#39;',
    '/': '&#x2F;'
  };

  function escapeHtml (string) {
    return String(string).replace(/[&<>"'\/]/g, function fromEntityMap (s) {
      return entityMap[s];
    });
  }

  var whiteRe = /\s*/;
  var spaceRe = /\s+/;
  var equalsRe = /\s*=/;
  var curlyRe = /\s*\}/;
  var tagRe = /#|\^|\/|>|\{|&|=|!/;

  /**
   * Breaks up the given `template` string into a tree of tokens. If the `tags`
   * argument is given here it must be an array with two string values: the
   * opening and closing tags used in the template (e.g. [ "<%", "%>" ]). Of
   * course, the default is to use mustaches (i.e. mustache.tags).
   *
   * A token is an array with at least 4 elements. The first element is the
   * mustache symbol that was used inside the tag, e.g. "#" or "&". If the tag
   * did not contain a symbol (i.e. {{myValue}}) this element is "name". For
   * all text that appears outside a symbol this element is "text".
   *
   * The second element of a token is its "value". For mustache tags this is
   * whatever else was inside the tag besides the opening symbol. For text tokens
   * this is the text itself.
   *
   * The third and fourth elements of the token are the start and end indices,
   * respectively, of the token in the original template.
   *
   * Tokens that are the root node of a subtree contain two more elements: 1) an
   * array of tokens in the subtree and 2) the index in the original template at
   * which the closing tag for that section begins.
   */
  function parseTemplate (template, tags) {
    if (!template)
      return [];

    var sections = [];     // Stack to hold section tokens
    var tokens = [];       // Buffer to hold the tokens
    var spaces = [];       // Indices of whitespace tokens on the current line
    var hasTag = false;    // Is there a {{tag}} on the current line?
    var nonSpace = false;  // Is there a non-space char on the current line?

    // Strips all whitespace tokens array for the current line
    // if there was a {{#tag}} on it and otherwise only space.
    function stripSpace () {
      if (hasTag && !nonSpace) {
        while (spaces.length)
          delete tokens[spaces.pop()];
      } else {
        spaces = [];
      }

      hasTag = false;
      nonSpace = false;
    }

    var openingTagRe, closingTagRe, closingCurlyRe;
    function compileTags (tagsToCompile) {
      if (typeof tagsToCompile === 'string')
        tagsToCompile = tagsToCompile.split(spaceRe, 2);

      if (!isArray(tagsToCompile) || tagsToCompile.length !== 2)
        throw new Error('Invalid tags: ' + tagsToCompile);

      openingTagRe = new RegExp(escapeRegExp(tagsToCompile[0]) + '\\s*');
      closingTagRe = new RegExp('\\s*' + escapeRegExp(tagsToCompile[1]));
      closingCurlyRe = new RegExp('\\s*' + escapeRegExp('}' + tagsToCompile[1]));
    }

    compileTags(tags || mustache.tags);

    var scanner = new Scanner(template);

    var start, type, value, chr, token, openSection;
    while (!scanner.eos()) {
      start = scanner.pos;

      // Match any text between tags.
      value = scanner.scanUntil(openingTagRe);

      if (value) {
        for (var i = 0, valueLength = value.length; i < valueLength; ++i) {
          chr = value.charAt(i);

          if (isWhitespace(chr)) {
            spaces.push(tokens.length);
          } else {
            nonSpace = true;
          }

          tokens.push([ 'text', chr, start, start + 1 ]);
          start += 1;

          // Check for whitespace on the current line.
          if (chr === '\n')
            stripSpace();
        }
      }

      // Match the opening tag.
      if (!scanner.scan(openingTagRe))
        break;

      hasTag = true;

      // Get the tag type.
      type = scanner.scan(tagRe) || 'name';
      scanner.scan(whiteRe);

      // Get the tag value.
      if (type === '=') {
        value = scanner.scanUntil(equalsRe);
        scanner.scan(equalsRe);
        scanner.scanUntil(closingTagRe);
      } else if (type === '{') {
        value = scanner.scanUntil(closingCurlyRe);
        scanner.scan(curlyRe);
        scanner.scanUntil(closingTagRe);
        type = '&';
      } else {
        value = scanner.scanUntil(closingTagRe);
      }

      // Match the closing tag.
      if (!scanner.scan(closingTagRe))
        throw new Error('Unclosed tag at ' + scanner.pos);

      token = [ type, value, start, scanner.pos ];
      tokens.push(token);

      if (type === '#' || type === '^') {
        sections.push(token);
      } else if (type === '/') {
        // Check section nesting.
        openSection = sections.pop();

        if (!openSection)
          throw new Error('Unopened section "' + value + '" at ' + start);

        if (openSection[1] !== value)
          throw new Error('Unclosed section "' + openSection[1] + '" at ' + start);
      } else if (type === 'name' || type === '{' || type === '&') {
        nonSpace = true;
      } else if (type === '=') {
        // Set the tags for the next time around.
        compileTags(value);
      }
    }

    // Make sure there are no open sections when we're done.
    openSection = sections.pop();

    if (openSection)
      throw new Error('Unclosed section "' + openSection[1] + '" at ' + scanner.pos);

    return nestTokens(squashTokens(tokens));
  }

  /**
   * Combines the values of consecutive text tokens in the given `tokens` array
   * to a single token.
   */
  function squashTokens (tokens) {
    var squashedTokens = [];

    var token, lastToken;
    for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {
      token = tokens[i];

      if (token) {
        if (token[0] === 'text' && lastToken && lastToken[0] === 'text') {
          lastToken[1] += token[1];
          lastToken[3] = token[3];
        } else {
          squashedTokens.push(token);
          lastToken = token;
        }
      }
    }

    return squashedTokens;
  }

  /**
   * Forms the given array of `tokens` into a nested tree structure where
   * tokens that represent a section have two additional items: 1) an array of
   * all tokens that appear in that section and 2) the index in the original
   * template that represents the end of that section.
   */
  function nestTokens (tokens) {
    var nestedTokens = [];
    var collector = nestedTokens;
    var sections = [];

    var token, section;
    for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {
      token = tokens[i];

      switch (token[0]) {
      case '#':
      case '^':
        collector.push(token);
        sections.push(token);
        collector = token[4] = [];
        break;
      case '/':
        section = sections.pop();
        section[5] = token[2];
        collector = sections.length > 0 ? sections[sections.length - 1][4] : nestedTokens;
        break;
      default:
        collector.push(token);
      }
    }

    return nestedTokens;
  }

  /**
   * A simple string scanner that is used by the template parser to find
   * tokens in template strings.
   */
  function Scanner (string) {
    this.string = string;
    this.tail = string;
    this.pos = 0;
  }

  /**
   * Returns `true` if the tail is empty (end of string).
   */
  Scanner.prototype.eos = function eos () {
    return this.tail === '';
  };

  /**
   * Tries to match the given regular expression at the current position.
   * Returns the matched text if it can match, the empty string otherwise.
   */
  Scanner.prototype.scan = function scan (re) {
    var match = this.tail.match(re);

    if (!match || match.index !== 0)
      return '';

    var string = match[0];

    this.tail = this.tail.substring(string.length);
    this.pos += string.length;

    return string;
  };

  /**
   * Skips all text until the given regular expression can be matched. Returns
   * the skipped string, which is the entire tail if no match can be made.
   */
  Scanner.prototype.scanUntil = function scanUntil (re) {
    var index = this.tail.search(re), match;

    switch (index) {
    case -1:
      match = this.tail;
      this.tail = '';
      break;
    case 0:
      match = '';
      break;
    default:
      match = this.tail.substring(0, index);
      this.tail = this.tail.substring(index);
    }

    this.pos += match.length;

    return match;
  };

  /**
   * Represents a rendering context by wrapping a view object and
   * maintaining a reference to the parent context.
   */
  function Context (view, parentContext) {
    this.view = view;
    this.cache = { '.': this.view };
    this.parent = parentContext;
  }

  /**
   * Creates a new context using the given view with this context
   * as the parent.
   */
  Context.prototype.push = function push (view) {
    return new Context(view, this);
  };

  /**
   * Returns the value of the given name in this context, traversing
   * up the context hierarchy if the value is absent in this context's view.
   */
  Context.prototype.lookup = function lookup (name) {
    var cache = this.cache;

    var value;
    if (cache.hasOwnProperty(name)) {
      value = cache[name];
    } else {
      var context = this, names, index, lookupHit = false;

      while (context) {
        if (name.indexOf('.') > 0) {
          value = context.view;
          names = name.split('.');
          index = 0;

          /**
           * Using the dot notion path in `name`, we descend through the
           * nested objects.
           *
           * To be certain that the lookup has been successful, we have to
           * check if the last object in the path actually has the property
           * we are looking for. We store the result in `lookupHit`.
           *
           * This is specially necessary for when the value has been set to
           * `undefined` and we want to avoid looking up parent contexts.
           **/
          while (value != null && index < names.length) {
            if (index === names.length - 1)
              lookupHit = hasProperty(value, names[index]);

            value = value[names[index++]];
          }
        } else {
          value = context.view[name];
          lookupHit = hasProperty(context.view, name);
        }

        if (lookupHit)
          break;

        context = context.parent;
      }

      cache[name] = value;
    }

    if (isFunction(value))
      value = value.call(this.view);

    return value;
  };

  /**
   * A Writer knows how to take a stream of tokens and render them to a
   * string, given a context. It also maintains a cache of templates to
   * avoid the need to parse the same template twice.
   */
  function Writer () {
    this.cache = {};
  }

  /**
   * Clears all cached templates in this writer.
   */
  Writer.prototype.clearCache = function clearCache () {
    this.cache = {};
  };

  /**
   * Parses and caches the given `template` and returns the array of tokens
   * that is generated from the parse.
   */
  Writer.prototype.parse = function parse (template, tags) {
    var cache = this.cache;
    var tokens = cache[template];

    if (tokens == null)
      tokens = cache[template] = parseTemplate(template, tags);

    return tokens;
  };

  /**
   * High-level method that is used to render the given `template` with
   * the given `view`.
   *
   * The optional `partials` argument may be an object that contains the
   * names and templates of partials that are used in the template. It may
   * also be a function that is used to load partial templates on the fly
   * that takes a single argument: the name of the partial.
   */
  Writer.prototype.render = function render (template, view, partials) {
    var tokens = this.parse(template);
    var context = (view instanceof Context) ? view : new Context(view);
    return this.renderTokens(tokens, context, partials, template);
  };

  /**
   * Low-level method that renders the given array of `tokens` using
   * the given `context` and `partials`.
   *
   * Note: The `originalTemplate` is only ever used to extract the portion
   * of the original template that was contained in a higher-order section.
   * If the template doesn't use higher-order sections, this argument may
   * be omitted.
   */
  Writer.prototype.renderTokens = function renderTokens (tokens, context, partials, originalTemplate) {
    var buffer = '';

    var token, symbol, value;
    for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {
      value = undefined;
      token = tokens[i];
      symbol = token[0];

      if (symbol === '#') value = this.renderSection(token, context, partials, originalTemplate);
      else if (symbol === '^') value = this.renderInverted(token, context, partials, originalTemplate);
      else if (symbol === '>') value = this.renderPartial(token, context, partials, originalTemplate);
      else if (symbol === '&') value = this.unescapedValue(token, context);
      else if (symbol === 'name') value = this.escapedValue(token, context);
      else if (symbol === 'text') value = this.rawValue(token);

      if (value !== undefined)
        buffer += value;
    }

    return buffer;
  };

  Writer.prototype.renderSection = function renderSection (token, context, partials, originalTemplate) {
    var self = this;
    var buffer = '';
    var value = context.lookup(token[1]);

    // This function is used to render an arbitrary template
    // in the current context by higher-order sections.
    function subRender (template) {
      return self.render(template, context, partials);
    }

    if (!value) return;

    if (isArray(value)) {
      for (var j = 0, valueLength = value.length; j < valueLength; ++j) {
        buffer += this.renderTokens(token[4], context.push(value[j]), partials, originalTemplate);
      }
    } else if (typeof value === 'object' || typeof value === 'string' || typeof value === 'number') {
      buffer += this.renderTokens(token[4], context.push(value), partials, originalTemplate);
    } else if (isFunction(value)) {
      if (typeof originalTemplate !== 'string')
        throw new Error('Cannot use higher-order sections without the original template');

      // Extract the portion of the original template that the section contains.
      value = value.call(context.view, originalTemplate.slice(token[3], token[5]), subRender);

      if (value != null)
        buffer += value;
    } else {
      buffer += this.renderTokens(token[4], context, partials, originalTemplate);
    }
    return buffer;
  };

  Writer.prototype.renderInverted = function renderInverted (token, context, partials, originalTemplate) {
    var value = context.lookup(token[1]);

    // Use JavaScript's definition of falsy. Include empty arrays.
    // See https://github.com/janl/mustache.js/issues/186
    if (!value || (isArray(value) && value.length === 0))
      return this.renderTokens(token[4], context, partials, originalTemplate);
  };

  Writer.prototype.renderPartial = function renderPartial (token, context, partials) {
    if (!partials) return;

    var value = isFunction(partials) ? partials(token[1]) : partials[token[1]];
    if (value != null)
      return this.renderTokens(this.parse(value), context, partials, value);
  };

  Writer.prototype.unescapedValue = function unescapedValue (token, context) {
    var value = context.lookup(token[1]);
    if (value != null)
      return value;
  };

  Writer.prototype.escapedValue = function escapedValue (token, context) {
    var value = context.lookup(token[1]);
    if (value != null)
      return mustache.escape(value);
  };

  Writer.prototype.rawValue = function rawValue (token) {
    return token[1];
  };

  mustache.name = 'mustache.js';
  mustache.version = '2.2.0';
  mustache.tags = [ '{{', '}}' ];

  // All high-level mustache.* functions use this writer.
  var defaultWriter = new Writer();

  /**
   * Clears all cached templates in the default writer.
   */
  mustache.clearCache = function clearCache () {
    return defaultWriter.clearCache();
  };

  /**
   * Parses and caches the given template in the default writer and returns the
   * array of tokens it contains. Doing this ahead of time avoids the need to
   * parse templates on the fly as they are rendered.
   */
  mustache.parse = function parse (template, tags) {
    return defaultWriter.parse(template, tags);
  };

  /**
   * Renders the `template` with the given `view` and `partials` using the
   * default writer.
   */
  mustache.render = function render (template, view, partials) {
    if (typeof template !== 'string') {
      throw new TypeError('Invalid template! Template should be a "string" ' +
                          'but "' + typeStr(template) + '" was given as the first ' +
                          'argument for mustache#render(template, view, partials)');
    }

    return defaultWriter.render(template, view, partials);
  };

  // This is here for backwards compatibility with 0.4.x.,
  /*eslint-disable */ // eslint wants camel cased function name
  mustache.to_html = function to_html (template, view, partials, send) {
    /*eslint-enable*/

    var result = mustache.render(template, view, partials);

    if (isFunction(send)) {
      send(result);
    } else {
      return result;
    }
  };

  // Export the escaping function so that the user may override it.
  // See https://github.com/janl/mustache.js/issues/244
  mustache.escape = escapeHtml;

  // Export these mainly for testing, but also for advanced usage.
  mustache.Scanner = Scanner;
  mustache.Context = Context;
  mustache.Writer = Writer;

}));

},{}],28:[function(require,module,exports){
/* object-iterators.js - Mini Underscore library
 * by Jonathan Eiten
 *
 * The methods below operate on objects (but not arrays) similarly
 * to Underscore (http://underscorejs.org/#collections).
 *
 * Recommended usage:
 *
 *    var _ = require('object-iterators');
 */

'use strict';

/**
 * @constructor
 * @summary Wrap an object for one method.
 * @Desc Note that the `new` keyword is not necessary.
 * @param {object|null|undefined} object - `null` or `undefined` is treated as an empty plain object.
 * @return {Wrapper} The wrapped object.
 */
function Wrapper(object) {
    if (object instanceof Wrapper) {
        return object;
    }
    if (!(this instanceof Wrapper)) {
        return new Wrapper(object);
    }
    this.originalValue = object;
    this.o = object || {};
}

/**
 * @name Wrapper.chain
 * @summary Wrap an object for a chain of methods.
 * @Desc Calls the constructor `Wrapper()` and modifies the wrapper for chaining.
 * @param {object} object
 * @return {Wrapper} The wrapped object.
 */
Wrapper.chain = function (object) {
    var wrapped = Wrapper(object); // eslint-disable-line new-cap
    wrapped.chaining = true;
    return wrapped;
};

Wrapper.prototype = {
    /**
     * Unwrap an object wrapped with {@link Wrapper.chain|Wrapper.chain()}.
     * @return {object|null|undefined} The value originally wrapped by the constructor.
     * @memberOf Wrapper.prototype
     */
    value: function () {
        return this.originalValue;
    },

    /**
     * @desc Mimics Underscore's [each](http://underscorejs.org/#each) method: Iterate over the members of the wrapped object, calling `iteratee()` with each.
     * @param {function} iteratee - For each member of the wrapped object, this function is called with three arguments: `(value, key, object)`. The return value of this function is undefined; an `.each` loop cannot be broken out of (use {@link Wrapper#find|.find} instead).
     * @param {object} [context] - If given, `iteratee` is bound to this object. In other words, this object becomes the `this` value in the calls to `iteratee`. (Otherwise, the `this` value will be the unwrapped object.)
     * @return {Wrapper} The wrapped object for chaining.
     * @memberOf Wrapper.prototype
     */
    each: function (iteratee, context) {
        var o = this.o;
        context = context || o;
        Object.keys(o).forEach(function (key) {
            iteratee.call(context, o[key], key, o);
        });
        return this;
    },

    /**
     * @desc Mimics Underscore's [find](http://underscorejs.org/#find) method: Look through each member of the wrapped object, returning the first one that passes a truth test (predicate), or `undefined` if no value passes the test. The function returns the value of the first acceptable member, and doesn't necessarily traverse the entire object.
     * @param {function} predicate - For each member of the wrapped object, this function is called with three arguments: `(value, key, object)`. The return value of this function should be truthy if the member passes the test and falsy otherwise.
     * @param {object} [context] - If given, `predicate` is bound to this object. In other words, this object becomes the `this` value in the calls to `predicate`. (Otherwise, the `this` value will be the unwrapped object.)
     * @return {*} The found property's value.
     * @memberOf Wrapper.prototype
     */
    find: function (predicate, context) {
        var o = this.o;
        context = context || o;
        var result = Object.keys(o).find(function (key) {
            return predicate.call(context, o[key], key, o);
        });
        return result === undefined ? undefined : o[result];
    },

    /**
     * @desc Mimics Underscore's [reduce](http://underscorejs.org/#reduce) method: Boil down the values of all the members of the wrapped object into a single value. `memo` is the initial state of the reduction, and each successive step of it should be returned by `iteratee()`.
     * @param {function} iteratee - For each member of the wrapped object, this function is called with four arguments: `(memo, value, key, object)`. The return value of this function becomes the new value of `memo` for the next iteration.
     * @param {*} [memo] - If no memo is passed to the initial invocation of reduce, the iteratee is not invoked on the first element of the list. The first element is instead passed as the memo in the invocation of the iteratee on the next element in the list.
     * @param {object} [context] - If given, `iteratee` is bound to this object. In other words, this object becomes the `this` value in the calls to `iteratee`. (Otherwise, the `this` value will be the unwrapped object.)
     * @return {*} The value of `memo` "reduced" as per `iteratee`.
     * @memberOf Wrapper.prototype
     */
    reduce: function (iteratee, memo, context) {
        var o = this.o;
        context = context || o;
        Object.keys(o).forEach(function (key, idx) {
            memo = (!idx && memo === undefined) ? o[key] : iteratee.call(context, memo, o[key], key, o);
        });
        return memo;
    },

    /**
     * @desc Mimics Underscore's [extend](http://underscorejs.org/#extend) method: Copy all of the properties in each of the `source` object parameter(s) over to the (wrapped) destination object (thus mutating it). It's in-order, so the properties of the last `source` object will override properties with the same name in previous arguments or in the destination object.
     * > This method copies own members as well as members inherited from prototype chain.
     * @param {...object|null|undefined} source - Values of `null` or `undefined` are treated as empty plain objects.
     * @return {Wrapper|object} The wrapped destination object if chaining is in effect; otherwise the unwrapped destination object.
     * @memberOf Wrapper.prototype
     */
    extend: function (source) {
        var o = this.o;
        Array.prototype.slice.call(arguments).forEach(function (object) {
            if (object) {
                for (var key in object) {
                    o[key] = object[key];
                }
            }
        });
        return this.chaining ? this : o;
    },

    /**
     * @desc Mimics Underscore's [extendOwn](http://underscorejs.org/#extendOwn) method: Like {@link Wrapper#extend|extend}, but only copies its "own" properties over to the destination object.
     * @param {...object|null|undefined} source - Values of `null` or `undefined` are treated as empty plain objects.
     * @return {Wrapper|object} The wrapped destination object if chaining is in effect; otherwise the unwrapped destination object.
     * @memberOf Wrapper.prototype
     */
    extendOwn: function (source) {
        var o = this.o;
        Array.prototype.slice.call(arguments).forEach(function (object) {
            Wrapper(object).each(function (val, key) { // eslint-disable-line new-cap
                o[key] = val;
            });
        });
        return this.chaining ? this : o;
    }
};

module.exports = Wrapper;

},{}],29:[function(require,module,exports){
'use strict';

/* eslint-env node, browser */

/* [ONCE CALLING CODE IS UPDATED AND TESTED, REMOVE THIS COMMENT + ALL LINES CONTAINING "Formerly..."]
 * This module rectangular.js differs from predecessor fin-rectangle.js as follows:
 * 1. Instead of creating Polymer component `fin-rectangles`, now does one of following:
 *  a. If object `exports` exists: Adds object as new property `exports.rectangular`
 *     thus supporting Node as well as file bundling by Browserify.
 *  b. If object `exports` does not exist: Adds object as new property
 *     `window.fin.rectangular` (first creating object `window.fin` if necessary)
 *     thus supporting client-side inclusion via <script> tag.
 * 2. File was reorganized to use prototypal inheritance so:
 *  a. change 'rectangles.point.create(' to 'new rectangular.Point('
 *  b. change 'rectangles.rectangle.create(' to 'new rectangular.Rectangle('
 * 3. Change all instances of 'ThanEqualTo' to 'ThanOrEqualTo'
 * 4. Change all invocations of Rectangle.top, .left, .bottom, .right, .width,
 *    .height, and .area to getter references by removing the invocation operator
 *    (i.e., the parentheses).
 */

(function(module, exports) {  // eslint-disable-line no-unused-expressions

    // This closure supports NodeJS-less client side includes with <script> tags. See https://github.com/joneit/mnm.

    /**
     * Creates a new read-only property and attaches it to the provided context.
     * @private
     * @param {string} name - Name for new property.
     * @param {*} [value] - Value of new property.
     */
    function addReadOnlyProperty(name, value) {
        Object.defineProperty(this, name, {
            value: value,
            writable: false,
            enumerable: true,
            configurable: false
        });
    }

    /**
     * @constructor Point
     *
     * @desc This object represents a single point in an abstract 2-dimensional matrix.
     *
     * The unit of measure is typically pixels.
     * (If used to model computer graphics, vertical coordinates are typically measured downwards
     * from the top of the window. This convention however is not inherent in this object.)
     *
     * Note: This object should be instantiated with the `new` keyword.
     *
     * @param {number} x - the new point's `x` property
     * @param {number} y - the new point's `y` property
     */
    function Point(x, y) {

        /**
         * @name x
         * @type {number}
         * @summary This point's horizontal coordinate.
         * @desc Created upon instantiation by the {@link Point|constructor}.
         * @memberOf Point.prototype
         * @abstract
         */
        addReadOnlyProperty.call(this, 'x', Number(x) || 0);

        /**
         * @name y
         * @type {number}
         * @summary This point's vertical coordinate.
         * @desc Created upon instantiation by the {@link Point|constructor}.
         * @memberOf Point.prototype
         * @abstract
         */
        addReadOnlyProperty.call(this, 'y', Number(y) || 0);

    }

    Point.prototype = {

        /**
         * @returns {Point} A new point which is this point's position increased by coordinates of given `point`.
         * @param {Point} Offset - Horizontal and vertical values to add to this point's coordinates.
         * @memberOf Point.prototype
         */
        plus: function(offset) {
            return new Point(
                this.x + offset.x,
                this.y + offset.y
            );
        },

        /**
         * @returns {Point} A new point which is this point's position increased by given offsets.
         * @param {number} [offsetX=0] - Value to add to this point's horizontal coordinate.
         * @param {number} [offsetY=0] - Value to add to this point's horizontal coordinate.
         * @memberOf Point.prototype
         */
        plusXY: function(offsetX, offsetY) {
            return new Point(
                this.x + (offsetX || 0),
                this.y + (offsetY || 0)
            );
        },

        /**
         * @returns {Point} A new point which is this point's position decreased by coordinates of given `point`.
         * @param {Point} offset - Horizontal and vertical values to subtract from this point's coordinates.
         * @memberOf Point.prototype
         */
        minus: function(offset) {
            return new Point(
                this.x - offset.x,
                this.y - offset.y
            );
        },

        /**
         * @returns {Point} A new `Point` positioned to least x and least y of this point and given `point`.
         * @param {Point} point - A point to compare to this point.
         * @memberOf Point.prototype
         */
        min: function(point) {
            return new Point(
                Math.min(this.x, point.x),
                Math.min(this.y, point.y)
            );
        },

        /**
         * @returns {Point} A new `Point` positioned to greatest x and greatest y of this point and given `point`.
         * @param {Point} point - A point to compare to this point.
         * @memberOf Point.prototype
         */
        max: function(point) {
            return new Point(
                Math.max(this.x, point.x),
                Math.max(this.y, point.y)
            );
        },

        /**
         * @returns {number} Distance between given `point` and this point using Pythagorean Theorem formula.
         * @param {Point} point - A point from which to compute the distance to this point.
         * @memberOf Point.prototype
         */
        distance: function(point) {
            var deltaX = point.x - this.x,
                deltaY = point.y - this.y;

            return Math.sqrt(
                deltaX * deltaX +
                deltaY * deltaY
            );
        },

        /**
         * _(Formerly: `equal`.)_
         * @returns {boolean} `true` iff _both_ coordinates of this point are exactly equal to those of given `point`.
         * @param {Point} point - A point to compare to this point.
         * @memberOf Point.prototype
         */
        equals: function(point) {
            var result = false;

            if (point) {
                result =
                    this.x === point.x &&
                    this.y === point.y;
            }

            return result;
        },

        /**
         * @returns {boolean} `true` iff _both_ coordinates of this point are greater than those of given `point`.
         * @param {Point} point - A point to compare to this point
         * @memberOf Point.prototype
         */
        greaterThan: function(point) {
            return (
                this.x > point.x &&
                this.y > point.y
            );
        },

        /**
         * @returns {boolean} `true` iff _both_ coordinates of this point are less than those of given `point`.
         * @param {Point} point - A point to compare to this point
         * @memberOf Point.prototype
         */
        lessThan: function(point) {
            return (
                this.x < point.x &&
                this.y < point.y
            );
        },

        /**
         * _(Formerly `greaterThanEqualTo`.)_
         * @returns {boolean} `true` iff _both_ coordinates of this point are greater than or equal to those of given `point`.
         * @param {Point} point - A point to compare to this point
         * @memberOf Point.prototype
         */
        greaterThanOrEqualTo: function(point) {
            return (
                this.x >= point.x &&
                this.y >= point.y
            );
        },

        /**
         * _(Formerly `lessThanEqualTo`.)_
         * @returns {boolean} `true` iff _both_ coordinates of this point are less than or equal to those of given `point`.
         * @param {Point} point - A point to compare to this point.
         * @memberOf Point.prototype
         */
        lessThanOrEqualTo: function(point) {
            return (
                this.x <= point.x &&
                this.y <= point.y
            );
        },

        /**
         * _(Formerly `isContainedWithinRectangle`.)_
         * @param rect {Rectangle} - Rectangle to test this point against.
         * @returns {boolean} `true` iff this point is within given `rect`.
         * @memberOf Point.prototype
         */
        within: function(rect) {
            var minX = rect.origin.x,
                maxX = minX + rect.extent.x;
            var minY = rect.origin.y,
                maxY = minY + rect.extent.y;

            if (rect.extent.x < 0) {
                minX = maxX;
                maxX = rect.origin.x;
            }

            if (rect.extent.y < 0) {
                minY = maxY;
                maxY = rect.origin.y;
            }

            return (
                minX <= this.x && this.x < maxX &&
                minY <= this.y && this.y < maxY
            );
        }
    };

    Point.prototype.EQ = Point.prototype.equals;
    Point.prototype.GT = Point.prototype.greaterThan;
    Point.prototype.LT = Point.prototype.lessThan;
    Point.prototype.GE = Point.prototype.greaterThanOrEqualTo;
    Point.prototype.LE = Point.prototype.lessThanOrEqualTo;


    /**
     * @constructor Rectangle
     *
     * @desc This object represents a rectangular area within an abstract 2-dimensional matrix.
     *
     * The unit of measure is typically pixels.
     * (If used to model computer graphics, vertical coordinates are typically measured downwards
     * from the top of the window. This convention however is not inherent in this object.)
     *
     * Normally, the `x` and `y` parameters to the constructor describe the upper left corner of the rect.
     * However, negative values of `width` and `height` will be added to the given `x` and `y`. That is,
     * a negative value of the `width` parameter will extend the rect to the left of the given `x` and
     * a negative value of the `height` parameter will extend the rect above the given `y`.
     * In any case, after instantiation the following are guaranteed to always be true:
     * * The `extent`, `width`, and `height` properties _always_ give positive values.
     * * The `origin`, `top`, and `left` properties _always_ reflect the upper left corner.
     * * The `corner`, `bottom`, and `right` properties _always_ reflect the lower right corner.
     *
     * Note: This object should be instantiated with the `new` keyword.
     *
     * @param {number} [x=0] - Horizontal coordinate of some corner of the rect.
     * @param {number} [y=0] - Vertical coordinate of some corner of the rect.
     * @param {number} [width=0] - Width of the new rect. May be negative (see above).
     * @param {number} [height=0] - Height of the new rect. May be negative (see above).
     */
    function Rectangle(x, y, width, height) {

        x = Number(x) || 0;
        y = Number(y) || 0;
        width = Number(width) || 0;
        height = Number(height) || 0;

        if (width < 0) {
            x += width;
            width = -width;
        }

        if (height < 0) {
            y += height;
            height = -height;
        }

        /**
         * @name origin
         * @type {Point}
         * @summary Upper left corner of this rect.
         * @desc Created upon instantiation by the {@linkplain Rectangle|constructor}.
         * @memberOf Rectangle.prototype
         * @abstract
         */
        addReadOnlyProperty.call(this, 'origin', new Point(x, y));

        /**
         * @name extent
         * @type {Point}
         * @summary this rect's width and height.
         * @desc Unlike the other `Point` properties, `extent` is not a global coordinate pair; rather it consists of a _width_ (`x`, always positive) and a _height_ (`y`, always positive).
         *
         * This object might be more legitimately typed as something like `Area` with properties `width` and `height`; however we wanted it to be able to use it efficiently with a point's `plus` and `minus` methods (that is, without those methods having to check and branch on the type of its parameter).
         *
         * Created upon instantiation by the {@linkplain Rectangle|constructor}.
         * @see The {@link Rectangle#corner|corner} method.
         * @memberOf Rectangle.prototype
         * @abstract
         */
        addReadOnlyProperty.call(this, 'extent', new Point(width, height));

        /**
         * @name corner
         * @type {Point}
         * @summary Lower right corner of this rect.
         * @desc This is a calculated value created upon instantiation by the {@linkplain Rectangle|constructor}. It is `origin` offset by `extent`.
         *
         * **Note:** These coordinates actually point to the pixel one below and one to the right of the rect's actual lower right pixel.
         * @memberOf Rectangle.prototype
         * @abstract
         */
        addReadOnlyProperty.call(this, 'corner', new Point(x + width, y + height));

        /**
         * @name center
         * @type {Point}
         * @summary Center of this rect.
         * @desc Created upon instantiation by the {@linkplain Rectangle|constructor}.
         * @memberOf Rectangle.prototype
         * @abstract
         */
        addReadOnlyProperty.call(this, 'center', new Point(x + (width / 2), y + (height / 2)));

    }

    Rectangle.prototype = {

        /**
         * @type {number}
         * @desc _(Formerly a function; now a getter.)_
         * @summary Minimum vertical coordinate of this rect.
         * @memberOf Rectangle.prototype
         */
        get top() {
            return this.origin.y;
        },

        /**
         * @type {number}
         * @desc _(Formerly a function; now a getter.)_
         * @summary Minimum horizontal coordinate of this rect.
         * @memberOf Rectangle.prototype
         */
        get left() {
            return this.origin.x;
        },

        /**
         * @type {number}
         * @desc _(Formerly a function; now a getter.)_
         * @summary Maximum vertical coordinate of this rect + 1.
         * @memberOf Rectangle.prototype
         */
        get bottom() {
            return this.corner.y;
        },

        /**
         * @type {number}
         * @desc _(Formerly a function; now a getter.)_
         * @summary Maximum horizontal coordinate of this rect + 1.
         * @memberOf Rectangle.prototype
         */
        get right() {
            return this.corner.x;
        },

        /**
         * @type {number}
         * @desc _(Formerly a function; now a getter.)_
         * @summary Width of this rect (always positive).
         * @memberOf Rectangle.prototype
         */
        get width() {
            return this.extent.x;
        },

        /**
         * @type {number}
         * @desc _(Formerly a function; now a getter.)_
         * @summary Height of this rect (always positive).
         * @memberOf Rectangle.prototype
         */
        get height() {
            return this.extent.y;
        },

        /**
         * @type {number}
         * @desc _(Formerly a function; now a getter.)_
         * @summary Area of this rect.
         * @memberOf Rectangle.prototype
         */
        get area() {
            return this.width * this.height;
        },

        /**
         * @returns {Rectangle} A copy of this rect but with horizontal position reset to given `x` and no width.
         * @param {number} x - Horizontal coordinate of the new rect.
         * @memberOf Rectangle.prototype
         */
        flattenXAt: function(x) {
            return new Rectangle(x, this.origin.y, 0, this.extent.y);
        },

        /**
         * @returns {Rectangle} A copy of this rect but with vertical position reset to given `y` and no height.
         * @param {number} y - Vertical coordinate of the new rect.
         * @memberOf Rectangle.prototype
         */
        flattenYAt: function(y) {
            return new Rectangle(this.origin.x, y, this.extent.x, 0);
        },

        /**
         * @returns {boolean} `true` iff given `point` entirely contained within this rect.
         * @param {Point} pointOrRect - The point or rect to test for containment.
         * @memberOf Rectangle.prototype
         */
        contains: function(pointOrRect) {
            return pointOrRect.within(this);
        },

        /**
         * _(Formerly `isContainedWithinRectangle`.)_
         * @returns {boolean} `true` iff `this` rect is entirely contained within given `rect`.
         * @param {Rectangle} rect - Rectangle to test against this rect.
         * @memberOf Rectangle.prototype
         */
        within: function(rect) {
            return (
                rect.origin.lessThanOrEqualTo(this.origin) &&
                rect.corner.greaterThanOrEqualTo(this.corner)
            );
        },

        /**
         * _(Formerly: `insetBy`.)_
         * @returns {Rectangle} That is enlarged/shrunk by given `padding`.
         * @param {number} padding - Amount by which to increase (+) or decrease (-) this rect
         * @see The {@link Rectangle#shrinkBy|shrinkBy} method.
         * @memberOf Rectangle.prototype
         */
        growBy: function(padding) {
            return new Rectangle(
                this.origin.x + padding,
                this.origin.y + padding,
                this.extent.x - padding - padding,
                this.extent.y - padding - padding);
        },

        /**
         * @returns {Rectangle} That is enlarged/shrunk by given `padding`.
         * @param {number} padding - Amount by which to decrease (+) or increase (-) this rect.
         * @see The {@link Rectangle#growBy|growBy} method.
         * @memberOf Rectangle.prototype
         */
        shrinkBy: function(padding) {
            return this.growBy(-padding);
        },

        /**
         * @returns {Rectangle} Bounding rect that contains both this rect and the given `rect`.
         * @param {Rectangle} rect - The rectangle to union with this rect.
         * @memberOf Rectangle.prototype
         */
        union: function(rect) {
            var origin = this.origin.min(rect.origin),
                corner = this.corner.max(rect.corner),
                extent = corner.minus(origin);

            return new Rectangle(
                origin.x, origin.y,
                extent.x, extent.y
            );
        },

        /**
         * iterate over all points within this rect, invoking `iteratee` for each.
         * @param {function(number,number)} iteratee - Function to call for each point.
         * Bound to `context` when given; otherwise it is bound to this rect.
         * Each invocation of `iteratee` is called with two arguments:
         * the horizontal and vertical coordinates of the point.
         * @param {object} [context=this] - Context to bind to `iteratee` (when not `this`).
         * @memberOf Rectangle.prototype
         */
        forEach: function(iteratee, context) {
            context = context || this;
            for (var x = this.origin.x, x2 = this.corner.x; x < x2; x++) {
                for (var y = this.origin.y, y2 = this.corner.y; y < y2; y++) {
                    iteratee.call(context, x, y);
                }
            }
        },

        /**
         * @returns {Rectangle} One of:
         * * _If this rect intersects with the given `rect`:_
         *      a new rect representing that intersection.
         * * _If it doesn't intersect and `ifNoneAction` defined:_
         *      result of calling `ifNoneAction`.
         * * _If it doesn't intersect and `ifNoneAction` undefined:_
         *      `null`.
         * @param {Rectangle} rect - The rectangle to intersect with this rect.
         * @param {function(Rectangle)} [ifNoneAction] - When no intersection, invoke and return result.
         * Bound to `context` when given; otherwise bound to this rect.
         * Invoked with `rect` as sole parameter.
         * @param {object} [context=this] - Context to bind to `ifNoneAction` (when not `this`).
         * @memberOf Rectangle.prototype
         */
        intersect: function(rect, ifNoneAction, context) {
            var result = null,
                origin = this.origin.max(rect.origin),
                corner = this.corner.min(rect.corner),
                extent = corner.minus(origin);

            if (extent.x > 0 && extent.y > 0) {
                result = new Rectangle(
                    origin.x, origin.y,
                    extent.x, extent.y
                );
            } else if (typeof ifNoneAction === 'function') {
                result = ifNoneAction.call(context || this, rect);
            }

            return result;
        },

        /**
         * @returns {boolean} `true` iff this rect overlaps with given `rect`.
         * @param {Rectangle} rect - The rectangle to intersect with this rect.
         * @memberOf Rectangle.prototype
         */
        intersects: function(rect) {
            return (
                rect.corner.x > this.origin.x &&
                rect.corner.y > this.origin.y &&
                rect.origin.x < this.corner.x &&
                rect.origin.y < this.corner.y
            );
        }
    };

    // Interface
    exports.Point = Point;
    exports.Rectangle = Rectangle;
})(
    typeof module === 'object' && module || (window.rectangular = {}),
    typeof module === 'object' && module.exports || (window.rectangular.exports = {})
) || (
    typeof module === 'object' || (window.rectangular = window.rectangular.exports)
);

/* About the above IIFE:
 * This file is a "modified node module." It functions as usual in Node.js *and* is also usable directly in the browser.
 * 1. Node.js: The IIFE is superfluous but innocuous.
 * 2. In the browser: The IIFE closure serves to keep internal declarations private.
 * 2.a. In the browser as a global: The logic in the actual parameter expressions + the post-invocation expression
 * will put your API in `window.rectangular`.
 * 2.b. In the browser as a module: If you predefine a `window.module` object, the results will be in `module.exports`.
 * The bower component `mnm` makes this easy and also provides a global `require()` function for referencing your module
 * from other closures. In either case, this works with both NodeJs-style export mechanisms -- a single API assignment,
 * `module.exports = yourAPI` *or* a series of individual property assignments, `module.exports.property = property`.
 *
 * Before the IIFE runs, the actual parameter expressions are executed:
 * 1. If `window` object undefined, we're in NodeJs so assume there is a `module` object with an `exports` property
 * 2. If `window` object defined, we're in browser
 * 2.a. If `module` object predefined, use it
 * 2.b. If `module` object undefined, create a `rectangular` object
 *
 * After the IIFE returns:
 * Because it always returns undefined, the expression after the || will execute:
 * 1. If `window` object undefined, then we're in NodeJs so we're done
 * 2. If `window` object defined, then we're in browser
 * 2.a. If `module` object predefined, we're done; results are in `moudule.exports`
 * 2.b. If `module` object undefined, redefine`rectangular` to be the `rectangular.exports` object
 */

},{}],30:[function(require,module,exports){
'use strict';

/* eslint-env node, browser */

(function (module) {  // eslint-disable-line no-unused-expressions

    // This closure supports NodeJS-less client side includes with <script> tags. See https://github.com/joneit/mnm.

    /**
     * @constructor RangeSelectionModel
     *
     * @desc This object models selection of "cells" within an abstract single-dimensional matrix.
     *
     * Disjoint selections can be built with calls to the following methods:
     * * {@link RangeSelectionModel#select|select(start, stop)} - Add a range to the matrix.
     * * {@link RangeSelectionModel#deselect|deselect(start, stop)} - Remove a range from the matrix.
     *
     * Two more methods are available:
     * * Test a cell to see if it {@link RangeSelectionModel#isSelected|isSelected(cell)}
     * * {@link RangeSelectionModel#clear|clear()} the matrix
     *
     * Internally, the selection is run-length-encoded. It is therefore a "sparse" matrix
     * with undefined bounds. A single data property called `selection` is an array that
     * contains all the "runs" (ranges) of selected cells albeit in no particular order.
     * This property should not normally need to be accessed directly.
     *
     * Note: This object should be instantiated with the `new` keyword.
     *
     * @returns {RangeSelectionModel} Self (i.e., `this` object).
     */
    function RangeSelectionModel() {
        /**
         * @name selection
         * @type {Array.Array.number}
         * @summary Unordered list of runs.
         * @desc A "run" is defined as an Array(2) where:
         * * element [0] is the beginning of the run
         * * element [1] is the end of the run (inclusive) and is always >= element [0]
         * The order of the runs within is undefined.
         * @memberOf RangeSelectionModel.prototype
         * @abstract
         */
        this.selection = [];

        //we need to be able to go back in time
        //the states field
        this.states = [];

        //clone and store my current state
        //so we can unwind changes if need be
        this.storeState = function () {
            var sels = this.selection;
            var state = [];
            var copy;
            for (var i = 0; i < sels.length; i++) {
                copy = [].concat(sels[i]);
                state.push(copy);
            }
            this.states.push(state);
        };
    }

    RangeSelectionModel.prototype = {

        /**
         * @summary Add a contiguous run of points to the selection.
         * @desc Insert a new run into `this.selection`.
         * The new run will be merged with overlapping and adjacent runs.
         *
         * The two parameters may be given in either order.
         * The start and stop elements in the resulting run will however always be ordered.
         * (However, note that the order of the runs within `this.selection` is itself always unordered.)
         *
         * Note that `this.selection` is updated in place, preserving validity of any external references.
         * @param {number} start - Start of run. May be greater than `stop`.
         * @param {number} [stop=stop] - End of run (inclusive). May be less than `start`.
         * @returns {RangeSelectionModel} Self (i.e., `this`), for chaining.
         * @memberOf RangeSelectionModel.prototype
         */
        select: function (start, stop) {
            this.storeState();
            var run = makeRun(start, stop);
            var splicer = [0, 1];
            this.selection.forEach(function (each) {
                if (overlaps(each, run) || abuts(each, run)) {
                    run = merge(each, run);
                } else {
                    splicer.push(each);
                }
            });
            splicer.push(run);
            splicer[1] = this.selection.length;
            this.selection.splice.apply(this.selection, splicer); // update in place to preserve external references
            return this;
        },

        /**
         * @summary Remove a contiguous run of points from the selection.
         * @desc Truncate and/or remove run(s) from `this.selection`.
         * Removing part of existing runs will (correctly) shorten them or break them into two fragments.
         *
         * The two parameters may be given in either order.
         *
         * Note that `this.selection` is updated in place, preserving validity of any external references.
         * @param {number} start - Start of run. May be greater than `stop`.
         * @param {number} [stop=stop] - End of run (inclusive). May be less than `start`.
         * @returns {RangeSelectionModel} Self (i.e., `this`), for chaining.
         * @memberOf RangeSelectionModel.prototype
         */
        deselect: function (start, stop) {
            var run = makeRun(start, stop);
            var splicer = [0, 0];
            this.selection.forEach(function (each) {
                if (overlaps(each, run)) {
                    var pieces = subtract(each, run);
                    splicer = splicer.concat(pieces);
                } else {
                    splicer.push(each);
                }
            });
            splicer[1] = this.selection.length;
            this.selection.splice.apply(this.selection, splicer); // update in place to preserve external references
            return this;
        },

        /**
         * @summary Empties `this.selection`, effectively removing all runs.
         * @returns {RangeSelectionModel} Self (i.e., `this`), for chaining.
         * @memberOf RangeSelectionModel.prototype
         */
        clear: function () {
            this.states.length = 0;
            this.selection.length = 0;
            return this;
        },

        clearMostRecentSelection: function () {
            if (this.states.length === 0) {
                return;
            }
            this.selection = this.states.pop();
        },

        /**
         * @summary Determines if the given `cell` is selected.
         * @returns {boolean} `true` iff given `cell` is within any of the runs in `this.selection`.
         * @param {number} cell - The cell to test for inclusion in the selection.
         * @memberOf RangeSelectionModel.prototype
         */
        isSelected: function (cell) {
            return this.selection.some(function (each) {
                return each[0] <= cell && cell <= each[1];
            });
        },

        isEmpty: function (){
            return this.selection.length === 0;
        },

        /**
         * @summary Return the indexes that are selected.
         * @desc Return the indexes that are selected.
         * @returns {Array.Array.number}
         * @memberOf RangeSelectionModel.prototype
         */
        getSelections: function (){
            var result = [];
            this.selection.forEach(function (each) {
                for (var i = each[0]; i <= each[1]; i++) {
                    result.push(i);
                }
            });
            result.sort(function (a, b){
                return a - b;
            });
            return result;
        }

    };

    /**
     * @private
     * @summary Preps `start` and `stop` params into order array
     * @function makeRun
     * @desc Utility function called by both `select()` and `deselect()`.
     * @param {number|number[]} start - Start of run. if array, `start` and `stop` are taken from first two elements.
     * @param {number} [stop=start] - End of run (inclusive).
     */
    function makeRun(start, stop) {
        return (
            start instanceof Array
                ? makeRun.apply(this, start) // extract params from given array
                : stop === undefined
                ? [ start, start ] // single param is a run that stops where it starts
                : start <= stop
                ? [ start, stop ]
                : [ stop, start ] // reverse descending params into ascending order
        );
    }

    /**
     * @private
     * @function overlaps
     * @returns {boolean} `true` iff `run1` overlaps `run2`
     * @summary Comparison operator that determines if given runs overlap with one another.
     * @desc Both parameters are assumed to be _ordered_ arrays.
     *
     * Overlap is defined to include the case where one run completely contains the other.
     *
     * Note: This operator is commutative.
     * @param {number[]} run1 - first run
     * @param {number[]} run2 - second run
     */
    function overlaps(run1, run2) {
        return (
            run1[0] <= run2[0] && run2[0] <= run1[1] || // run2's start is within run1 OR...
            run1[0] <= run2[1] && run2[1] <= run1[1] || // run2's stop is within run1 OR...
            run2[0] <  run1[0] && run1[1] <  run2[1]    // run2 completely contains run1
        );
    }

    /**
     * @private
     * @function abuts
     * @summary Comparison operator that determines if given runs are consecutive with one another.
     * @returns {boolean} `true` iff `run1` is consecutive with `run2`
     * @desc Both parameters are assumed to be _ordered_ arrays.
     *
     * Note: This operator is commutative.
     * @param {number[]} run1 - first run
     * @param {number[]} run2 - second run
     */
    function abuts(run1, run2) {
        return (
            run1[1] === run2[0] - 1 || // run1's top immediately precedes run2's start OR...
            run2[1] === run1[0] - 1    // run2's top immediately precedes run1's start
        );
    }

    /**
     * @private
     * @function subtract
     * @summary Operator that subtracts one run from another.
     * @returns {Array.Array.number} The remaining pieces of `minuend` after removing `subtrahend`.
     * @desc Both parameters are assumed to be _ordered_ arrays.
     *
     * This function _does not assumes_ that `overlap()` has already been called with the same runs and has returned `true`.
     *
     * Returned array contains 0, 1, or 2 runs which are the portion(s) of `minuend` that do _not_ include `subtrahend`.
     *
     * Caveat: This operator is *not* commutative.
     * @param {number[]} minuend - a run from which to "subtract" `subtrahend`
     * @param {number[]} subtrahend - a run to "subtracted" from `minuend`
     */
    function subtract(minuend, subtrahend) {
        var m0 = minuend[0];
        var m1 = minuend[1];
        var s0 = subtrahend[0];
        var s1 = subtrahend[1];
        var result = [];

        if (s0 <= m0 && s1 < m1) {
            //subtrahend extends before minuend: return remaining piece of `minuend`
            result.push([s1 + 1, m1]);
        } else if (s0 > m0 && s1 >= m1) {
            //subtrahend extends after minuend: return remaining piece of `minuend`
            result.push([m0, s0 - 1]);
        } else if (m0 < s0 && s1 < m1) {
            //completely inside: return 2 smaller pieces resulting from the hole
            result.push([m0, s0 - 1]);
            result.push([s1 + 1, m1]);
        } else if (s1 < m0 || s0 > m1) {
            // completely outside: return `minuend` untouched
            result.push(minuend);
        }

        //else subtrahend must completely overlap minuend so return no pieces

        return result;
    }


    // Local utility functions

    /**
     * @private
     * @function merge
     * @summary Operator that merges given runs.
     * @returns {number[]} A single merged run.
     * @desc Both parameters are assumed to be _ordered_ arrays.
     *
     * The runs are assumed to be overlapping or adjacent to one another.
     *
     * Note: This operator is commutative.
     * @param {number[]} run1 - a run to merge with `run2`
     * @param {number[]} run2 - a run to merge with `run1`
     */
    function merge(run1, run2) {
        var min = Math.min(Math.min.apply(Math, run1), Math.min.apply(Math, run2));
        var max = Math.max(Math.max.apply(Math, run1), Math.max.apply(Math, run2));
        return [min, max];
    }

    // Interface
    module.exports = RangeSelectionModel;
})(
    typeof module === 'object' && module || (window.RangeSelectionModel = {}),
    typeof module === 'object' && module.exports || (window.RangeSelectionModel.exports = {})
) || (
    typeof module === 'object' || (window.RangeSelectionModel = window.RangeSelectionModel.exports)
);

/* About the above IIFE:
 * This file is a "modified node module." It functions as usual in Node.js *and* is also usable directly in the browser.
 * 1. Node.js: The IIFE is superfluous but innocuous.
 * 2. In the browser: The IIFE closure serves to keep internal declarations private.
 * 2.a. In the browser as a global: The logic in the actual parameter expressions + the post-invocation expression
 * will put your API in `window.RangeSelectionModel`.
 * 2.b. In the browser as a module: If you predefine a `window.module` object, the results will be in `module.exports`.
 * The bower component `mnm` makes this easy and also provides a global `require()` function for referencing your module
 * from other closures. In either case, this works with both NodeJs-style export mechanisms -- a single API assignment,
 * `module.exports = yourAPI` *or* a series of individual property assignments, `module.exports.property = property`.
 *
 * Before the IIFE runs, the actual parameter expressions are executed:
 * 1. If `window` object undefined, we're in NodeJs so assume there is a `module` object with an `exports` property
 * 2. If `window` object defined, we're in browser
 * 2.a. If `module` object predefined, use it
 * 2.b. If `module` object undefined, create a `RangeSelectionModel` object
 *
 * After the IIFE returns:
 * Because it always returns undefined, the expression after the || will execute:
 * 1. If `window` object undefined, then we're in NodeJs so we're done
 * 2. If `window` object defined, then we're in browser
 * 2.a. If `module` object predefined, we're done; results are in `moudule.exports`
 * 2.b. If `module` object undefined, redefine`RangeSelectionModel` to be the `RangeSelectionModel.exports` object
 */

},{}],31:[function(require,module,exports){
// templex node module
// https://github.com/joneit/templex

/* eslint-env node, browser */ //to allow refs to `window` in IIFE's call's actual params

(function (module, exports) { // eslint-disable-line no-unused-expressions, no-unused-vars

    // This closure supports NodeJS-less client side includes with <script> tags. See notes at bottom of this file.

    /**
     * Merges values of execution context properties named in template by {prop1},
     * {prop2}, etc., or any javascript expression incorporating such prop names.
     * The context always includes the global object. In addition you can specify a single
     * context or an array of contexts to search (in the order given) before finally
     * searching the global context.
     *
     * Merge expressions consisting of simple numeric terms, such as {0}, {1}, etc., deref
     * the first context given, which is assumed to be an array. As a convenience feature,
     * if additional args are given after `template`, `arguments` is unshifted onto the context
     * array, thus making first additional arg available as {1}, second as {2}, etc., as in
     * `templex('Hello, {1}!', 'World')`. ({0} is the template so consider this to be 1-based.)
     *
     * If you prefer something other than braces, redefine `templex.regexp`.
     *
     * See tests for examples.
     *
     * @param {string} template
     * @param {...string} [args]
     */
    function templex(template) {
        var contexts = this instanceof Array ? this : [this];
        if (arguments.length > 1) { contexts.unshift(arguments); }
        return template.replace(templex.regexp, templex.merger.bind(contexts));
    }

    templex.regexp = /\{(.*?)\}/g;

    templex.with = function (i, s) {
        return 'with(this[' + i + ']){' + s + '}';
    };

    templex.cache = [];

    templex.deref = function (key) {
        if (!(this.length in templex.cache)) {
            var code = 'return eval(expr)';

            for (var i = 0; i < this.length; ++i) {
                code = templex.with(i, code);
            }

            templex.cache[this.length] = eval('(function(expr){' + code + '})'); // eslint-disable-line no-eval
        }
        return templex.cache[this.length].call(this, key);
    };

    templex.merger = function (match, key) {
        // Advanced features: Context can be a list of contexts which are searched in order.
        var replacement;

        try {
            replacement = isNaN(key) ? templex.deref.call(this, key) : this[0][key];
        } catch (e) {
            replacement = '{' + key + '}';
        }

        return replacement;
    };

    // this interface consists solely of the templex function object
    module.exports = templex;

})(
    typeof module === 'object' && module || (window.templex = {}),
    typeof module === 'object' && module.exports || (window.templex.exports = {})
) || (
    typeof module === 'object' || (window.templex = window.templex.exports)
);

/* About the above IIFE:
 * This file is a "modified node module." It functions as usual in Node.js *and* is also usable directly in the browser.
 * 1. Node.js: The IIFE is superfluous but innocuous.
 * 2. In the browser: The IIFE closure serves to keep internal declarations private.
 * 2.a. In the browser as a global: The logic in the actual parameter expressions + the post-invocation expression
 * will put your API in `window.templex`.
 * 2.b. In the browser as a module: If you predefine a `window.module` object, the results will be in `module.exports`.
 * The bower component `mnm` makes this easy and also provides a global `require()` function for referencing your module
 * from other closures. In either case, this works with both NodeJs-style export mechanisms -- a single API assignment,
 * `module.exports = yourAPI` *or* a series of individual property assignments, `module.exports.property = property`.
 *
 * Before the IIFE runs, the actual parameter expressions are executed:
 * 1. If `module` object defined, we're in NodeJs so assume there is a `module` object with an `exports` object
 * 2. If `module` object undefined, we're in browser so define a `window.templex` object with an `exports` object
 *
 * After the IIFE returns:
 * Because it always returns undefined, the expression after the || will always execute:
 * 1. If `module` object defined, then we're in NodeJs so we're done
 * 2. If `module` object undefined, then we're in browser so redefine`window.templex` as its `exports` object
 */

},{}],32:[function(require,module,exports){
'use strict';

var Base = require('extend-me').Base;

/** @constructor
 * @desc Instances of features are connected to one another to make a chain of responsibility for handling all the input to the hypergrid.
 *
 * See {@link CellProvider#initialize|initialize} which is called by the constructor.
 */
var CellProvider = Base.extend('CellProvider', {

    /**
     * @summary Constructor logic
     * @desc This method will be called upon instantiation of this class or of any class that extends from this class.
     * > All `initialize()` methods in the inheritance chain are called, in turn, each with the same parameters that were passed to the constructor, beginning with that of the most "senior" class through that of the class of the new instance.
     * @memberOf CellProvider.prototype
     */
    initialize: function() {
        this.cellCache = {};
        this.initializeCells();
    },

    /**
     * @desc replace this function in on your instance of cellProvider
     * @returns cell
     * @param {object} config - an object with everything you might need for renderering a cell
     * @memberOf CellProvider.prototype
     */
    getCell: function(config) {
        var cell = this.cellCache.simpleCellRenderer;
        cell.config = config;
        return cell;
    },

    /**
     * @desc replace this function in on your instance of cellProvider
     * @returns cell
     * @param {object} config - an object with everything you might need for renderering a cell
     * @memberOf CellProvider.prototype
     */
    getColumnHeaderCell: function(config) {
        var cell = this.cellCache.simpleCellRenderer;
        cell.config = config;
        return cell;
    },

    /**
     * @desc replace this function in on your instance of cellProvider
     * @returns cell
     * @param {object} config - an object with everything you might need for renderering a cell
     * @memberOf CellProvider.prototype
     */
    getRowHeaderCell: function(config) {
        var cell = this.cellCache.simpleCellRenderer;
        cell.config = config;
        return cell;
    },

    paintButton: function(gc, config) {
        var val = config.value;
        var c = config.x;
        var r = config.y;
        var bounds = config.bounds;
        var x = bounds.x + 2;
        var y = bounds.y + 2;
        var width = bounds.width - 3;
        var height = bounds.height - 3;
        var radius = height / 2;
        var arcGradient = gc.createLinearGradient(x, y, x, y + height);
        if (config.mouseDown) {
            arcGradient.addColorStop(0, '#B5CBED');
            arcGradient.addColorStop(1, '#4d74ea');
        } else {
            arcGradient.addColorStop(0, '#ffffff');
            arcGradient.addColorStop(1, '#aaaaaa');
        }
        gc.fillStyle = arcGradient;
        gc.strokeStyle = '#000000';
        roundRect(gc, x, y, width, height, radius, arcGradient, true);

        var ox = (width - config.getTextWidth(gc, val)) / 2;
        var oy = (height - config.getTextHeight(gc.font).descent) / 2;

        if (gc.textBaseline !== 'middle') {
            gc.textBaseline = 'middle';
        }

        gc.fillStyle = '#000000';

        config.backgroundColor = 'rgba(0,0,0,0)';
        gc.fillText(val, x + ox, y + oy);

        //identify that we are a button
        config.buttonCells[c + ',' + r] = true;
    },

    /**
     * @summary The default cell rendering function for rendering a vanilla cell.
     * @desc Great care has been taken in crafting this function as it needs to perform extremely fast. Reads on the gc object are expensive but not quite as expensive as writes to it. We do our best to avoid writes, then avoid reads. Clipping bounds are not set here as this is also an expensive operation. Instead, we truncate overflowing text and content by filling a rectangle with background color column by column instead of cell by cell.  This column by column fill happens higher up on the stack in a calling function from fin-hypergrid-renderer.  Take note we do not do cell by cell border renderering as that is expensive.  Instead we render many fewer gridlines after all cells are rendered.
     * @param {CanvasGraphicsContext} gc - the "pen" in the mvc model, we issue drawing commands to
     * @param {number} x - the x screen coordinate of my origin
     * @param {number} y - the y screen coordinate of my origin
     * @param {number} width - the width I'm allowed to draw within
     * @param {number} height - the height I'm allowed to draw within
     * @param {boolean} isLink - is this a hyperlink cell
     * @memberOf CellProvider.prototype
     */
    defaultCellPaint: function(gc, config) {
        var val = config.value,
            x = config.bounds.x,
            y = config.bounds.y,
            width = config.bounds.width,
            height = config.bounds.height,
            wrapHeaders = config.headerTextWrapping,
            leftPadding = 2, //TODO: fix this
            isHeader = config.y === 0;

        var leftIcon, rightIcon, centerIcon, ixoffset, iyoffset;

        //setting gc properties are expensive, lets not do it unnecessarily

        if (val && val.constructor === Array) {
            leftIcon = val[0];
            rightIcon = val[2];
            val = val[1];
            if (typeof val === 'object') { // must be an image
                centerIcon = val;
                val = null;
            }
            if (leftIcon && leftIcon.nodeName !== 'IMG') {
                leftIcon = null;
            }
            if (rightIcon && rightIcon.nodeName !== 'IMG') {
                rightIcon = null;
            }
            if (centerIcon && centerIcon.nodeName !== 'IMG') {
                centerIcon = null;
            }
        }

        val = valueOrFunctionExecute(config, val);

        if (gc.font !== config.font) {
            gc.font = config.font;
        }
        if (gc.textAlign !== 'left') {
            gc.textAlign = 'left';
        }
        if (gc.textBaseline !== 'middle') {
            gc.textBaseline = 'middle';
        }

        //fill background only if our bgColor is populated or we are a selected cell
        if (config.backgroundColor || config.isSelected) {
            gc.fillStyle = valueOrFunctionExecute(config, config.isSelected ? config.backgroundSelectionColor : config.backgroundColor);
            gc.fillRect(x, y, width, height);
        }

        //draw text
        var theColor = valueOrFunctionExecute(config, config.isSelected ? config.foregroundSelectionColor : config.color);
        if (gc.fillStyle !== theColor) {
            gc.fillStyle = theColor;
            gc.strokeStyle = theColor;
        }

        if (isHeader && wrapHeaders) {
            this.renderMultiLineText(x, y, height, width, gc, config, val);
        } else {
            this.renderSingleLineText(x, y, height, width, gc, config, val);
        }

        if (config.isInCurrentSelectionRectangle) {
            gc.fillStyle = 'rgba(0, 0, 0, 0.2)';
            gc.fillRect(x, y, width, height);
        }
        var iconWidth = 0;
        if (leftIcon) {
            iyoffset = Math.round((height - leftIcon.height) / 2);
            gc.drawImage(leftIcon, x + leftPadding, y + iyoffset);
            iconWidth = Math.max(leftIcon.width + 2);
        }
        if (rightIcon) {
            iyoffset = Math.round((height - rightIcon.height) / 2);
            ixoffset = 0; //Math.round((halignOffset - rightIcon.width) / 2);
            gc.drawImage(rightIcon, x + width - ixoffset - rightIcon.width, y + iyoffset);
            iconWidth = Math.max(rightIcon.width + 2);
        }
        if (centerIcon) {
            iyoffset = Math.round((height - centerIcon.height) / 2);
            ixoffset = Math.round((width - centerIcon.width) / 2);
            gc.drawImage(centerIcon, x + width - ixoffset - centerIcon.width, y + iyoffset);
            iconWidth = Math.max(centerIcon.width + 2);
        }
        if (config.cellBorderThickness) {
            gc.beginPath();
            gc.rect(x, y, width, height);
            gc.lineWidth = config.cellBorderThickness;
            gc.strokeStyle = config.cellBorderStyle;

            // animate the dashed line a bit here for fun

            gc.stroke();
            gc.closePath();
        }
        config.minWidth = config.minWidth + 2 * (iconWidth);
    },

    renderMultiLineText: function(x, y, height, width, gc, config, val) {
        var lines = fitText(gc, config, val, width);
        if (lines.length === 1) {
            return this.renderSingleLineText(x, y, height, width, gc, config, squeeze(val));
        }

        var colHEdgeOffset = config.cellPadding,
            halignOffset = 0,
            valignOffset = config.voffset,
            halign = config.halign,
            textHeight = config.getTextHeight(config.font).height;

        switch (halign) {
            case 'right':
                halignOffset = width - colHEdgeOffset;
                break;
            case 'center':
                halignOffset = width / 2;
                break;
            case 'left':
                halignOffset = colHEdgeOffset;
                break;
        }

        var hMin = 0, vMin = Math.ceil(textHeight / 2);

        valignOffset += Math.ceil((height - (lines.length - 1) * textHeight) / 2);

        halignOffset = Math.max(hMin, halignOffset);
        valignOffset = Math.max(vMin, valignOffset);

        gc.save(); // define a clipping region for cell
        gc.moveTo(x, y);
        gc.lineTo(x + width, y);
        gc.lineTo(x + width, y + height);
        gc.lineTo(x, y + height);
        gc.lineTo(x, y);
        gc.closePath();
        gc.clip();

        gc.textAlign = halign;

        for (var i = 0; i < lines.length; i++) {
            gc.fillText(lines[i], x + halignOffset, y + valignOffset + (i * textHeight));
        }

        gc.restore(); // discard clipping region
    },

    renderSingleLineText: function(x, y, height, width, gc, config, val) {
        var colHEdgeOffset = config.cellPadding,
            halignOffset = 0,
            valignOffset = config.voffset,
            halign = config.halign,
            isColumnHovered = config.isColumnHovered,
            isRowHovered = config.isRowHovered,
            isLink = isLink || false;

        var fontMetrics = config.getTextHeight(config.font);
        var textWidth = config.getTextWidth(gc, val);

        //we must set this in order to compute the minimum width
        //for column autosizing purposes
        config.minWidth = textWidth + (2 * colHEdgeOffset);

        switch (halign) {
            case 'right':
                //textWidth = config.getTextWidth(gc, config.value);
                halignOffset = width - colHEdgeOffset - textWidth;
                break;
            case 'center':
                //textWidth = config.getTextWidth(gc, config.value);
                halignOffset = (width - textWidth) / 2;
                break;
            case 'left':
                halignOffset = colHEdgeOffset;
                break;
        }

        halignOffset = Math.max(0, halignOffset);
        valignOffset = valignOffset + Math.ceil(height / 2);

        if (val !== null) {
            gc.fillText(val, x + halignOffset, y + valignOffset);
        }

        if (isColumnHovered && isRowHovered) {
            gc.beginPath();
            if (isLink) {
                underline(config, gc, val, x + halignOffset, y + valignOffset + Math.floor(fontMetrics.height / 2), 1);
                gc.stroke();
            }
            gc.closePath();
        }
    },

    /**
     * @param {CanvasGraphicsContext} gc - the "pen" in the mvc model, we issue drawing commands to
     * @param {number} x - the x screen coordinate of my origin
     * @param {number} y - the y screen coordinate of my origin
     * @param {number} width - the width I'm allowed to draw within
     * @param {number} height - the height I'm allowed to draw within
     * @param {boolean} isLink - is this a hyperlink cell
     * @memberOf CellProvider.prototype
     * @desc emersons paint function for a slider button. currently the user cannot interact with it
     */
    paintSlider: function(gc, x, y, width, height) {
        // gc.strokeStyle = 'white';
        // var val = this.config.value;
        // var radius = height / 2;
        // var offset = width * val;
        // var bgColor = this.config.isSelected ? this.config.bgSelColor : '#333333';
        // var btnGradient = gc.createLinearGradient(x, y, x, y + height);
        // btnGradient.addColorStop(0, bgColor);
        // btnGradient.addColorStop(1, '#666666');
        // var arcGradient = gc.createLinearGradient(x, y, x, y + height);
        // arcGradient.addColorStop(0, '#aaaaaa');
        // arcGradient.addColorStop(1, '#777777');
        // gc.fillStyle = btnGradient;
        // roundRect(gc, x, y, width, height, radius, btnGradient);
        // if (val < 1.0) {
        //     gc.fillStyle = arcGradient;
        // } else {
        //     gc.fillStyle = '#eeeeee';
        // }
        // gc.beginPath();
        // gc.arc(x + Math.max(offset - radius, radius), y + radius, radius, 0, 2 * Math.PI);
        // gc.fill();
        // gc.closePath();
        // this.config.minWidth = 100;
    },

    /**
     * @desc A simple implementation of a sparkline, because it's a barchart we've changed the name ;).
     * @param {CanvasGraphicsContext} gc - the "pen" in the mvc model, we issue drawing commands to
     * @param {number} x - the x screen coordinate of my origin
     * @param {number} y - the y screen coordinate of my origin
     * @param {number} width - the width I'm allowed to draw within
     * @param {number} height - the height I'm allowed to draw within
     * @param {boolean} isLink - is this a hyperlink cell
     * @memberOf CellProvider.prototype
     */
    paintSparkbar: function(gc, x, y, width, height) {
        gc.beginPath();
        var val = this.config.value;
        if (!val || !val.length) {
            return;
        }
        var count = val.length;
        var eWidth = width / count;
        var fgColor = this.config.isSelected ? this.config.fgSelColor : this.config.fgColor;
        if (this.config.bgColor || this.config.isSelected) {
            gc.fillStyle = this.config.isSelected ? this.config.bgSelColor : this.config.bgColor;
            gc.fillRect(x, y, width, height);
        }
        gc.fillStyle = fgColor;
        for (var i = 0; i < val.length; i++) {
            var barheight = val[i] / 110 * height;
            gc.fillRect(x + 5, y + height - barheight, eWidth * 0.6666, barheight);
            x = x + eWidth;
        }
        gc.closePath();
        this.config.minWidth = count * 10;

    },

    /**
     * @desc A simple implementation of a sparkline.  see [Edward Tufte sparkline](http://www.edwardtufte.com/bboard/q-and-a-fetch-msg?msg_id=0001OR)
     * @param {CanvasGraphicsContext} gc - the "pen" in the mvc model, we issue drawing commands to
     * @param {number} x - the x screen coordinate of my origin
     * @param {number} y - the y screen coordinate of my origin
     * @param {number} width - the width I'm allowed to draw within
     * @param {number} height - the height I'm allowed to draw within
     * @param {boolean} isLink - is this a hyperlink cell
     * @memberOf CellProvider.prototype
     */
    paintSparkline: function(gc, x, y, width, height) {
        gc.beginPath();
        var val = this.config.value;
        if (!val || !val.length) {
            return;
        }
        var count = val.length;
        var eWidth = width / count;

        var fgColor = this.config.isSelected ? this.config.fgSelColor : this.config.fgColor;
        if (this.config.bgColor || this.config.isSelected) {
            gc.fillStyle = this.config.isSelected ? this.config.bgSelColor : this.config.bgColor;
            gc.fillRect(x, y, width, height);
        }
        gc.strokeStyle = fgColor;
        gc.fillStyle = fgColor;
        gc.beginPath();
        var prev;
        for (var i = 0; i < val.length; i++) {
            var barheight = val[i] / 110 * height;
            if (!prev) {
                prev = barheight;
            }
            gc.lineTo(x + 5, y + height - barheight);
            gc.arc(x + 5, y + height - barheight, 1, 0, 2 * Math.PI, false);
            x = x + eWidth;
        }
        this.config.minWidth = count * 10;
        gc.stroke();
        gc.closePath();
    },

    /**
     * @desc A simple implementation of a tree cell renderer for use mainly with the qtree.
     * @param {CanvasGraphicsContext} gc - the "pen" in the mvc model, we issue drawing commands to
     * @param {number} x - the x screen coordinate of my origin
     * @param {number} y - the y screen coordinate of my origin
     * @param {number} width - the width I'm allowed to draw within
     * @param {number} height - the height I'm allowed to draw within
     * @param {boolean} isLink - is this a hyperlink cell
     * @memberOf CellProvider.prototype
     */
    treeCellRenderer: function(gc, x, y, width, height) {
        var val = this.config.value.data;
        var indent = this.config.value.indent;
        var icon = this.config.value.icon;

        //fill background only if our bgColor is populated or we are a selected cell
        if (this.config.bgColor || this.config.isSelected) {
            gc.fillStyle = this.config.isSelected ? this.config.bgSelColor : this.config.bgColor;
            gc.fillRect(x, y, width, height);
        }

        if (!val || !val.length) {
            return;
        }
        var valignOffset = Math.ceil(height / 2);

        gc.fillStyle = this.config.isSelected ? this.config.fgSelColor : this.config.fgColor;
        gc.fillText(icon + val, x + indent, y + valignOffset);

        var textWidth = this.config.getTextWidth(gc, icon + val);
        var minWidth = x + indent + textWidth + 10;
        this.config.minWidth = minWidth;
    },

    /**
     * @desc An empty implementation of a cell renderer, see [the null object pattern](http://c2.com/cgi/wiki?NullObject).
     * @param {CanvasGraphicsContext} gc - the "pen" in the mvc model, we issue drawing commands to
     * @param {number} x - the x screen coordinate of my origin
     * @param {number} y - the y screen coordinate of my origin
     * @param {number} width - the width I'm allowed to draw within
     * @param {number} height - the height I'm allowed to draw within
     * @memberOf CellProvider.prototype
     * @param {boolean} isLink - is this a hyperlink cell
     */
    emptyCellRenderer: function(gc, x, y, width, height) {},

    /**
     * @memberOf CellProvider.prototype
     * @private
     */
    initializeCells: function() {
        var self = this;
        this.cellCache.simpleCellRenderer = {
            paint: this.defaultCellPaint,
            renderSingleLineText: this.renderSingleLineText,
            renderMultiLineText: this.renderMultiLineText
        };
        this.cellCache.sliderCellRenderer = {
            paint: this.paintSlider
        };
        this.cellCache.sparkbarCellRenderer = {
            paint: this.paintSparkbar
        };
        this.cellCache.sparklineCellRenderer = {
            paint: this.paintSparkline
        };
        this.cellCache.treeCellRenderer = {
            paint: this.treeCellRenderer
        };
        this.cellCache.emptyCellRenderer = {
            paint: this.emptyCellRenderer
        };
        this.cellCache.buttonRenderer = {
            paint: this.paintButton,
            //defaultCellPaint: this.defaultCellPaint
        };
        this.cellCache.linkCellRenderer = {
            paint: function(gc, x, y, width, height) {
                self.config = this.config;
                self.defaultCellPaint(gc, x, y, width, height, true);
            }
        };
    }
});

function valueOrFunctionExecute(config, valueOrFunction) {
    var isFunction = (((typeof valueOrFunction)[0]) === 'f');
    var result = isFunction ? valueOrFunction(config) : valueOrFunction;
    if (!result && result !== 0) {
        return '';
    }
    return result;
}

function underline(config, gc, text, x, y, thickness) {
    var width = config.getTextWidth(gc, text);

    switch (gc.textAlign) {
        case 'center':
            x -= (width / 2);
            break;
        case 'right':
            x -= width;
            break;
    }

    //gc.beginPath();
    gc.lineWidth = thickness;
    gc.moveTo(x + 0.5, y + 0.5);
    gc.lineTo(x + width + 0.5, y + 0.5);
}

function findLines(gc, config, words, width) {

    if (words.length === 1) {
        return words;
    }

    // starting with just the first word…
    var stillFits, line = [words.shift()];
    while (
        // so lone as line still fits within current column…
    (stillFits = config.getTextWidth(gc, line.join(' ')) < width)
        // …AND there are more words available…
    && words.length
        ) {
        // …add another word to end of line and retest
        line.push(words.shift());
    }

    if (
        !stillFits // if line is now too long…
        && line.length > 1 // …AND is multiple words…
    ) {
        words.unshift(line.pop()); // …back off by (i.e., remove) one word
    }

    line = [line.join(' ')];

    if (words.length) { // if there's anything left…
        line = line.concat(findLines(gc, config, words, width)); // …break it up as well
    }

    return line;
}

function fitText(gc, config, string, width) {
    return findLines(gc, config, squeeze(string).split(' '), width);
}

// trim string; then reduce all runs of multiple spaces to a single space
function squeeze(string) {
    return string.toString().trim().replace(/\s\s+/g, ' ');
}

function roundRect(gc, x, y, width, height, radius, fill, stroke) {

    if (!stroke) {
        stroke = true;
    }
    if (!radius) {
        radius = 5;
    }
    gc.beginPath();
    gc.moveTo(x + radius, y);
    gc.lineTo(x + width - radius, y);
    gc.quadraticCurveTo(x + width, y, x + width, y + radius);
    gc.lineTo(x + width, y + height - radius);
    gc.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
    gc.lineTo(x + radius, y + height);
    gc.quadraticCurveTo(x, y + height, x, y + height - radius);
    gc.lineTo(x, y + radius);
    gc.quadraticCurveTo(x, y, x + radius, y);
    gc.closePath();
    if (stroke) {
        gc.stroke();
    }
    if (fill) {
        gc.fill();
    }
    gc.closePath();
}

module.exports = CellProvider;

},{"extend-me":3}],33:[function(require,module,exports){
/* eslint-env browser */

'use strict';

var extend = require('extend-me');
var FinBar = require('finbars');
var Canvas = require('fincanvas');
var Point = require('rectangular').Point;
var Rectangle = require('rectangular').Rectangle;
var LRUCache = require('lru-cache');
var _ = require('object-iterators');

var Renderer = require('./Renderer');
var SelectionModel = require('./SelectionModel');
var addStylesheet = require('./stylesheets');

var globalCellEditors = {},
    propertiesInitialized = false,
    textWidthCache = new LRUCache(2000),
    defaults = defaultProperties(),
    polymerTheme = Object.create(defaults),
    globalProperties = Object.create(polymerTheme);

/**
 * @constructor
 * @param {string|Element} div - CSS selector or Element
 * @param {string} behaviorName - name of a behavior consstructor from ./behaviors
 */
function Hypergrid(div, behaviorFactory) {

    extend.debug = true;

    installPolyfills();

    var self = this;

    this.div = (typeof div === 'string') ? document.querySelector(div) : div;

    addStylesheet('grid');

    this.lastEdgeSelection = [0, 0];

    this.lnfProperties = Object.create(globalProperties);

    this.isWebkit = navigator.userAgent.toLowerCase().indexOf('webkit') > -1;
    this.selectionModel = new SelectionModel();
    this.selectionModel.getGrid = function() {
        return self;
    };
    this.cellEditors = Object.create(globalCellEditors);
    this.renderOverridesCache = {};

    this.behavior = behaviorFactory(this);

    //prevent the default context menu for appearing
    this.div.oncontextmenu = function(event) {
        event.preventDefault();
        return false;
    };

    this.clearMouseDown();
    this.dragExtent = new Point(0, 0);
    this.numRows = 0;
    this.numColumns = 0;

    //install any plugins
    this.pluginsDo(function(each) {
        if (each.installOn) {
            each.installOn(self);
        }
    });

    //initialize our various pieces
    this.initRenderer();
    this.initCanvas();
    this.initScrollbars();
    this.initGlobalCellEditors();

    this.checkScrollbarVisibility();
    //Register a listener for the copy event so we can copy our selected region to the pastebuffer if conditions are right.
    document.body.addEventListener('copy', function(evt) {
        self.checkClipboardCopy(evt);
    });
    this.getCanvas().resize();
    //this.computeCellsBounds();
}

Hypergrid.prototype = {
    constructor: Hypergrid.prototype.constructor,

    /**
     *
     * A null object behavior serves as a place holder.
     * @type {object}
     * @memberOf Hypergrid.prototype
     */
    behavior: null,

    /**
     * Cached result of if we are running in webkit.
     * @type {boolean}
     * @memberOf Hypergrid.prototype
     */
    isWebkit: true,

    /**
     * The pixel location of an initial mousedown click, either for editing a cell or for dragging a selection.
     * @type {Point}
     * @memberOf Hypergrid.prototype
     */
    mouseDown: [],

    /**
     * The extent from the mousedown point during a drag operation.
     * @type {Point}
     * @memberOf Hypergrid.prototype
     */

    dragExtent: null,

    /**
     * A float value between 0.0 - 1.0 of the vertical scroll position.
     * @type {number}
     * @memberOf Hypergrid.prototype
     */
    vScrollValue: 0,

    /**
     * A float value between 0.0 - 1.0 of the horizontal scroll position.
     * @type {number}
     * @memberOf Hypergrid.prototype
     */
    hScrollValue: 0,

    /**
     * @property {window.fin.rectangular} rectangular - Namespace for Point and Rectangle "classes" (constructors).
     * @memberOf Hypergrid.prototype
     */
    rectangular: null,

    /**
     * @property {fin-hypergrid-selection-model} selectionModel - A [fin-hypergrid-selection-model](module-._selection-model.html) instance.
     * @memberOf Hypergrid.prototype
     */
    selectionModel: null,

    /**
     * @property {fin-hypergrid-cell-editor} cellEditor - The current instance of [fin-hypergrid-cell-editor](module-cell-editors_base.html).
     * @memberOf Hypergrid.prototype
     */
    cellEditor: null,

    /**
     * @property {fin-vampire-bar} sbHScroller - An instance of [fin-vampire-bar](http://datamadic.github.io/fin-vampire-bar/components/fin-vampire-bar/).
     * @memberOf Hypergrid.prototype
     */
    sbHScroller: null,

    /**
     * @property {fin-vampire-bar} sbVScroller - An instance of [fin-vampire-bar](http://datamadic.github.io/fin-vampire-bar/components/fin-vampire-bar/).
     * @memberOf Hypergrid.prototype
     */
    sbVScroller: null,

    /**
     * The previous value of sbVScrollVal.
     * @type {number}
     * @memberOf Hypergrid.prototype
     */
    sbPrevVScrollValue: null,

    /**
     * The previous value of sbHScrollValue.
     * @type {number}
     * @memberOf Hypergrid.prototype
     */
    sbPrevHScrollValue: null,

    /**
     * The cache of singleton cellEditors.
     * @type {object}
     * @memberOf Hypergrid.prototype
     */
    cellEditors: null,

    /**
     * is the short term memory of what column I might be dragging around
     * @type {object}
     * @memberOf Hypergrid.prototype
     */

    renderOverridesCache: {},

    /**
     * The pixel location of the current hovered cell.
     * @type {Point}
     * @memberOf Hypergrid.prototype
     */
    hoverCell: null,

    scrollingNow: false,

    lastEdgeSelection: null,

    /**
     * @memberOf Hypergrid.prototype
    clear out the LRU cache of text widths
     */
    setAttribute: function(attribute, value) {
        this.div.setAttribute(attribute, value);
    },

    /**
     * @memberOf Hypergrid.prototype
    clear out all state and data of the grid
     */
    reset: function() {
        var self = this;
        this.lastEdgeSelection = [0, 0];
        this.lnfProperties = Object.create(globalProperties);
        this.selectionModel = new SelectionModel();
        this.selectionModel.getGrid = function() {
            return self;
        };
        this.cellEditors = Object.create(globalCellEditors);
        this.renderOverridesCache = {};
        this.clearMouseDown();
        this.dragExtent = new Point(0, 0);

        this.numRows = 0;
        this.numColumns = 0;

        this.vScrollValue = 0;
        this.hScrollValue = 0;

        this.cellEditor = null;

        this.sbPrevVScrollValue = null;
        this.sbPrevHScrollValue = null;

        this.hoverCell = null;
        this.scrollingNow = false;
        this.lastEdgeSelection = [0, 0];

        this.getBehavior().reset();
        this.getRenderer().reset();
        this.getCanvas().resize();
        this.behaviorChanged();
    },

    resetTextWidthCache: function() {
        textWidthCache = new LRUCache(2000);
    },

    getProperties: function() {
        return this.getPrivateState();
    },

    _getProperties: function() {
        return this.lnfProperties;
    },

    computeCellsBounds: function() {
        this.getRenderer().computeCellsBounds();
    },

    initCellEditor: function(cellEditor) {
        var divCellEditor = document.createElement('div');
        this.div.appendChild(divCellEditor);

        globalCellEditors[cellEditor.alias] = cellEditor;
    },

    initGlobalCellEditors: function() {
        if (!propertiesInitialized) {
            propertiesInitialized = true;

            buildPolymerTheme();

            var cellEditors = [
                'Textfield',
                'Choice',
                //'Combo',
                'Color',
                'Date',
                'Slider',
                'Spinner'
            ];

            var self = this;
            cellEditors.forEach(function(name) {
                self.initCellEditor(new Hypergrid.cellEditors[name]);
            });
        }
    },

    toggleColumnPicker: function() {
        this.getBehavior().toggleColumnPicker();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {boolean} The pointer is over the given cell.
     * @param {number} x - The x cell coordinate.
     * @param {number} y - The y cell coordinate.
     */
    isHovered: function(x, y) {
        var p = this.getHoverCell();
        if (!p) {
            return false;
        }
        return p.x === x && p.y === y;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns boolean} The pointer is hovering over the given column.
     * @param {number} x - The horizontal cell coordinate.
     */
    isColumnHovered: function(x) {
        var p = this.getHoverCell();
        if (!p) {
            return false;
        }
        return p.x === x;
    },

    isRowResizeable: function() {
        return this.resolveProperty('rowResize');
    },

    /**
     *
     *
     * @memberOf Hypergrid.prototype
     * @returns {boolean} The pointer is hovering over the row `y`.
     * @param {number} y - The vertical cell coordinate.
     */
    isRowHovered: function(y) {
        var p = this.getHoverCell();
        if (!p) {
            return false;
        }
        return p.y === y;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {Point} The cell over which the cursor is hovering.
     */
    getHoverCell: function() {
        return this.hoverCell;
    },


    /**
     * @memberOf Hypergrid.prototype
     * @desc Set the cell under the cursor.
     * @param {Point} point
     */
    setHoverCell: function(point) {
        var me = this.hoverCell;
        var newPoint = new Point(point.x, point.y);
        if (me && me.equals(newPoint)) {
            return;
        }
        this.hoverCell = newPoint;
        this.fireSyntheticOnCellEnterEvent(newPoint);
        this.repaint();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Ammend properties for all hypergrids in this process.
     * @param {object} properties - A simple properties hash.
     */
    addGlobalProperties: function(properties) {
        //we check for existence to avoid race condition in initialization
        if (!globalProperties) {
            var self = this;
            setTimeout(function() {
                self.addGlobalProperties(properties);
            }, 10);
        } else {
            this._addGlobalProperties(properties);
        }

    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Ammend properties for all hypergrids in this process.
     * @param {object} properties - A simple properties hash.
     * @private
     */
    _addGlobalProperties: function(properties) {
        _(properties).each(function(property, key) {
            globalProperties[key] = property;
        });
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Ammend properties for this hypergrid only.
     * @param {object} properties - A simple properties hash.
     */
    addProperties: function(moreProperties) {
        var properties = this.getProperties();
        _(moreProperties).each(function(property, key) {
            properties[key] = moreProperties[key];
        });
        this.refreshProperties();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Utility function to push out properties if we change them.
     * @param {object} properties - An object of various key value pairs.
     */

    refreshProperties: function() {
        // this.canvas = this.shadowRoot.querySelector('fin-canvas');
        //this.canvas = new Canvas(this.divCanvas, this.renderer); //TODO: Do we really need to be recreating it here?
        this.checkScrollbarVisibility();
        this.getBehavior().defaultRowHeight = null;
        if (this.isColumnAutosizing()) {
            this.getBehavior().autosizeAllColumns();
        }
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {object} The state object for remembering our state.
     * @see [Memento pattern](http://en.wikipedia.org/wiki/Memento_pattern)
     */
    getPrivateState: function() {
        return this.getBehavior().getPrivateState();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Set the state object to return to the given user configuration.
     * @param {object} state - A memento object.
     * @see [Memento pattern](http://en.wikipedia.org/wiki/Memento_pattern)
     */
    setState: function(state) {
        var self = this;
        this.getBehavior().setState(state);
        setTimeout(function() {
            self.behaviorChanged();
            self.synchronizeScrollingBoundries();
        }, 100);
    },

    getState: function() {
        return this.getBehavior().getState();
    },
    /**
     * @memberOf Hypergrid.prototype
     * @returns {object} The initial mouse position on a mouse down event for cell editing or a drag operation.
     * @memberOf Hypergrid.prototype
     */
    getMouseDown: function() {
        var last = this.mouseDown.length - 1;
        if (last < 0) {
            return null;
        }
        return this.mouseDown[last];
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Remove the last item from the mouse down stack.
     */
    popMouseDown: function() {
        if (this.mouseDown.length === 0) {
            return;
        }
        this.mouseDown.length = this.mouseDown.length - 1;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Empty out the mouse down stack.
     */
    clearMouseDown: function() {
        this.mouseDown = [new Point(-1, -1)];
        this.dragExtent = null;
    },

    /**
     * @memberOf Hypergrid.prototype
     set the mouse point that initated a cell edit or drag operation
     *
     * @param {Point} point
     */
    setMouseDown: function(point) {
        this.mouseDown.push(point);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {Point} The extent point of the current drag selection rectangle.
     */
    getDragExtent: function() {
        return this.dragExtent;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary Sets the extent point of the current drag selection operation.
     * @param {Point} point
     */
    setDragExtent: function(point) {
        this.dragExtent = point;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary Iterate over the plugins invoking the given function with each.
     * @todo We need a new plugin mechanism!
     * @param {function} func - The function to invoke on all the plugins.
     */
    pluginsDo: function(func) {
        //TODO: We need a new plugin mechanism!
        //var userPlugins = this.children.array();
        //var pluginsTag = this.shadowRoot.querySelector('fin-plugins');
        //
        //var plugins = userPlugins;
        //if (pluginsTag) {
        //    var systemPlugins = pluginsTag.children.array();
        //    plugins = systemPlugins.concat(plugins);
        //}
        //
        //plugins.forEach(function(plugin) {
        //    func(plugin);
        //});
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc The CellProvider is accessed through Hypergrid because Hypergrid is the mediator and should have ultimate control on where it comes from. The default is to delegate through the behavior object.
     * @returns {fin-hypergrid-cell-provider}
     */
    getCellProvider: function() {
        var provider = this.getBehavior().getCellProvider();
        return provider;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc This function is a callback from the HypergridRenderer sub-component. It is called after each paint of the canvas.
     */
    gridRenderedNotification: function() {
        this.updateRenderedSizes();
        if (this.cellEditor) {
            this.cellEditor.gridRenderedNotification();
        }
        this.checkColumnAutosizing();
        this.fireSyntheticGridRenderedEvent();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc The grid has just been rendered, make sure the column widths are optimal.
     */
    checkColumnAutosizing: function() {
        var behavior = this.getBehavior();
        behavior.autoSizeRowNumberColumn();
        if (this.isColumnAutosizing()) {
            behavior.checkColumnAutosizing(false);
        }
    },
    /**
     * @memberOf Hypergrid.prototype
     * @desc Notify the GridBehavior how many rows and columns we just rendered.
     */
    updateRenderedSizes: function() {
        var behavior = this.getBehavior();
        //add one to each of these values as we want also to include
        //the columns and rows that are partially visible
        behavior.setRenderedColumnCount(this.getVisibleColumns() + 1);
        behavior.setRenderedRowCount(this.getVisibleRows() + 1);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary Conditionally copy to clipboard.
     * @desc If we have focus, copy our current selection data to the system clipboard.
     * @param {event} event - The copy system event.
     */
    checkClipboardCopy: function(event) {
        if (!this.hasFocus()) {
            return;
        }
        event.preventDefault();
        var csvData = this.getSelectionAsTSV();
        event.clipboardData.setData('text/plain', csvData);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {boolean} We have any selections.
     */
    hasSelections: function() {
        if (!this.getSelectionModel) {
            return; // were not fully initialized yet
        }
        return this.getSelectionModel().hasSelections();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {string} Tab separated value string from the selection and our data.
     */
    getSelectionAsTSV: function() {
        var sm = this.getSelectionModel();
        if (sm.hasSelections()) {
            var selections = this.getSelectionMatrix();
            selections = selections[selections.length - 1];
            return this.getMatrixSelectionAsTSV(selections);
        } else if (sm.hasRowSelections()) {
            return this.getMatrixSelectionAsTSV(this.getRowSelectionMatrix());
        } else if (sm.hasColumnSelections()) {
            return this.getMatrixSelectionAsTSV(this.getColumnSelectionMatrix());
        }
    },

    getMatrixSelectionAsTSV: function(selections) {
        //only use the data from the last selection
        if (selections.length) {
            var width = selections.length,
                height = selections[0].length,
                area = width * height,
                collector = [];

            //disallow if selection is too big
            if (area > 20000) {
                alert('selection size is too big to copy to the paste buffer'); // eslint-disable-line no-alert
                return '';
            }

            var collectCells = function(selectionCell, x) {
                collector.push(selectionCell);
                if (x < width) {
                    collector.push('\t');
                }
            };

            var collectRows = function(selectionRow, y) {
                selectionRow.forEach(collectCells);
                if (y < height) {
                    collector.push('\n');
                }
            };

            selections.forEach(collectRows);

            return collector.join('');
        }
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {boolean} We have focus.
     */
    hasFocus: function() {
        return this.getCanvas().hasFocus();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Clear all the selections.
     */
    clearSelections: function() {
        this.getSelectionModel().clear();
        this.clearMouseDown();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Clear the most recent selection.
     */
    clearMostRecentSelection: function() {
        this.getSelectionModel().clearMostRecentSelection();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Clear the most recent column selection.
     */
    clearMostRecentColumnSelection: function() {
        this.getSelectionModel().clearMostRecentColumnSelection();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Clear the most recent row selection.
     */
    clearMostRecentRowSelection: function() {
        this.getSelectionModel().clearMostRecentRowSelection();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary Select given region.
     * @param {number} ox - origin x
     * @param {number} oy - origin y
     * @param {number} ex - extent x
     * @param {number} ex - extent y
     */
    select: function(ox, oy, ex, ey) {
        if (ox < 0 || oy < 0) {
            //we don't select negative area
            //also this means there is no origin mouse down for a selection rect
            return;
        }
        this.getSelectionModel().select(ox, oy, ex, ey);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {boolean} Given point is selected.
     * @param {number} x - The horizontal coordinate.
     * @param {number} y - The vertical coordinate.
     */
    isSelected: function(x, y) {
        return this.getSelectionModel().isSelected(x, y);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {boolean} The given column is selected anywhere in the entire table.
     * @param {number} col - The column index.
     */
    isCellSelectedInRow: function(col) {
        var selectionModel = this.getSelectionModel();
        var isSelected = selectionModel.isCellSelectedInRow(col);
        return isSelected;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {boolean} The given row is selected anywhere in the entire table.
     * @param {number} row - The row index.
     */
    isCellSelectedInColumn: function(row) {
        var selectionModel = this.getSelectionModel();
        var isSelected = selectionModel.isCellSelectedInColumn(row);
        return isSelected;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {fin-hypergrid-selection-model} The selection model.
     */
    getSelectionModel: function() {
        return this.selectionModel;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {Behavior} The behavior (model).
     */
    getBehavior: function() {
        return this.behavior;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary Set the Behavior (model) object for this grid control.
     * @desc This can be done dynamically.
     * @param {Behavior} The behavior (model).
     */
    setBehavior: function(newBehavior) {

        this.behavior = newBehavior;
        this.behavior.setGrid(this);

        this.behavior.changed = this.behaviorChanged.bind(this);
        this.behavior.shapeChanged = this.behaviorShapeChanged.bind(this);
        this.behavior.stateChanged = this.behaviorStateChanged.bind(this);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc I've been notified that the behavior has changed.
     */
    behaviorChanged: function() {
        if (this.numColumns !== this.getColumnCount() || this.numRows !== this.getRowCount()) {
            this.numColumns = this.getColumnCount();
            this.numRows = this.getRowCount();
            this.behaviorShapeChanged();
        }
        this.computeCellsBounds();
        this.repaint();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {Rectangle} My bounds.
     */
    getBounds: function() {
        return this.getRenderer().getBounds();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {string} The value of a lnf property.
     * @param {string} key - A look-and-feel key.
     */
    resolveProperty: function(key) {
        return this.getProperties()[key];
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc The dimensions of the grid data have changed. You've been notified.
     */
    behaviorShapeChanged: function() {
        this.synchronizeScrollingBoundries();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc The dimensions of the grid data have changed. You've been notified.
     */
    behaviorStateChanged: function() {
        this.getRenderer().computeCellsBounds();
        this.repaint();
    },

    repaint: function() {
        var now = this.resolveProperty('repaintImmediately');
        var canvas = this.getCanvas();
        if (canvas) {
            if (now === true) {
                canvas.paintNow();
            } else {
                canvas.repaint();
            }
        }
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Paint immediately in this microtask.
     */
    paintNow: function() {
        var canvas = this.getCanvas();
        canvas.paintNow();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {boolean} In HiDPI mode (has an attribute as such).
     */
    useHiDPI: function() {
        return this.resolveProperty('useHiDPI') !== false;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary Initialize drawing surface.
     * @private
     */
    initCanvas: function() {

        var self = this;

        var divCanvas = this.divCanvas = document.createElement('div');
        this.div.appendChild(divCanvas);
        this.canvas = new Canvas(divCanvas, this.renderer);

        var style = divCanvas.style;
        style.position = 'absolute';
        style.top = 0;
        style.right = '-200px';
        //leave room for the vertical scrollbar
        //style.marginRight = '15px';
        style.bottom = 0;
        //leave room for the horizontal scrollbar
        //style.marginBottom = '15px';
        style.left = 0;

        this.canvas.resizeNotification = function() {
            self.resized();
        };

        this.addFinEventListener('fin-canvas-mousemove', function(e) {
            if (self.resolveProperty('readOnly')) {
                return;
            }
            var mouse = e.detail.mouse;
            var mouseEvent = self.getGridCellFromMousePoint(mouse);
            mouseEvent.primitiveEvent = e;
            self.delegateMouseMove(mouseEvent);
        });

        this.addFinEventListener('fin-canvas-mousedown', function(e) {
            if (self.resolveProperty('readOnly')) {
                return;
            }
            //self.stopEditing();
            var mouse = e.detail.mouse;
            var mouseEvent = self.getGridCellFromMousePoint(mouse);
            mouseEvent.keys = e.detail.keys;
            mouseEvent.primitiveEvent = e;
            self.mouseDownState = mouseEvent;
            self.delegateMouseDown(mouseEvent);
            self.fireSyntheticMouseDownEvent(mouseEvent);
            self.repaint();
        });


        // this.addFinEventListener('fin-canvas-click', function(e) {
        //     if (self.resolveProperty('readOnly')) {
        //         return;
        //     }
        //     //self.stopEditing();
        //     var mouse = e.detail.mouse;
        //     var mouseEvent = self.getGridCellFromMousePoint(mouse);
        //     mouseEvent.primitiveEvent = e;
        //     self.fireSyntheticClickEvent(mouseEvent);
        // });

        this.addFinEventListener('fin-canvas-mouseup', function(e) {
            if (self.resolveProperty('readOnly')) {
                return;
            }
            self.dragging = false;
            if (self.isScrollingNow()) {
                self.setScrollingNow(false);
            }
            if (self.columnDragAutoScrolling) {
                self.columnDragAutoScrolling = false;
            }
            //self.stopEditing();
            var mouse = e.detail.mouse;
            var mouseEvent = self.getGridCellFromMousePoint(mouse);
            mouseEvent.primitiveEvent = e;
            self.delegateMouseUp(mouseEvent);
            if (self.mouseDownState) {
                self.fireSyntheticButtonPressedEvent(self.mouseDownState);
            }
            self.mouseDownState = null;
            self.fireSyntheticMouseUpEvent(mouseEvent);
        });

        this.addFinEventListener('fin-canvas-tap', function(e) {
            if (self.resolveProperty('readOnly')) {
                return;
            }
            //self.stopEditing();
            var mouse = e.detail.mouse;
            var tapEvent = self.getGridCellFromMousePoint(mouse);
            tapEvent.primitiveEvent = e;
            tapEvent.keys = e.detail.keys;
            self.fireSyntheticClickEvent(tapEvent);
            self.delegateTap(tapEvent);
        });

        this.addFinEventListener('fin-canvas-drag', function(e) {
            if (self.resolveProperty('readOnly')) {
                return;
            }
            self.dragging = true;
            var mouse = e.detail.mouse;
            var mouseEvent = self.getGridCellFromMousePoint(mouse);
            mouseEvent.primitiveEvent = e;
            self.delegateMouseDrag(mouseEvent);
        });

        this.addFinEventListener('fin-canvas-keydown', function(e) {
            if (self.resolveProperty('readOnly')) {
                return;
            }
            self.fireSyntheticKeydownEvent(e);
            self.delegateKeyDown(e);
        });

        this.addFinEventListener('fin-canvas-keyup', function(e) {
            if (self.resolveProperty('readOnly')) {
                return;
            }
            self.fireSyntheticKeyupEvent(e);
            self.delegateKeyUp(e);
        });

        this.addFinEventListener('fin-canvas-track', function(e) {
            if (self.resolveProperty('readOnly')) {
                return;
            }
            if (self.dragging) {
                return;
            }
            var primEvent = e.detail.primitiveEvent;
            if (Math.abs(primEvent.dy) > Math.abs(primEvent.dx)) {
                if (primEvent.yDirection > 0) {
                    self.scrollVBy(-2);
                } else if (primEvent.yDirection < -0) {
                    self.scrollVBy(2);
                }
            } else {
                if (primEvent.xDirection > 0) {
                    self.scrollHBy(-1);
                } else if (primEvent.xDirection < -0) {
                    self.scrollHBy(1);
                }
            }
        });

        // this.addFinEventListener('fin-canvas-holdpulse', function(e) {
        //     console.log('holdpulse');
        //     if (self.resolveProperty('readOnly')) {
        //         return;
        //     }
        //     var mouse = e.detail.mouse;
        //     var mouseEvent = self.getGridCellFromMousePoint(mouse);
        //     mouseEvent.primitiveEvent = e;
        //     self.delegateHoldPulse(mouseEvent);
        // });

        this.addFinEventListener('fin-canvas-dblclick', function(e) {
            if (self.resolveProperty('readOnly')) {
                return;
            }
            var mouse = e.detail.mouse;
            var mouseEvent = self.getGridCellFromMousePoint(mouse);
            mouseEvent.primitiveEvent = e;
            self.fireSyntheticDoubleClickEvent(mouseEvent, e);
            self.delegateDoubleClick(mouseEvent);
        });

        this.addFinEventListener('fin-canvas-wheelmoved', function(e) {
            var mouse = e.detail.mouse;
            var mouseEvent = self.getGridCellFromMousePoint(mouse);
            mouseEvent.primitiveEvent = e.detail.primitiveEvent;
            self.delegateWheelMoved(mouseEvent);
        });

        this.addFinEventListener('fin-canvas-mouseout', function(e) {
            if (self.resolveProperty('readOnly')) {
                return;
            }
            var mouse = e.detail.mouse;
            var mouseEvent = self.getGridCellFromMousePoint(mouse);
            mouseEvent.primitiveEvent = e.detail.primitiveEvent;
            self.delegateMouseExit(mouseEvent);
        });


        this.addFinEventListener('fin-canvas-context-menu', function(e) {
            var mouse = e.detail.mouse;
            var mouseEvent = self.getGridCellFromMousePoint(mouse);
            mouseEvent.primitiveEvent = e.detail.primitiveEvent;
            self.delegateContextMenu(mouseEvent);
        });

        this.div.removeAttribute('tabindex');

    },

    convertViewPointToDataPoint: function(viewPoint) {
        return this.getBehavior().convertViewPointToDataPoint(viewPoint);
    },

    convertDataPointToViewPoint: function(dataPoint) {
        return this.getBehavior().convertDataPointToViewPoint(dataPoint);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary Add an event listener to me.
     * @param {string} eventName - The type of event we are interested in.
     * @param {function} callback - The event handler.
     */
    addFinEventListener: function(eventName, callback) {
        this.canvas.addEventListener(eventName, callback);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary Set for `scrollingNow` field.
     * @param {boolean} isItNow - The type of event we are interested in.
     */
    setScrollingNow: function(isItNow) {
        this.scrollingNow = isItNow;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {boolean} The `scrollingNow` field.
     */
    isScrollingNow: function() {
        return this.scrollingNow;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {number} The index of the column divider under the mouse coordinates.
     * @param {MouseEvent} mouseEvent - The event to interogate.
     */
    overColumnDivider: function(mouseEvent) {
        var x = mouseEvent.primitiveEvent.detail.mouse.x;
        var whichCol = this.getRenderer().overColumnDivider(x);
        return whichCol;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {number} The index of the row divider under the mouse coordinates.
     * @param {MouseEvent} mouseEvent - The event to interogate.
     */
    overRowDivider: function(mouseEvent) {
        var y = mouseEvent.primitiveEvent.detail.mouse.y;
        var which = this.getRenderer().overRowDivider(y);
        return which;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Switch the cursor for the grid.
     * @param {string} cursorName - A well know cursor name.
     * @see [cursor names](http://www.javascripter.net/faq/stylesc.htm)
     */
    beCursor: function(cursorName) {
        if (!cursorName) {
            cursorName = 'default';
        }
        this.div.style.cursor = cursorName;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Delegate the wheel moved event to the behavior.
     * @param {Event} event - The pertinent event.
     */
    delegateWheelMoved: function(event) {
        var behavior = this.getBehavior();
        behavior.onWheelMoved(this, event);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Delegate MouseExit to the behavior (model).
     * @param {Event} event - The pertinent event.
     */
    delegateMouseExit: function(event) {
        var behavior = this.getBehavior();
        behavior.handleMouseExit(this, event);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Delegate MouseExit to the behavior (model).
     * @param {Event} event - The pertinent event.
     */
    delegateContextMenu: function(event) {
        var behavior = this.getBehavior();
        behavior.onContextMenu(this, event);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Delegate MouseMove to the behavior (model).
     * @param {mouseDetails} mouseDetails - An enriched mouse event from fin-canvas.
     */
    delegateMouseMove: function(mouseDetails) {
        var behavior = this.getBehavior();
        behavior.onMouseMove(this, mouseDetails);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Delegate mousedown to the behavior (model).
     * @param {mouseDetails} mouseDetails - An enriched mouse event from fin-canvas.
     */
    delegateMouseDown: function(mouseDetails) {
        var behavior = this.getBehavior();
        behavior.handleMouseDown(this, mouseDetails);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Delegate mouseup to the behavior (model).
     * @param {mouseDetails} mouseDetails - An enriched mouse event from fin-canvas.
     */
    delegateMouseUp: function(mouseDetails) {
        var behavior = this.getBehavior();
        behavior.onMouseUp(this, mouseDetails);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Delegate tap to the behavior (model).
     * @param {mouseDetails} mouseDetails - An enriched mouse event from fin-canvas.
     */
    delegateTap: function(mouseDetails) {
        var behavior = this.getBehavior();
        behavior.onTap(this, mouseDetails);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Delegate mouseDrag to the behavior (model).
     * @param {mouseDetails} mouseDetails - An enriched mouse event from fin-canvas.
     */
    delegateMouseDrag: function(mouseDetails) {
        var behavior = this.getBehavior();
        behavior.onMouseDrag(this, mouseDetails);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc We've been doubleclicked on. Delegate through the behavior (model).
     * @param {mouseDetails} mouseDetails - An enriched mouse event from fin-canvas.
     */
    delegateDoubleClick: function(mouseDetails) {
        var behavior = this.getBehavior();
        behavior.onDoubleClick(this, mouseDetails);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Delegate holdpulse through the behavior (model).
     * @param {mouseDetails} mouseDetails - An enriched mouse event from fin-canvas.
     */
    delegateHoldPulse: function(mouseDetails) {
        var behavior = this.getBehavior();
        behavior.onHoldPulse(this, mouseDetails);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary Generate a function name and call it on self.
     * @desc This should also be delegated through Behavior keeping the default implementation here though.
     * @param {event} event - The pertinent event.
     */
    delegateKeyDown: function(event) {
        var behavior = this.getBehavior();
        behavior.onKeyDown(this, event);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary Generate a function name and call it on self.
     * @desc This should also be delegated through Behavior keeping the default implementation here though.
     * @param {event} event - The pertinent event.
     */
    delegateKeyUp: function(event) {
        var behavior = this.getBehavior();
        behavior.onKeyUp(this, event);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary Shut down the current cell editor.
     */
    stopEditing: function() {
        if (this.cellEditor) {
            if (this.cellEditor.stopEditing) {
                this.cellEditor.stopEditing();
            }
            this.cellEditor = null;
        }
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary Register a cell editor.
     * @desc This is typically called from within a cell-editor's `installOn` method, when it is being initialized as a plugin.
     * @param {string} alias - The name/id of the cell editor.
     * @param {fin-hypergrid-cell-editor-base} cellEditor - see [fin-hypergrid-cell-editor-base](module-cell-editors_base.html)
     */
    registerCellEditor: function(alias, cellEditor) {
        this.cellEditors[alias] = cellEditor;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {Rectangle} The pixel coordinates of just the center 'main" data area.
     */
    getDataBounds: function() {
        var colDNDHackWidth = 200; //this was a hack to help with column dnd, need to factor this into a shared variable
        //var behavior = this.getBehavior();
        var b = this.canvas.bounds;

        //var x = this.getRowNumbersWidth();
        // var y = behavior.getFixedRowsHeight() + 2;

        var result = new Rectangle(0, 0, b.origin.x + b.extent.x - colDNDHackWidth, b.origin.y + b.extent.y);
        return result;
    },

    getRowNumbersWidth: function() {
        if (this.isShowRowNumbers()) {
            return this.getRenderer().getRowNumbersWidth();
        } else {
            return 0;
        }
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {Canvas} Our fin-canvas instance.
     */
    getCanvas: function() {
        return this.canvas;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary Open the given cell-editor at the provided model coordinates.
     * @param {string} cellEditor - The specific cell editor to use.
     * @param {Point} coordinates - The pixel locaiton of the cell to edit at.
     */
    editAt: function(cellEditor, coordinates) {

        this.cellEditor = cellEditor;

        var cell = coordinates.gridCell;

        var x = cell.x;
        var y = cell.y;

        if (x < 0 || y < 0) {
            return;
        }

        var editPoint = new Point(x, y);
        this.setMouseDown(editPoint);
        this.setDragExtent(new Point(0, 0));

        if (!cellEditor.isAdded) {
            cellEditor.isAdded = true;
            this.div.appendChild(cellEditor.getInput());
        }
        cellEditor.grid = this;
        cellEditor.beginEditAt(editPoint);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {boolean} The given column is fully visible.
     * @param {number} columnIndex - The column index in question.
     */
    isColumnVisible: function(columnIndex) {
        var isVisible = this.getRenderer().isColumnVisible(columnIndex);
        return isVisible;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {boolean} The given row is fully visible.
     * @param {number} rowIndex - The row index in question.
     */
    isDataRowVisible: function(rowIndex) {
        var isVisible = this.getRenderer().isRowVisible(rowIndex);
        return isVisible;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {boolean} The given cell is fully is visible.
     * @param {number} columnIndex - The column index in question.
     * @param {number} rowIndex - The row index in question.
     */
    isDataVisible: function(columnIndex, rowIndex) {
        var isVisible = this.isDataRowVisible(rowIndex) && this.isColumnVisible(columnIndex);
        return isVisible;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary Scroll in the `offsetX` direction if column index `colIndex` is not visible.
     * @param {number} colIndex - The column index in question.
     * @param {number} offsetX - The direction and magnitude to scroll if we need to.
     */
    insureModelColIsVisible: function(colIndex, offsetX) {
        //-1 because we want only fully visible columns, don't include partially
        //visible columns
        var maxCols = this.getColumnCount() - 1;
        var indexToCheck = colIndex;

        if (offsetX > 0) {
            indexToCheck++;
        }

        if (!this.isColumnVisible(indexToCheck) || colIndex === maxCols) {
            //the scroll position is the leftmost column {
            this.scrollBy(offsetX, 0);
            return true;
        }
        return false;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary Scroll in the offsetY direction if column index c is not visible.
     * @param {number} rowIndex - The column index in question.
     * @param {number} offsetX - The direction and magnitude to scroll if we need to.
     */
    insureModelRowIsVisible: function(rowIndex, offsetY) {
        //-1 because we want only fully visible rows, don't include partially
        //viewable rows
        var maxRows = this.getRowCount() - 1;
        var indexToCheck = rowIndex;

        if (offsetY > 0) {
            indexToCheck++;
        }

        if (!this.isDataRowVisible(indexToCheck) || rowIndex === maxRows) {
            //the scroll position is the topmost row
            this.scrollBy(0, offsetY);
            return true;
        }
        return false;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary Scroll horizontal and vertically by the provided offsets.
     * @param {number} offsetX - Scroll in the x direction this much.
     * @param {number} offsetY - Scroll in the y direction this much.
     */
    scrollBy: function(offsetX, offsetY) {
        this.scrollHBy(offsetX);
        this.scrollVBy(offsetY);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary Scroll vertically by the provided offset.
     * @param {number} offsetY - Scroll in the y direction this much.
     */
    scrollVBy: function(offsetY) {
        var max = this.sbVScroller.range.max;
        var oldValue = this.getVScrollValue();
        var newValue = Math.min(max, Math.max(0, oldValue + offsetY));
        if (newValue === oldValue) {
            return;
        }
        this.setVScrollValue(newValue);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary Scroll horizontally by the provided offset.
     * @param {number} offsetX - Scroll in the x direction this much.
     */
    scrollHBy: function(offsetX) {
        var max = this.sbHScroller.range.max;
        var oldValue = this.getHScrollValue();
        var newValue = Math.min(max, Math.max(0, oldValue + offsetX));
        if (newValue === oldValue) {
            return;
        }
        this.setHScrollValue(newValue);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary Answer which data cell is under a pixel value mouse point.
     * @param {mousePoint} mouse - The mouse point to interrogate.
     */

    getGridCellFromMousePoint: function(mouse) {
        var cell = this.getRenderer().getGridCellFromMousePoint(mouse);
        return cell;
    },

    /**
     * @returns {Rectangle} The pixel based bounds rectangle given a data cell point.
     * @param {Point} cell - The pixel location of the mouse.
     * @memberOf Hypergrid.prototype
     */
    getBoundsOfCell: function(cell) {
        var b = this.getRenderer().getBoundsOfCell(cell);

        //we need to convert this to a proper rectangle
        var newBounds = new Rectangle(b.x, b.y, b.width, b.height);
        return newBounds;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc This is called by the fin-canvas when a resize occurs.
     */
    resized: function() {
        this.synchronizeScrollingBoundries();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary A click event occured.
     * @desc Determine the cell and delegate to the behavior (model).
     * @param {MouseEvent} event - The mouse event to interrogate.
     */
    cellClicked: function(event) {
        var cell = event.gridCell;
        var colCount = this.getColumnCount();
        var rowCount = this.getRowCount();

        //click occured in background area
        if (cell.x > colCount || cell.y > rowCount) {
            return;
        }

        //var behavior = this.getBehavior();
        var hovered = this.getHoverCell();
        var sy = this.getVScrollValue();
        var x = hovered.x;
        // if (hovered.x > -1) {
        //     x = behavior.translateColumnIndex(hovered.x + this.getHScrollValue());
        // }
        if (hovered.y < 0) {
            sy = 0;
        }
        hovered = new Point(x, hovered.y + sy);
        this.getBehavior().cellClicked(hovered, event);
    },

    setTotalsValueNotification: function(x, y, value) {
        this.fireSyntheticSetTotalsValue(x, y, value);
    },

    fireSyntheticSetTotalsValue: function(x, y, value) {
        var clickEvent = new CustomEvent('fin-set-totals-value', {
            detail: {
                x: x,
                y: y,
                value: value
            }
        });
        this.canvas.dispatchEvent(clickEvent);
    },

    fireSyntheticEditorKeyUpEvent: function(inputControl, keyEvent) {
        var clickEvent = new CustomEvent('fin-editor-key-up', {
            detail: {
                input: inputControl,
                keyEvent: keyEvent
            },

        });
        this.canvas.dispatchEvent(clickEvent);
    },

    fireSyntheticEditorKeyDownEvent: function(inputControl, keyEvent) {
        var clickEvent = new CustomEvent('fin-editor-key-down', {
            detail: {
                input: inputControl,
                keyEvent: keyEvent
            },

        });
        this.canvas.dispatchEvent(clickEvent);
    },

    fireSyntheticEditorKeyPressEvent: function(inputControl, keyEvent) {
        var clickEvent = new CustomEvent('fin-editor-key-press', {
            detail: {
                input: inputControl,
                keyEvent: keyEvent
            },

        });
        this.canvas.dispatchEvent(clickEvent);
    },

    fireSyntheticEditorDataChangeEvent: function(inputControl, oldValue, newValue) {
        var clickEvent = new CustomEvent('fin-editor-data-change', {
            detail: {
                input: inputControl,
                oldValue: oldValue,
                newValue: newValue
            },
            cancelable: true
        });
        return this.canvas.dispatchEvent(clickEvent);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Synthesize and fire a `fin-row-selection-changed` event.
     */
    fireSyntheticRowSelectionChangedEvent: function() {
        var selectionEvent = new CustomEvent('fin-row-selection-changed', {
            detail: {
                rows: this.getSelectedRows(),
                columns: this.getSelectedColumns(),
                selections: this.getSelectionModel().getSelections(),
            }
        });
        this.canvas.dispatchEvent(selectionEvent);
    },

    fireSyntheticColumnSelectionChangedEvent: function() {
        var selectionEvent = new CustomEvent('fin-column-selection-changed', {
            detail: {
                rows: this.getSelectedRows(),
                columns: this.getSelectedColumns(),
                selections: this.getSelectionModel().getSelections()
            }
        });
        this.canvas.dispatchEvent(selectionEvent);
    },
    /**
     * @memberOf Hypergrid.prototype
     * @desc Synthesize and dispatch a `fin-selection-changed` event.
     */
    selectionChanged: function() {
        var selectedRows = this.getSelectedRows();
        var selectionEvent = new CustomEvent('fin-selection-changed', {
            detail: {
                rows: selectedRows,
                columns: this.getSelectedColumns(),
                selections: this.getSelectionModel().getSelections(),
            }
        });
        this.canvas.dispatchEvent(selectionEvent);
    },


    getRowSelection: function() {
        var c, column, self = this,
            selectedRowIndexes = this.getSelectionModel().getSelectedRows(),
            numCols = this.getColumnCount(),
            result = {};

        function setValue(selectedRowIndex, r) {
            column[r] = valueOrFunctionExecute(self.getValue(c, selectedRowIndex));
        }

        for (c = 0; c < numCols; c++) {
            column = new Array(selectedRowIndexes.length);
            result[this.getField(c)] = column;
            selectedRowIndexes.forEach(setValue);
        }

        return result;
    },

    getRowSelectionMatrix: function() {
        var c, self = this,
            selectedRowIndexes = this.getSelectionModel().getSelectedRows(),
            numCols = this.getColumnCount(),
            result = new Array(numCols);

        function getValue(selectedRowIndex, r) {
            result[c][r] = valueOrFunctionExecute(self.getValue(c, selectedRowIndex));
        }

        for (c = 0; c < numCols; c++) {
            result[c] = new Array(selectedRowIndexes.length);
            selectedRowIndexes.forEach(getValue);
        }

        return result;
    },

    getColumnSelectionMatrix: function() {
        var selectedColumnIndexes = this.getSelectedColumns();
        var numRows = this.getRowCount();
        var result = new Array(selectedColumnIndexes.length);
        var self = this;
        selectedColumnIndexes.forEach(function(selectedColumnIndex, c) {
            result[c] = new Array(numRows);
            for (var r = 0; r < numRows; r++) {
                result[c][r] = valueOrFunctionExecute(self.getValue(selectedColumnIndex, r));
            }
        });
        return result;
    },

    getColumnSelection: function() {
        var selectedColumnIndexes = this.getSelectedColumns();
        var result = {};
        var rowCount = this.getRowCount();
        var self = this;
        selectedColumnIndexes.forEach(function(selectedColumnIndex) {
            var column = new Array(rowCount);
            result[self.getField(selectedColumnIndex)] = column;
            for (var r = 0; r < rowCount; r++) {
                column[r] = valueOrFunctionExecute(self.getValue(selectedColumnIndex, r));
            }
        });
        return result;
    },

    getSelection: function() {
        var self = this;
        var selections = this.getSelections();
        var result = new Array(selections.length);
        selections.forEach(function(selectionRect, i) {
            result[i] = self._getSelection(selectionRect);
        });
        return result;
    },

    _getSelection: function(rect) {
        rect = normalizeRect(rect);
        var colCount = rect.extent.x + 1;
        var rowCount = rect.extent.y + 1;
        var ox = rect.origin.x;
        var oy = rect.origin.y;
        var result = {};
        var r;
        for (var c = 0; c < colCount; c++) {
            var column = new Array(rowCount);
            result[this.getField(c + ox)] = column;
            for (r = 0; r < rowCount; r++) {
                column[r] = valueOrFunctionExecute(this.getValue(ox + c, oy + r));
            }
        }
        return result;
    },

    getSelectionMatrix: function() {
        var self = this;
        var selections = this.getSelections();
        var result = new Array(selections.length);
        selections.forEach(function(selectionRect, i) {
            result[i] = self._getSelectionMatrix(selectionRect);
        });
        return result;
    },

    _getSelectionMatrix: function(rect) {
        rect = normalizeRect(rect);
        var colCount = rect.extent.x + 1;
        var rowCount = rect.extent.y + 1;
        var ox = rect.origin.x;
        var oy = rect.origin.y;
        var result = [];
        for (var c = 0; c < colCount; c++) {
            var column = new Array(rowCount);
            result[c] = column;
            for (var r = 0; r < rowCount; r++) {
                column[r] = valueOrFunctionExecute(this.getValue(ox + c, oy + r));
            }
        }
        return result;
    },
    /**
     * @memberOf Hypergrid.prototype
     * @desc Synthesize and fire a `fin-context-menu` event
     * @param {keyEvent} event - The canvas event.
     */
    fireSyntheticContextMenuEvent: function(e) {
        e.gridCell = this.convertViewPointToDataPoint(e.gridCell);
        var event = new CustomEvent('fin-context-menu', {
            detail: {
                gridCell: e.gridCell,
                mousePoint: e.mousePoint,
                viewPoint: e.viewPoint,
                primitiveEvent: e.primitiveEvent,
                rows: this.getSelectedRows(),
                columns: this.getSelectedColumns(),
                selections: this.getSelectionModel().getSelections()
            }
        });
        this.canvas.dispatchEvent(event);
    },

    fireSyntheticMouseUpEvent: function(e) {
        var event = new CustomEvent('fin-mouseup', {
            detail: {
                gridCell: e.gridCell,
                mousePoint: e.mousePoint,
                viewPoint: e.viewPoint,
                primitiveEvent: e.primitiveEvent,
                rows: this.getSelectedRows(),
                columns: this.getSelectedColumns(),
                selections: this.getSelectionModel().getSelections()
            }
        });
        this.canvas.dispatchEvent(event);
    },

    fireSyntheticMouseDownEvent: function(e) {
        var event = new CustomEvent('fin-mousedown', {
            detail: {
                gridCell: e.gridCell,
                mousePoint: e.mousePoint,
                viewPoint: e.viewPoint,
                primitiveEvent: e.primitiveEvent,
                rows: this.getSelectedRows(),
                columns: this.getSelectedColumns(),
                selections: this.getSelectionModel().getSelections()
            }
        });
        this.canvas.dispatchEvent(event);
    },

    isViewableButton: function(c, r) {
        return this.getRenderer().isViewableButton(c, r);
    },

    fireSyntheticButtonPressedEvent: function(evt) {
        var dataCell = evt.dataCell;
        var gridCell = evt.gridCell;
        if (!this.isViewableButton(dataCell.x, dataCell.y)) {
            return;
        }
        var event = new CustomEvent('fin-button-pressed', {
            detail: {
                gridCell: gridCell
            }
        });
        this.canvas.dispatchEvent(event);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Synthesize and fire a `fin-keydown` event.
     * @param {keyEvent} event - The canvas event.
     */
    fireSyntheticKeydownEvent: function(keyEvent) {
        var clickEvent = new CustomEvent('fin-keydown', {
            detail: keyEvent.detail
        });
        this.canvas.dispatchEvent(clickEvent);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Synthesize and fire a `fin-keyup` event.
     * @param {keyEvent} event - The canvas event.
     */
    fireSyntheticKeyupEvent: function(keyEvent) {
        var clickEvent = new CustomEvent('fin-keyup', {
            detail: keyEvent.detail
        });
        this.canvas.dispatchEvent(clickEvent);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Synthesize and fire a `fin-cell-enter` event
     * @param {Point} cell - The pixel location of the cell in which the click event occurred.
     * @param {MouseEvent} event - The system mouse event.
     */
    fireSyntheticOnCellEnterEvent: function(cell) {
        var detail = {
            gridCell: cell,
            time: Date.now(),
            grid: this
        };
        var clickEvent = new CustomEvent('fin-cell-enter', {
            detail: detail
        });
        this.canvas.dispatchEvent(clickEvent);
    },

    fireSyntheticGroupsChangedEvent: function(groups) {
        var detail = {
            groups: groups,
            time: Date.now(),
            grid: this
        };
        var clickEvent = new CustomEvent('fin-groups-changed', {
            detail: detail
        });
        this.canvas.dispatchEvent(clickEvent);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Synthesize and fire a `fin-cell-exit` event.
     * @param {Point} cell - The pixel location of the cell in which the click event occured.
     * @param {MouseEvent} event - The system mouse event.
     */
    fireSyntheticOnCellExitEvent: function(cell) {
        var detail = {
            gridCell: cell,
            time: Date.now(),
            grid: this
        };
        var clickEvent = new CustomEvent('fin-cell-exit', {
            detail: detail
        });
        this.canvas.dispatchEvent(clickEvent);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Synthesize and fire a `fin-cell-click` event.
     * @param {Point} cell - The pixel location of the cell in which the click event occured.
     * @param {MouseEvent} event - The system mouse event.
     */
    fireSyntheticClickEvent: function(mouseEvent) {
        var cell = mouseEvent.gridCell;
        var detail = {
            gridCell: cell,
            mousePoint: mouseEvent.mousePoint,
            keys: mouseEvent.keys,
            primitiveEvent: mouseEvent,
            time: Date.now(),
            grid: this
        };
        this.getBehavior().enhanceDoubleClickEvent(detail);
        var clickEvent = new CustomEvent('fin-click', {
            detail: detail
        });
        this.canvas.dispatchEvent(clickEvent);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Synthesize and fire a `fin-double-click` event.
     * @param {Point} cell - The pixel location of the cell in which the click event occured.
     * @param {MouseEvent} event - The system mouse event.
     */
    fireSyntheticDoubleClickEvent: function(mouseEvent) {
        var cell = mouseEvent.gridCell;
        var behavior = this.getBehavior();
        var detail = {
            gridCell: cell,
            mousePoint: mouseEvent.mousePoint,
            time: Date.now(),
            grid: this
        };
        behavior.enhanceDoubleClickEvent(mouseEvent);
        var clickEvent = new CustomEvent('fin-double-click', {
            detail: detail
        });
        behavior.cellDoubleClicked(cell, mouseEvent);
        this.canvas.dispatchEvent(clickEvent);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Synthesize and fire a rendered event.
     */
    fireSyntheticGridRenderedEvent: function() {
        var event = new CustomEvent('fin-grid-rendered', {
            detail: {
                source: this,
                time: Date.now()
            }
        });
        if (this.canvas) {
            this.canvas.dispatchEvent(event);
        }
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Synthesize and fire a scroll event.
     * @param {string} type - Should be either `fin-scroll-x` or `fin-scroll-y`.
     * @param {number} oldValue - The old scroll value.
     * @param {number} newValue - The new scroll value.
     */
    fireScrollEvent: function(type, oldValue, newValue) {
        var event = new CustomEvent(type, {
            detail: {
                oldValue: oldValue,
                value: newValue,
                time: Date.now()
            }
        });
        this.canvas.dispatchEvent(event);

    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Set the vertical scroll value.
     * @param {number} newValue - The new scroll value.
     */
    setVScrollValue: function(y) {
        y = Math.round(y);
        var max = this.sbVScroller.range.max;
        y = Math.min(max, Math.max(0, y));
        var self = this;
        if (y === this.vScrollValue) {
            return;
        }
        this.getBehavior()._setScrollPositionY(y);
        var oldY = this.vScrollValue;
        this.vScrollValue = y;
        this.scrollValueChangedNotification();
        setTimeout(function() {
            // self.sbVRangeAdapter.subjectChanged();
            self.fireScrollEvent('fin-scroll-y', oldY, y);
        });
    },

    /**
     * @memberOf Hypergrid.prototype
     * @return {number} The vertical scroll value.
     */
    getVScrollValue: function() {
        return this.vScrollValue;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Set the horizontal scroll value.
     * @param {number} newValue - The new scroll value.
     */
    setHScrollValue: function(x) {
        x = Math.round(x);
        var max = this.sbHScroller.range.max;
        x = Math.min(max, Math.max(0, x));
        var self = this;
        if (x === this.hScrollValue) {
            return;
        }
        this.getBehavior()._setScrollPositionX(x);
        var oldX = this.hScrollValue;
        this.hScrollValue = x;
        this.scrollValueChangedNotification();
        setTimeout(function() {
            //self.sbHRangeAdapter.subjectChanged();
            self.fireScrollEvent('fin-scroll-x', oldX, x);
        });
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns The vertical scroll value.
     */
    getHScrollValue: function() {
        return this.hScrollValue;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Request input focus.
     */
    takeFocus: function() {
        if (this.isEditing()) {
            this.stopEditing();
        } else {
            this.getCanvas().takeFocus();
        }
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Request focus for our cell editor.
     */
    editorTakeFocus: function() {
        if (this.cellEditor) {
            return this.cellEditor.takeFocus();
        }
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {boolean} We have a currently active cell editor.
     */
    isEditing: function() {
        if (this.cellEditor) {
            return this.cellEditor.isEditing;
        }
        return false;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Initialize the scroll bars.
     */
    initScrollbars: function() {

        var self = this;

        var horzBar = new FinBar({
            orientation: 'horizontal',
            onchange: self.setHScrollValue.bind(self),
            cssStylesheetReferenceElement: this.div
        });

        var vertBar = new FinBar({
            orientation: 'vertical',
            onchange: self.setVScrollValue.bind(self),
            paging: {
                up: self.pageUp.bind(self),
                down: self.pageDown.bind(self)
            }
        });

        this.sbHScroller = horzBar;
        this.sbVScroller = vertBar;

        var hPrefix = this.resolveProperty('hScrollbarClassPrefix');
        var vPrefix = this.resolveProperty('vScrollbarClassPrefix');

        if (hPrefix && hPrefix !== '') {
            this.sbHScroller.classPrefix = hPrefix;
        }

        if (vPrefix && vPrefix !== '') {
            this.sbVScroller.classPrefix = vPrefix;
        }

        this.div.appendChild(horzBar.bar);
        this.div.appendChild(vertBar.bar);

        this.resizeScrollbars();

    },

    resizeScrollbars: function() {
        this.sbHScroller.shortenBy(this.sbVScroller).resize();
        //this.sbVScroller.shortenBy(this.sbHScroller);
        this.sbVScroller.resize();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Scroll values have changed, we've been notified.
     */
    setVScrollbarValues: function(max) {
        this.sbVScroller.range = {
            min: 0,
            max: max
        };
    },

    setHScrollbarValues: function(max) {
        this.sbHScroller.range = {
            min: 0,
            max: max
        };
    },

    scrollValueChangedNotification: function() {

        if (this.hScrollValue === this.sbPrevHScrollValue && this.vScrollValue === this.sbPrevVScrollValue) {
            return;
        }

        this.sbPrevHScrollValue = this.hScrollValue;
        this.sbPrevVScrollValue = this.vScrollValue;

        if (this.cellEditor) {
            this.cellEditor.scrollValueChangedNotification();
        }

        this.computeCellsBounds();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary Get data value at given cell.
     * @desc Delegates to the behavior.
     * @param {number} x - The horizontal coordinate.
     * @param {number} y - The vertical coordinate.
     * @param {*} value
     */
    getValue: function(x, y) {
        return this.getBehavior().getValue(x, y);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Set a data value into the behavior (model) at the given point
     * @param {number} x - The horizontal coordinate.
     * @param {number} y - The vertical coordinate.
     */
    setValue: function(x, y, value) {
        this.getBehavior().setValue(x, y, value);
    },

    getColumnAlignment: function(c) {
        return this.getBehavior().getColumnAlignment(c);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc The data dimensions have changed, or our pixel boundries have changed.
     * Adjust the scrollbar properties as necessary.
     */
    synchronizeScrollingBoundries: function() {
        //327/664
        var behavior = this.getBehavior();

        var numFixedColumns = this.getFixedColumnCount();
        var numFixedRows = this.getFixedRowCount();

        var numColumns = this.getColumnCount();
        var numRows = this.getRowCount();

        var bounds = this.getBounds();
        if (!bounds) {
            return;
        }
        var scrollableHeight = bounds.height - behavior.getFixedRowsMaxHeight() - 15; //5px padding at bottom and right side
        var scrollableWidth = (bounds.width - 200) - behavior.getFixedColumnsMaxWidth() - 15;

        var lastPageColumnCount = 0;
        var columnsWidth = 0;
        for (; lastPageColumnCount < numColumns; lastPageColumnCount++) {
            var eachWidth = this.getColumnWidth(numColumns - lastPageColumnCount - 1);
            columnsWidth = columnsWidth + eachWidth;
            if (columnsWidth > scrollableWidth) {
                break;
            }
        }

        var lastPageRowCount = 0;
        var rowsHeight = 0;
        for (; lastPageRowCount < numRows; lastPageRowCount++) {
            var eachHeight = this.getRowHeight(numRows - lastPageRowCount - 1);
            rowsHeight = rowsHeight + eachHeight;
            if (rowsHeight > scrollableHeight) {
                break;
            }
        }

        var hMax = 1 + Math.max(0, numColumns - numFixedColumns - lastPageColumnCount);
        this.setHScrollbarValues(hMax);

        var vMax = Math.max(0, numRows - numFixedRows - lastPageRowCount);
        this.setVScrollbarValues(vMax);

        this.setHScrollValue(Math.min(this.getHScrollValue(), hMax));
        this.setVScrollValue(Math.min(this.getVScrollValue(), vMax));

        //this.getCanvas().resize();
        this.computeCellsBounds();
        this.repaint();

        this.resizeScrollbars();

    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Note that "viewable rows" includes any partially viewable rows.
     * @returns {number} The number of viewable rows.
     */
    getVisibleRows: function() {
        return this.getRenderer().getVisibleRows();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Note that "viewable columns" includes any partially viewable columns.
     * @returns {number} The number of viewable columns.
     */
    getVisibleColumns: function() {
        return this.getRenderer().getVisibleColumns();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary Initialize the renderer sub-component.
     */
    initRenderer: function() {
        this.renderer = new Renderer(this);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {Renderer} sub-component
     */
    getRenderer: function() {
        return this.renderer;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {number} The width of the given column.
     * @param {number} columnIndex - The untranslated column index.
     */
    getColumnWidth: function(columnIndex) {
        return this.getBehavior().getColumnWidth(columnIndex);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Set the width of the given column.
     * @param {number} columnIndex - The untranslated column index.
     * @param {number} columnWidth - The width in pixels.
     */
    setColumnWidth: function(columnIndex, columnWidth) {
        this.getBehavior().setColumnWidth(columnIndex, columnWidth);
    },

    getColumnEdge: function(c) {
        return this.getBehavior().getColumnEdge(c, this.getRenderer());
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {number} The total width of all the fixed columns.
     */
    getFixedColumnsWidth: function() {
        return this.getBehavior().getFixedColumnsWidth();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {number} The height of the given row
     * @param {number} rowIndex - The untranslated fixed column index.
     */
    getRowHeight: function(rowIndex) {
        return this.getBehavior().getRowHeight(rowIndex);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Set the height of the given row.
     * @param {number} rowIndex - The row index.
     * @param {number} rowHeight - The width in pixels.
     */
    setRowHeight: function(rowIndex, rowHeight) {
        this.getBehavior().setRowHeight(rowIndex, rowHeight);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {number} The total fixed rows height
     */
    getFixedRowsHeight: function() {
        return this.getBehavior().getFixedRowsHeight();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {number} The number of columns.
     */
    getColumnCount: function() {
        return this.getBehavior().getColumnCount();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {number} The number of fixed rows.
     */
    getRowCount: function() {
        return this.getBehavior().getRowCount();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {number} The number of fixed columns.
     */
    getFixedColumnCount: function() {
        return this.getBehavior().getFixedColumnCount();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns The number of fixed rows.
     */
    getFixedRowCount: function() {
        return this.getBehavior().getFixedRowCount();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary The top left area has been clicked on
     * @desc Delegates to the behavior.
     * @param {event} event - The event details.
     */
    topLeftClicked: function(mouse) {
        this.getBehavior().topLeftClicked(this, mouse);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary A fixed row has been clicked.
     * @desc Delegates to the behavior.
     * @param {event} event - The event details.
     */
    rowHeaderClicked: function(mouse) {
        this.getBehavior().rowHeaderClicked(this, mouse);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary A fixed column has been clicked.
     * @desc Delegates to the behavior.
     * @param {event} event - The event details.
     */
    columnHeaderClicked: function(mouse) {
        this.getBehavior().columnHeaderClicked(this, mouse);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc An edit event has occurred. Activate the editor.
     * @param {event} event - The event details.
     */
    _activateEditor: function(event) {
        var gridCell = event.gridCell;
        this.activateEditor(gridCell.x, gridCell.y);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Activate the editor at the given coordinates.
     * @param {x} x - The horizontal coordinate.
     * @param {y} y - The vertical coordinate.
     */
    activateEditor: function(x, y) {
        if (!this.isEditable() && !this.isFilterRow(y)) {
            return;
        }
        var editor = this.getCellEditorAt(x, y);
        if (!editor) {
            return;
        }
        var point = editor.editorPoint;
        if (editor) {
            if (point.x === x && point.y === y && editor.isEditing) {
                return; //we're already open at this location
            } else if (this.isEditing()) {
                this.stopEditing(); //other editor is open, close it first
            }
            event.gridCell = {
                x: x,
                y: y
            };
            this.editAt(editor, event);
        }
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary Get the cell editor.
     * @desc Delegates to the behavior.
     * @returns The cell editor at the given coordinates.
     * @param {x} x - The horizontal coordinate.
     * @param {y} y - The vertical coordinate.
     */
    getCellEditorAt: function(x, y) {
        return this.getBehavior().getCellEditorAt(x, y);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @summary Toggle HiDPI support.
     * @desc HiDPI support is now *on* by default.
     * > There used to be a bug in Chrome that caused severe slow down on bit blit of large images, so this HiDPI needed to be optional.
     */
    toggleHiDPI: function() {
        if (this.useHiDPI()) {
            this.removeAttribute('hidpi');
        } else {
            this.setAttribute('hidpi', null);
        }
        this.canvas.resize();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {number} Te HiDPI ratio.
     */
    getHiDPI: function(ctx) {
        if (window.devicePixelRatio && this.useHiDPI()) {
            var devicePixelRatio = window.devicePixelRatio || 1;
            var backingStoreRatio = ctx.webkitBackingStorePixelRatio ||
                ctx.mozBackingStorePixelRatio ||
                ctx.msBackingStorePixelRatio ||
                ctx.oBackingStorePixelRatio ||
                ctx.backingStorePixelRatio || 1;

            var ratio = devicePixelRatio / backingStoreRatio;
            return ratio;
        } else {
            return 1;
        }
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {number} The width of the given (recently rendered) column.
     * @param {number} colIndex - The column index.
     */
    getRenderedWidth: function(colIndex) {
        return this.renderer.getRenderedWidth(colIndex);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {number} The height of the given (recently rendered) row.
     * @param {number} rowIndex - Tthe row index.
     */
    getRenderedHeight: function(rowIndex) {
        return this.renderer.getRenderedHeight(rowIndex);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {CellEditor} The cell editor at alias "name" (a sub-component).
     * @param {string} name
     */
    resolveCellEditor: function(name) {
        return this.cellEditors[name];
    },

    /**
     * @memberOf Hypergrid.prototype
    update the cursor under the hover cell
     */
    updateCursor: function() {
        var translate = this.getBehavior();
        var cursor = translate.getCursorAt(-1, -1);
        var hoverCell = this.getHoverCell();
        if (hoverCell && hoverCell.x > -1 && hoverCell.y > -1) {
            var x = hoverCell.x + this.getHScrollValue();
            cursor = translate.getCursorAt(x, hoverCell.y + this.getVScrollValue());
        }
        this.beCursor(cursor);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Repaint the given cell.
     * @param {x} x - The horizontal coordinate.
     * @param {y} y - The vertical coordinate.
     */
    repaintCell: function(x, y) {
        this.getRenderer().repaintCell(x, y);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {boolean} The user is currently dragging a column to reorder it.
     */
    isDraggingColumn: function() {
        return !!this.renderOverridesCache.dragger;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Scroll up one full page.
     * @returns {number}
     */
    pageUp: function() {
        var rowNum = this.getRenderer().getPageUpRow();
        this.setVScrollValue(rowNum);
        return rowNum;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Scroll down one full page.
     * @returns {number}
     */
    pageDown: function() {
        var rowNum = this.getRenderer().getPageDownRow();
        this.setVScrollValue(rowNum);
        return rowNum;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Not yet implemented.
     */
    pageLeft: function() {
        console.log('page left');
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Not yet implemented.
     */
    pageRight: function() {
        console.log('page right');
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {object[]} Objects with the values that were just rendered.
     */
    getRenderedData: function() {
        // assumes one row of headers
        var behavior = this.getBehavior(),
            renderer = this.getRenderer(),
            colCount = this.getColumnCount(),
            rowCount = renderer.getVisibleRows(),
            headers = new Array(colCount),
            results = new Array(rowCount),
            row;

        headers.forEach(function(header, c) {
            headers[c] = behavior.getColumnId(c, 0);
        });

        results.forEach(function(result, r) {
            row = results[r] = {
                hierarchy: behavior.getFixedColumnValue(0, r)
            };
            headers.forEach(function(field, c) {
                row[field] = behavior.getValue(c, r);
            });
        });

        return results;
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {object} An object that represents the currently selection row.
     */
    getSelectedRow: function() {
        var sels = this.getSelectionModel().getSelections();
        if (sels.length) {
            var behavior = this.getBehavior(),
                colCount = this.getColumnCount(),
                topRow = sels[0].origin.y,
                row = {
                    //hierarchy: behavior.getFixedColumnValue(0, topRow)
                };

            for (var c = 0; c < colCount; c++) {
                row[behavior.getColumnId(c, 0)] = behavior.getValue(c, topRow);
            }

            return row;
        }
    },

    fireRequestCellEdit: function(cell, value) {
        var clickEvent = new CustomEvent('fin-request-cell-edit', {
            cancelable: true,
            detail: {
                value: value,
                gridCell: cell,
                time: Date.now()
            }
        });
        return this.canvas.dispatchEvent(clickEvent); //I wasn't cancelled
    },
    /**
     * @memberOf Hypergrid.prototype
     * @desc Synthesize and fire a fin-before-cell-edit event.
     * @param {Point} cell - The x,y coordinates.
     * @param {Object} value - The current value.
     */
    fireBeforeCellEdit: function(cell, oldValue, newValue, control) {
        var clickEvent = new CustomEvent('fin-before-cell-edit', {
            cancelable: true,
            detail: {
                oldValue: oldValue,
                newValue: newValue,
                gridCell: cell,
                time: Date.now(),
                input: control
            }
        });
        var proceed = this.canvas.dispatchEvent(clickEvent);
        return proceed; //I wasn't cancelled
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {Renderer} sub-component
     * @param {Point} cell - The x,y coordinates.
     * @param {Object} oldValue - The old value.
     * @param {Object} newValue - The new value.
     */
    fireAfterCellEdit: function(cell, oldValue, newValue, control) {
        var clickEvent = new CustomEvent('fin-after-cell-edit', {
            detail: {
                newValue: newValue,
                oldValue: oldValue,
                gridCell: cell,
                time: Date.now(),
                input: control
            }
        });
        this.canvas.dispatchEvent(clickEvent);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Autosize the column at colIndex for best fit.
     * @param {number} colIndex - The column index to modify at
     */
    autosizeColumn: function(colIndex) {
        var column = this.getBehavior().getColumn(colIndex);
        column.checkColumnAutosizing(true);
        this.computeCellsBounds();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Enable/disable if this component can receive the focus.
     * @param {boolean} - canReceiveFocus
     */
    setFocusable: function(canReceiveFocus) {
        this.getCanvas().setFocusable(canReceiveFocus);
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {number} The number of columns that were just rendered
     */
    getVisibleColumnsCount: function() {
        return this.getRenderer().getVisibleColumnsCount();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @returns {number} The number of rows that were just rendered
     */
    getVisibleRowsCount: function() {
        return this.getRenderer().getVisibleRowsCount();
    },

    /**
     * @memberOf Hypergrid.prototype
    update the size of the grid
     *
     * #### returns: integer
     */
    updateSize: function() {
        this.canvas.checksize();
    },


    /**
     * @memberOf Hypergrid.prototype
     * @desc Stop the global repainting flag thread.
     */
    stopPaintThread: function() {
        this.canvas.stopPaintThread();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Stop the global resize check flag thread.
     */
    stopResizeThread: function() {
        this.canvas.stopResizeThread();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Restart the global resize check flag thread.
     */
    restartResizeThread: function() {
        this.canvas.restartResizeThread();
    },

    /**
     * @memberOf Hypergrid.prototype
     * @desc Restart the global repainting check flag thread.
     */
    restartPaintThread: function() {
        this.canvas.restartPaintThread();
    },

    swapColumns: function(source, target) {
        this.getBehavior().swapColumns(source, target);
    },

    endDragColumnNotification: function() {
        this.getBehavior().endDragColumnNotification();
    },

    getFixedColumnsMaxWidth: function() {
        return this.getBehavior().getFixedColumnsMaxWidth();
    },

    isMouseDownInHeaderArea: function() {
        var numHeaderColumns = this.getHeaderColumnCount();
        var numHeaderRows = this.getHeaderRowCount();
        var mouseDown = this.getMouseDown();
        return mouseDown.x < numHeaderColumns || mouseDown.y < numHeaderRows;
    },

    isHeaderWrapping: function() {
        return this.resolveProperty('headerTextWrapping');
    },

    _getBoundsOfCell: function(x, y) {
        var bounds = this.getRenderer()._getBoundsOfCell(x, y);
        return bounds;
    },

    getColumnProperties: function(columnIndex) {
        var properties = this.getBehavior().getColumnProperties(columnIndex);
        return properties;
    },

    setColumnProperties: function(columnIndex, properties) {
        this.getBehavior().setColumnProperties(columnIndex, properties);
    },

    moveSingleSelect: function(x, y) {
        this.getBehavior().moveSingleSelect(this, x, y);
    },

    selectCell: function(x, y) {
        this.getSelectionModel().clear();
        this.getSelectionModel().select(x, y, 0, 0);
    },

    getHeaderColumnCount: function() {
        return this.getBehavior().getHeaderColumnCount();
    },

    toggleSort: function(x, keys) {
        this.stopEditing();
        var behavior = this.getBehavior();
        var self = this;
        behavior.toggleSort(x, keys);

        setTimeout(function() {
            self.synchronizeScrollingBoundries();
            //self.behaviorChanged();
            if (self.isColumnAutosizing()) {
                behavior.autosizeAllColumns();
            }
            self.repaint();
        }, 10);
    },

    toggleSelectColumn: function(x, keys) {
        keys = keys || [];
        var model = this.getSelectionModel();
        var alreadySelected = model.isColumnSelected(x);
        var hasCTRL = keys.indexOf('CTRL') > -1;
        var hasSHIFT = keys.indexOf('SHIFT') > -1;
        if (!hasCTRL && !hasSHIFT) {
            model.clear();
            if (!alreadySelected) {
                model.selectColumn(x);
            }
        } else {
            if (hasCTRL) {
                if (alreadySelected) {
                    model.deselectColumn(x);
                } else {
                    model.selectColumn(x);
                }
            }
            if (hasSHIFT) {
                model.clear();
                model.selectColumn(this.lastEdgeSelection[0], x);
            }
        }
        if (!alreadySelected && !hasSHIFT) {
            this.lastEdgeSelection[0] = x;
        }
        this.repaint();
        this.fireSyntheticColumnSelectionChangedEvent();
    },

    toggleSelectRow: function(y, keys) {

        //we can select the totals rows if they exist,
        //but not rows above that
        var selectionEdge = this.getFilterRowIndex() + 1;
        if (y < selectionEdge) {
            return;
        }

        keys = keys || [];

        var isSingleRowSelection = this.isSingleRowSelectionMode();
        var model = this.getSelectionModel();
        var alreadySelected = model.isRowSelected(y);
        var hasCTRL = keys.indexOf('CTRL') > -1;
        var hasSHIFT = keys.indexOf('SHIFT') > -1;

        if (!hasCTRL && !hasSHIFT) {
            model.clear();
            if (!alreadySelected) {
                model.selectRow(y);
            }
        } else {
            if (hasCTRL) {
                if (alreadySelected) {
                    model.deselectRow(y);
                } else {
                    if (isSingleRowSelection) {
                        model.clearRowSelection();
                    }
                    model.selectRow(y);
                }
            }
            if (hasSHIFT) {
                model.clear();
                model.selectRow(this.lastEdgeSelection[1], y);
            }
        }
        if (!alreadySelected && !hasSHIFT) {
            this.lastEdgeSelection[1] = y;
        }
        this.repaint();
    },

    selectViewportCell: function(x, y) {
        var headerRowCount = this.getHeaderRowCount();
        var renderer = this.getRenderer();
        var realX = renderer.getVisibleColumns()[x];
        var realY = renderer.getVisibleRows()[y];
        this.clearSelections();
        this.select(realX, realY + headerRowCount, 0, 0);
        this.setMouseDown(this.newPoint(realX, realY + headerRowCount));
        this.setDragExtent(this.newPoint(0, 0));
        this.repaint();
    },

    selectToViewportCell: function(x, y) {
        var selections = this.getSelections();
        if (!selections || selections.length === 0) {
            return;
        }
        var headerRowCount = this.getHeaderRowCount();
        var renderer = this.getRenderer();
        var realX = renderer.getVisibleColumns()[x];
        var realY = renderer.getVisibleRows()[y] + headerRowCount;
        var selection = selections[0];
        var origin = selection.origin;
        this.setDragExtent(this.newPoint(realX - origin.x, realY - origin.y));
        this.select(origin.x, origin.y, realX - origin.x, realY - origin.y);
        this.repaint();
    },

    selectFinalCellOfCurrentRow: function() {
        var x = this.getColumnCount() - 1;
        var y = this.getSelectedRows()[0];
        var headerRowCount = this.getHeaderRowCount();
        this.clearSelections();
        this.scrollBy(this.getColumnCount(), 0);
        this.select(x, y + headerRowCount, 0, 0);
        this.setMouseDown(this.newPoint(x, y + headerRowCount));
        this.setDragExtent(this.newPoint(0, 0));
        this.repaint();
    },

    selectToFinalCellOfCurrentRow: function() {
        var selections = this.getSelections();
        if (!selections || selections.length === 0) {
            return;
        }
        var selection = selections[0];
        var origin = selection.origin;
        var extent = selection.extent;
        var columnCount = this.getColumnCount();
        this.scrollBy(columnCount, 0);

        this.clearSelections();
        this.select(origin.x, origin.y, columnCount - origin.x - 1, extent.y);

        this.repaint();
    },

    selectFirstCellOfCurrentRow: function() {
        var x = 0;
        var y = this.getSelectedRows()[0];
        var headerRowCount = this.getHeaderRowCount();
        this.clearSelections();
        this.setHScrollValue(0);
        this.select(x, y + headerRowCount, 0, 0);
        this.setMouseDown(this.newPoint(x, y + headerRowCount));
        this.setDragExtent(this.newPoint(0, 0));
        this.repaint();
    },

    selectToFirstCellOfCurrentRow: function() {
        var selections = this.getSelections();
        if (!selections || selections.length === 0) {
            return;
        }
        var selection = selections[0];
        var origin = selection.origin;
        var extent = selection.extent;
        this.clearSelections();
        this.select(origin.x, origin.y, -origin.x, extent.y);
        this.setHScrollValue(0);
        this.repaint();
    },

    selectFinalCell: function() {
        this.selectCell(this.getColumnCount() - 1, this.getRowCount() - 1);
        this.scrollBy(this.getColumnCount(), this.getRowCount());
        this.repaint();
    },

    selectToFinalCell: function() {

        var selections = this.getSelections();
        if (!selections || selections.length === 0) {
            return;
        }
        var selection = selections[0];
        var origin = selection.origin;
        var columnCount = this.getColumnCount();
        var rowCount = this.getRowCount();

        this.clearSelections();
        this.select(origin.x, origin.y, columnCount - origin.x - 1, rowCount - origin.y - 1);
        this.scrollBy(columnCount, rowCount);
        this.repaint();
    },

    isShowRowNumbers: function() {
        return this.resolveProperty('showRowNumbers');
    },
    isEditable: function() {
        return this.resolveProperty('editable') === true;
    },
    isShowFilterRow: function() {
        return this.resolveProperty('showFilterRow');
    },
    isShowHeaderRow: function() {
        return this.resolveProperty('showHeaderRow');
    },
    getHeaderRowCount: function() {
        return this.getBehavior().getHeaderRowCount();
    },
    isFilterRow: function(y) {
        return y === this.getFilterRowIndex();
    },
    getFilterRowIndex: function() {
        if (!this.isShowFilterRow()) {
            return -1;
        }
        if (this.isShowHeaderRow()) {
            return 1;
        } else {
            return 0;
        }
    },
    setGroups: function(arrayOfColumnIndexes) {
        this.getBehavior().setGroups(arrayOfColumnIndexes);
    },
    filterClicked: function(event) {
        this.activateEditor(event.gridCell.x, event.gridCell.y);
    },
    hasHierarchyColumn: function() {
        return this.getBehavior().hasHierarchyColumn();
    },
    isHierarchyColumn: function(x) {
        if (!this.hasHierarchyColumn()) {
            return false;
        }
        return x === 0;
    },
    checkScrollbarVisibility: function() {
        // var hoverClassOver = this.resolveProperty('scrollbarHoverOver');
        // var hoverClassOff = this.resolveProperty('scrollbarHoverOff');

        // if (hoverClassOff === 'visible') {
        //     this.sbHScroller.classList.remove(hoverClassOver);
        //     this.sbVScroller.classList.remove(hoverClassOff);
        //     this.sbHScroller.classList.add('visible');
        //     this.sbVScroller.classList.add('visible');
        // }
    },
    isColumnOrRowSelected: function() {
        return this.getSelectionModel().isColumnOrRowSelected();
    },
    selectColumn: function(x1, x2) {
        this.getSelectionModel().selectColumn(x1, x2);
    },
    selectRow: function(y1, y2) {
        if (this.isSingleRowSelectionMode()) {
            this.getSelectionModel().clearRowSelection();
            y1 = y2;
        } else {
            y2 = y2 || y1;
        }
        var min = Math.min(y1, y2);
        var max = Math.max(y1, y2);
        var selectionEdge = this.getFilterRowIndex() + 1;
        if (min < selectionEdge) {
            return;
        }
        this.getSelectionModel().selectRow(min, max);
    },
    isRowSelected: function(r) {
        return this.getSelectionModel().isRowSelected(r);
    },
    isColumnSelected: function(c) {
        return this.getSelectionModel().isColumnSelected(c);
    },
    lookupFeature: function(key) {
        return this.getBehavior().lookupFeature(key);
    },
    getRow: function(y) {
        return this.getBehavior().getRow(y);
    },
    getFieldName: function(index) {
        return this.getBehavior().getFieldName(index);
    },

    getColumnIndex: function(fieldName) {
        return this.getBehavior().getColumnIndex(fieldName);
    },
    isCellSelection: function() {
        return this.resolveProperty('cellSelection') === true;
    },
    isRowSelection: function() {
        return this.resolveProperty('rowSelection') === true;
    },
    isColumnSelection: function() {
        return this.resolveProperty('columnSelection') === true;
    },
    getComputedRow: function(y) {
        return this.getBehavior().getComputedRow(y);
    },
    isColumnAutosizing: function() {
        return this.resolveProperty('columnAutosizing') === true;
    },
    setGlobalFilter: function(string) {
        this.getBehavior().setGlobalFilter(string);
    },
    selectRowsFromCells: function() {
        var sm = this.getSelectionModel();
        if (this.isSingleRowSelectionMode()) {
            var last = sm.getLastSelection();
            if (!last) {
                sm.clearRowSelection();
            } else {
                this.selectRow(null, last.corner.y);
            }
        } else {
            sm.selectRowsFromCells();
        }
    },
    selectColumnsFromCells: function() {
        this.getSelectionModel().selectColumnsFromCells();
    },
    getSelectedRows: function() {
        return this.getBehavior().getSelectedRows();
    },
    getSelectedColumns: function() {
        return this.getBehavior().getSelectedColumns();
    },
    getSelections: function() {
        return this.getBehavior().getSelections();
    },
    getLastSelectionType: function() {
        return this.getSelectionModel().getLastSelectionType();
    },
    isCellSelected: function(x, y) {
        return this.getSelectionModel().isCellSelected(x, y);
    },
    isInCurrentSelectionRectangle: function(x, y) {
        return this.getSelectionModel().isInCurrentSelectionRectangle(x, y);
    },
    selectAllRows: function() {
        this.getSelectionModel().selectAllRows();
    },
    areAllRowsSelected: function() {
        return this.getSelectionModel().areAllRowsSelected();
    },
    toggleSelectAllRows: function() {
        if (this.areAllRowsSelected()) {
            this.getSelectionModel().clear();
        } else {
            this.selectAllRows();
        }
        this.repaint();
    },
    getField: function(x) {
        return this.getBehavior().getField(x);
    },
    isSingleRowSelectionMode: function() {
        return this.resolveProperty('singleRowSelectionMode');
    },
    newPoint: function(x, y) {
        return new Point(x, y);
    },
    newRectangle: function(x, y, width, height) {
        return new Rectangle(x, y, width, height);
    }
};

function getTextWidth(gc, string) {
    if (string === null || string === undefined) {
        return 0;
    }
    string = string + '';
    if (string.length === 0) {
        return 0;
    }
    var key = gc.font + string;
    var width = textWidthCache.get(key);
    if (!width) {
        width = gc.measureText(string).width;
        textWidthCache.set(key, width);
    }
    return width;
}

function getTextHeight(font) {

    var result = getTextHeight.fontData[font];
    if (result) {
        return result;
    }
    result = {};
    var text = document.createElement('span');
    text.textContent = 'Hg';
    text.style.font = font;

    var block = document.createElement('div');
    block.style.display = 'inline-block';
    block.style.width = '1px';
    block.style.height = '0px';

    var div = document.createElement('div');
    div.appendChild(text);
    div.appendChild(block);

    div.style.position = 'absolute';
    document.body.appendChild(div);

    try {

        block.style.verticalAlign = 'baseline';

        var blockRect = block.getBoundingClientRect();
        var textRect = text.getBoundingClientRect();

        result.ascent = blockRect.top - textRect.top;

        block.style.verticalAlign = 'bottom';
        result.height = blockRect.top - textRect.top;

        result.descent = result.height - result.ascent;

    } finally {
        document.body.removeChild(div);
    }
    if (result.height !== 0) {
        getTextHeight.fontData[font] = result;
    }
    return result;
}
getTextHeight.fontData = {};

function defaultProperties() {
    var properties = {
        //these are for the theme
        font: '13px Tahoma, Geneva, sans-serif',
        color: 'rgb(25, 25, 25)',
        backgroundColor: 'rgb(241, 241, 241)',
        foregroundSelectionColor: 'rgb(25, 25, 25)',
        backgroundSelectionColor: 'rgb(183, 219, 255)',

        columnHeaderFont: '12px Tahoma, Geneva, sans-serif',
        columnHeaderColor: 'rgb(25, 25, 25)',
        columnHeaderBackgroundColor: 'rgb(223, 227, 232)',
        columnHeaderForegroundSelectionColor: 'rgb(25, 25, 25)',
        columnHeaderBackgroundSelectionColor: 'rgb(255, 220, 97)',
        columnHeaderForegroundColumnSelectionColor: 'rgb(25, 25, 25)',
        columnHeaderBackgroundColumnSelectionColor: 'rgb(255, 180, 0)',

        rowHeaderFont: '12px Tahoma, Geneva, sans-serif',
        rowHeaderColor: 'rgb(25, 25, 25)',
        rowHeaderBackgroundColor: 'rgb(223, 227, 232)',
        rowHeaderForegroundSelectionColor: 'rgb(25, 25, 25)',
        rowHeaderBackgroundSelectionColor: 'rgb(255, 220, 97)',
        rowHeaderForegroundRowSelectionColor: 'rgb(25, 25, 25)',
        rowHeaderBackgroundRowSelectionColor: 'rgb(255, 180, 0)',

        filterFont: '12px Tahoma, Geneva, sans-serif',
        filterColor: 'rgb(25, 25, 25)',
        filterBackgroundColor: 'white',
        filterForegroundSelectionColor: 'rgb(25, 25, 25)',
        filterBackgroundSelectionColor: 'rgb(255, 220, 97)',
        filterCellBorderStyle: 'rgba(0,0,0,0.8)',
        filterCellBorderThickness: '0.4',

        treeColumnFont: '12px Tahoma, Geneva, sans-serif',
        treeColumnColor: 'rgb(25, 25, 25)',
        treeColumnBackgroundColor: 'rgb(223, 227, 232)',
        treeColumnForegroundSelectionColor: 'rgb(25, 25, 25)',
        treeColumnBackgroundSelectionColor: 'rgb(255, 220, 97)',
        treeColumnForegroundColumnSelectionColor: 'rgb(25, 25, 25)',
        treeColumnBackgroundColumnSelectionColor: 'rgb(255, 180, 0)',

        backgroundColor2: 'rgb(201, 201, 201)',
        voffset: 0,
        scrollbarHoverOver: 'visible',
        scrollbarHoverOff: 'hidden',
        scrollingEnabled: true,
        vScrollbarClassPrefix: '',
        hScrollbarClassPrefix: '',

        //these used to be in the constants element
        fixedRowAlign: 'center',
        fixedColAlign: 'center',
        cellPadding: 5,
        gridLinesH: true,
        gridLinesV: true,
        lineColor: 'rgb(199, 199, 199)',
        lineWidth: 0.4,

        defaultRowHeight: 15,
        defaultColumnWidth: 100,

        //for immediate painting, set these values to 0, true respectively
        repaintIntervalRate: 60,
        repaintImmediately: false,

        //enable or disable double buffering
        useBitBlit: false,

        useHiDPI: true,
        editorActivationKeys: ['alt', 'esc'],
        readOnly: false,

        //inhertied by cell renderers
        getTextWidth: getTextWidth,
        getTextHeight: getTextHeight,

        fixedColumnCount: 0,
        fixedRowCount: 0,
        headerColumnCount: 0,

        showRowNumbers: true,
        showHeaderRow: true,
        showFilterRow: true,

        cellSelection: true,
        columnSelection: true,
        rowSelection: true,
        singleRowSelectionMode: true,

        columnAutosizing: true,
        headerTextWrapping: false,
        rowResize: false

    };
    return properties;
}

function normalizeRect(rect) {
    var o = rect.origin;
    var c = rect.corner;

    var ox = Math.min(o.x, c.x);
    var oy = Math.min(o.y, c.y);

    var cx = Math.max(o.x, c.x);
    var cy = Math.max(o.y, c.y);

    var result = new Rectangle(ox, oy, cx - ox, cy - oy);

    return result;
}

function buildPolymerTheme() {
    clearObjectProperties(polymerTheme);
    var pb = document.createElement('paper-button');

    pb.style.display = 'none';
    pb.setAttribute('disabled', true);
    document.body.appendChild(pb);
    var p = window.getComputedStyle(pb);

    var section = document.createElement('section');
    section.style.display = 'none';
    section.setAttribute('hero', true);
    document.body.appendChild(section);

    var h = window.getComputedStyle(document.querySelector('html'));
    var hb = window.getComputedStyle(document.querySelector('html, body'));
    var s = window.getComputedStyle(section);

    polymerTheme.columnHeaderBackgroundColor = p.color;
    polymerTheme.rowHeaderBackgroundColor = p.color;
    polymerTheme.topLeftBackgroundColor = p.color;
    polymerTheme.lineColor = p.backgroundColor;

    polymerTheme.backgroundColor2 = hb.backgroundColor;

    polymerTheme.color = h.color;
    polymerTheme.fontFamily = h.fontFamily;
    polymerTheme.backgroundColor = s.backgroundColor;

    pb.setAttribute('disabled', false);
    pb.setAttribute('secondary', true);
    pb.setAttribute('raised', true);
    p = window.getComputedStyle(pb);

    polymerTheme.columnHeaderColor = p.color;
    polymerTheme.rowHeaderColor = p.color;
    polymerTheme.topLeftColor = p.color;


    polymerTheme.backgroundSelectionColor = p.backgroundColor;
    polymerTheme.foregroundSelectionColor = p.color;

    pb.setAttribute('secondary', false);
    pb.setAttribute('warning', true);

    polymerTheme.columnHeaderForegroundSelectionColor = p.color;
    polymerTheme.columnHeaderBackgroundSelectionColor = p.backgroundColor;
    polymerTheme.rowHeaderForegroundSelectionColor = p.color;
    polymerTheme.fixedColumnBackgroundSelectionColor = p.backgroundColor;

    //check if there is actually a theme loaded if not, clear out all bogus values
    //from my cache
    if (polymerTheme.columnHeaderBackgroundSelectionColor === 'rgba(0, 0, 0, 0)' ||
        polymerTheme.lineColor === 'transparent') {
        clearObjectProperties(polymerTheme);
    }

    document.body.removeChild(pb);
    document.body.removeChild(section);
}

function clearObjectProperties(obj) {
    for (var prop in obj) {
        if (obj.hasOwnProperty(prop)) {
            delete obj[prop];
        }
    }
}

function valueOrFunctionExecute(valueOrFunction) {
    var result = typeof valueOrFunction === 'function' ? valueOrFunction() : valueOrFunction;
    return result || result === 0 ? result : '';
}

function installPolyfills() {
    if (!Array.prototype.find) {
        Array.prototype.find = function(predicate) { // eslint-disable-line no-extend-native
            if (this === null) {
                throw new TypeError('Array.prototype.find called on null or undefined');
            }
            if (typeof predicate !== 'function') {
                throw new TypeError('predicate must be a function');
            }
            var list = Object(this);
            var length = list.length >>> 0;
            var thisArg = arguments[1];
            var value;

            for (var i = 0; i < length; i++) {
                value = list[i];
                if (predicate.call(thisArg, value, i, list)) {
                    return value;
                }
            }
            return undefined;
        };
    }
}

module.exports = Hypergrid;

},{"./Renderer":34,"./SelectionModel":35,"./stylesheets":72,"extend-me":3,"finbars":4,"fincanvas":5,"lru-cache":26,"object-iterators":28,"rectangular":29}],34:[function(require,module,exports){
/* eslint-env browser */
/* global requestAnimationFrame */

'use strict';

var _ = require('object-iterators');
var Base = require('extend-me').Base;

/**
 * @constructor
 * @desc fin-hypergrid-renderer is the canvas enabled top level sub component that handles the renderering of the Grid.
 *
 * It relies on two other external subprojects
 *
 * 1. fin-canvas: a wrapper to provide a simpler interface to the HTML5 canvas component
 * 2. rectangular: a small npm module providing Point and Rectangle objects
 *
 * The fin-hypergrid-renderer is in a unique position to provide critical functionality to the fin-hypergrid in a hightly performant manner.
 * Because it MUST iterate over all the visible cells it can store various bits of information that can be encapsulated as a service for consumption by the fin-hypergrid component.
 *
 * Instances of this object have basically four main functions.
 *
 * 1. render fixed row headers
 * 2. render fixed col headers
 * 3. render main data cells
 * 4. render grid lines
 *
 * Same parameters as {@link Renderer#initialize|initialize}, which is called by this constructor.
 *
 */
var Renderer = Base.extend('Renderer', {

    //the shared single item "pooled" cell object for drawing each cell
    cell: {
        x: 0,
        y: 0,
        width: 0,
        height: 0
    },

    scrollHeight: 0,

    viewHeight: 0,

    /**
     * @summary Constructor logic
     * @desc This method will be called upon instantiation of this class or of any class that extends from this class.
     * > All `initialize()` methods in the inheritance chain are called, in turn, each with the same parameters that were passed to the constructor, beginning with that of the most "senior" class through that of the class of the new instance.
     * @memberOf Renderer.prototype
     */
    initialize: function(grid) {
        this.grid = grid;
        this.bounds = {
            width:0,
            height:0
        };
        this.columnEdges = [];
        this.columnEdgesIndexMap = {};
        this.renderedColumnMinWidths = [];
        this.renderedHeight = 0;
        this.rowEdges = [];
        this.rowEdgesIndexMap = {};
        this.visibleColumns = [];
        this.visibleRows = [];
        this.insertionBounds = [];
    },

    //this function computes the grid coordinates used for extremely fast iteration over
    //painting the grid cells. this function is very fast, for thousand rows X 100 columns
    //on a modest machine taking usually 0ms and no more that 3 ms.
    computeCellsBounds: function() {

        //var startTime = Date.now();

        var grid = this.getGrid();
        var scrollTop = this.getScrollTop();
        var scrollLeft = this.getScrollLeft();

        var numColumns = this.getColumnCount();
        var numFixedColumns = this.getFixedColumnCount();

        var numRows = this.getRowCount();
        var numFixedRows = this.getFixedRowCount();

        var bounds = this.getBounds();
        var viewWidth = bounds.width;

        //we must be in bootstrap
        if (viewWidth === 0) {
            //viewWidth = grid.sbHScroller.getClientRects()[0].width;
            viewWidth = grid.canvas.width;
        }
        var viewHeight = bounds.height;

        var x, y, c, r, vx, vy, width, height;

        this.getColumnEdges().length = 0;
        this.rowEdges.length = 0;

        this.columnEdges[0] = 0;
        this.rowEdges[0] = 0;
        this.scrollHeight = 0;

        this.visibleColumns.length = 0;
        this.visibleRows.length = 0;
        this.columnEdgesIndexMap = {};
        this.rowEdgesIndexMap = {};

        this.insertionBounds = [];
        var insertionBoundsCursor = 0;
        var previousInsertionBoundsCursorValue = 0;

        x = 0;
        var start = 0;
        var firstVX, lastVX;
        var firstVY, lastVY;
        if (grid.isShowRowNumbers()) {
            start--;
            this.columnEdges[-1] = -1;
        }
        for (c = start; c < numColumns; c++) {
            vx = c;
            if (c >= numFixedColumns) {
                vx = vx + scrollLeft;
                if (firstVX === undefined) {
                    firstVX = vx;
                }
                lastVX = vx;
            }
            if (x > viewWidth || numColumns <= vx) {
                break;
            }
            width = this.getColumnWidth(vx);
            x = x + width;
            this.columnEdges[c + 1] = Math.round(x);
            this.visibleColumns[c] = vx;
            this.columnEdgesIndexMap[vx] = c;

            insertionBoundsCursor = insertionBoundsCursor + Math.round(width / 2) + previousInsertionBoundsCursorValue;
            this.insertionBounds.push(insertionBoundsCursor);
            previousInsertionBoundsCursorValue = Math.round(width / 2);
        }

        y = 0;
        for (r = 0; r < numRows; r++) {
            vy = r;
            if (r >= numFixedRows) {
                vy = vy + scrollTop;
                if (firstVY === undefined) {
                    firstVY = vy;
                }
                lastVY = vy;
            }
            if (y > viewHeight || numRows <= vy) {
                break;
            }
            height = this.getRowHeight(vy);
            y = y + height;
            this.rowEdges[r + 1] = Math.round(y);
            this.visibleRows[r] = vy;
            this.rowEdgesIndexMap[vy] = r;
        }
        this.viewHeight = viewHeight;
        this.dataWindow = grid.newRectangle(firstVX, firstVY, lastVX - firstVX, lastVY - firstVY);
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {Object} a property value at a key, delegates to the grid
     */
    resolveProperty: function(key) {
        return this.getGrid().resolveProperty(key);
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {Hypergrid} grid
     */
    getGrid: function() {
        return this.grid;
    },

    /**
     * @memberOf Renderer.prototype
     * @summary Notify the fin-hypergrid everytime we've repainted.
     * @desc This is the entry point from fin-canvas.
     * @param {CanvasRenderingContext2D} gc - [CanvasRenderingContext2D](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D)
     */
    _paint: function(gc) {
        if (this.grid) {
            this.renderGrid(gc);
            this.getGrid().gridRenderedNotification();
        }
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {number} Answer how many rows we rendered
     */
    getVisibleRowsCount: function() {
        return this.visibleRows.length - 1;
    },

    getVisibleScrollHeight: function() {
        var grid = this.getGrid(),
            frh = grid.getFixedRowsHeight();

        return this.viewHeight - frh;
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {number[]} Rows we just rendered.
     */
    getVisibleRows: function() {
        return this.visibleRows;
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {number} Numer of columns we just rendered.
     */
    getVisibleColumnsCount: function() {
        return this.visibleColumns.length - 1;
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {number} Columns we just rendered.
     */
    getVisibleColumns: function() {
        return this.visibleColumns;
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {number} The column index whne the mouseEvent coordinates are over a column divider.
     */
    overColumnDivider: function(x) {
        x = Math.round(x);
        var edges = this.getColumnEdges();
        var whichCol = edges.indexOf(x - 1);
        if (whichCol < 0) {
            whichCol = edges.indexOf(x);
        }
        if (whichCol < 0) {
            whichCol = edges.indexOf(x - 2);
        }
        if (whichCol < 0) {
            whichCol = edges.indexOf(x + 1);
        }
        if (whichCol < 0) {
            whichCol = edges.indexOf(x - 3);
        }

        return whichCol;
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {number} The row index when the mouseEvent coordinates are over a row divider.
     */
    overRowDivider: function(y) {
        y = Math.round(y);
        var which = this.rowEdges.indexOf(y + 1);
        if (which < 0) {
            which = this.rowEdges.indexOf(y);
        }
        if (which < 0) {
            which = this.rowEdges.indexOf(y - 1);
        }
        return which;
    },

    /**
     * @memberOf Renderer.prototype
     * @param {Point} cell
     * @returns {Rectangle} Bounding rect of the given `cell`.
     */
    getBoundsOfCell: function(cell) {
        return this._getBoundsOfCell(cell.x, cell.y);
    },

    /**
     * @memberOf Renderer.prototype
     * @param {number} c - The horizontal coordinate.
     * @param {number} r - The vertical coordinate.
     * @returns {Rectangle} Bounding rect of cell with the given coordinates.
     */
    _getBoundsOfCell: function(c, r) {
        var xOutside = false;
        var yOutside = false;
        var columnEdges = this.getColumnEdges();
        var rowEdges = this.getRowEdges();

        var x = this.columnEdgesIndexMap[c];
        var y = this.rowEdgesIndexMap[r];
        if (x === undefined) {
            x = this.columnEdgesIndexMap[c - 1];
            xOutside = true;
        }

        if (y === undefined) {
            y = this.rowEdgesIndexMap[r - 1];
            yOutside = true;
        }

        var ox = columnEdges[x],
            oy = rowEdges[y],
            cx = columnEdges[x + 1],
            cy = rowEdges[y + 1],
            ex = cx - ox,
            ey = cy - oy;

        var cell = this.cell;
        cell.x = xOutside ? cx : ox;
        cell.y = yOutside ? cy : oy;
        cell.width = xOutside ? 0 : ex;
        cell.height = yOutside ? 0 : ey;

        return cell;

    },

    /**
     * @memberOf Renderer.prototype
     * @desc answer the column index under the coordinate at pixelX
     * @param {number} pixelX - The horizontal coordinate.
     * @returns {number} The column index under the coordinate at pixelX.
     */
    getColumnFromPixelX: function(pixelX) {
        var width = 0;
        var grid = this.getGrid();
        var fixedColumnCount = this.getFixedColumnCount();
        var scrollLeft = grid.getHScrollValue();
        var c;
        var edges = this.getColumnEdges();
        for (c = 1; c < edges.length - 1; c++) {
            width = edges[c] - (edges[c] - edges[c - 1]) / 2;
            if (pixelX < width) {
                if (c > fixedColumnCount) {
                    c = c + scrollLeft;
                }
                return c - 1;
            }
        }
        if (c > fixedColumnCount) {
            c = c + scrollLeft;
        }
        return c - 1;
    },


    /**
     * @memberOf Renderer.prototype
     * @desc Answer specific data cell coordinates given mouse coordinates in pixels.
     * @param {Point} point
     * @returns {Point} Cell coordinates
     */
    getGridCellFromMousePoint: function(point) {

        var grid = this.getGrid();
        var behavior = grid.getBehavior();
        var width = 0;
        var height = 0;
        var x, y, c, r;
        var previous = 0;
        var columnEdges = this.getColumnEdges();
        var fixedColumnCount = this.getFixedColumnCount(); // + gridSize;
        var fixedRowCount = this.getFixedRowCount();

        // var fixedColumnCount = this.getFixedColumnCount();
        // var fixedRowCount = this.getFixedRowCount();
        var scrollX = this.getScrollLeft();
        var scrollY = this.getScrollTop();

        for (c = 0; c < columnEdges.length; c++) {
            width = columnEdges[c];
            if (point.x < width) {
                x = Math.max(0, point.x - previous - 2);
                break;
            }
            previous = width;
        }
        c--;
        previous = 0;
        for (r = 0; r < this.rowEdges.length; r++) {
            height = this.rowEdges[r];
            if (point.y < height) {
                y = Math.max(0, point.y - previous - 2);
                break;
            }
            previous = height;
        }
        r--;
        if (point.x < 0) {
            c = -1;
        }
        if (point.y < 0) {
            r = -1;
        }

        var viewPoint = grid.newPoint(c, r);

        //compensate if we are scrolled
        if (c >= fixedColumnCount) {
            c = c + scrollX;
        }
        if (r >= fixedRowCount) {
            r = r + scrollY;
        }

        var translatedIndex = -1;

        var column = behavior.getColumn(c);
        if (column) {
            translatedIndex = column.index;
        }

        return {
            gridCell: grid.newPoint(c, r),
            mousePoint: grid.newPoint(x, y),
            viewPoint: viewPoint,
            dataCell: grid.newPoint(translatedIndex, r),
        };
    },

    /**
     * @memberOf Renderer.prototype
     * @summary Determines if a column is visible.
     * @param {number} colIndex - the column index*
     * @returns {boolean} The given column is fully visible.
     */
    isColumnVisible: function(colIndex) {
        var isVisible = this.visibleColumns.indexOf(colIndex) !== -1;
        return isVisible;
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {number} The width x coordinate of the last rendered column
     */
    getFinalVisableColumnBoundry: function() {
        var isMaxX = this.isLastColumnVisible();
        var chop = isMaxX ? 2 : 1;
        var colWall = this.getColumnEdges()[this.getColumnEdges().length - chop];
        var result = Math.min(colWall, this.getBounds().width - 200);
        return result;
    },

    /**
     * @memberOf Renderer.prototype
     * @summary Determines visibility of a row.
     * @param {number} rowIndex - the row index
     * @returns {boolean} The given row is fully visible.
     */
    isRowVisible: function(rowIndex) {
        var isVisible = this.visibleRows.indexOf(rowIndex) !== -1;
        return isVisible;
    },

    /**
     * @memberOf Renderer.prototype
     * @summary Determines if a cell is selected.
     * @param {number} x - the x cell coordinate
     * @param {number} y - the y cell coordinate*
     * @returns {boolean} The given cell is fully visible.
     */
    isSelected: function(x, y) {
        return this.getGrid().isSelected(x, y);
    },

    /**
     * @memberOf Renderer.prototype
     * @desc This is the main forking of the renderering task.
     * @param {CanvasRenderingContext2D} gc - [CanvasRenderingContext2D](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D)
     */
    renderGrid: function(gc) {
        gc.beginPath();

        this.paintCells(gc);
        this.paintGridlines(gc);
        //this.blankOutOverflow(gc); // no longer needed
        this.renderOverrides(gc);
        this.renderFocusCell(gc);
        gc.closePath();
    },

    focusLineStep: [
        [5, 5],
        [0, 1, 5, 4],
        [0, 2, 5, 3],
        [0, 3, 5, 2],
        [0, 4, 5, 1],
        [0, 5, 5, 0],
        [1, 5, 4, 0],
        [2, 5, 3, 0],
        [3, 5, 2, 0],
        [4, 5, 1, 0]
    ],

    renderFocusCell: function(gc) {
        gc.beginPath();
        this._renderFocusCell(gc);
        gc.closePath();
    },

    _renderFocusCell: function(gc) {

        var grid = this.getGrid();
        var selections = grid.getSelectionModel().getSelections();
        if (!selections || selections.length === 0) {
            return;
        }
        var selection = selections[selections.length - 1];
        var mouseDown = selection.origin;
        if (mouseDown.x === -1) {
            //no selected area, lets exit
            return;
        }

        var visibleColumns = this.getVisibleColumns();
        var visibleRows = this.getVisibleRows();
        var lastVisibleColumn = visibleColumns[visibleColumns.length - 1];
        var lastVisibleRow = visibleRows[visibleRows.length - 1];

        var extent = selection.extent;

        var dpOX = Math.min(mouseDown.x, mouseDown.x + extent.x);
        var dpOY = Math.min(mouseDown.y, mouseDown.y + extent.y);

        //lets check if our selection rectangle is scrolled outside of the visible area
        if (dpOX > lastVisibleColumn) {
            return; //the top of our rectangle is below visible
        }
        if (dpOY > lastVisibleRow) {
            return; //the left of our rectangle is to the right of being visible
        }

        var dpEX = Math.max(mouseDown.x, mouseDown.x + extent.x) + 1;
        dpEX = Math.min(dpEX, 1 + lastVisibleColumn);

        var dpEY = Math.max(mouseDown.y, mouseDown.y + extent.y) + 1;
        dpEY = Math.min(dpEY, 1 + lastVisibleRow);

        var o = this._getBoundsOfCell(dpOX, dpOY);
        var ox = Math.round((o.x === undefined) ? grid.getFixedColumnsWidth() : o.x);
        var oy = Math.round((o.y === undefined) ? grid.getFixedRowsHeight() : o.y);
        // var ow = o.width;
        // var oh = o.height;
        var e = this._getBoundsOfCell(dpEX, dpEY);
        var ex = Math.round((e.x === undefined) ? grid.getFixedColumnsWidth() : e.x);
        var ey = Math.round((e.y === undefined) ? grid.getFixedRowsHeight() : e.y);
        // var ew = e.width;
        // var eh = e.height;
        var x = Math.min(ox, ex);
        var y = Math.min(oy, ey);
        var width = 1 + ex - ox;
        var height = 1 + ey - oy;
        if (x === ex) {
            width = ox - ex;
        }
        if (y === ey) {
            height = oy - ey;
        }
        if (width * height < 1) {
            //if we are only a skinny line, don't render anything
            return;
        }

        gc.rect(x, y, width, height);
        gc.fillStyle = 'rgba(0, 0, 0, 0.2)';
        gc.fill();
        gc.lineWidth = 1;
        gc.strokeStyle = 'black';

        // animate the dashed line a bit here for fun

        gc.stroke();

        //gc.rect(x, y, width, height);

        //gc.strokeStyle = 'white';

        // animate the dashed line a bit here for fun
        //gc.setLineDash(this.focusLineStep[Math.floor(10 * (Date.now() / 300 % 1)) % this.focusLineStep.length]);

        gc.stroke();
    },


    /**
     * @memberOf Renderer.prototype
     * @desc Paint the background color over the overflow from the final column paint
     * @param {CanvasRenderingContext2D} gc - [CanvasRenderingContext2D](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D)
     */
    blankOutOverflow: function(gc) {
        var isMaxX = this.isLastColumnVisible();
        var chop = isMaxX ? 1 : 0;
        var x = this.getColumnEdges()[this.getColumnEdges().length - chop];
        var bounds = this.getBounds();
        var width = bounds.width - 200 - x;
        var height = bounds.height;
        gc.fillStyle = this.resolveProperty('backgroundColor2');
        gc.fillRect(x + 1, 0, width, height);
    },

    /**
     * @memberOf Renderer.prototype
     * @desc iterate the renderering overrides and manifest each
     * @param {CanvasRenderingContext2D} gc - [CanvasRenderingContext2D](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D)
     */
    renderOverrides: function(gc) {
        var grid = this.getGrid();
        var cache = grid.renderOverridesCache;
        for (var key in cache) {
            if (cache.hasOwnProperty(key)) {
                var override = cache[key];
                if (override) {
                    this.renderOverride(gc, override);
                }
            }
        }
    },

    /**
     * @memberOf Renderer.prototype
     * @desc copy each overrides specified area to it's target and blank out the source area
     * @param {CanvasRenderingContext2D} gc - [CanvasRenderingContext2D](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D)
     * @param {OverrideObject} override - an object with details contain an area and a target context
     */
    renderOverride: function(gc, override) {
        //lets blank out the drag row
        var hdpiRatio = override.hdpiratio;
        //var edges = this.getColumnEdges();
        var startX = override.startX; //hdpiRatio * edges[override.columnIndex];
        var width = override.width + 1;
        var height = override.height;
        var targetCTX = override.ctx;
        var imgData = gc.getImageData(startX, 0, Math.round(width * hdpiRatio), Math.round(height * hdpiRatio));
        targetCTX.putImageData(imgData, 0, 0);
        gc.fillStyle = this.resolveProperty('backgroundColor2');
        gc.fillRect(Math.round(startX / hdpiRatio), 0, width, height);
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {boolean} mouse is currently over cell x, y
     * @param {number} offsetX - x coordinate
     * @param {number} offsetY - y coordinate
     */
    isHovered: function(x, y) {
        return this.getGrid().isHovered(x, y);
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {boolean} mouse is currently over row y
     * @param {number} offsetY - y coordinate
     */
    isRowHovered: function(y) {
        return this.getGrid().isRowHovered(y);
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {boolean} mouse is currently over column x
     * @param {number} offsetX - x coordinate
     */
    isColumnHovered: function(x) {
        return this.getGrid().isColumnHovered(x);
    },

    /**
     * @memberOf Renderer.prototype
     * @summary Smart render the main cells.
     * @desc We snapshot the context to insure against its pollution.
     * @param {CanvasRenderingContext2D} gc - [CanvasRenderingContext2D](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D)
     */
    paintCells: function(gc) {
        try {
            gc.save();
            this._paintCells(gc);
        } catch (e) {
            console.error(e);
        } finally {
            gc.restore();
        }
    },

    /**
     * @memberOf Renderer.prototype
     * @param {number} colIndex
     * @returns {boolean} The given column within the fixed row area is selected.
     */
    isCellSelectedInRow: function(colIndex) {
        return this.getGrid().isCellSelectedInRow(colIndex);
    },

    /**
     * @memberOf Renderer.prototype
     * @param {number} rowIndex
     * @returns {boolean} The given row within the fixed column area is selected.
     */
    isCellSelectedInColumn: function(rowIndex) {
        return this.getGrid().isCellSelectedInColumn(rowIndex);
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {number} Current vertical scroll value.
     */
    getScrollTop: function() {
        var st = this.getGrid().getVScrollValue();
        return st;
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {number} Current horizontal scroll value.
     */
    getScrollLeft: function() {
        var st = this.getGrid().getHScrollValue();
        return st;
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {Behavior}
     */
    getBehavior: function() {
        return this.getGrid().getBehavior();
    },

    getColumnEdges: function() {
        return this.columnEdges;
    },

    getRowEdges: function() {
        return this.rowEdges;
    },
    /**
     * @memberOf Renderer.prototype
     * @returns {number} The row height of the row at index rowIndex
     * @param {number} rowIndex
     */
    getRowHeight: function(rowIndex) {
        var height = this.getBehavior().getRowHeight(rowIndex);
        return height;
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {number} The columnWidth of the column at index columnIndex
     * @param {number} columnIndex
     */
    getColumnWidth: function(columnIndex) {
        var width = this.getGrid().getColumnWidth(columnIndex);
        return width;
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {boolean} The last col was rendered (is visible)
     */
    isLastColumnVisible: function() {
        var lastColumnIndex = this.getColumnCount() - 1;
        var isMax = this.visibleColumns.indexOf(lastColumnIndex) !== -1;
        return isMax;
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {number} The rendered column width at index
     */
    getRenderedWidth: function(index) {
        return this.getColumnEdges()[index];
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {number} The rendered row height at index
     */
    getRenderedHeight: function(index) {
        return this.rowEdges[index];
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {fin-canvas} my [fin-canvas](https://github.com/stevewirts/fin-canvas)
     */
    getCanvas: function() {
        return this.getGrid().getCanvas();
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {boolean} User is currently dragging a column for reordering.
     */
    isDraggingColumn: function() {
        return this.getGrid().isDraggingColumn();
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {number} The row to goto for a page up.
     */
    getPageUpRow: function() {
        var behavior = this.getBehavior();
        var scrollHeight = this.getVisibleScrollHeight();
        var headerRows = this.getGrid().getFixedRowCount();
        var top = this.dataWindow.origin.y - headerRows;
        var scanHeight = 0;
        while (scanHeight < scrollHeight && top > -1) {
            scanHeight = scanHeight + behavior.getRowHeight(top);
            top--;
        }
        return top + 1;
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {number} The row to goto for a page down.
     */
    getPageDownRow: function() {
        var headerRows = this.getGrid().getFixedRowCount();
        var rowNum = this.dataWindow.corner.y - headerRows - 1;
        return rowNum;
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {number} The number of columns.
     */
    getColumnCount: function() {
        return this.getGrid().getColumnCount();
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {number} The number of rows.
     */
    getRowCount: function() {
        return this.getGrid().getRowCount();
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {number} The number of fixed columns.
     */
    getFixedColumnCount: function() {
        return this.getGrid().getFixedColumnCount();
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {number} The number of fixed rows.
     */
    getFixedRowCount: function() {
        return this.getGrid().getFixedRowCount();
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {number} The number of header rows.
     */
    getHeaderRowCount: function() {
        return this.getGrid().getHeaderRowCount();
    },

    /**
     * @memberOf Renderer.prototype
     * @returns {number} The number of header columns.
     */
    getHeaderColumnCount: function() {
        return this.getGrid().getHeaderColumnCount();
    },

    /**
     * @memberOf Renderer.prototype
     * @desc Dumb render the fixed columns along the left side.
     * @param {CanvasRenderingContext2D} gc - [CanvasRenderingContext2D](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D)
     */
    _paintCells: function(gc) {
        var x, y, c, r = 0;

        var columnEdges = this.getColumnEdges();
        var rowEdges = this.rowEdges;
        this.buttonCells = {};
        var visibleCols = this.getVisibleColumns();
        var visibleRows = this.getVisibleRows();

        var width = columnEdges[columnEdges.length - 1];
        var height = rowEdges[rowEdges.length - 1];

        gc.moveTo(0, 0);
        gc.rect(0, 0, width, height);
        gc.stroke();
        gc.clip();

        var loopLength = visibleCols.length;
        var loopStart = 0;

        if (this.getGrid().isShowRowNumbers()) {
            //loopLength++;
            loopStart--;
        }

        for (x = loopStart; x < loopLength; x++) {
            c = visibleCols[x];
            this.renderedColumnMinWidths[c] = 0;
            for (y = 0; y < visibleRows.length; y++) {
                r = visibleRows[y];
                this._paintCell(gc, c, r);
            }
        }

        setNumberColumnWidth(gc, this.getBehavior(), this.getGrid().getRowCount());
    },

    /**
     * @memberOf Renderer.prototype
     * @desc We opted to not paint borders for each cell as that was extremely expensive. Instead we draw gridlines here. Also we record the widths and heights for later.
     * @param {CanvasRenderingContext2D} gc - [CanvasRenderingContext2D](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D)
     */
    paintGridlines: function(gc) {
        var x, y, c, r = 0;

        var colWidths = this.getColumnEdges();
        var rowHeights = this.rowEdges;

        var viewWidth = colWidths[colWidths.length - 1];
        var viewHeight = rowHeights[rowHeights.length - 1];

        var drawThemH = this.resolveProperty('gridLinesH');
        var drawThemV = this.resolveProperty('gridLinesV');
        var lineColor = this.resolveProperty('lineColor');

        gc.beginPath();
        gc.strokeStyle = lineColor;
        gc.lineWidth = this.resolveProperty('lineWidth');
        gc.moveTo(0, 0);

        if (drawThemV) {
            for (c = 0; c < colWidths.length + 1; c++) {
                x = colWidths[c] + 0.5;
                gc.moveTo(x, 0);
                gc.lineTo(x, viewHeight);
            }
        }

        if (drawThemH) {
            for (r = 0; r < rowHeights.length; r++) {
                y = rowHeights[r] + 0.5;
                gc.moveTo(0, y);
                gc.lineTo(viewWidth, y);
            }
        }
        gc.stroke();
        gc.closePath();
    },

    /**
     * @memberOf Renderer.prototype
     * @param {CanvasRenderingContext2D} gc
     * @param x
     * @param y
     */
    paintCell: function(gc, x, y) {
        gc.moveTo(0, 0);

        var c = this.getVisibleColumns()[x],
            r = this.getVisibleRows()[y];

        if (c) { //something is being viewed at at the moment (otherwise returns undefined)
            this._paintCell(gc, c, r);
        }
    },

    _paintCell: function(gc, c, r) {

        var grid = this.getGrid();
        var behavior = this.getBehavior();
        var baseProperties = behavior.getColumnProperties(c);

        if (baseProperties.isNull) {
            return;
        }

        var columnProperties = baseProperties;
        var headerRowCount = behavior.getHeaderRowCount();
        //var headerColumnCount = behavior.getHeaderColumnCount();

        var isShowRowNumbers = grid.isShowRowNumbers();
        var isHeaderRow = r < headerRowCount;
        //var isHeaderColumn = c < headerColumnCount;
        var isFilterRow = grid.isFilterRow(r);
        var isHierarchyColumn = grid.isHierarchyColumn(c);
        var isRowSelected = grid.isRowSelected(r);
        var isColumnSelected = grid.isColumnSelected(c);
        var isCellSelected = grid.isCellSelected(c, r);
        var isCellSelectedInColumn = grid.isCellSelectedInColumn(c);
        var isCellSelectedInRow = grid.isCellSelectedInRow(r);
        var areAllRowsSelected = grid.areAllRowsSelected();

        var cellProperties;

        if ((isShowRowNumbers && c === -1) || isHierarchyColumn) {
            if (isRowSelected) {
                baseProperties = baseProperties.rowHeaderRowSelection;
                cellProperties = Object.create(baseProperties);
                cellProperties.isSelected = true;
            } else {
                baseProperties = baseProperties.rowHeader;
                cellProperties = Object.create(baseProperties);
                cellProperties.isSelected = isCellSelectedInRow;
            }
            cellProperties.isUserDataArea = false;
        } else if (isHeaderRow) {
            if (isFilterRow) {
                baseProperties = baseProperties.filterProperties;
                cellProperties = Object.create(baseProperties);
                cellProperties.isSelected = false;
            } else if (isColumnSelected) {
                baseProperties = baseProperties.columnHeaderColumnSelection;
                cellProperties = Object.create(baseProperties);
                cellProperties.isSelected = true;
            } else {
                baseProperties = baseProperties.columnHeader;
                cellProperties = Object.create(baseProperties);
                cellProperties.isSelected = isCellSelectedInColumn;
            }
            cellProperties.isUserDataArea = false;
        } else if (isHierarchyColumn) {
            baseProperties = baseProperties.rowHeader;
            cellProperties = Object.create(baseProperties);
            cellProperties.isSelected = isCellSelectedInRow;
        } else {
            cellProperties = Object.create(baseProperties);
            cellProperties.isSelected = isCellSelected || isRowSelected || isColumnSelected;
            cellProperties.isUserDataArea = true;
        }

        var rowNum = r - headerRowCount + 1;

        if (c === -1) {
            var checkedImage = isRowSelected ? 'checked' : 'unchecked';
            cellProperties.value = isHeaderRow ? '' : [behavior.getImage(checkedImage), rowNum, null];
            if (r === 0) {
                checkedImage = areAllRowsSelected ? 'checked' : 'unchecked';
                cellProperties.value = [behavior.getImage(checkedImage), '', null];
            } else if (isFilterRow) {
                cellProperties.value = [behavior.getImage('filter-off'), '', null];
            }
            cellProperties.halign = 'right';
        } else {
            cellProperties.value = grid.getValue(c, r);
            cellProperties.halign = grid.getColumnAlignment(c);
        }
        cellProperties.isColumnHovered = this.isRowHovered(c, r);
        cellProperties.isRowHovered = this.isColumnHovered(c, r);
        cellProperties.bounds = this._getBoundsOfCell(c, r);
        cellProperties.isCellSelected = isCellSelected;
        cellProperties.isRowSelected = isRowSelected;
        cellProperties.isColumnSelected = isColumnSelected;
        cellProperties.isInCurrentSelectionRectangle = grid.isInCurrentSelectionRectangle(c, r);

        var mouseDownState = grid.mouseDownState;
        if (mouseDownState) {
            var point = mouseDownState.gridCell;
            cellProperties.mouseDown = point.x === c && point.y === r;
        }

        cellProperties.x = c;
        cellProperties.y = r;

        behavior.cellPropertiesPrePaintNotification(cellProperties);

        var cell = behavior.getCellRenderer(cellProperties, c, r);
        var overrides = behavior.getCellProperties(c, r);

        //declarative cell properties
        _(cellProperties).extendOwn(overrides);

        //allow the renderer to identify itself if it's a button
        cellProperties.buttonCells = this.buttonCells;

        cell.paint(gc, cellProperties);

        this.renderedColumnMinWidths[c] = Math.max(cellProperties.minWidth || 0, this.renderedColumnMinWidths[c]);
        columnProperties.preferredWidth = this.renderedColumnMinWidths[c];
    },

    isViewableButton: function(c, r) {
        var key = c + ',' + r;
        return this.buttonCells[key] === true;
    },

    getRowNumbersWidth: function() {
        var colEdges = this.getColumnEdges();
        if (colEdges.length === 0) {
            return 0;
        }
        return colEdges[0];
    },

    startAnimator: function() {
        var animate;
        var self = this;
        animate = function() {
            self.animate();
            requestAnimationFrame(animate);
        };
        requestAnimationFrame(animate);
    },

    animate: function() {
        var ctx = this.getCanvas().canvasCTX;
        ctx.beginPath();
        ctx.save();
        this.renderFocusCell(ctx);
        ctx.restore();
        ctx.closePath();
    },

    getBounds: function() {
        return this.bounds;
    },

    setBounds: function(bounds) {
        return (this.bounds = bounds);
    }

});

function setNumberColumnWidth(gc, behavior, maxRow) {
    var columnProperties = behavior.getColumnProperties(-1),
        cellProperties = columnProperties.rowHeader,
        icon = behavior.getImage('checked');

    gc.font = cellProperties.font;

    columnProperties.preferredWidth = icon.width + 7 + cellProperties.getTextWidth(gc, maxRow + 1);
}

module.exports = Renderer;

},{"extend-me":3,"object-iterators":28}],35:[function(require,module,exports){
'use strict';

var RangeSelectionModel = require('sparse-boolean-array');

/**
 *
 * @constructor
 * @desc We represent selections as a list of rectangles because large areas can be represented and tested against quickly with a minimal amount of memory usage. Also we need to maintain the selection rectangles flattened counter parts so we can test for single dimension contains. This is how we know to highlight the fixed regions on the edges of the grid.
 */

function SelectionModel() {

    /**
     * @name selections
     * @type {Rectangle[]}
     * @summary The selection rectangles.
     * @desc Created as an empty array upon instantiation by the {@link SelectionModel|constructor}.
     * @memberOf SelectionModel.prototype
     */
    this.selections = [];

    /**
     * @name flattenedX
     * @type {Rectangle[]}
     * @summary The selection rectangles flattened in the horizontal direction (no width).
     * @desc Created as an empty array upon instantiation by the {@link SelectionModel|constructor}.
     * @memberOf SelectionModel.prototype
     */
    this.flattenedX = [];

    /**
     * @name flattenedY
     * @type {Rectangle[]}
     * @summary The selection rectangles flattened in the vertical direction (no height).
     * @desc Created as an empty array upon instantiation by the {@link SelectionModel|constructor}.
     * @memberOf SelectionModel.prototype
     */
    this.flattenedY = [];

    /**
     * @name rowSelectionModel
     * @type {RangeSelectionModel}
     * @summary The selection rectangles.
     * @desc Created as a new RangeSelectionModel upon instantiation by the {@link SelectionModel|constructor}.
     * @memberOf SelectionModel.prototype
     */
    this.rowSelectionModel = new RangeSelectionModel();

    /**
     * @name columnSelectionModel
     * @type {RangeSelectionModel}
     * @summary The selection rectangles.
     * @desc Created as a new RangeSelectionModel upon instantiation by the {@link SelectionModel|constructor}.
     * @memberOf SelectionModel.prototype
     */
    this.columnSelectionModel = new RangeSelectionModel();

    this.setLastSelectionType('');
}

SelectionModel.prototype = {

    /**
     * @type {boolean}
     * @memberOf SelectionModel.prototype
     */
    allRowsSelected: false,

    /**
     * @memberOf SelectionModel.prototype
     * @desc getter for the [fin-hypergrid](module-._fin-hypergrid.html)
     * #### returns: fin-hypergrid
     */
    getGrid: function() {
        return null;
    },

    /**
     * @memberOf SelectionModel.prototype
     * @returns {*}
     */
    getLastSelection: function() {
        var sels = this.selections;
        var sel = sels[sels.length - 1];
        return sel;
    },

    /**
     * @memberOf SelectionModel.prototype
     * @returns {*}
     */
    getLastSelectionType: function() {
        return this.lastSelectionType;
    },

    /**
     * @param type
     * @memberOf SelectionModel.prototype
     */
    setLastSelectionType: function(type) {
        this.lastSelectionType = type;
    },

    /**
     * @memberOf SelectionModel.prototype
     * @description Select the region described by the given coordinates.
     *
     * @param {number} ox - origin x coordinate
     * @param {number} oy - origin y coordinate
     * @param {number} ex - extent x coordinate
     * @param {number} ey - extent y coordinate
     */
    select: function(ox, oy, ex, ey) {
        var newSelection = this.getGrid().newRectangle(ox, oy, ex, ey);
        this.selections.push(newSelection);
        this.flattenedX.push(newSelection.flattenXAt(0));
        this.flattenedY.push(newSelection.flattenYAt(0));
        this.setLastSelectionType('cell');
        this.getGrid().selectionChanged();
    },

    /**
     * @memberOf SelectionModel.prototype
     * @param {number} ox - origin x coordinate
     * @param {number} oy - origin y coordinate
     * @param {number} ex - extent x coordinate
     * @param {number} ey - extent y coordinate
     */
    toggleSelect: function(ox, oy, ex, ey) {

        var selected, index;

        selected = this.selections.find(function(selection, idx) {
            index = idx;
            return (
                selection.origin.x === ox && selection.origin.y === oy &&
                selection.extent.x === ex && selection.extent.y === ey
            );
        });

        if (selected) {
            this.selections.splice(index, 1);
            this.flattenedX.splice(index, 1);
            this.flattenedY.splice(index, 1);
            this.getGrid().selectionChanged();
        } else {
            this.select(ox, oy, ex, ey);
        }
    },

    /**
     * @memberOf SelectionModel.prototype
     * @desc Remove the last selection that was created.
     */
    clearMostRecentSelection: function() {
        this.allRowsSelected = false;
        this.selections.length = Math.max(0, this.selections.length - 1);
        this.flattenedX.length = Math.max(0, this.flattenedX.length - 1);
        this.flattenedY.length = Math.max(0, this.flattenedY.length - 1);
        //this.getGrid().selectionChanged();
    },

    /**
     * @memberOf SelectionModel.prototype
     */
    clearMostRecentColumnSelection: function() {
        this.columnSelectionModel.clearMostRecentSelection();
        this.setLastSelectionType('column');
    },

    /**
     * @memberOf SelectionModel.prototype
     */
    clearMostRecentRowSelection: function() {
        this.rowSelectionModel.clearMostRecentSelection();
        this.setLastSelectionType('row');
    },

    /**
     * @memberOf SelectionModel.prototype
     */
    clearRowSelection: function() {
        this.rowSelectionModel.clear();
        this.setLastSelectionType('row');
    },

    /**
     * @memberOf SelectionModel.prototype
     * @returns {*}
     */
    getSelections: function() {
        return this.selections;
    },

    /**
     * @memberOf SelectionModel.prototype
     * @returns {boolean} There are active selection(s).
     */
    hasSelections: function() {
        return this.selections.length !== 0;
    },

    /**
     * @memberOf SelectionModel.prototype
     * @returns {boolean}
     */
    hasRowSelections: function() {
        return !this.rowSelectionModel.isEmpty();
    },

    /**
     * @memberOf SelectionModel.prototype
     * @returns {boolean}
     */
    hasColumnSelections: function() {
        return !this.columnSelectionModel.isEmpty();
    },

    /**
     * @memberOf SelectionModel.prototype
     * @return {boolean} Selection covers a specific column.
     * @param {number} y
     */
    isCellSelectedInRow: function(y) {
        return this._isCellSelected(this.flattenedX, 0, y);
    },

    /**
     * @memberOf SelectionModel.prototype
     * @returns Selection covers a specific row.
     * @param {number} x
     */
    isCellSelectedInColumn: function(x) {
        return this._isCellSelected(this.flattenedY, x, 0);
    },

    /**
     * @memberOf SelectionModel.prototype
     * @summary Selection query function.
     * @returns {boolean} The given cell is selected (part of an active selection).
     * @param {Rectangle[]} selections - Selection rectangles to search through.
     * @param {number} x
     * @param {number} y
     */
    isSelected: function(x, y) {
        return (
            this.isColumnSelected(x) ||
            this.isRowSelected(y) ||
            this._isCellSelected(this.selections, x, y)
        );
    },

    /**
     * @memberOf SelectionModel.prototype
     * @param x
     * @param y
     * @returns {*}
     */
    isCellSelected: function(x, y) {
        return this._isCellSelected(this.selections, x, y);
    },

    /**
     * @memberOf SelectionModel.prototype
     * @param selections
     * @param x
     * @param y
     * @returns {boolean}
     * @private
     */
    _isCellSelected: function(selections, x, y) {
        var self = this;
        return !!selections.find(function(selection) {
            return self.rectangleContains(selection, x, y);
        });
    },

    /**
     * @memberOf SelectionModel.prototype
     * @desc empty out all our state
     *
     */
    clear: function() {
        this.allRowsSelected = false;
        this.selections.length = 0;
        this.flattenedX.length = 0;
        this.flattenedY.length = 0;
        this.rowSelectionModel.clear();
        this.columnSelectionModel.clear();
        //this.getGrid().selectionChanged();
    },

    /**
     * @memberOf SelectionModel.prototype
     * @param {number} ox - origin x coordinate
     * @param {number} oy - origin y coordinate
     * @param {number} ex - extent x coordinate
     * @param {number} ey - extent y coordinate
     * @returns {boolean}
     */
    isRectangleSelected: function(ox, oy, ex, ey) {
        return !!this.selections.find(function(selection) {
            return (
                selection.origin.x === ox && selection.origin.y === oy &&
                selection.extent.x === ex && selection.extent.y === ey
            );
        });
    },

    /**
     * @memberOf SelectionModel.prototype
     * @param x
     * @returns {*}
     */
    isColumnSelected: function(x) {
        return this.columnSelectionModel.isSelected(x);
    },

    /**
     * @memberOf SelectionModel.prototype
     * @param y
     * @returns {boolean|*}
     */
    isRowSelected: function(y) {
        return this.allRowsSelected || this.rowSelectionModel.isSelected(y);
    },

    /**
     * @memberOf SelectionModel.prototype
     * @param x1
     * @param x2
     */
    selectColumn: function(x1, x2) {
        this.columnSelectionModel.select(x1, x2);
        this.setLastSelectionType('column');
    },

    /**
     * @memberOf SelectionModel.prototype
     */
    selectAllRows: function() {
        this.clear();
        this.allRowsSelected = true;
    },

    /**
     * @memberOf SelectionModel.prototype
     * @returns {boolean}
     */
    areAllRowsSelected: function() {
        return this.allRowsSelected;
    },

    /**
     * @memberOf SelectionModel.prototype
     * @param y1
     * @param y2
     */
    selectRow: function(y1, y2) {
        this.rowSelectionModel.select(y1, y2);
        this.setLastSelectionType('row');
    },

    /**
     * @memberOf SelectionModel.prototype
     * @param x1
     * @param x2
     */
    deselectColumn: function(x1, x2) {
        this.columnSelectionModel.deselect(x1, x2);
        this.setLastSelectionType('column');
    },

    /**
     * @memberOf SelectionModel.prototype
     * @param y1
     * @param y2
     */
    deselectRow: function(y1, y2) {
        this.rowSelectionModel.deselect(y1, y2);
        this.setLastSelectionType('row');
    },

    /**
     * @memberOf SelectionModel.prototype
     * @returns {*}
     */
    getSelectedRows: function() {
        if (this.areAllRowsSelected()) {
            var grid = this.getGrid();
            var headerRows = grid.getHeaderRowCount();
            var rowCount = grid.getRowCount() - headerRows;
            var result = new Array(rowCount);
            for (var i = 0; i < rowCount; i++) {
                result[i] = i + headerRows;
            }
            return result;
        }
        return this.rowSelectionModel.getSelections();
    },

    /**
     * @memberOf SelectionModel.prototype
     * @returns {*|Array.Array.number}
     */
    getSelectedColumns: function() {
        return this.columnSelectionModel.getSelections();
    },

    /**
     * @memberOf SelectionModel.prototype
     * @returns {boolean}
     */
     isColumnOrRowSelected: function() {
        return !this.columnSelectionModel.isEmpty() || !this.rowSelectionModel.isEmpty();
    },

    /**
     * @memberOf SelectionModel.prototype
     * @returns {Array}
     */
    getFlattenedYs: function() {
        var result = [];
        var set = {};
        this.selections.forEach(function(selection) {
            var top = selection.origin.y;
            var size = selection.extent.y + 1;
            for (var r = 0; r < size; r++) {
                var ti = r + top;
                if (!set[ti]) {
                    result.push(ti);
                    set[ti] = true;
                }
            }
        });
        result.sort(function(x, y) {
            return x - y;
        });
        return result;
    },

    /**
     * @memberOf SelectionModel.prototype
     * @param offset
     */
    selectRowsFromCells: function(offset) {
        offset = offset || 0;

        var sm = this.rowSelectionModel;
        this.allRowsSelected = false;
        sm.clear();

        this.selections.forEach(function(selection) {
            var top = selection.origin.y,
                size = selection.extent.y;
            sm.select(top + offset, top + size + offset);
        });
    },

    /**
     * @memberOf SelectionModel.prototype
     * @param offset
     */
    selectColumnsFromCells: function(offset) {
        offset = offset || 0;

        var sm = this.columnSelectionModel;
        sm.clear();

        this.selections.forEach(function(selection) {
            var left = selection.origin.x;
            var size = selection.extent.x;
            sm.select(left + offset, left + size + offset);
        });
    },

    /**
     * @memberOf SelectionModel.prototype
     * @param x
     * @param y
     * @returns {*}
     */
    isInCurrentSelectionRectangle: function(x, y) {
        var last = this.selections[this.selections.length - 1];
        return last && this.rectangleContains(last, x, y);
    },

    /**
     * @memberOf SelectionModel.prototype
     * @param rect
     * @param x
     * @param y
     * @returns {boolean}
     */
    rectangleContains: function(rect, x, y) { //TODO: explore why this works and contains on rectanglular does not
        var minX = rect.origin.x;
        var minY = rect.origin.y;
        var maxX = minX + rect.extent.x;
        var maxY = minY + rect.extent.y;

        if (rect.extent.x < 0) {
            minX = maxX;
            maxX = rect.origin.x;
        }

        if (rect.extent.y < 0) {
            minY = maxY;
            maxY = rect.origin.y;
        }

        var result =
            x >= minX &&
            y >= minY &&
            x <= maxX &&
            y <= maxY;

        return result;
    }
};

module.exports = SelectionModel;

},{"sparse-boolean-array":30}],36:[function(require,module,exports){
/* eslint-env browser */

'use strict';

var _ = require('object-iterators');
var Base = require('extend-me').Base;

var Column = require('./Column');
var images = require('./images');
var CellProvider = require('../CellProvider');

var noExportProperties = [
    'columnHeader',
    'columnHeaderColumnSelection',
    'filterProperties',
    'rowHeader',
    'rowHeaderRowSelection',
    'rowNumbersProperties',
    'treeColumnProperties',
    'treeColumnPropertiesColumnSelection',
];

/**
 * @constructor
 * @desc This is the base class for creating behaviors.  a behavior can be thought of as a model++.
it contains all code/data that's necessary for easily implementing a virtual data source and it's manipulation/analytics
 */
var Behavior = Base.extend('Behavior', {

    /**
     * @desc this is the callback for the plugin pattern of nested tags
     * @param {Hypergrid} grid
     * @memberOf Behavior.prototype
     */
    initialize: function(grid) { //formerly installOn
        grid.setBehavior(this);
        this.initializeFeatureChain(grid);

        this.getDataModel();
        this.cellProvider = this.createCellProvider();
        this.renderedColumnCount = 30;
        this.renderedRowCount = 60;
        this.dataUpdates = {}; //for overriding with edit values;
    },

    /**
     * @desc create the feature chain - this is the [chain of responsibility](http://c2.com/cgi/wiki?ChainOfResponsibilityPattern) pattern.
     * @param {Hypergrid} grid
     * @memberOf Behavior.prototype
     */
    initializeFeatureChain: function(grid) {
        var self = this;
        this.features.forEach(function(FeatureConstructor) {
            self.setNextFeature(new FeatureConstructor);
        });

        this.featureChain.initializeOn(grid);
    },

    features: [], // in case implementing class has no features TODO: Will this ever happen?

    /**
     * memento for the user configured visual properties of the table
     * @type {object}
     * @memberOf Behavior.prototype
     */
    tableState: null,

    /**
     * @type {Hypergrid}
     * @memberOf Behavior.prototype
     */
    grid: null,

    /**
     * list of default cell editor names
     * @type {string[]}
     * @memberOf Behavior.prototype
     */
    editorTypes: ['choice', 'textfield', 'color', 'slider', 'spinner', 'date'],

    /**
     * controller chain of command
     * @type {object}
     * @memberOf Behavior.prototype
     */
    featureChain: null,

    dataModel: null,
    baseModel: null,

    scrollPositionX: 0,
    scrollPositionY: 0,

    featureMap: {},
    allColumns: [],
    columns: [],

    reset: function() {

        this.cellProvider = this.createCellProvider();
        this.renderedColumnCount = 30;
        this.renderedRowCount = 60;
        this.dataUpdates = {}; //for overriding with edit values;
        this.clearColumns();
        this.clearState();
        this.getDataModel().reset();
        this.createColumns();
    },

    clearColumns: function() {
        this.columns = [];
        this.allColumns = [];
        this.columns[-1] = this.newColumn(-1, '');
        this.columns[-2] = this.newColumn(-2, 'Tree');
        this.allColumns[-1] = this.columns[-1];
        this.allColumns[-2] = this.columns[-2];
    },

    getColumn: function(x) {
        return this.columns[x];
    },

    getColumnId: function(x) {
        return this.getColumn(x).label;
    },

    newColumn: function(index, label) {
        var properties = this.createColumnProperties();
        this.getPrivateState().columnProperties[index] = properties;
        return new Column(this, index, label);
    },

    addColumn: function(index, label) {
        var column = this.newColumn(index, label);
        this.columns.push(column);
        this.allColumns.push(column);
        return column;
    },

    createColumns: function() {
        //concrete implementation here
    },

    createColumnProperties: function() {
        var tableState = this.getPrivateState();
        var properties = Object.create(tableState);

        properties.rowNumbersProperties = Object.create(properties, {
            foregroundSelectionColor: {
                configurable: true,
                get: function() {
                    return this.columnHeaderForegroundSelectionColor;
                },
                set: function(value) {
                    this.columnHeaderForegroundSelectionColor = value;
                }
            },
            backgroundSelectionColor: {
                configurable: true,
                get: function() {
                    return this.columnHeaderBackgroundSelectionColor;
                },
                set: function(value) {
                    this.columnHeaderBackgroundSelectionColor = value;
                }
            }
        });

        properties.rowHeader = Object.create(properties, {
            font: {
                configurable: true,
                get: function() {
                    return this.rowHeaderFont;
                },
                set: function(value) {
                    this.rowHeaderFont = value;
                }
            },
            color: {
                configurable: true,
                get: function() {
                    return this.rowHeaderColor;
                },
                set: function(value) {
                    this.rowHeaderColor = value;
                }
            },
            backgroundColor: {
                configurable: true,
                get: function() {
                    return this.rowHeaderBackgroundColor;
                },
                set: function(value) {
                    this.rowHeaderBackgroundColor = value;
                }
            },
            foregroundSelectionColor: {
                configurable: true,
                get: function() {
                    return this.rowHeaderForegroundSelectionColor;
                },
                set: function(value) {
                    this.rowHeaderForegroundSelectionColor = value;
                }
            },
            backgroundSelectionColor: {
                configurable: true,
                get: function() {
                    return this.rowHeaderBackgroundSelectionColor;
                },
                set: function(value) {
                    this.rowHeaderBackgroundSelectionColor = value;
                }
            }
        });

        properties.columnHeader = Object.create(properties, {
            font: {
                configurable: true,
                get: function() {
                    return this.columnHeaderFont;
                },
                set: function(value) {
                    this.columnHeaderFont = value;
                }
            },
            color: {
                configurable: true,
                get: function() {
                    return this.columnHeaderColor;
                },
                set: function(value) {
                    this.columnHeaderColor = value;
                }
            },
            backgroundColor: {
                configurable: true,
                get: function() {
                    return this.columnHeaderBackgroundColor;
                },
                set: function(value) {
                    this.columnHeaderBackgroundColor = value;
                }
            },
            foregroundSelectionColor: {
                configurable: true,
                get: function() {
                    return this.columnHeaderForegroundSelectionColor;
                },
                set: function(value) {
                    this.columnHeaderForegroundSelectionColor = value;
                }
            },
            backgroundSelectionColor: {
                configurable: true,
                get: function() {
                    return this.columnHeaderBackgroundSelectionColor;
                },
                set: function(value) {
                    this.columnHeaderBackgroundSelectionColor = value;
                }
            }
        });

        properties.columnHeaderColumnSelection = Object.create(properties.columnHeader, {
            foregroundSelectionColor: {
                configurable: true,
                get: function() {
                    return this.columnHeaderForegroundColumnSelectionColor;
                },
                set: function(value) {
                    this.columnHeaderForegroundColumnSelectionColor = value;
                }
            },
            backgroundSelectionColor: {
                configurable: true,
                get: function() {
                    return this.columnHeaderBackgroundColumnSelectionColor;
                },
                set: function(value) {
                    this.columnHeaderBackgroundColumnSelectionColor = value;
                }
            }
        });

        properties.rowHeaderRowSelection = Object.create(properties.rowHeader, {
            foregroundSelectionColor: {
                configurable: true,
                get: function() {
                    return this.rowHeaderForegroundRowSelectionColor;
                },
                set: function(value) {
                    this.rowHeaderForegroundRowSelectionColor = value;
                }
            },
            backgroundSelectionColor: {
                configurable: true,
                get: function() {
                    return this.rowHeaderBackgroundRowSelectionColor;
                },
                set: function(value) {
                    this.rowHeaderBackgroundRowSelectionColor = value;
                }
            }
        });

        properties.filterProperties = Object.create(properties, {
            font: {
                configurable: true,
                get: function() {
                    return this.filterFont;
                },
                set: function(value) {
                    this.filterFont = value;
                }
            },
            color: {
                configurable: true,
                get: function() {
                    return this.filterColor;
                },
                set: function(value) {
                    this.filterColor = value;
                }
            },
            backgroundColor: {
                configurable: true,
                get: function() {
                    return this.filterBackgroundColor;
                },
                set: function(value) {
                    this.filterBackgroundColor = value;
                }
            },
            foregroundSelectionColor: {
                configurable: true,
                get: function() {
                    return this.filterForegroundSelectionColor;
                },
                set: function(value) {
                    this.filterForegroundSelectionColor = value;
                }
            },
            backgroundSelectionColor: {
                configurable: true,
                get: function() {
                    return this.filterBackgroundSelectionColor;
                },
                set: function(value) {
                    this.filterBackgroundSelectionColor = value;
                }
            },
            cellBorderStyle: {
                configurable: true,
                get: function() {
                    return this.filterCellBorderStyle;
                },
                set: function(value) {
                    this.filterCellBorderStyle = value;
                }
            },
            cellBorderThickness: {
                configurable: true,
                get: function() {
                    return this.filterCellBorderThickness;
                },
                set: function(value) {
                    this.filterCellBorderThickness = value;
                }
            }
        });

        properties.treeColumnProperties = Object.create(properties, {
            font: {
                configurable: true,
                get: function() {
                    return this.treeColumnFont;
                },
                set: function(value) {
                    this.treeColumnFont = value;
                }
            },
            color: {
                configurable: true,
                get: function() {
                    return this.treeColumnColor;
                },
                set: function(value) {
                    this.treeColumnColor = value;
                }
            },
            backgroundColor: {
                configurable: true,
                get: function() {
                    return this.treeColumnBackgroundColor;
                },
                set: function(value) {
                    this.treeColumnBackgroundColor = value;
                }
            },
            foregroundSelectionColor: {
                configurable: true,
                get: function() {
                    return this.treeColumnForegroundSelectionColor;
                },
                set: function(value) {
                    this.treeColumnForegroundSelectionColor = value;
                }
            },
            backgroundSelectionColor: {
                configurable: true,
                get: function() {
                    return this.treeColumnBackgroundSelectionColor;
                },
                set: function(value) {
                    this.treeColumnBackgroundSelectionColor = value;
                }
            }
        });

        properties.treeColumnPropertiesColumnSelection = Object.create(properties.treeColumnProperties, {
            foregroundSelectionColor: {
                configurable: true,
                get: function() {
                    return this.treeColumnForegroundColumnSelectionColor;
                },
                set: function(value) {
                    this.treeColumnForegroundColumnSelectionColor = value;
                }
            },
            backgroundSelectionColor: {
                configurable: true,
                get: function() {
                    return this.treeColumnBackgroundColumnSelectionColor;
                },
                set: function(value) {
                    this.treeColumnBackgroundColumnSelectionColor = value;
                }
            }
        });

        return properties;
    },

    getColumnWidth: function(x) {
        var col = this.getColumn(x);
        if (!col) {
            return this.resolveProperty('defaultColumnWidth');
        }
        var width = col.getWidth();
        return width;
    },

    setColumnWidth: function(x, width) {
        this.getColumn(x).setWidth(width);
        this.stateChanged();
    },

    getDataModel: function() {
        if (this.dataModel === null) {
            var dataModel = this.getDefaultDataModel();
            this.setDataModel(dataModel);
        }
        return this.dataModel;
    },

    getCellRenderer: function(config, x, y) {
        return this.getColumn(x).getCellRenderer(config, y);
    },

    setDataModel: function(newDataModel) {
        this.dataModel = newDataModel;
    },

    /**
     * @memberOf Behavior.prototype
     * @desc utility function to empty an object of its members
     * @param {object} obj - the object to empty
     * @param {boolean} [exportProps]
     * * `undefined` (omitted) - delete *all* properties
     * * **falsy** - delete *only* the export properties
     * * **truthy** - delete all properties *except* the export properties
     */
    clearObjectProperties: function(obj, exportProps) {
        for (var key in obj) {
            if (
                obj.hasOwnProperty(key) && (
                    exportProps === undefined ||
                    !exportProps && noExportProperties.indexOf(key) >= 0 ||
                    exportProps && noExportProperties.indexOf(key) < 0
                )
            ) {
                delete obj[key];
            }
        }
    },

    /**
     * @memberOf Behavior.prototype
     * @desc getter for a [Memento](http://c2.com/cgi/wiki?MementoPattern) Object
     * @returns {object}
     */
    getPrivateState: function() {
        if (!this.tableState) {
            this.tableState = this.getDefaultState();
        }
        return this.tableState;
    },

    //this is effectively a clone, with certain things removed....
    getState: function() {
        var copy = JSON.parse(JSON.stringify(this.getPrivateState()));
        this.clearObjectProperties(copy.columnProperties, true);
        return copy;
    },
    /**
     * @memberOf Behavior.prototype
     * @desc clear all table state
     */
    clearState: function() {
        this.tableState = null;
    },

    /**
     * @memberOf Behavior.prototype
     * @return {object} Newly created default empty tablestate.
     */
    getDefaultState: function() {
        var tableProperties = this.getGrid()._getProperties();
        var state = Object.create(tableProperties);

        _(state).extendOwn({
            rowHeights: {},
            cellProperties: {},
            columnProperties: []
        });

        return state;
    },

    /**
     * @memberOf Behavior.prototype
     * @desc Restore this table to a previous state.
     * See the [memento pattern](http://c2.com/cgi/wiki?MementoPattern).
     * @param {Object} memento - an encapsulated representation of table state
     */
    setState: function(memento) {

        //we don't want to clobber the column properties completely
        if (!memento.columnIndexes) {
            var fields = this.getFields();
            memento.columnIndexes = [];
            for (var i = 0; i < fields.length; i++) {
                memento.columnIndexes[i] = i;
            }
        }
        var colProperties = memento.columnProperties;
        delete memento.columnProperties;
        this.tableState = null;
        var state = this.getPrivateState();
        this.createColumns();
        this.setColumnOrder(memento.columnIndexes);
        _(state).extendOwn(memento);
        this.setAllColumnProperties(colProperties);
        memento.columnProperties = colProperties;
        //memento.columnProperties = colProperties;

        // this.getDataModel().setState(memento);
        // var self = this;
        // requestAnimationFrame(function() {
        //     self.applySorts();
        //     self.changed();
        //     self.stateChanged();
        // });

        //just to be close/ it's easier on the eyes
        this.setColumnWidth(-1, 24.193359375);
        this.getDataModel().applyState();
    },

    setAllColumnProperties: function(properties) {
        properties = properties || [];
        for (var i = 0; i < properties.length; i++) {
            var current = this.getPrivateState().columnProperties[i];
            this.clearObjectProperties(current, false);
            _(current).extendOwn(properties[i]);
        }
    },

    setColumnOrder: function(indexes) {
        if (!indexes) {
            this.columns.length = 0;
            return;
        }
        this.columns.length = indexes.length;
        for (var i = 0; i < indexes.length; i++) {
            this.columns[i] = this.allColumns[indexes[i]];
        }
    },

    applySorts: function() {
        //if I have sorts, apply them now//
    },

    /**
     * @memberOf Behavior.prototype
     * @desc fetch the value for a property key
     * @returns {*} The value of the given property.
     * @param {string} key - a property name
     */
    resolveProperty: function(key) {
        return this.grid.resolveProperty(key);
    },

    /**
     * @memberOf Behavior.prototype
     * @desc A specific cell was clicked; you've been notified.
     * @param {Point} cell - point of cell coordinates
     * @param {Object} event - all event information
     */
    cellClicked: function(cell, event) {
        this.getDataModel().cellClicked(cell, event);
    },

    /**
     * @memberOf Behavior.prototype
     * @desc A specific cell was le double-clicked; you've been notified.
     * @param {Point} cell - point of cell coordinates
     * @param {Object} event - all event information
     */
    cellDoubleClicked: function(cell, event) {

    },

    /**
     * @memberOf Behavior.prototype
     * @desc add nextFeature to me If I don't have a next node, otherwise pass it along
     * @param {Feature}
     */
    setNextFeature: function(nextFeature) {
        this.featureMap[nextFeature.alias] = nextFeature;
        if (this.featureChain) {
            this.featureChain.setNext(nextFeature);
        } else {
            this.featureChain = nextFeature;
        }
    },

    lookupFeature: function(key) {
        return this.featureMap[key];
    },

    /**
     * @memberOf Behavior.prototype
     * @desc getter for the cell provider
     * @return {CellProvider}
     */
    getCellProvider: function() {
        return this.cellProvider;
    },

    /**
     * @memberOf Behavior.prototype
     * @desc setter for the hypergrid
     * @param {Hypergrid} grid
     */
    setGrid: function(finGrid) {
        this.grid = finGrid;
        this.getDataModel().setGrid(finGrid);
        this.clearColumns();
    },

    /**
     * @memberOf Behavior.prototype
     * @returns: {Hypergrid} The hypergrid to which this behavior is attached.
     * @param {type} varname - descripton
     */
    getGrid: function() {
        return this.grid;
    },

    /**
     * @memberOf Behavior.prototype
     * @desc You can override this function and substitute your own cell provider.
     * @return {CellProvider}
     */
    createCellProvider: function() {
        return new CellProvider();
    },

    /**
     * @memberOf Behavior.prototype
     * @desc First check to see if something was overridden.
     * @return {*} The value at `x,y` for the top left section of the hypergrid.
     * @param {number} x - x coordinate
     * @param {number} y - y coordinate
     */
    getValue: function(x, y) {
        var column = this.getColumn(x);
        if (!column) {
            return undefined;
        }
        return column.getValue(y);
    },

    /**
     * @memberOf Behavior.prototype
     * @desc update the data at point x, y with value
     * @return The data.
     * @param {number} x - x coordinate
     * @param {number} y - y coordinate
     * @param {Object} value - the value to use
     */
    setValue: function(x, y, value) {
        var column = this.getColumn(x);
        if (!column) {
            return;
        }
        return column.setValue(y, value);
    },

    getDataValue: function(x, y) {
        return this.getDataModel().getValue(x, y);
    },

    setDataValue: function(x, y, value) {
        this.getDataModel().setValue(x, y, value);
    },
    /**
     * @memberOf Behavior.prototype
     * @desc First checks to see if something was overridden.
     * @return {*} The value at x,y for the top left section of the hypergrid.
     * @param {number} x - x coordinate
     * @param {number} y - y coordinate
     */
    getCellProperties: function(x, y) {
        var col = this.getColumn(x);
        return col.getCellProperties(y);
    },

    /**
     * @memberOf Behavior.prototype
     * @desc update the data at point x, y with value
     * @param {number} x - x coordinate
     * @param {number} y - y coordinate
     * @param {Object} value - the value to use
     */
    setCellProperties: function(x, y, value) {
        var col = this.getColumn(x);
        if (col) {
            col.setCellProperties(y, value);
        }
    },
    /**
     * @memberOf Behavior.prototype
     * @return {number} The number of rows in the hypergrid.
     */
    getRowCount: function() {
        return this.getDataModel().getRowCount();
    },

    /**
     * @memberOf Behavior.prototype
     * @return {number} The height in pixels of the fixed rows area  of the hypergrid.
     */
    getFixedRowsHeight: function() {
        var count = this.getFixedRowCount();
        var total = 0;
        for (var i = 0; i < count; i++) {
            total = total + this.getRowHeight(i);
        }
        return total;
    },

    /**
     * @memberOf Behavior.prototype
     * @return {number} The height in pixels of a specific row in the hypergrid.
     * @param {number} rowNum - row index of interest
     */
    getRowHeight: function(rowNum) {
        var tableState = this.getPrivateState();
        if (tableState.rowHeights) {
            var override = tableState.rowHeights[rowNum];
            if (override) {
                return override;
            }
        }
        return this.getDefaultRowHeight();
    },

    /**
     * @memberOf Behavior.prototype
     * @desc The value is lazily initialized and comes from the properties mechanism for '`defaultRowHeight`', which should be ~20px.
     * @returns {number} The row height in pixels.
     */
    getDefaultRowHeight: function() {
        if (!this.defaultRowHeight) {
            this.defaultRowHeight = this.resolveProperty('defaultRowHeight');
        }
        return this.defaultRowHeight;
    },

    /**
     * @memberOf Behavior.prototype
     * @desc set the pixel height of a specific row
     * @param {number} rowNum - the row index of interest
     * @param {number} height - pixel height
     */
    setRowHeight: function(rowNum, height) {
        var tableState = this.getPrivateState();
        tableState.rowHeights[rowNum] = Math.max(5, height);
        this.stateChanged();
    },

    /**
     * @memberOf Behavior.prototype
     * @desc This will allow 'floating' fixed rows.
     * @return {number} The maximum height of the fixed rows area in the hypergrid.
     */
    getFixedRowsMaxHeight: function() {
        return this.getFixedRowsHeight();
    },

    /**
     * @memberOf Behavior.prototype
     * @return {number} The width of the fixed column area in the hypergrid.
     */
    getFixedColumnsWidth: function() {
        var count = this.getFixedColumnCount();
        var total = 0;
        if (this.getGrid().isShowRowNumbers()) {
            total = this.getColumnWidth(-1);
        }
        for (var i = 0; i < count; i++) {
            total = total + this.getColumnWidth(i);
        }
        return total;
    },

    /**
     * @memberOf Behavior.prototype
     * @desc This exists to support "floating" columns.
     * @return {number} The total width of the fixed columns area.
     */
    getFixedColumnsMaxWidth: function() {
        var width = this.getFixedColumnsWidth();
        return width;
    },

    /**
     * @memberOf Behavior.prototype
     * @desc Set the scroll position in vertical dimension and notify listeners.
     * @param {number} y - the new y value
     */
    _setScrollPositionY: function(y) {
        this.setScrollPositionY(y);
        this.changed();
    },

    /**
     * @memberOf Behavior.prototype
     * @desc Set the scroll position in horizontal dimension and notify listeners.
     * @param {number} x - the new x value
     */
    _setScrollPositionX: function(x) {
        this.setScrollPositionX(x);
        this.changed();
    },

    /**
     * @memberOf Behavior.prototype
     * @desc Set the number of columns just rendered, including partially rendered columns.
     * @param {number} count - how many columns were just rendered
     */
    setRenderedColumnCount: function(count) {
        this.renderedColumnCount = count;
    },

    /**
     * @memberOf Behavior.prototype
     * @desc Set the number of rows just rendered, including partially rendered rows.
     * @param {number} count - how many rows were just rendered
     */
    setRenderedRowCount: function(count) {
        this.renderedRowCount = count;
    },


    /**
     * @memberOf Behavior.prototype
     * @desc The fixed row area has been clicked, massage the details and call the real function.
     * @param {Hypergrid} grid
     * @param {Object} mouse - event details
     */
    _fixedRowClicked: function(grid, mouse) {
        var x = this.translateColumnIndex(this.getScrollPositionX() + mouse.gridCell.x - this.getFixedColumnCount());
        var translatedPoint = this.grid.newPoint(x, mouse.gridCell.y);
        mouse.gridCell = translatedPoint;
        this.fixedRowClicked(grid, mouse);
    },

    /**
     * @memberOf Behavior.prototype
     * @desc The fixed column area has been clicked, massage the details and call the real function.
     * @param {Hypergrid} grid
     * @param {Object} mouse - event details
     */
    _fixedColumnClicked: function(grid, mouse) {
        var translatedPoint = this.grid.newPoint(mouse.gridCell.x, this.getScrollPositionY() + mouse.gridCell.y - this.getFixedRowCount());
        mouse.gridCell = translatedPoint;
        this.fixedColumnClicked(grid, mouse);
    },

    moveSingleSelect: function(grid, x, y) {
        if (this.featureChain) {
            this.featureChain.moveSingleSelect(grid, x, y);
            this.setCursor(grid);
        }
    },

    /**
     * @memberOf Behavior.prototype
     * @desc delegate setting the cursor up the feature chain of responsibility
     * @param {Hypergrid} grid
     */
    setCursor: function(grid) {
        grid.updateCursor();
        this.featureChain.setCursor(grid);
    },

    /**
     * @memberOf Behavior.prototype
     * @desc delegate handling mouse move to the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    onMouseMove: function(grid, event) {
        if (this.featureChain) {
            this.featureChain.handleMouseMove(grid, event);
            this.setCursor(grid);
        }
    },

    /**
     * @memberOf Behavior.prototype
     * @desc delegate handling tap to the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    onTap: function(grid, event) {

        if (this.featureChain) {
            this.featureChain.handleTap(grid, event);
            this.setCursor(grid);
        }
    },

    /**
     * @memberOf Behavior.prototype
     * @desc delegate handling tap to the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    onContextMenu: function(grid, event) {
        var proceed = grid.fireSyntheticContextMenuEvent(event);
        if (proceed && this.featureChain) {
            this.featureChain.handleContextMenu(grid, event);
            this.setCursor(grid);
        }
    },

    /**
     * @memberOf Behavior.prototype
     * @desc delegate handling wheel moved to the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    onWheelMoved: function(grid, event) {
        if (this.featureChain) {
            this.featureChain.handleWheelMoved(grid, event);
            this.setCursor(grid);
        }
    },

    /**
     * @memberOf Behavior.prototype
     * @desc delegate handling mouse up to the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    onMouseUp: function(grid, event) {
        if (this.featureChain) {
            this.featureChain.handleMouseUp(grid, event);
            this.setCursor(grid);
        }
    },

    /**
     * @memberOf Behavior.prototype
     * @desc delegate handling mouse drag to the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    onMouseDrag: function(grid, event) {
        if (this.featureChain) {
            this.featureChain.handleMouseDrag(grid, event);
            this.setCursor(grid);
        }
    },

    /**
     * @memberOf Behavior.prototype
     * @desc delegate handling key down to the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    onKeyDown: function(grid, event) {
        if (this.featureChain) {
            this.featureChain.handleKeyDown(grid, event);
            this.setCursor(grid);
        }
    },

    /**
     * @memberOf Behavior.prototype
     * @desc delegate handling key up to the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    onKeyUp: function(grid, event) {
        if (this.featureChain) {
            this.featureChain.handleKeyUp(grid, event);
            this.setCursor(grid);
        }
    },

    /**
     * @memberOf Behavior.prototype
     * @desc delegate handling double click to the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    onDoubleClick: function(grid, event) {
        if (this.featureChain) {
            this.featureChain.handleDoubleClick(grid, event);
            this.setCursor(grid);
        }
    },

    /**
     * @memberOf Behavior.prototype
     * @desc delegate handling hold pulse to the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    onHoldPulse: function(grid, event) {
        if (this.featureChain) {
            this.featureChain.handleHoldPulse(grid, event);
            this.setCursor(grid);
        }
    },

    /**
     * @memberOf Behavior.prototype
     * @desc delegate handling double click to the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    toggleColumnPicker: function() {
        if (this.featureChain) {
            this.featureChain.toggleColumnPicker(this.getGrid());
        }
    },

    /**
     * @memberOf Behavior.prototype
     * @desc delegate handling mouse down to the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseDown: function(grid, event) {
        if (this.featureChain) {
            this.featureChain.handleMouseDown(grid, event);
            this.setCursor(grid);
        }
    },

    /**
     * @memberOf Behavior.prototype
     * @desc delegate handling mouse exit to the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseExit: function(grid, event) {
        if (this.featureChain) {
            this.featureChain.handleMouseExit(grid, event);
            this.setCursor(grid);
        }
    },

    /**
     * @memberOf Behavior.prototype
     * @desc this function is replaced by the grid on initialization and serves as the callback
     */
    changed: function() {},

    /**
     * @memberOf Behavior.prototype
     * @desc this function is replaced by the grid on initialization and serves as the callback
     */
    shapeChanged: function() {},

    /**
     * @memberOf Behavior.prototype
     * @return {boolean} Can re-order columns.
     */
    isColumnReorderable: function() {
        return true;
    },

    /**
     * @memberOf Behavior.prototype
     * @return {Object} The properties for a specific column. These are used if no cell properties are specified.
     * @param {index} columnIndex - the column index of interest
     */
    getColumnProperties: function(columnIndex) {
        var col = this.columns[columnIndex];
        if (!col) {
            return {
                isNull: true
            };
        }
        var properties = col.getProperties(); //TODO: returns `null` on Hypergrid.reset();
        if (!properties) {
            return {
                isNull: true
            };
        }
        return properties;
    },
    setColumnProperties: function(columnIndex, properties) {
        var columnProperties = this.getColumnProperties(columnIndex);
        _(columnProperties).extendOwn(properties);
        this.changed();
    },

    /**
     * @memberOf Behavior.prototype
     * @return {strings[]} Labels to use for the column picker.
     */
    getColumnDescriptors: function() {
        //assumes there is one row....
        this.insureColumnIndexesAreInitialized();
        var tableState = this.getPrivateState();
        var columnCount = tableState.columnIndexes.length;
        var labels = [];
        for (var i = 0; i < columnCount; i++) {
            var id = tableState.columnIndexes[i];
            labels.push({
                id: id,
                label: this.getHeader(id),
                field: this.getField(id)
            });
        }
        return labels;
    },

    /**
     * @memberOf Behavior.prototype
     * @return {string} The field at `colIndex`.
     * @param {number} colIndex - the column index of interest
     */
    getField: function(colIndex) {
        if (colIndex === -1) {
            return 'tree';
        }
        var col = this.getColumn(colIndex);
        return col.getField();
    },
    /**
     * @memberOf Behavior.prototype
     * @return {string} The column heading at `colIndex'.
     * @param {number} colIndex - the column index of interest
     */
    getHeader: function(colIndex) {
        if (colIndex === -1) {
            return 'Tree';
        }
        var col = this.getColumn(colIndex);
        return col.getHeader();
    },
    /**
     * @memberOf Behavior.prototype
     * @desc this is called by the column editor post closing; rebuild the column order indexes
     * @param {Array} list - list of column objects from the column editor
     */
    setColumnDescriptors: function(lists) {
        //assumes there is one row....
        var visible = lists.visible;
        var tableState = this.getPrivateState();

        var columnCount = visible.length;
        var indexes = [];
        var i;
        for (i = 0; i < columnCount; i++) {
            indexes.push(visible[i].id);
        }
        tableState.columnIndexes = indexes;
        this.changed();
    },

    /**
     * @memberOf Behavior.prototype
     * @return {string[]} All the currently hidden column header labels.
     */
    getHiddenColumnDescriptors: function() {
        var tableState = this.getPrivateState();
        var indexes = tableState.columnIndexes;
        var labels = [];
        var columnCount = this.getColumnCount();
        for (var i = 0; i < columnCount; i++) {
            if (indexes.indexOf(i) === -1) {
                labels.push({
                    id: i,
                    label: this.getHeader(i),
                    field: this.getField(i)
                });
            }
        }
        return labels;
    },

    /**
     * @memberOf Behavior.prototype
     * @desc hide columns that are specified by their indexes
     * @param {Array} arrayOfIndexes - an array of column indexes to hide
     */
    hideColumns: function(arrayOfIndexes) {
        var tableState = this.getPrivateState();
        var order = tableState.columnIndexes;
        for (var i = 0; i < arrayOfIndexes.length; i++) {
            var each = arrayOfIndexes[i];
            if (order.indexOf(each) !== -1) {
                order.splice(order.indexOf(each), 1);
            }
        }
    },

    /**
     * @memberOf Behavior.prototype
     * @return {integer} The number of fixed columns.
     */
    getFixedColumnCount: function() {
        var tableState = this.getPrivateState();
        return tableState.fixedColumnCount || 0;
    },

    /**
     * @memberOf Behavior.prototype
     * @desc set the number of fixed columns
     * @param {number} numberOfFixedColumns - the integer count of how many columns to be fixed
     */
    setFixedColumnCount: function(numberOfFixedColumns) {
        var tableState = this.getPrivateState();
        tableState.fixedColumnCount = numberOfFixedColumns;
    },

    /**
     * @memberOf Behavior.prototype
     * @return {integer} The number of fixed rows.
     */
    getFixedRowCount: function() {
        if (!this.tableState) {
            return 0;
        }
        var usersSize = this.tableState.fixedRowCount || 0;
        var headers = this.getGrid().getHeaderRowCount();
        var total = usersSize + headers;
        return total;
    },

    /**
     * @memberOf Behavior.prototype
     * @desc set the number of rows that are fixed
     * @param {number} numberOfFixedRows - the count of rows to be set fixed
     */
    setFixedRowCount: function(numberOfFixedRows) {
        this.tableState.fixedRowCount = numberOfFixedRows;
    },

    /**
     * @memberOf Behavior.prototype
     * @return {number} The number of fixed rows.
     */
    getHeaderRowCount: function() {
        var grid = this.getGrid();
        var header = grid.isShowHeaderRow() ? 1 : 0;
        var filter = grid.isShowFilterRow() ? 1 : 0;
        var totals = this.getTopTotals().length;
        var count = header + filter + totals;
        return count;
    },

    /**
     * @memberOf Behavior.prototype
     * @desc set the number of rows that are fixed
     * @param {number} numberOfFixedRows - the count of rows to be set fixed
     */
    setHeaderRowCount: function(numberOfHeaderRows) {
        this.tableState.headerRowCount = numberOfHeaderRows;
    },

    /**
     * @memberOf Behavior.prototype
     * @return {number} The number of fixed rows.
     */
    getHeaderColumnCount: function() {
        var grid = this.getGrid();
        var count = grid.resolveProperty('headerColumnCount');
        return count;
    },

    /**
     * @memberOf Behavior.prototype
     * @param {number} The number of fixed rows.
     */
    setHeaderColumnCount: function(numberOfHeaderColumns) {
        this.tableState.headerColumnCount = numberOfHeaderColumns;
    },
    /**
     * @memberOf Behavior.prototype
     * @desc build and open the editor within the container div argument
     * @return {boolean} `false` prevents editor from opening
     * @param {HTMLDivElement} div - the containing div element
     */
    openEditor: function(div) {
        var container = document.createElement('div');

        var hidden = document.createElement('fin-hypergrid-dnd-list');
        var visible = document.createElement('fin-hypergrid-dnd-list');

        container.appendChild(hidden);
        container.appendChild(visible);

        this.beColumnStyle(hidden.style);
        hidden.title = 'hidden columns';
        hidden.list = this.getHiddenColumnDescriptors();

        this.beColumnStyle(visible.style);
        visible.style.left = '50%';
        visible.title = 'visible columns';
        visible.list = this.getColumnDescriptors();

        div.lists = {
            hidden: hidden.list,
            visible: visible.list
        };
        div.appendChild(container);
        return true;
    },

    /**
     * @memberOf Behavior.prototype
     * @desc the editor is requesting close; deal with the edits
     * @return `true`
     * @param {HTMLDivElement} div - the containing div element
     */
    closeEditor: function(div) {
        var lists = div.lists;
        this.setColumnDescriptors(lists);
        return true;
    },

    /**
     * @memberOf Behavior.prototype
     * @desc a dnd column has just been dropped, we've been notified
     */
    endDragColumnNotification: function() {},

    /**
     * @memberOf Behavior.prototype
     * @desc bind column editor appropriate css values to arg style
     * @param {HTMLStyleElement} style - the style object to enhance
     */
    beColumnStyle: function(style) {
        style.top = '5%';
        style.position = 'absolute';
        style.width = '50%';
        style.height = '100%';
        style.whiteSpace = 'nowrap';
    },

    /**
     * @memberOf Behavior.prototype
     * @return {null} the cursor at a specific x,y coordinate
     * @param {number} x - the x coordinate
     * @param {number} y - the y coordinate
     */
    getCursorAt: function(x, y) {
        return null;
    },

    /**
     * @memberOf Behavior.prototype
     * @return {number} The total number of columns.
     */
    getColumnCount: function() {
        return this.columns.length;
    },

    /**
     * @memberOf Behavior.prototype
     * @return {string} - The column alignment at column `x`, which is one of `'left'`, `'center'` , or `'right'`.
     * @param {number} x - the column index of interest
     */
    getColumnAlignment: function(x) {
        return 'center';
    },

    /**
     * @memberOf Behavior.prototype
     * @desc quietly set the scroll position in the horizontal dimension
     * @param {number} x - the position in pixels
     */
    setScrollPositionX: function(x) {
        this.scrollPositionX = x;
    },

    getScrollPositionX: function() {
        return this.scrollPositionX;
    },

    /**
     * @memberOf Behavior.prototype
     * @desc quietly set the scroll position in the horizontal dimension
     * @param {number} y - the position in pixels
     */
    setScrollPositionY: function(y) {
        this.scrollPositionY = y;
    },

    getScrollPositionY: function() {
        return this.scrollPositionY;
    },

    /**
     * @memberOf Behavior.prototype
     * @return {cellEditor} Cell editor for coordinate `x,y`.
     * @param {number} x - x coordinate
     * @param {number} y - y coordinate
     */
    getCellEditorAt: function(x, y) {
        return this.getColumn(x).getCellEditorAt(x, y);
    },

    /**
     * @memberOf Behavior.prototype
     * @desc fixed row has been clicked, you've been notified
     * @param {Hypergrid} grid
     * @param {Object} mouse - event details
     */
    toggleSort: function(x, keys) {
        this.getColumn(x).toggleSort(keys);
    },

    /**
     * @memberOf Behavior.prototype
     * @return {boolean} `true` if we should highlight on hover
     * @param {boolean} isColumnHovered - the column is hovered or not
     * @param {boolean} isRowHovered - the row is hovered or not
     */
    highlightCellOnHover: function(isColumnHovered, isRowHovered) {
        return isColumnHovered && isRowHovered;
    },

    /**
     * @memberOf Behavior.prototype
     * @return {HTMLImageElement}
     * @param {string} key - an image alias
     */
    getImage: function(key) {
        return images[key];
    },

    /**
     * @memberOf Behavior.prototype
     * @desc set the image for a specific alias
     * @param {string} key - an image alias
     * @param {HTMLImageElement} image - the image to cache
     */
    setImage: function(key, image) {
        images[key] = image;
    },

    /**
     * @memberOf Behavior.prototype
     * @desc this function is a hook and is called just before the painting of a cell occurs
     * @param {window.fin.rectangular.Point} cell
     */
    cellPropertiesPrePaintNotification: function(cellProperties) {
        var row = this.getRow(cellProperties.y);
        var columnId = this.getHeader(cellProperties.x);
        cellProperties.row = row;
        cellProperties.columnId = columnId;
    },

    /**
     * @memberOf Behavior.prototype
     * @desc this function is a hook and is called just before the painting of a fixed row cell occurs
     * @param {window.fin.rectangular.Point} cell
     */
    cellFixedRowPrePaintNotification: function(cell) {

    },

    /**
     * @memberOf Behavior.prototype
     * @desc this function is a hook and is called just before the painting of a fixed column cell occurs
     * @param {window.fin.rectangular.Point} cell
     */
    cellFixedColumnPrePaintNotification: function(cell) {

    },

    /**
     * @memberOf Behavior.prototype
     * @desc this function is a hook and is called just before the painting of a top left cell occurs
     * @param {window.fin.rectangular.Point} cell
     */
    cellTopLeftPrePaintNotification: function(cell) {

    },

    /**
     * @memberOf Behavior.prototype
     * @desc this function enhance the double click event just before it's broadcast to listeners
     * @param {Object} event - event to enhance
     */
    enhanceDoubleClickEvent: function(event) {},

    /**
     * @memberOf Behavior.prototype
     * @desc swap src and tar columns
     * @param {number} src - column index
     * @param {number} tar - column index
     */
    swapColumns: function(source, target) {
        var columns = this.columns;
        var tmp = columns[source];
        columns[source] = columns[target];
        columns[target] = tmp;
        this.changed();
    },

    getColumnEdge: function(c, renderer) {
        return this.getDataModel().getColumnEdge(c, renderer);
    },

    setTotalsValue: function(x, y, value) {
        this.getGrid().setTotalsValueNotification(x, y, value);
    },

    /**
     * @memberOf Behavior.prototype
     * @return {object} The object at y index.
     * @param {number} y - the row index of interest
     */
    getRow: function(y) {
        return this.getDataModel().getRow(y);
    },

    convertViewPointToDataPoint: function(viewPoint) {
        var newX = this.getColumn(viewPoint.x);
        var newPoint = this.getGrid().newPoint(newX, viewPoint.y);
        return newPoint;
    },

    setGroups: function(arrayOfColumnIndexes) {
        this.getDataModel().setGroups(arrayOfColumnIndexes);
        this.createColumns();
        this.changed();
    },

    setAggregates: function(mapOfKeysToFunctions) {
        var self = this;
        this.getDataModel().setAggregates(mapOfKeysToFunctions);
        this.createColumns();
        setTimeout(function() {
            self.changed();
        }, 100);
    },

    hasHierarchyColumn: function() {
        return false;
    },

    getRowContextFunction: function(selectedRows) {
        return function() {
            return null;
        };
    },

    getSelectionMatrixFunction: function(selectedRows) {
        return function() {
            return null;
        };
    },

    getFieldName: function(index) {
        return this.getFields()[index];
    },

    getColumnIndex: function(fieldName) {
        return this.getFields().indexOf(fieldName);
    },

    getComputedRow: function(y) {
        return this.getDataModel().getComputedRow(y);
    },

    autosizeAllColumns: function() {
        this.checkColumnAutosizing(true);
        this.changed();
    },

    checkColumnAutosizing: function(force) {
        force = force === true;
        this.allColumns[-1].checkColumnAutosizing(true);
        this.allColumns[-2].checkColumnAutosizing(force);
        this.allColumns.forEach(function(column) {
            column.checkColumnAutosizing(force);
        });
    },

    autoSizeRowNumberColumn: function() {
        this.allColumns[-1].checkColumnAutosizing(true);
    },

    setGlobalFilter: function(string) {
        this.getDataModel().setGlobalFilter(string);
    },

    getSelectedRows: function() {
        return this.getGrid().getSelectionModel().getSelectedRows();
    },

    getSelectedColumns: function() {
        return this.getGrid().getSelectionModel().getSelectedColumns();
    },

    getSelections: function() {
        return this.getGrid().getSelectionModel().getSelections();
    }

});

module.exports = Behavior;

},{"../CellProvider":32,"./Column":37,"./images":41,"extend-me":3,"object-iterators":28}],37:[function(require,module,exports){
/* eslint-env browser */

'use strict';

var _ = require('object-iterators');

function Column(behavior, index, label) {
    this.behavior = behavior;
    this.dataModel = behavior.getDataModel();
    this.index = index;
    this.label = label;
}

Column.prototype = {
    constructor: Column.prototype.constructor,

    getValue: function(y) {
        return this.dataModel.getValue(this.index, y);
    },

    setValue: function(y, value) {
        return this.dataModel.setValue(this.index, y, value);
    },

    getWidth: function() {
        var properties = this.getProperties();
        if (properties) {
            var override = properties.width;
            if (override) {
                return override;
            }
        }
        return this.behavior.resolveProperty('defaultColumnWidth');
    },

    setWidth: function(width) {
        this.getProperties().width = Math.max(5, width);
    },

    getCellRenderer: function(config, y) {
        return this.dataModel.getCellRenderer(config, this.index, y);
    },

    getCellProperties: function(y) {
        return this.behavior.getPrivateState().cellProperties[this.index + ',' + y];
    },

    setCellProperties: function(y, value) {
        this.behavior.getPrivateState().cellProperties[this.index + ',' + y] = value;
    },

    checkColumnAutosizing: function(force) {
        var properties = this.getProperties();
        var a, b, d;
        if (properties) {
            a = properties.width;
            b = properties.preferredWidth || properties.width;
            d = properties.columnAutosized && !force;
            if (a !== b || !d) {
                properties.width = !d ? b : Math.max(a, b);
                properties.columnAutosized = !isNaN(properties.width);
            }
        }
    },

    getProperties: function() {
        return this.behavior.getPrivateState().columnProperties[this.index];
    },

    setProperties: function(properties) {
        var current = this.behavior.getPrivateState().columnProperties[this.index];
        this.clearObjectProperties(current, false);
        _(current).extendOwn(properties);
    },

    toggleSort: function(keys) {
        this.dataModel.toggleSort(this.index, keys);
    },

    getCellEditorAt: function(x, y) {
        return this.dataModel.getCellEditorAt(this.index, y);
    },

    getHeader: function() {
        return this.label;
    },

    getField: function() {
        return this.dataModel.getFields()[this.index];
    }
};

module.exports = Column;

},{"object-iterators":28}],38:[function(require,module,exports){
'use strict';

function DataModelDecorator(grid, component) {
    this.setComponent(component);
    this.setGrid(grid);
}

DataModelDecorator.prototype = {
    constructor: DataModelDecorator.prototype.constructor,

    component: null,
    grid: null,

    getGrid: function() {
        return this.grid;
    },

    setGrid: function(newGrid) {
        this.grid = newGrid;
        this.getComponent().setGrid(newGrid);
    },

    getBehavior: function() {
        return this.getGrid().getBehavior();
    },

    changed: function() {
        this.getBehavior().changed();
    },

    getPrivateState: function() {
        return this.getGrid().getPrivateState();
    },

    applyState: function() {

    },

    setComponent: function(newComponent) {
        this.component = newComponent;
    },

    getComponent: function() {
        return this.component;
    },

    setGlobalFilter: function(string) {
        return this.getComponent().setGlobalFilter(string);
    },

    getValue: function(x, y) {
        return this.getComponent().getValue(x, y);
    },

    setValue: function(x, y, value) {
        this.getComponent().setValue(x, y, value);
    },

    getColumnCount: function() {
        return this.getComponent().getColumnCount();
    },

    getRowCount: function() {
        return this.getComponent().getRowCount();
    },

    getCellRenderer: function(config, x, y, untranslatedX, untranslatedY) {
        return this.getComponent().getCellRenderer(config, x, y, untranslatedX, untranslatedY);
    },

    getRowHeight: function(y) {
        return this.getComponent().getRowHeight(y);
    },

    getColumnEdge: function(x, renderer) {
        return this.getComponent().getColumnEdge(x, renderer);
    },

    getColumnWidth: function(x) {
        return this.getComponent().getColumnWidth(x);
    },

    setColumnWidth: function(x, width) {
        this.getComponent().setColumnWidth(x, width);
    },

    toggleSort: function(x, keys) {
        this.getComponent().toggleSort(x, keys);
    },

    getColumnProperties: function(columnIndex) {
        return this.getComponent().getColumnProperties(columnIndex);
    },

    setColumnProperties: function(columnIndex, properties) {
        this.getComponent().setColumnProperties(columnIndex, properties);
    },

    getHeaders: function() {
        return this.getComponent().getHeaders();
    },

    getFields: function() {
        return this.getComponent().getFields();
    },

    setFields: function(fields) {
        this.getComponent().setFields(fields);
    },

    getCellProperties: function(x, y) {
        return this.getComponent().getCellProperties(x, y);
    },

    setCellProperties: function(x, y, value) {
        this.getComponent().setCellProperties(x, y, value);
    },

    getRow: function(y) {
        return this.getComponent().getRow(y);
    },

    setTopTotals: function(nestedArray) {
        this.getComponent().setTopTotals(nestedArray);
    },

    getTopTotals: function() {
        return this.getComponent().getTopTotals();
    },

    setData: function(y) {
        return this.getComponent().setData(y);
    },

    hasHierarchyColumn: function() {
        return this.getComponent().hasHierarchyColumn();
    },

    setHeaders: function(headerLabels) {
        return this.getComponent().setHeaders(headerLabels);
    },

    cellClicked: function(cell, event) {
        return this.getComponent().cellClicked(cell, event);
    },

    getAvailableGroups: function() {
        return this.getComponent().getAvailableGroups();
    },

    getGroups: function() {
        return this.getComponent().getGroups();
    },

    setGroups: function(groups) {
        this.getComponent().setGroups(groups);
    },

    getHiddenColumns: function() {
        return this.getComponent().getHiddenColumns();
    },

    getVisibleColumns: function() {
        return this.getComponent().getVisibleColumns();
    },

    setAggregates: function(aggregates) {
        return this.getComponent().setAggregates(aggregates);
    },

    reset: function() {
        this.getComponent().reset();
    }
};

module.exports = DataModelDecorator;

},{}],39:[function(require,module,exports){
'use strict';

var ListDragon = require('list-dragon');

var Behavior = require('./Behavior');
var DataModelDecorator = require('./DataModelDecorator');
var DataModelJSON = require('../dataModels/JSON');
var features = require('../features/index');
var addStylesheet = require('../stylesheets');
var aggregations = require('hyper-analytics').util.aggregations;
//var aggregations = require('../local_node_modules/newanalytics').util.aggregations;
//var aggregations = require('../local_node_modules/finanalytics').aggregations;

/**
 * @name behaviors.JSON
 * @desc > Same parameters as {@link behaviors.JSON#initialize|initialize}, which is called by this constructor.
 * @constructor
 */
var JSON = Behavior.extend('behaviors.JSON', {

    /**
     * @summary Constructor logic, called _after_{@link Behavior#initialize|Behavior.initialize()}.
     * @desc This method will be called upon instantiation of this class or of any class that extends from this class.
     * > All `initialize()` methods in the inheritance chain are called, in turn, each with the same parameters that were passed to the constructor, beginning with that of the most "senior" class through that of the class of the new instance.
     *
     * @param grid - the hypergrid
     * @param {object[]} dataRows - array of uniform data objects
     * @memberOf behaviors.JSON.prototype
     */
    initialize: function(grid, dataRows) {
        this.setData(dataRows);
    },

    features: [
        features.CellSelection,
        features.KeyPaging,
        features.Overlay,
        features.ColumnResizing,
        features.RowResizing,
        features.Filters,
        features.RowSelection,
        features.ColumnSelection,
        features.ColumnMoving,
        features.ColumnSorting,
        features.CellEditing,
        features.CellClick,
        features.OnHover
    ],

    aggregations: aggregations,

    createColumns: function() {
        var dataModel = this.getDataModel();
        var columnCount = dataModel.getColumnCount();
        var headers = dataModel.getHeaders();
        var fields = dataModel.getFields();
        this.clearColumns();
        for (var i = 0; i < columnCount; i++) {
            var header = headers[i];
            var column = this.addColumn(i, header);
            var properties = column.getProperties();
            properties.field = fields[i];
            properties.header = header;
        }
    },

    getDefaultDataModel: function() {
        var model = new DataModelJSON();
        var wrapper = new DataModelDecorator(this.getGrid(), model);
        wrapper.setComponent(model);
        return wrapper;
    },

    /**
     * @memberOf behaviors.JSON.prototype
     * @description Set the header labels.
     * @param {string[]} headerLabels - The header labels.
     */
    setHeaders: function(headerLabels) {
        this.getDataModel().setHeaders(headerLabels);
    },

    /**
     * @memberOf behaviors.JSON.prototype
     * @desc * @returns {string[]} The header labels.
     */
    getHeaders: function() {
        return this.getDataModel().getHeaders();
    },

    /**
     * @memberOf behaviors.JSON.prototype
     * @description Set the fields array.
     * @param {string[]} fieldNames - The field names.
     */
    setFields: function(fieldNames) {
        //were defining the columns based on field names....
        //we must rebuild the column definitions
        this.getDataModel().setFields(fieldNames);
        this.createColumns();
    },

    /**
     * @memberOf behaviors.JSON.prototype
     * @description Get the field names.
     * @returns {string[]}
     */
    getFields: function() {
        return this.getDataModel().getFields();
    },

    /**
     * @memberOf behaviors.JSON.prototype
     * @description Set the data field.
     * @param {object[]} objects - An array of uniform objects, each being a row in the grid.
     */
    setData: function(dataRows) {
        this.getDataModel().setData(dataRows);
        this.createColumns();
        var self = this;
        if (this.getGrid().isColumnAutosizing()) {
            setTimeout(function() {
                self.autosizeAllColumns();
            }, 100);
        } else {
            setTimeout(function() {
                self.allColumns[-1].checkColumnAutosizing(true);
                self.changed();
            });
        }
    },

    /**
     * @memberOf behaviors.JSON.prototype
     * @description Get the data field.
     */
    getData: function() {
        return this.getDataModel().getData();
    },


    /**
     * @memberOf behaviors.JSON.prototype
     * @description Set the totals field.
     * @param {array} nestedArray - array2D of totals data
     */
    setTopTotals: function(nestedArray) {
        this.getDataModel().setTopTotals(nestedArray);
    },

    getTopTotals: function() {
        return this.getDataModel().getTopTotals();
    },

    /**
     * @memberOf behaviors.JSON.prototype
     * @description Build the fields and headers from the supplied column definitions.
     * ```javascript
     * myJsonBehavior.setColumns([
     *     { title: 'Stock Name', field: 'short_description' },
     *     { title: 'Status', field: 'trading_phase' },
     *     { title: 'Reference Price', field: 'reference_price' }
     * ]);
     * ```
     * @param {Array} columnDefinitions - an array of objects with fields 'title', and 'field'
     */
    setColumns: function(columnDefinitions) {
        this.getDataModel().setColumns(columnDefinitions);
    },

    /**
     * @memberOf behaviors.JSON.prototype
     * @description Enhance the double-click event just before it's broadcast to listeners.
     * @param {Point} event
     */
    enhanceDoubleClickEvent: function(event) {
        event.row = this.getRow(event.gridCell.y);
    },

    setDataProvider: function(dataProvider) {
        this.getDataModel().setDataProvider(dataProvider);
    },

    hasHierarchyColumn: function() {
        return this.getDataModel().hasHierarchyColumn();
    },

    getColumnAlignment: function(x) {
        if (x === 0 && this.hasHierarchyColumn()) {
            return 'left';
        } else {
            return 'center';
        }
    },

    getRowSelectionMatrix: function(selectedRows) {
        return this.getDataModel().getRowSelectionMatrix(selectedRows);
    },

    getColumnSelectionMatrix: function(selectedColumns) {
        return this.getDataModel().getColumnSelectionMatrix(selectedColumns);
    },

    getSelectionMatrix: function(selections) {
        return this.getDataModel().getSelectionMatrix(selections);
    },

    getRowSelection: function() {
        var selectedRows = this.getSelectedRows();
        return this.getDataModel().getRowSelection(selectedRows);
    },

    getColumnSelection: function() {
        var selectedColumns = this.getSelectedColumns();
        return this.getDataModel().getColumnSelection(selectedColumns);
    },

    getSelection: function() {
        var selections = this.getSelections();
        return this.getDataModel().getSelection(selections);
    },

    openEditor: function(div) {
        if (!this.isColumnReorderable()) {
            return false;
        }

        addStylesheet('dnd', null);

        var groups = { models: this.getGroups(), title: 'Groups' },
            availableGroups = { models: this.getAvailableGroups(), title: 'Available Groups' },
            hiddenColumns = { models: this.getHiddenColumns(), title: 'Hidden Ccolumns' },
            visibleColumns = { models: this.getVisibleColumns(), title: 'Visible Columns'},
            groupLists = new ListDragon([groups, availableGroups]),
            columnLists = new ListDragon([hiddenColumns, visibleColumns]),
            listSets = [groupLists, columnLists];

        listSets.forEach(function(listSet) {
            listSet.modelLists.forEach(function(list) {
                div.appendChild(list.container);
            });
        });

        //attach for later retrieval
        div.lists = {
            group: groups.models,
            availableGroups: availableGroups.models,
            hidden: hiddenColumns.models,
            visible: visibleColumns.models
        };

        return true;
    },
    getGroups: function() {
        return this.getDataModel().getGroups();
    },
    getAvailableGroups: function() {
        return this.getDataModel().getAvailableGroups();
    },
    getHiddenColumns: function() {
        return this.getDataModel().getHiddenColumns();
    },
    getVisibleColumns: function() {
        return this.getDataModel().getVisibleColumns();
    },
    setColumnDescriptors: function(lists) {
        //assumes there is one row....
        var tree = this.columns[0];
        this.columns.length = 0;
        if (tree && tree.label === 'Tree') {
            this.columns.push(tree);
        }
        for (var i = 0; i < lists.visible.length; i++) {
            this.columns.push(lists.visible[i]);
        }

        var groupBys = lists.group.map(function(e) {
            return e.id;
        });
        this.getDataModel().setGroups(groupBys);

        this.changed();
    },

    getSelectedRows: function() {
        var offset = -this.getGrid().getHeaderRowCount();
        var selections = this.getGrid().getSelectionModel().getSelectedRows();
        var result = selections.map(function(each) {
            return each + offset;
        });
        return result;
    },

    getSelectedColumns: function() {
        return this.getGrid().getSelectionModel().getSelectedColumns();
    },

    getSelections: function() {
        return this.getGrid().getSelectionModel().getSelections();
    }

});

module.exports = JSON;

},{"../dataModels/JSON":53,"../features/index":71,"../stylesheets":72,"./Behavior":36,"./DataModelDecorator":38,"hyper-analytics":20,"list-dragon":25}],40:[function(require,module,exports){
'use strict';

var Behavior = require('./Behavior');

var noop = function() {},
    n00p = function() { return 0; };

/**
 * @constructor
 */
var Null = Behavior.extend('Null', {

    //initalize: function(grid, component) {},

    setScrollPositionY: noop,
    setScrollPositionX: noop,
    getColumnCount: n00p,
    getFixedColumnCount: n00p,
    getFixedColumnsWidth: n00p,
    getFixedColumnsMaxWidth: n00p,
    setRenderedWidth: n00p,
    getRowCount: n00p,
    getFixedRowCount: n00p,
    getFixedRowsHeight: n00p,
    getFixedRowsMaxHeight: n00p,
    setRenderedHeight: n00p,
    getCellProvider: noop,
    click: noop,
    doubleClick: noop
});

module.exports = Null;

},{"./Behavior":36}],41:[function(require,module,exports){
/* eslint-env browser */

'use strict';

var _ = require('object-iterators');

var images = require('../../images'); // this index.js is generated by gulp and ignored by git

_(images).each(function(image, key) {
    var element = new Image();
    element.src = 'data:' + image.type + ';base64,' + image.data;
    images[key] = element;
});

module.exports = images;

},{"../../images":1,"object-iterators":28}],42:[function(require,module,exports){
'use strict';

module.exports = {
    Behavior: require('./Behavior'), // abstract base class
    JSON: require('./JSON'),
    Null: require('./Null')
};
},{"./Behavior":36,"./JSON":39,"./Null":40}],43:[function(require,module,exports){
/* eslint-env browser */

'use strict';

var mustache = require('mustache');
var Base = require('extend-me').Base;

/**
 * @constructor
 */
var CellEditor = Base.extend('CellEditor', {

    alias: 'base',

    /**
     * am I currently editing (i.e., between calls to `beginEditAt` and either `stopEditing` or `cancelEditing`)
     * @type {boolean}
     * @default false
     * @memberOf CellEditor.prototype
     */
    isEditing: false,

    /**
     * the point that I am editing at right now
     * @type {Point}
     * @default null
     * @memberOf CellEditor.prototype
     */
    editorPoint: null,

    /**
     * if true, check that the editor is in the right location
     * @type {boolean}
     * @default false
     * @memberOf CellEditor.prototype
     */
    checkEditorPositionFlag: false,

    /**
     * my main input control
     * @type {Element}
     * @default null
     * @memberOf CellEditor.prototype
     */
    input: null,

    /**
     * my instance of hypergrid
     * @type {Hypergrid}
     * @default null
     * @memberOf CellEditor.prototype
     */
    grid: null,

    /**
     * the value before editing
     * @type {type}
     * @default null
     * @memberOf CellEditor.prototype
     */
    initialValue: null,

    /**
     * @memberOf CellEditor.prototype
     * @desc return the behavior (model)
     * @returns {Behavior} The behavior (model).
     */
    getBehavior: function() {
        return this.grid.getBehavior();
    },

    /**
     * @memberOf CellEditor.prototype
     * @desc This function is a callback from the fin-hypergrid.   It is called after each paint of the canvas.
     */
    gridRenderedNotification: function() {
        this.checkEditor();
    },

    /**
     * @memberOf CellEditor.prototype
     * @desc scroll values have changed, we've been notified
     */
    scrollValueChangedNotification: function() {
        this.setCheckEditorPositionFlag();
    },

    /**
     * @memberOf CellEditor.prototype
     * @desc turn on checkEditorPositionFlag boolean field
     */
    setCheckEditorPositionFlag: function() {
        this.checkEditorPositionFlag = true;
    },

    /**
     * @memberOf CellEditor.prototype
     * @desc begin editing at location point
     * @param {Point} point - the location to start editing at
     */
    beginEditAt: function(point) {
        this.setEditorPoint(point);
        var model = this.getBehavior();
        var value = model.getValue(point.x, point.y);
        if (value.constructor.name === 'Array') {
            value = value[1]; //it's a nested object
        }
        var proceed = this.grid.fireRequestCellEdit(point, value);
        if (!proceed) {
            //we were cancelled
            return;
        }
        this.initialValue = value;
        this.setEditorValue(value);
        this.isEditing = true;
        this.setCheckEditorPositionFlag();
        this.checkEditor();
    },

    /**
     * @memberOf CellEditor.prototype
     * @desc put value into our editor
     * @param {object} value - whatever value we want to edit
     */
    setEditorValue: function(value) {},

    /**
     * @memberOf CellEditor.prototype
     * @desc returns the point at which we are currently editing
     * @returns {Point}
     */
    getEditorPoint: function() {
        return this.editorPoint;
    },

    /**
     * @memberOf CellEditor.prototype
     * @desc set the current editor location
     * @param {Point} point - the data location of the current editor
     */
    setEditorPoint: function(point) {
        this.editorPoint = point;
        this.modelPoint = this.getGrid().convertViewPointToDataPoint(point);
    },

    /**
     * @memberOf CellEditor.prototype
     * @desc display the editor
     */
    showEditor: function() {},

    /**
     * @memberOf CellEditor.prototype
     * @desc hide the editor
     */
    hideEditor: function() {},

    /**
     * @memberOf CellEditor.prototype
     * @desc stop editing
     */
    stopEditing: function() {
        if (!this.isEditing) {
            return;
        }
        var proceed = this.getGrid().fireSyntheticEditorDataChangeEvent(this, this.initialValue, this.getEditorValue, this);
        if (!proceed) {
            return;
        }
        this.saveEditorValue();
        this.isEditing = false;
        this.hideEditor();
    },

    cancelEditing: function() {
        if (!this.isEditing) {
            return;
        }
        this.isEditing = false;
        this.hideEditor();
    },

    /**
     * @memberOf CellEditor.prototype
     * @desc save the new value into the behavior(model)
     */
    saveEditorValue: function() {
        var point = this.getEditorPoint();
        var value = this.getEditorValue();
        if (value === this.initialValue) {
            return; //data didn't change do nothing
        }
        var continued = this.getGrid().fireBeforeCellEdit(point, this.initialValue, value, this);
        if (!continued) {
            return;
        }
        this.getBehavior().setValue(point.x, point.y, value);
        this.getGrid().fireAfterCellEdit(point, this.initialValue, value, this);
    },

    /**
     * @memberOf CellEditor.prototype
     * @desc return the current editor's value
     */
    getEditorValue: function() {},

    /**
     * @memberOf CellEditor.prototype
     * @desc request focus for my input control
     */
    takeFocus: function() {},

    /**
     * @memberOf CellEditor.prototype
     * @desc move the editor to the current editor point
     */
    _moveEditor: function() {
        var grid = this.getGrid();
        var editorPoint = this.getEditorPoint();
        var cellBounds = grid._getBoundsOfCell(editorPoint.x, editorPoint.y);

        //hack to accomodate bootstrap margin issues...
        var xOffset = grid.div.getBoundingClientRect().left - grid.divCanvas.getBoundingClientRect().left;
        cellBounds.x = cellBounds.x - xOffset;

        this.setBounds(cellBounds);
    },

    moveEditor: function() {
        this._moveEditor();
        this.takeFocus();
    },

    /**
     * @memberOf CellEditor.prototype
     * @desc set the bounds of my input control
     * @param {Rectangle} the bounds to move to
     */
    setBounds: function(rectangle) {},

    /**
     * @memberOf CellEditor.prototype
     * @desc check that the editor is in the correct location, and is showing/hidden appropriately
     */
    checkEditor: function() {
        if (!this.checkEditorPositionFlag) {
            return;
        } else {
            this.checkEditorPositionFlag = false;
        }
        if (!this.isEditing) {
            return;
        }
        var editorPoint = this.getEditorPoint();
        if (this.grid.isDataVisible(editorPoint.x, editorPoint.y)) {
            this.moveEditor();
            this.showEditor();
        } else {
            this.hideEditor();
        }
    },

    getGrid: function() {
        return this.grid;
    },

    template: function() {
        /*

         */
    },

    getHTML: function() {
        var string = this.template.toString().split('\n');
        string.shift();
        string.shift();
        string.length = string.length - 2;
        string = string.join('\n').trim();
        return mustache.render(string, this);
    },

    getInput: function() {
        if (!this.input) {
            this.input = this.getDefaultInput();
        }
        return this.input;
    },

    getDefaultInput: function() {
        var div = document.createElement('DIV');
        div.innerHTML = this.getHTML();
        var input = div.firstChild;
        this.initializeInput(input);
        return input;
    },

    updateView: function() {
        var oldGuy = this.getInput();
        var parent = oldGuy.parentNode;
        var newGuy = this.getDefaultInput();
        this.input = newGuy;
        parent.replaceChild(newGuy, oldGuy);
    },

    initializeInput: function(input) {},

    showDropdown: function(element) {
        var event;
        event = document.createEvent('MouseEvents');
        event.initMouseEvent('mousedown', true, true, window);
        element.dispatchEvent(event);
    }

});

module.exports = CellEditor;

},{"extend-me":3,"mustache":27}],44:[function(require,module,exports){
'use strict';

var Simple = require('./Simple');

/**
 * @constructor
 */
var Choice = Simple.extend('Choice', {

    /**
     * my lookup alias
     * @type {string}
     * @memberOf Choice.prototype
     */
    alias: 'choice',

    /**
     * the list of items to pick from
     * @type {Array}
     * @memberOf Choice.prototype
     */
    items: ['a', 'b', 'c'],

    template: function() {
        /*
                <select id="editor">
                    {{#items}}
                        <option value="{{.}}">{{.}}</option>
                    {{/items}}
                </select>
            */
    },

    //no events are fired while the dropdown is open
    //see http://jsfiddle.net/m4tndtu4/6/

    /**
     * @memberOf Choice.prototype
     */
    showEditor: function() {
        var self = this;
        this.input.style.display = 'inline';
        setTimeout(function() {
            self.showDropdown(self.input);
        }, 50);
    },

    /**
     * @memberOf Choice.prototype
     * @param items
     */
    setItems: function(items) {
        this.items = items;
        this.updateView();
    },

    /**
     * @memberOf Choice.prototype
     * @param input
     */
    initializeInput: function(input) {
        var self = this;
        Simple.prototype.initializeInput(input);
        input.onchange = function() {
            self.stopEditing();
        };
    }

});

module.exports = Choice;

},{"./Simple":47}],45:[function(require,module,exports){
'use strict';

var Simple = require('./Simple');

/**
 * @constructor
 */
var Color = Simple.extend('Color', {

    /**
     * my lookup alias
     * @type {string}
     * @memberOf Color.prototype
     */
    alias: 'color',

    template: function() {
        /*
            <input id="editor" type="color">
        */
    }

});

module.exports = Color;

},{"./Simple":47}],46:[function(require,module,exports){
'use strict';

var Simple = require('./Simple');

/**
 * @constructor
 */
var Date = Simple.extend('Date', {

    /**
     * my lookup alias
     * @type {string}
     * @memberOf Date.prototype
     */
    alias: 'date',

    template: function() {
        /*
            <input id="editor" type="date">
        */
    }

});

module.exports = Date;

},{"./Simple":47}],47:[function(require,module,exports){
'use strict';

var CellEditor = require('./CellEditor.js');

/**
 * @constructor
 */
var Simple = CellEditor.extend('Simple', {

    /**
     * my lookup alias
     * @type {string}
     * @memberOf Simple.prototype
     */
    alias: 'simple',

    /**
     * @memberOf Simple.prototype
     */
    initialize: function() {
        this.editorPoint = {
            x: 0,
            y: 0
        };
    },

    /**
     * @memberOf Simple.prototype
     * @desc  the function to override for initialization
     */
    initializeInput: function(input) {
        var self = this;
        input.addEventListener('keyup', function(e) {
            if (e && (e.keyCode === 13 || e.keyCode === 27 || e.keyCode === 8)) {
                e.preventDefault();
                if (e.keyCode === 8) {
                    self.clearStopEditing();
                } else if (e.keyCode === 27) {
                    self.cancelEditing();
                } else {
                    self.stopEditing();
                }
                self.getGrid().repaint();
                self.getGrid().takeFocus();
            }
            self.getGrid().fireSyntheticEditorKeyUpEvent(self, e);
        });
        input.addEventListener('keydown', function(e) {
            self.getGrid().fireSyntheticEditorKeyDownEvent(self, e);
        });
        input.addEventListener('keypress', function(e) {
            console.log('keypress', e.keyCode);
            self.getGrid().fireSyntheticEditorKeyPressEvent(self, e);
        });
        // input.addEventListener('focusout', function() {
        //     self.stopEditing();
        // });
        // input.addEventListener('blur', function() {
        //     self.stopEditing();
        // });
        input.style.position = 'absolute';
        input.style.display = 'none';
        input.style.border = 'solid 2px black';
        input.style.outline = 0;
        input.style.padding = 0;
        input.style.zIndex = 1000;
        input.style.fontSize = '8pt';
        input.style.boxShadow = 'white 0px 0px 1px 1px';
    },

    /**
     * @memberOf Simple.prototype
     * @returns {object} the current editor's value
     */
    getEditorValue: function() {
        var value = this.getInput().value;
        return value;
    },

    /**
     * @memberOf Simple.prototype
     * @desc save the new value into the behavior(model)
     */
    setEditorValue: function(value) {
        this.getInput().value = value + '';
    },

    clearStopEditing: function() {
        this.setEditorValue('');
        this.stopEditing();
    },

    cancelEditing: function() {
        if (!this.isEditing) {
            return;
        }
        this.getInput().value = null;
        this.isEditing = false;
        this.hideEditor();
    },

    /**
     * @memberOf Simple.prototype
     * @desc display the editor
     */
    showEditor: function() {
        this.getInput().style.display = 'inline';
    },

    /**
     * @memberOf Simple.prototype
     * @desc hide the editor
     */
    hideEditor: function() {
        this.getInput().style.display = 'none';
    },

    /**
     * @memberOf Simple.prototype
     * @desc request focus for my input control
     */
    takeFocus: function() {
        var self = this;
        setTimeout(function() {
            self.input.focus();
            self.selectAll();
        }, 300);
    },

    /**
     * @memberOf Simple.prototype
     * @desc select everything
     */
    selectAll: function() {

    },

    /**
     * @memberOf Simple.prototype
     * @desc how much should I offset my bounds from 0,0
     */
    originOffset: function() {
        return [0, 0];
    },

    /**
     * @memberOf Simple.prototype
     * @desc set the bounds of my input control
     * @param {rectangle} rectangle - the bounds to move to
     */
    setBounds: function(cellBounds) {
        var originOffset = this.originOffset();
        var translation = 'translate('
            + (cellBounds.x - 1 + originOffset[0]) + 'px,'
            + (cellBounds.y - 1 + originOffset[1]) + 'px)';

        this.getInput().style.webkitTransform = translation;
        this.getInput().style.MozTransform = translation;
        this.getInput().style.msTransform = translation;
        this.getInput().style.OTransform = translation;

        // this.getInput().style.left = cellBounds.x + originOffset[0] + 'px';
        // this.getInput().style.top = cellBounds.y + originOffset[1] + 'px';

        this.getInput().style.width = (cellBounds.width + 2) + 'px';
        this.getInput().style.height = (cellBounds.height + 2) + 'px';
        //var xOffset = this.grid.canvas.getBoundingClientRect().left;
    }

});

module.exports = Simple;

},{"./CellEditor.js":43}],48:[function(require,module,exports){
'use strict';

var Simple = require('./Simple');

/**
 * @constructor
 */
var Slider = Simple.extend('Slider', {

    /**
     * my lookup alias
     * @type {string}
     * @memberOf Slider.prototype
     */
    alias: 'slider',

    template: function() {
        /*
            <input id="editor" type="range">
        */
    }

});

module.exports = Slider;

},{"./Simple":47}],49:[function(require,module,exports){
'use strict';

var Simple = require('./Simple');

/**
 * @constructor
 */
var Spinner = Simple.extend('Spinner', {

    /**
     * my lookup alias
     * @type {string}
     * @memberOf Spinner.prototype
     */
    alias: 'spinner',

    template: function() {
        /*
            <input id="editor" type="number">
        */
    }

});

module.exports = Spinner;

},{"./Simple":47}],50:[function(require,module,exports){
'use strict';

var Simple = require('./Simple');

/**
 * @constructor
 */
var Textfield = Simple.extend('Textfield', {

    /**
     * my lookup alias
     * @type {string}
     * @memberOf Textfield.prototype
     */
    alias: 'textfield',

    template: function() {
        /*
            <input id="editor">
        */
    },

    selectAll: function() {
        this.input.setSelectionRange(0, this.input.value.length);
    }
});

module.exports = Textfield;

},{"./Simple":47}],51:[function(require,module,exports){
'use strict';

module.exports = {
    CellEditor: require('./CellEditor'), // abstract base class
    Textfield: require('./Textfield'),
    Choice: require('./Choice'),
    //Combo: require('./Combo'),
    Color: require('./Color'),
    Date: require('./Date'),
    Slider: require('./Slider'),
    Spinner: require('./Spinner')
};
},{"./CellEditor":43,"./Choice":44,"./Color":45,"./Date":46,"./Slider":48,"./Spinner":49,"./Textfield":50}],52:[function(require,module,exports){
'use strict';

var Base = require('extend-me').Base;

var A = 'A'.charCodeAt(0);

/**
 * @constructor
 */
var DataModel = Base.extend('DataModel', {

    next: null,

    grid: null,

    setGrid: function(newGrid) {
        this.grid = newGrid;
    },

    getGrid: function() {
        return this.grid;
    },

    getBehavior: function() {
        return this.getGrid().getBehavior();
    },

    changed: function() {
        this.getBehavior().changed();
    },

    getPrivateState: function() {
        return this.getGrid().getPrivateState();
    },

    applyState: function() {

    },

    alphaFor: function(i) {
        // Name the column headers in A, .., AA, AB, AC, .., AZ format
        // quotient/remainder
        //var quo = Math.floor(col/27);
        var quo = Math.floor(i / 26);
        var rem = i % 26;
        var code = '';
        if (quo > 0) {
            code += this.alpha(quo - 1);
        }
        code += this.alpha(rem);
        return code;
    },

    alpha: function(i) {
        return String.fromCharCode(A + i);
    }

});

module.exports = DataModel;

},{"extend-me":3}],53:[function(require,module,exports){
'use strict';

var analytics = require('hyper-analytics');
//var analytics = require('../local_node_modules/newanalytics');
//var analytics = require('../local_node_modules/finanalytics');
var DataModel = require('./DataModel');

var UPWARDS_BLACK_ARROW = '\u2b06',
    DOWNWARDS_BLACK_ARROW = '\u2b07';

var nullDataSource = {
    isNullObject: function() {
        return true;
    },
    getFields: function() {
        return [];
    },
    getHeaders: function() {
        return [];
    },
    getColumnCount: function() {
        return 0;
    },
    getRowCount: function() {
        return 0;
    },
    getGrandTotals: function() {
        return [];
    },
    hasAggregates: function() {
        return false;
    },
    hasGroups: function() {
        return false;
    },
    getRow: function() {
        return null;
    }
};

/**
 * @name dataModels.JSON
 * @constructor
 */
var JSON = DataModel.extend('dataModels.JSON', {

    //null object pattern for the source object
    source: nullDataSource,

    preglobalfilter: nullDataSource,
    prefilter: nullDataSource,

    presorter: nullDataSource,
    analytics: nullDataSource,
    postfilter: nullDataSource,
    postsorter: nullDataSource,

    topTotals: [],

    /**
     * @memberOf dataModels.JSON.prototype
     * @returns {boolean}
     */
    hasAggregates: function() {
        return this.analytics.hasAggregates();
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @returns {boolean}
     */
    hasGroups: function() {
        return this.analytics.hasGroups();
    },

    getDataSource: function() {
        return this.analytics; //this.hasAggregates() ? this.analytics : this.presorter;
    },

    getFilterSource: function() {
        return this.prefilter; //this.hasAggregates() ? this.postfilter : this.prefilter;
    },

    getSortingSource: function() {
        return this.presorter; //this.hasAggregates() ? this.postsorter : this.presorter;
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @param {number} x
     * @param {number} y
     * @returns {*}
     */
    getValue: function(x, y) {
        var hasHierarchyColumn = this.hasHierarchyColumn();
        var grid = this.getGrid();
        var headerRowCount = grid.getHeaderRowCount();
        var value;
        if (hasHierarchyColumn && x === -2) {
            x = 0;
        }
        if (y < headerRowCount) {
            value = this.getHeaderRowValue(x, y);
            return value;
        }
        if (hasHierarchyColumn) {
            y += 1;
        }
        value = this.getDataSource().getValue(x, y - headerRowCount);
        return value;
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @param {number} x
     * @param {number} y
     * @returns {*}
     */
    getHeaderRowValue: function(x, y) {
        if (y === undefined) {
            return this.getHeaders()[Math.max(x, 0)];
        }
        var grid = this.getGrid();
        var behavior = grid.getBehavior();
        var isFilterRow = grid.isShowFilterRow();
        var isHeaderRow = grid.isShowHeaderRow();
        var isBoth = isFilterRow && isHeaderRow;
        var topTotalsOffset = (isFilterRow ? 1 : 0) + (isHeaderRow ? 1 : 0);
        if (y >= topTotalsOffset) {
            return this.getTopTotals()[y - topTotalsOffset][x];
        }
        var filter = this.getFilter(x);
        var image = filter.length === 0 ? 'filter-off' : 'filter-on';
        var header, sortString;
        if (isBoth) {
            if (y === 0) {
                header = this.getHeaders()[x];
                sortString = this.getSortImageForColumn(x, true);
                if (sortString) { header = sortString + header; }
                return [null, header, null];
            } else {
                return [null, filter, behavior.getImage(image)];
            }
        } else if (isFilterRow) {
            return [null, filter, behavior.getImage(image)];
        } else {
            header = this.getHeaders()[x];
            sortString = this.getSortImageForColumn(x, true);
            if (sortString) { header = sortString + header; }
            return [null, header, null];
        }
        return '';
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @param {number} x
     * @param {number} y
     * @param value
     */
    setValue: function(x, y, value) {
        var hasHierarchyColumn = this.hasHierarchyColumn();
        var grid = this.getGrid();
        var headerRowCount = grid.getHeaderRowCount();
        if (hasHierarchyColumn) {
            if (x === -2) {
                return;
            } else {
                x += 1;
            }
        }
        if (y < headerRowCount) {
            this.setHeaderRowValue(x, y, value);
        } else if (hasHierarchyColumn) {
            y += 1;
        } else {
            this.getDataSource().setValue(x, y - headerRowCount, value);
        }
        this.changed();
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @param {number} x
     * @param {number} y
     * @param value
     * @returns {*}
     */
    setHeaderRowValue: function(x, y, value) {
        if (value === undefined) {
            return this._setHeader(x, y); // y is really the value
        }
        var grid = this.getGrid();
        var isFilterRow = grid.isShowFilterRow();
        var isHeaderRow = grid.isShowHeaderRow();
        var isBoth = isFilterRow && isHeaderRow;
        var topTotalsOffset = (isFilterRow ? 1 : 0) + (isHeaderRow ? 1 : 0);
        if (y >= topTotalsOffset) {
            this.getTopTotals()[y - topTotalsOffset][x] = value;
        } else if (x === -1) {
            return; // can't change the row numbers
        } else if (isBoth) {
            if (y === 0) {
                return this._setHeader(x, value);
            } else {
                this.setFilter(x, value);
            }
        } else if (isFilterRow) {
            this.setFilter(x, value);
        } else {
            return this._setHeader(x, value);
        }
        return '';
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @param {number} colIndex
     * @returns {*}
     */
    getColumnProperties: function(colIndex) {
        //access directly because we want it ordered
        var column = this.getBehavior().allColumns[colIndex];
        if (column) {
            return column.getProperties();
        }
        return undefined;
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @param {number} colIndex
     * @returns {*}
     */
    getFilter: function(colIndex) {
        var columnProperties = this.getColumnProperties(colIndex);
        if (!columnProperties) {
            return '';
        }
        return columnProperties.filter || '';
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @param {number} colIndex
     * @param value
     */
    setFilter: function(colIndex, value) {
        var columnProperties = this.getColumnProperties(colIndex);
        columnProperties.filter = value;
        this.applyAnalytics();
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @returns {number}
     */
    getColumnCount: function() {
        return this.analytics.getColumnCount();
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @returns {number}
     */
    getRowCount: function() {
        var grid = this.getGrid();
        var count = this.getDataSource().getRowCount();
        count += grid.getHeaderRowCount();
        return count;
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @returns {string[]}
     */
    getHeaders: function() {
        return this.analytics.getHeaders();
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @param {string[]} headers
     */
    setHeaders: function(headers) {
        this.getDataSource().setHeaders(headers);
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @param {string[]} fields
     */
    setFields: function(fields) {
        this.getDataSource().setFields(fields);
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @returns {string[]}
     */
    getFields: function() {
        return this.getDataSource().getFields();
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @param {object[]} dataRows
     */
    setData: function(dataRows) {
        this.source = new analytics.JSDataSource(dataRows);
        this.preglobalfilter = new analytics.DataSourceGlobalFilter(this.source);
        this.prefilter = new analytics.DataSourceFilter(this.preglobalfilter);
        this.presorter = new analytics.DataSourceSorterComposite(this.prefilter);
        this.analytics = new analytics.DataSourceAggregator(this.presorter);

        this.applyAnalytics();

        //this.postfilter = new analytics.DataSourceFilter(this.analytics);
        //this.postsorter = new analytics.DataSourceSorterComposite(this.postfilter);
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @returns {*}
     */
    getTopTotals: function() {
        if (!this.hasAggregates()) {
            return this.topTotals;
        }
        return this.getDataSource().getGrandTotals();
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @param nestedArray
     */
    setTopTotals: function(nestedArray) {
        this.topTotals = nestedArray;
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @param groups
     */
    setGroups: function(groups) {
        this.analytics.setGroupBys(groups);
        this.applyAnalytics();
        this.getGrid().fireSyntheticGroupsChangedEvent(this.getGroups());
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @returns {object[]}
     */
    getGroups: function() {
        var headers = this.getHeaders().slice(0);
        var fields = this.getFields().slice(0);
        var groupBys = this.analytics.groupBys;
        var groups = [];
        for (var i = 0; i < groupBys.length; i++) {
            var field = headers[groupBys[i]];
            groups.push({
                id: groupBys[i],
                label: field,
                field: fields
            });
        }
        return groups;
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @returns {object[]}
     */
    getAvailableGroups: function() {
        var headers = this.source.getHeaders().slice(0);
        var groupBys = this.analytics.groupBys;
        var groups = [];
        for (var i = 0; i < headers.length; i++) {
            if (groupBys.indexOf(i) === -1) {
                var field = headers[i];
                groups.push({
                    id: i,
                    label: field,
                    field: field
                });
            }
        }
        return groups;
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @returns {object[]}
     */
    getVisibleColumns: function() {
        var items = this.getBehavior().columns;
        items = items.filter(function(each) {
            return each.label !== 'Tree';
        });
        return items;
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @returns {object[]}
     */
    getHiddenColumns: function() {
        var visible = this.getBehavior().columns;
        var all = this.getBehavior().allColumns;
        var hidden = [];
        for (var i = 0; i < all.length; i++) {
            if (visible.indexOf(all[i]) === -1) {
                hidden.push(all[i]);
            }
        }
        hidden.sort(function(a, b) {
            return a.label < b.label;
        });
        return hidden;
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @param aggregations
     */
    setAggregates: function(aggregations) {
        this.quietlySetAggregates(aggregations);
        this.applyAnalytics();
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @param aggregations
     */
    quietlySetAggregates: function(aggregations) {
        this.analytics.setAggregates(aggregations);
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @returns {boolean}
     */
    hasHierarchyColumn: function() {
        return this.hasAggregates() && this.hasGroups();
    },

    /**
     * @memberOf dataModels.JSON.prototype
     */
    applyAnalytics: function() {
        this.applyFilters();
        this.applySorts();
        this.applyGroupBysAndAggregations();
    },

    /**
     * @memberOf dataModels.JSON.prototype
     */
    applyGroupBysAndAggregations: function() {
        if (this.analytics.aggregates.length === 0) {
            this.quietlySetAggregates({});
        }
        this.analytics.apply();
    },

    /**
     * @memberOf dataModels.JSON.prototype
     */
    applyFilters: function() {
        this.preglobalfilter.apply();
        var colCount = this.getColumnCount();
        var filterSource = this.getFilterSource();
        var groupOffset = this.hasAggregates() ? 1 : 0;
        filterSource.clearAll();
        for (var i = 0; i < colCount; i++) {
            var filterText = this.getFilter(i);
            if (filterText.length > 0) {
                filterSource.add(i - groupOffset, textMatchFilter(filterText));
            }
        }
        filterSource.applyAll();
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @param {number} colIndex
     * @param keys
     */
    toggleSort: function(colIndex, keys) {
        this.incrementSortState(colIndex, keys);
        this.applyAnalytics();
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @param {number} colIndex
     * @param {string[]} keys
     */
    incrementSortState: function(colIndex, keys) {
        colIndex++; //hack to get around 0 index
        var state = this.getPrivateState();
        var hasCTRL = keys.indexOf('CTRL') > -1;
        state.sorts = state.sorts || [];
        var already = state.sorts.indexOf(colIndex);
        if (already === -1) {
            already = state.sorts.indexOf(-1 * colIndex);
        }
        if (already > -1) {
            if (state.sorts[already] > 0) {
                state.sorts[already] = -1 * state.sorts[already];
            } else {
                state.sorts.splice(already, 1);
            }
        } else if (hasCTRL || state.sorts.length === 0) {
            state.sorts.unshift(colIndex);
        } else {
            state.sorts.length = 0;
            state.sorts.unshift(colIndex);
        }
        if (state.sorts.length > 3) {
            state.sorts.length = 3;
        }
    },

    /**
     * @memberOf dataModels.JSON.prototype
     */
    applySorts: function() {
        var sortingSource = this.getSortingSource();
        var sorts = this.getPrivateState().sorts;
        var groupOffset = this.hasAggregates() ? 1 : 0;
        if (!sorts || sorts.length === 0) {
            sortingSource.clearSorts();
        } else {
            for (var i = 0; i < sorts.length; i++) {
                var colIndex = Math.abs(sorts[i]) - 1;
                var type = sorts[i] < 0 ? -1 : 1;
                sortingSource.sortOn(colIndex - groupOffset, type);
            }
        }
        sortingSource.applySorts();
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @param index
     * @param returnAsString
     * @returns {*}
     */
    getSortImageForColumn: function(index, returnAsString) {
        index++;
        var up = true;
        var sorts = this.getPrivateState().sorts;
        if (!sorts) {
            return null;
        }
        var position = sorts.indexOf(index);
        if (position < 0) {
            position = sorts.indexOf(-1 * index);
            up = false;
        }
        if (position < 0) {
            return null;
        }

        var rank = sorts.length - position;

        if (returnAsString) {
            var arrow = up ? UPWARDS_BLACK_ARROW : DOWNWARDS_BLACK_ARROW;
            return rank + arrow + ' ';
        }

        var name = rank + (up ? '-up' : '-down');
        return this.getBehavior().getImage(name);
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @param cell
     * @param event
     */
    cellClicked: function(cell, event) {
        if (!this.hasAggregates()) {
            return;
        }
        if (event.gridCell.x !== 0) {
            return; // this wasn't a click on the hierarchy column
        }
        var grid = this.getGrid();
        var headerRowCount = grid.getHeaderRowCount();
        var y = event.gridCell.y - headerRowCount + 1;
        this.analytics.click(y);
        this.changed();
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @param {number} y
     * @returns {object}
     */
    getRow: function(y) {
        var grid = this.getGrid();
        var headerRowCount = grid.getHeaderRowCount();
        if (y < headerRowCount && !this.hasAggregates()) {
            var topTotals = this.getTopTotals();
            return topTotals[y - (headerRowCount - topTotals.length)];
        }
        return this.getDataSource().getRow(y - headerRowCount);
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @param {number} y
     * @returns {object}
     */
    buildRow: function(y) {
        var colCount = this.getColumnCount();
        var fields = [].concat(this.getFields());
        var result = {};
        if (this.hasAggregates()) {
            result.tree = this.getValue(-2, y);
            fields.shift();
        }
        for (var i = 0; i < colCount; i++) {
            result[fields[i]] = this.getValue(i, y);
        }
        return result;
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @param {number} y
     * @returns {object}
     */
    getComputedRow: function(y) {
        var rcf = this.getRowContextFunction([y]);
        var fields = this.getFields();
        var row = {};
        for (var i = 0; i < fields.length; i++) {
            var field = fields[i];
            row[field] = rcf(field)[0];
        }
        return row;
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @param {string} fieldName
     * @param {number} y
     * @returns {*}
     */
    getValueByField: function(fieldName, y) {
        var index = this.getFields().indexOf(fieldName);
        if (this.hasAggregates()) {
            y += 1;
        }
        return this.getDataSource().getValue(index, y);
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @param {sring} string
     */
    setGlobalFilter: function(string) {
        if (!string || string.length === 0) {
            this.preglobalfilter.clear();
        } else {
            this.preglobalfilter.set(textMatchFilter(string));
        }
        this.applyAnalytics();
    },

    /**
     * @memberOf dataModels.JSON.prototype
     * @param {object} config
     * @param {number} x
     * @param {number} y
     * @param {number} untranslatedX
     * @param {number} untranslatedY
     * @returns {object}
     */
    getCellRenderer: function(config, x, y, untranslatedX, untranslatedY) {
        var renderer;
        var provider = this.getGrid().getCellProvider();

        config.x = x;
        config.y = y;
        config.untranslatedX = untranslatedX;
        config.untranslatedY = untranslatedY;

        renderer = provider.getCell(config);
        renderer.config = config;

        return renderer;
    },

    /**
     * @memberOf dataModels.JSON.prototype
     */
    applyState: function() {
        this.applyAnalytics();
    },

    /**
     * @memberOf dataModels.JSON.prototype
     */
    reset: function() {
        this.setData([]);
    }

});

function valueOrFunctionExecute(valueOrFunction) {
    return typeof valueOrFunction === 'function' ? valueOrFunction() : valueOrFunction;
}

function textMatchFilter(string) {
    return function(each) {
        each = valueOrFunctionExecute(each);
        return (each + '').toLowerCase().search(string.toLowerCase()) > -1;
    };
}

module.exports = JSON;

},{"./DataModel":52,"hyper-analytics":20}],54:[function(require,module,exports){
/* eslint-env browser */

'use strict';

var Hypergrid = require('./Hypergrid');

Hypergrid.behaviors = require('./behaviors/index');
Hypergrid.cellEditors = require('./cellEditors/index');
Hypergrid.features = require('./features/index');

window.fin = {
    Hypergrid: Hypergrid
};

},{"./Hypergrid":33,"./behaviors/index":42,"./cellEditors/index":51,"./features/index":71}],55:[function(require,module,exports){
'use strict';

var Feature = require('./Feature.js');

/**
 * @constructor
 */
var CellClick = Feature.extend('CellClick', {

    alias: 'CellClick',

    /**
     * @memberOf CellClick.prototype
     * @desc Handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleTap: function(grid, event) {
        var gridCell = event.gridCell;
        var behavior = grid.getBehavior();
        var headerRowCount = behavior.getHeaderRowCount();
        var headerColumnCount = behavior.getHeaderColumnCount();
        if ((gridCell.y >= headerRowCount) &&
            (gridCell.x >= headerColumnCount)) {
            grid.cellClicked(event);
        } else if (this.next) {
            this.next.handleTap(grid, event);
        }
    }
});

module.exports = CellClick;

},{"./Feature.js":63}],56:[function(require,module,exports){
'use strict';

var Feature = require('./Feature.js');

/**
 * @constructor
 */
var CellEditing = Feature.extend('CellEditing', {

    alias: 'CellEditing',

    /**
     * @memberOf CellEditing.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleDoubleClick: function(grid, event) {
        var behavior = grid.getBehavior();
        var headerRowCount = behavior.getHeaderRowCount();
        var headerColumnCount = behavior.getHeaderColumnCount();
        var gridCell = event.gridCell;
        if (gridCell.x >= headerColumnCount && gridCell.y >= headerRowCount) {
            grid._activateEditor(event);
        } else if (this.next) {
            this.next.handleDoubleClick(grid, event);
        }
    },

    /**
     * @memberOf CellEditing.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleHoldPulse: function(grid, event) {
        var behavior = grid.getBehavior();
        var headerRowCount = behavior.getHeaderRowCount();
        var headerColumnCount = behavior.getHeaderColumnCount();
        var gridCell = event.gridCell;
        if (gridCell.x >= headerColumnCount && gridCell.y >= headerRowCount) {
            grid._activateEditor(event);
        } else if (this.next) {
            this.next.handleHoldPulse(grid, event);
        }
    }

});

module.exports = CellEditing;

},{"./Feature.js":63}],57:[function(require,module,exports){
'use strict';

var Feature = require('./Feature.js');

/**
 * @constructor
 */
var CellSelection = Feature.extend('CellSelection', {

    alias: 'CellSelection',

    /**
     * The pixel location of the mouse pointer during a drag operation.
     * @type {window.fin.rectangular.Point}
     * @memberOf CellSelection.prototype
     */
    currentDrag: null,

    /**
     * the cell coordinates of the where the mouse pointer is during a drag operation
     * @type {Object}
     * @memberOf CellSelection.prototype
     */
    lastDragCell: null,

    /**
     * a millisecond value representing the previous time an autoscroll started
     * @type {number}
     * @default 0
     * @memberOf CellSelection.prototype
     */
    sbLastAuto: 0,

    /**
     * a millisecond value representing the time the current autoscroll started
     * @type {number}
     * @default 0
     * @memberOf CellSelection.prototype
     */
    sbAutoStart: 0,

    /**
     * @memberOf CellSelection.prototype
     * @desc Handle this event down the feature chain of responsibility.
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseUp: function(grid, event) {
        if (this.dragging) {
            this.dragging = false;
        }
        if (this.next) {
            this.next.handleMouseUp(grid, event);
        }
    },

    /**
     * @memberOf CellSelection.prototype
     * @desc Handle this event down the feature chain of responsibility.
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseDown: function(grid, event) {
        var isRightClick = event.primitiveEvent.detail.isRightClick;
        var behavior = grid.getBehavior();
        var cell = event.gridCell;
        var viewCell = event.viewPoint;
        var dx = cell.x;
        var dy = cell.y;
        var headerRowCount = behavior.getHeaderRowCount();
        var headerColumnCount = behavior.getHeaderColumnCount();
        var columnCount = behavior.getColumnCount();
        var isOutside = viewCell.x >= columnCount;

        var isHeader = dy < headerRowCount || dx < headerColumnCount;

        if (!grid.isCellSelection() || isRightClick || isHeader || isOutside) {
            if (this.next) {
                this.next.handleMouseDown(grid, event);
            }
        } else {

            var numFixedColumns = grid.getFixedColumnCount();
            var numFixedRows = grid.getFixedRowCount();

            //if we are in the fixed area do not apply the scroll values
            //check both x and y values independently
            if (viewCell.x < numFixedColumns) {
                dx = viewCell.x;
            }

            if (viewCell.y < numFixedRows) {
                dy = viewCell.y;
            }

            var dCell = grid.newPoint(dx, dy);

            var primEvent = event.primitiveEvent;
            var keys = primEvent.detail.keys;
            this.dragging = true;
            this.extendSelection(grid, dCell, keys);
        }
    },

    /**
     * @memberOf CellSelection.prototype
     * @desc Handle this event down the feature chain of responsibility.
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseDrag: function(grid, event) {
        var isRightClick = event.primitiveEvent.detail.isRightClick;

        if (!grid.isCellSelection() || isRightClick || !this.dragging) {
            if (this.next) {
                this.next.handleMouseDrag(grid, event);
            }
        } else {

            var numFixedColumns = grid.getFixedColumnCount();
            var numFixedRows = grid.getFixedRowCount();

            var cell = event.gridCell;
            var viewCell = event.viewPoint;
            var dx = cell.x;
            var dy = cell.y;

            //if we are in the fixed area do not apply the scroll values
            //check both x and y values independently
            if (viewCell.x < numFixedColumns) {
                dx = viewCell.x;
            }

            if (viewCell.y < numFixedRows) {
                dy = viewCell.y;
            }

            var dCell = grid.newPoint(dx, dy);

            var primEvent = event.primitiveEvent;
            this.currentDrag = primEvent.detail.mouse;
            this.lastDragCell = dCell;

            this.checkDragScroll(grid, this.currentDrag);
            this.handleMouseDragCellSelection(grid, dCell, primEvent.detail.keys);
        }
    },

    /**
     * @memberOf CellSelection.prototype
     * @desc Handle this event down the feature chain of responsibility.
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleKeyDown: function(grid, event) {
        var command = 'handle' + event.detail.char;
        if (this[command]) {
            this[command].call(this, grid, event.detail);
        }
    },

    /**
     * @memberOf CellSelection.prototype
     * @desc Handle a mousedrag selection.
     * @param {Hypergrid} grid
     * @param {Object} mouse - the event details
     * @param {Array} keys - array of the keys that are currently pressed down
     */
    handleMouseDragCellSelection: function(grid, gridCell, keys) {

        var behavior = grid.getBehavior();
        var headerRowCount = behavior.getHeaderRowCount();
        var headerColumnCount = behavior.getHeaderColumnCount();
        var x = gridCell.x;
        var y = gridCell.y;
        x = Math.max(headerColumnCount, x);
        y = Math.max(headerRowCount, y);

        var previousDragExtent = grid.getDragExtent();
        var mouseDown = grid.getMouseDown();

        //var scrollingNow = grid.isScrollingNow();

        var newX = x - mouseDown.x;
        var newY = y - mouseDown.y;

        if (previousDragExtent.x === newX && previousDragExtent.y === newY) {
            return;
        }

        grid.clearMostRecentSelection();

        grid.select(mouseDown.x, mouseDown.y, newX, newY);
        grid.setDragExtent(grid.newPoint(newX, newY));

        grid.repaint();
    },

    /**
     * @memberOf CellSelection.prototype
     * @desc this checks while were dragging if we go outside the visible bounds, if so, kick off the external autoscroll check function (above)
     * @param {Hypergrid} grid
     * @param {Object} mouse - the event details
     */
    checkDragScroll: function(grid, mouse) {
        if (!grid.resolveProperty('scrollingEnabled')) {
            return;
        }
        var b = grid.getDataBounds();
        var inside = b.contains(mouse);
        if (inside) {
            if (grid.isScrollingNow()) {
                grid.setScrollingNow(false);
            }
        } else if (!grid.isScrollingNow()) {
            grid.setScrollingNow(true);
            this.scrollDrag(grid);
        }
    },

    /**
     * @memberOf CellSelection.prototype
     * @desc this function makes sure that while we are dragging outside of the grid visible bounds, we srcroll accordingly
     * @param {Hypergrid} grid
     */
    scrollDrag: function(grid) {

        if (!grid.isScrollingNow()) {
            return;
        }

        var dragStartedInHeaderArea = grid.isMouseDownInHeaderArea();
        var lastDragCell = this.lastDragCell;
        var b = grid.getDataBounds();
        var xOffset = 0;
        var yOffset = 0;

        var numFixedColumns = grid.getFixedColumnCount();
        var numFixedRows = grid.getFixedRowCount();

        var dragEndInFixedAreaX = lastDragCell.x < numFixedColumns;
        var dragEndInFixedAreaY = lastDragCell.y < numFixedRows;

        if (!dragStartedInHeaderArea) {
            if (this.currentDrag.x < b.origin.x) {
                xOffset = -1;
            }
            if (this.currentDrag.y < b.origin.y) {
                yOffset = -1;
            }
        }
        if (this.currentDrag.x > b.origin.x + b.extent.x) {
            xOffset = 1;
        }
        if (this.currentDrag.y > b.origin.y + b.extent.y) {
            yOffset = 1;
        }

        var dragCellOffsetX = xOffset;
        var dragCellOffsetY = yOffset;

        if (dragEndInFixedAreaX) {
            dragCellOffsetX = 0;
        }

        if (dragEndInFixedAreaY) {
            dragCellOffsetY = 0;
        }

        this.lastDragCell = lastDragCell.plusXY(dragCellOffsetX, dragCellOffsetY);
        grid.scrollBy(xOffset, yOffset);
        this.handleMouseDragCellSelection(grid, lastDragCell, []); // update the selection
        grid.repaint();
        setTimeout(this.scrollDrag.bind(this, grid), 25);
    },

    /**
     * @memberOf CellSelection.prototype
     * @desc extend a selection or create one if there isnt yet
     * @param {Hypergrid} grid
     * @param {Object} gridCell - the event details
     * @param {Array} keys - array of the keys that are currently pressed down
     */
    extendSelection: function(grid, gridCell, keys) {
        var hasCTRL = keys.indexOf('CTRL') !== -1;
        var hasSHIFT = keys.indexOf('SHIFT') !== -1;
        // var scrollTop = grid.getVScrollValue();
        // var scrollLeft = grid.getHScrollValue();

        // var numFixedColumns = 0;//grid.getFixedColumnCount();
        // var numFixedRows = 0;//grid.getFixedRowCount();

        var mousePoint = grid.getMouseDown();
        var x = gridCell.x; // - numFixedColumns + scrollLeft;
        var y = gridCell.y; // - numFixedRows + scrollTop;

        //were outside of the grid do nothing
        if (x < 0 || y < 0) {
            return;
        }

        //we have repeated a click in the same spot deslect the value from last time
        if (x === mousePoint.x && y === mousePoint.y) {
            grid.clearMostRecentSelection();
            grid.popMouseDown();
            grid.repaint();
            return;
        }

        if (!hasCTRL && !hasSHIFT) {
            grid.clearSelections();
        }

        if (hasSHIFT) {
            grid.clearMostRecentSelection();
            grid.select(mousePoint.x, mousePoint.y, x - mousePoint.x + 1, y - mousePoint.y + 1);
            grid.setDragExtent(grid.newPoint(x - mousePoint.x + 1, y - mousePoint.y));
        } else {
            grid.select(x, y, 0, 0);
            grid.setMouseDown(grid.newPoint(x, y));
            grid.setDragExtent(grid.newPoint(0, 0));
        }
        grid.repaint();
    },


    /**
     * @memberOf CellSelection.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     */
    handleDOWNSHIFT: function(grid) {
        this.moveShiftSelect(grid, 0, 1);
    },

    /**
     * @memberOf CellSelection.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleUPSHIFT: function(grid) {
        this.moveShiftSelect(grid, 0, -1);
    },

    /**
     * @memberOf CellSelection.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleLEFTSHIFT: function(grid) {
        this.moveShiftSelect(grid, -1, 0);
    },

    /**
     * @memberOf CellSelection.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleRIGHTSHIFT: function(grid) {
        this.moveShiftSelect(grid, 1, 0);
    },

    /**
     * @memberOf CellSelection.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleDOWN: function(grid, event) {
        //keep the browser viewport from auto scrolling on key event
        event.primitiveEvent.preventDefault();

        var count = this.getAutoScrollAcceleration();
        this.moveSingleSelect(grid, 0, count);
    },

    /**
     * @memberOf CellSelection.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleUP: function(grid, event) {
        //keep the browser viewport from auto scrolling on key event
        event.primitiveEvent.preventDefault();

        var count = this.getAutoScrollAcceleration();
        this.moveSingleSelect(grid, 0, -count);
    },

    /**
     * @memberOf CellSelection.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleLEFT: function(grid) {
        this.moveSingleSelect(grid, -1, 0);
    },

    /**
     * @memberOf CellSelection.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleRIGHT: function(grid) {
        this.moveSingleSelect(grid, 1, 0);
    },

    /**
     * @memberOf CellSelection.prototype
     * @desc If we are holding down the same navigation key, accelerate the increment we scroll
     * #### returns: integer
     */
    getAutoScrollAcceleration: function() {
        var count = 1;
        var elapsed = this.getAutoScrollDuration() / 2000;
        count = Math.max(1, Math.floor(elapsed * elapsed * elapsed * elapsed));
        return count;
    },

    /**
     * @memberOf CellSelection.prototype
     * @desc set the start time to right now when we initiate an auto scroll
     */
    setAutoScrollStartTime: function() {
        this.sbAutoStart = Date.now();
    },

    /**
     * @memberOf CellSelection.prototype
     * @desc update the autoscroll start time if we haven't autoscrolled within the last 500ms otherwise update the current autoscroll time
     */
    pingAutoScroll: function() {
        var now = Date.now();
        if (now - this.sbLastAuto > 500) {
            this.setAutoScrollStartTime();
        }
        this.sbLastAuto = Date.now();
    },

    /**
     * @memberOf CellSelection.prototype
     * @desc answer how long we have been auto scrolling
     * #### returns: integer
     */
    getAutoScrollDuration: function() {
        if (Date.now() - this.sbLastAuto > 500) {
            return 0;
        }
        return Date.now() - this.sbAutoStart;
    },

    /**
     * @memberOf CellSelection.prototype
     * @desc Augment the most recent selection extent by (offsetX,offsetY) and scroll if necessary.
     * @param {Hypergrid} grid
     * @param {number} offsetX - x coordinate to start at
     * @param {number} offsetY - y coordinate to start at
     */
    moveShiftSelect: function(grid, offsetX, offsetY) {

        var maxColumns = grid.getColumnCount() - 1;
        var maxRows = grid.getRowCount() - 1;

        var maxViewableColumns = grid.getVisibleColumns() - 1;
        var maxViewableRows = grid.getVisibleRows() - 1;

        if (!grid.resolveProperty('scrollingEnabled')) {
            maxColumns = Math.min(maxColumns, maxViewableColumns);
            maxRows = Math.min(maxRows, maxViewableRows);
        }

        var origin = grid.getMouseDown();
        var extent = grid.getDragExtent();

        var newX = extent.x + offsetX;
        var newY = extent.y + offsetY;

        newX = Math.min(maxColumns - origin.x, Math.max(-origin.x, newX));
        newY = Math.min(maxRows - origin.y, Math.max(-origin.y, newY));

        grid.clearMostRecentSelection();
        grid.select(origin.x, origin.y, newX, newY);

        grid.setDragExtent(grid.newPoint(newX, newY));

        if (grid.insureModelColIsVisible(newX + origin.x, offsetX)) {
            this.pingAutoScroll();
        }
        if (grid.insureModelRowIsVisible(newY + origin.y, offsetY)) {
            this.pingAutoScroll();
        }

        grid.repaint();

    },

    /**
     * @memberOf CellSelection.prototype
     * @desc Replace the most recent selection with a single cell selection that is moved (offsetX,offsetY) from the previous selection extent.
     * @param {Hypergrid} grid
     * @param {number} offsetX - x coordinate to start at
     * @param {number} offsetY - y coordinate to start at
     */
    moveSingleSelect: function(grid, offsetX, offsetY) {

        var maxColumns = grid.getColumnCount() - 1;
        var maxRows = grid.getRowCount() - 1;

        var maxViewableColumns = grid.getVisibleColumnsCount() - 1;
        var maxViewableRows = grid.getVisibleRowsCount() - 1;

        var minRows = grid.getHeaderRowCount();
        var minCols = grid.getHeaderColumnCount();

        if (!grid.resolveProperty('scrollingEnabled')) {
            maxColumns = Math.min(maxColumns, maxViewableColumns);
            maxRows = Math.min(maxRows, maxViewableRows);
        }

        var mouseCorner = grid.getMouseDown().plus(grid.getDragExtent());

        var newX = mouseCorner.x + offsetX;
        var newY = mouseCorner.y + offsetY;

        newX = Math.min(maxColumns, Math.max(minCols, newX));
        newY = Math.min(maxRows, Math.max(minRows, newY));

        grid.clearSelections();
        grid.select(newX, newY, 0, 0);
        grid.setMouseDown(grid.newPoint(newX, newY));
        grid.setDragExtent(grid.newPoint(0, 0));

        if (grid.insureModelColIsVisible(newX, offsetX)) {
            this.pingAutoScroll();
        }
        if (grid.insureModelRowIsVisible(newY, offsetY)) {
            this.pingAutoScroll();
        }

        grid.repaint();

    }

});

module.exports = CellSelection;

},{"./Feature.js":63}],58:[function(require,module,exports){
'use strict';

var Feature = require('./Feature.js');

/**
 * @constructor
 */
var ColumnAutosizing = Feature.extend('ColumnAutosizing', {

    alias: 'ColumnAutosizing',

    /**
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     * @memberOf ColumnAutosizing.prototype
     */
    handleDoubleClick: function(grid, event) {
        var headerRowCount = grid.getHeaderRowCount();
        //var headerColCount = grid.getHeaderColumnCount();
        var gridCell = event.gridCell;
        if (gridCell.y <= headerRowCount) {
            grid.autosizeColumn(gridCell.x);
        } else if (this.next) {
            this.next.handleDoubleClick(grid, event);
        }
    }

});

module.exports = ColumnAutosizing;

},{"./Feature.js":63}],59:[function(require,module,exports){
/* eslint-env browser */
/* global requestAnimationFrame */

'use strict';

// This feature is responsible for column drag and drop reordering.
// This object is a mess and desperately needs a complete rewrite.....

var Feature = require('./Feature.js');

var columnAnimationTime = 150;
var dragger;
var draggerCTX;
var floatColumn;
var floatColumnCTX;

/**
 * @constructor
 */
var ColumnMoving = Feature.extend('ColumnMoving', {

    alias: 'ColumnMoving',

    /**
     * queue up the animations that need to play so they are done synchronously
     * @type {Array}
     * @memberOf CellMoving.prototype
     */
    floaterAnimationQueue: [],

    /**
     * am I currently auto scrolling right
     * @type {boolean}
     * @memberOf CellMoving.prototype
     */
    columnDragAutoScrollingRight: false,

    /**
     * am I currently auto scrolling left
     * @type {boolean}
     * @memberOf CellMoving.prototype
     */
    columnDragAutoScrollingLeft: false,

    /**
     * is the drag mechanism currently enabled ("armed")
     * @type {boolean}
     * @memberOf CellMoving.prototype
     */
    dragArmed: false,

    /**
     * am I dragging right now
     * @type {boolean}
     * @memberOf CellMoving.prototype
     */
    dragging: false,

    /**
     * the column index of the currently dragged column
     * @type {number}
     * @memberOf CellMoving.prototype
     */
    dragCol: -1,

    /**
     * an offset to position the dragged item from the cursor
     * @type {number}
     * @memberOf CellMoving.prototype
     */
    dragOffset: 0,

    /**
     * @memberOf CellMoving.prototype
     * @desc give me an opportunity to initialize stuff on the grid
     * @param {Hypergrid} grid
     */
    initializeOn: function(grid) {
        this.isFloatingNow = false;
        this.initializeAnimationSupport(grid);
        if (this.next) {
            this.next.initializeOn(grid);
        }
    },

    /**
     * @memberOf CellMoving.prototype
     * @desc initialize animation support on the grid
     * @param {Hypergrid} grid
     */
    initializeAnimationSupport: function(grid) {
        if (!dragger) {
            dragger = document.createElement('canvas');
            dragger.setAttribute('width', '0px');
            dragger.setAttribute('height', '0px');

            document.body.appendChild(dragger);
            draggerCTX = dragger.getContext('2d');
        }
        if (!floatColumn) {
            floatColumn = document.createElement('canvas');
            floatColumn.setAttribute('width', '0px');
            floatColumn.setAttribute('height', '0px');

            document.body.appendChild(floatColumn);
            floatColumnCTX = floatColumn.getContext('2d');
        }

    },

    getCanDragCursorName: function() {
        return '-webkit-grab';
    },

    getDraggingCursorName: function() {
        return '-webkit-grabbing';
    },

    /**
     * @memberOf CellMoving.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseDrag: function(grid, event) {

        var gridCell = event.gridCell;
        var x;
        //var y;

        var distance = Math.abs(event.primitiveEvent.detail.dragstart.x - event.primitiveEvent.detail.mouse.x);

        if (distance < 10) {
            if (this.next) {
                this.next.handleMouseDrag(grid, event);
            }
            return;
        }

        if (this.isHeaderRow(grid, event) && this.dragArmed && !this.dragging) {
            this.dragging = true;
            this.dragCol = gridCell.x;
            this.dragOffset = event.mousePoint.x;
            this.detachChain();
            x = event.primitiveEvent.detail.mouse.x - this.dragOffset;
            //y = event.primitiveEvent.detail.mouse.y;
            this.createDragColumn(grid, x, this.dragCol);
        } else if (this.next) {
            this.next.handleMouseDrag(grid, event);
        }

        if (this.dragging) {
            x = event.primitiveEvent.detail.mouse.x - this.dragOffset;
            //y = event.primitiveEvent.detail.mouse.y;
            this.dragColumn(grid, x);
        }
    },

    /**
     * @memberOf CellMoving.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseDown: function(grid, event) {
        if (grid.getBehavior().isColumnReorderable()) {
            if (this.isHeaderRow(grid, event) && event.gridCell.x !== -1) {
                this.dragArmed = true;
                this.cursor = this.getDraggingCursorName();
                grid.clearSelections();
            }
        }
        if (this.next) {
            this.next.handleMouseDown(grid, event);
        }
    },

    /**
     * @memberOf CellMoving.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseUp: function(grid, event) {
        //var col = event.gridCell.x;
        if (this.dragging) {
            this.cursor = null;
            //delay here to give other events a chance to be dropped
            var self = this;
            this.endDragColumn(grid);
            setTimeout(function() {
                self.attachChain();
            }, 200);
        }
        this.dragCol = -1;
        this.dragging = false;
        this.dragArmed = false;
        this.cursor = null;
        grid.repaint();

        if (this.next) {
            this.next.handleMouseUp(grid, event);
        }

    },

    /**
     * @memberOf CellMoving.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseMove: function(grid, event) {

        if (!this.dragging && event.mousePoint.y < 5 && event.viewPoint.y === 0) {
            this.cursor = this.getCanDragCursorName();
        } else {
            this.cursor = null;
        }

        if (this.next) {
            this.next.handleMouseMove(grid, event);
        }

        if (this.isHeaderRow(grid, event) && this.dragging) {
            this.cursor = this.getDraggingCursorName(); //move';
        }
    },

    /**
     * @memberOf CellMoving.prototype
     * @desc this is the main event handler that manages the dragging of the column
     * @param {Hypergrid} grid
     * @param {boolean} draggedToTheRight - are we moving to the right
     */
    floatColumnTo: function(grid, draggedToTheRight) {
        this.floatingNow = true;

        var renderer = grid.getRenderer();
        var colEdges = renderer.getColumnEdges();
        //var behavior = grid.getBehavior();
        var scrollLeft = grid.getHScrollValue();
        var floaterIndex = grid.renderOverridesCache.floater.columnIndex;
        var draggerIndex = grid.renderOverridesCache.dragger.columnIndex;
        var hdpiratio = grid.renderOverridesCache.dragger.hdpiratio;

        var draggerStartX;
        var floaterStartX;
        var fixedColumnCount = grid.getFixedColumnCount();
        var draggerWidth = grid.getColumnWidth(draggerIndex);
        var floaterWidth = grid.getColumnWidth(floaterIndex);

        var max = grid.getVisibleColumnsCount();

        var doffset = 0;
        var foffset = 0;

        if (draggerIndex >= fixedColumnCount) {
            doffset = scrollLeft;
        }
        if (floaterIndex >= fixedColumnCount) {
            foffset = scrollLeft;
        }

        if (draggedToTheRight) {
            draggerStartX = colEdges[Math.min(max, draggerIndex - doffset)];
            floaterStartX = colEdges[Math.min(max, floaterIndex - foffset)];

            grid.renderOverridesCache.dragger.startX = (draggerStartX + floaterWidth) * hdpiratio;
            grid.renderOverridesCache.floater.startX = draggerStartX * hdpiratio;

        } else {
            floaterStartX = colEdges[Math.min(max, floaterIndex - foffset)];
            draggerStartX = floaterStartX + draggerWidth;

            grid.renderOverridesCache.dragger.startX = floaterStartX * hdpiratio;
            grid.renderOverridesCache.floater.startX = draggerStartX * hdpiratio;
        }
        grid.swapColumns(draggerIndex, floaterIndex);
        grid.renderOverridesCache.dragger.columnIndex = floaterIndex;
        grid.renderOverridesCache.floater.columnIndex = draggerIndex;


        this.floaterAnimationQueue.unshift(this.doColumnMoveAnimation(grid, floaterStartX, draggerStartX));

        this.doFloaterAnimation(grid);

    },

    /**
     * @memberOf CellMoving.prototype
     * @desc manifest the column drag and drop animation
     * @param {Hypergrid} grid
     * @param {number} floaterStartX - the x start coordinate of the column underneath that floats behind the dragged column
     * @param {number} draggerStartX - the x start coordinate of the dragged column
     */
    doColumnMoveAnimation: function(grid, floaterStartX, draggerStartX) {
        var self = this;
        return function() {
            var d = floatColumn;
            d.style.display = 'inline';
            self.setCrossBrowserProperty(d, 'transform', 'translate(' + floaterStartX + 'px, ' + 0 + 'px)');

            //d.style.webkit-webkit-Transform = 'translate(' + floaterStartX + 'px, ' + 0 + 'px)';
            //d.style.webkit-webkit-Transform = 'translate(' + floaterStartX + 'px, ' + 0 + 'px)';

            requestAnimationFrame(function() {
                self.setCrossBrowserProperty(d, 'transition', (self.isWebkit ? '-webkit-' : '') + 'transform ' + columnAnimationTime + 'ms ease');
                self.setCrossBrowserProperty(d, 'transform', 'translate(' + draggerStartX + 'px, ' + -2 + 'px)');
            });
            grid.repaint();
            //need to change this to key frames

            setTimeout(function() {
                self.setCrossBrowserProperty(d, 'transition', '');
                grid.renderOverridesCache.floater = null;
                grid.repaint();
                self.doFloaterAnimation(grid);
                requestAnimationFrame(function() {
                    d.style.display = 'none';
                    self.isFloatingNow = false;
                });
            }, columnAnimationTime + 50);
        };
    },

    /**
     * @memberOf CellMoving.prototype
     * @desc manifest the floater animation
     * @param {Hypergrid} grid
     */
    doFloaterAnimation: function(grid) {
        if (this.floaterAnimationQueue.length === 0) {
            this.floatingNow = false;
            grid.repaint();
            return;
        }
        var animation = this.floaterAnimationQueue.pop();
        animation();
    },

    /**
     * @memberOf CellMoving.prototype
     * @desc create the float column at columnIndex underneath the dragged column
     * @param {Hypergrid} grid
     * @param {number} columnIndex - the index of the column that will be floating
     */
    createFloatColumn: function(grid, columnIndex) {

        var fixedColumnCount = grid.getFixedColumnCount();
        var scrollLeft = grid.getHScrollValue();

        if (columnIndex < fixedColumnCount) {
            scrollLeft = 0;
        }

        var renderer = grid.getRenderer();
        var columnEdges = renderer.getColumnEdges();

        var columnWidth = grid.getColumnWidth(columnIndex);
        var colHeight = grid.div.clientHeight;
        var d = floatColumn;
        var style = d.style;
        var location = grid.div.getBoundingClientRect();

        style.top = (location.top - 2) + 'px';
        style.left = location.left + 'px';
        style.position = 'fixed';

        var hdpiRatio = grid.getHiDPI(floatColumnCTX);

        d.setAttribute('width', Math.round(columnWidth * hdpiRatio) + 'px');
        d.setAttribute('height', Math.round(colHeight * hdpiRatio) + 'px');
        style.boxShadow = '0 10px 20px rgba(0,0,0,0.19), 0 6px 6px rgba(0,0,0,0.23)';
        style.width = columnWidth + 'px'; //Math.round(columnWidth / hdpiRatio) + 'px';
        style.height = colHeight + 'px'; //Math.round(colHeight / hdpiRatio) + 'px';
        style.borderTop = '1px solid ' + renderer.resolveProperty('lineColor');
        style.backgroundColor = renderer.resolveProperty('backgroundColor');

        var startX = columnEdges[columnIndex - scrollLeft];
        startX = startX * hdpiRatio;

        floatColumnCTX.scale(hdpiRatio, hdpiRatio);

        grid.renderOverridesCache.floater = {
            columnIndex: columnIndex,
            ctx: floatColumnCTX,
            startX: startX,
            width: columnWidth,
            height: colHeight,
            hdpiratio: hdpiRatio
        };

        style.zIndex = '4';
        this.setCrossBrowserProperty(d, 'transform', 'translate(' + startX + 'px, ' + -2 + 'px)');
        style.cursor = this.getDraggingCursorName();
        grid.repaint();
    },

    /**
     * @memberOf CellMoving.prototype
     * @desc utility function for setting cross browser css properties
     * @param {HTMLElement} element - descripton
     * @param {string} property - the property
     * @param {string} value - the value to assign
     */
    setCrossBrowserProperty: function(element, property, value) {
        var uProperty = property[0].toUpperCase() + property.substr(1);
        this.setProp(element, 'webkit' + uProperty, value);
        this.setProp(element, 'Moz' + uProperty, value);
        this.setProp(element, 'ms' + uProperty, value);
        this.setProp(element, 'O' + uProperty, value);
        this.setProp(element, property, value);
    },

    /**
     * @memberOf CellMoving.prototype
     * @desc utility function for setting properties on HTMLElements
     * @param {HTMLElement} element - descripton
     * @param {string} property - the property
     * @param {string} value - the value to assign
     */
    setProp: function(element, property, value) {
        if (property in element.style) {
            element.style[property] = value;
        }
    },

    /**
     * @memberOf CellMoving.prototype
     * @desc create the dragged column at columnIndex above the floated column
     * @param {Hypergrid} grid
     * @param {number} x - the start position
     * @param {number} columnIndex - the index of the column that will be floating
     */
    createDragColumn: function(grid, x, columnIndex) {

        var fixedColumnCount = grid.getFixedColumnCount();
        var scrollLeft = grid.getHScrollValue();

        if (columnIndex < fixedColumnCount) {
            scrollLeft = 0;
        }

        var renderer = grid.getRenderer();
        var columnEdges = renderer.getColumnEdges();
        var hdpiRatio = grid.getHiDPI(draggerCTX);
        var columnWidth = grid.getColumnWidth(columnIndex);
        var colHeight = grid.div.clientHeight;
        var d = dragger;
        var location = grid.div.getBoundingClientRect();
        var style = d.style;

        style.top = location.top + 'px';
        style.left = location.left + 'px';
        style.position = 'fixed';
        style.opacity = 0.85;
        style.boxShadow = '0 19px 38px rgba(0,0,0,0.30), 0 15px 12px rgba(0,0,0,0.22)';
        //style.zIndex = 100;
        style.borderTop = '1px solid ' + renderer.resolveProperty('lineColor');
        style.backgroundColor = grid.renderer.resolveProperty('backgroundColor');

        d.setAttribute('width', Math.round(columnWidth * hdpiRatio) + 'px');
        d.setAttribute('height', Math.round(colHeight * hdpiRatio) + 'px');

        style.width = columnWidth + 'px'; //Math.round(columnWidth / hdpiRatio) + 'px';
        style.height = colHeight + 'px'; //Math.round(colHeight / hdpiRatio) + 'px';

        var startX = columnEdges[columnIndex - scrollLeft];
        startX = startX * hdpiRatio;

        draggerCTX.scale(hdpiRatio, hdpiRatio);

        grid.renderOverridesCache.dragger = {
            columnIndex: columnIndex,
            ctx: draggerCTX,
            startX: startX,
            width: columnWidth,
            height: colHeight,
            hdpiratio: hdpiRatio
        };

        this.setCrossBrowserProperty(d, 'transform', 'translate(' + x + 'px, -5px)');
        style.zIndex = '5';
        style.cursor = this.getDraggingCursorName();
        grid.repaint();
    },

    /**
     * @memberOf CellMoving.prototype
     * @desc this function is the main dragging logic
     * @param {Hypergrid} grid
     * @param {number} x - the start position
     */
    dragColumn: function(grid, x) {

        //TODO: this function is overly complex, refactor this in to something more reasonable
        var self = this;
        //var renderer = grid.getRenderer();
        //var columnEdges = renderer.getColumnEdges();

        var autoScrollingNow = this.columnDragAutoScrollingRight || this.columnDragAutoScrollingLeft;

        var hdpiRatio = grid.getHiDPI(draggerCTX);

        var dragColumnIndex = grid.renderOverridesCache.dragger.columnIndex;
        var columnWidth = grid.renderOverridesCache.dragger.width;

        var minX = 0; //grid.getFixedColumnsWidth();
        var maxX = grid.renderer.getFinalVisableColumnBoundry() - columnWidth;
        x = Math.min(x, maxX + 15);
        x = Math.max(minX - 15, x);

        //am I at my lower bound
        var atMin = x < minX && dragColumnIndex !== 0;

        //am I at my upper bound
        var atMax = x > maxX;

        var d = dragger;

        this.setCrossBrowserProperty(d, 'transition', (self.isWebkit ? '-webkit-' : '') + 'transform ' + 0 + 'ms ease, box-shadow ' + columnAnimationTime + 'ms ease');

        this.setCrossBrowserProperty(d, 'transform', 'translate(' + x + 'px, ' + -10 + 'px)');
        requestAnimationFrame(function() {
            d.style.display = 'inline';
        });

        var overCol = grid.renderer.getColumnFromPixelX(x + (d.width / 2 / hdpiRatio));

        if (atMin) {
            overCol = 0;
        }

        if (atMax) {
            overCol = grid.getColumnCount() - 1;
        }

        var doAFloat = dragColumnIndex > overCol;
        doAFloat = doAFloat || (overCol - dragColumnIndex >= 1);

        if (doAFloat && !atMax && !autoScrollingNow) {
            var draggedToTheRight = dragColumnIndex < overCol;
            // if (draggedToTheRight) {
            //     overCol = overCol - 1;
            // }
            if (this.isFloatingNow) {
                return;
            }

            this.isFloatingNow = true;
            this.createFloatColumn(grid, overCol);
            this.floatColumnTo(grid, draggedToTheRight);
        } else {

            if (x < minX - 10) {
                this.checkAutoScrollToLeft(grid, x);
            }
            if (x > minX - 10) {
                this.columnDragAutoScrollingLeft = false;
            }
            //lets check for autoscroll to right if were up against it
            if (atMax || x > maxX + 10) {
                this.checkAutoScrollToRight(grid, x);
                return;
            }
            if (x < maxX + 10) {
                this.columnDragAutoScrollingRight = false;
            }
        }
    },

    /**
     * @memberOf CellMoving.prototype
     * @desc autoscroll to the right if necessary
     * @param {Hypergrid} grid
     * @param {number} x - the start position
     */
    checkAutoScrollToRight: function(grid, x) {
        if (this.columnDragAutoScrollingRight) {
            return;
        }
        this.columnDragAutoScrollingRight = true;
        this._checkAutoScrollToRight(grid, x);
    },

    _checkAutoScrollToRight: function(grid, x) {
        if (!this.columnDragAutoScrollingRight) {
            return;
        }
        var scrollLeft = grid.getHScrollValue();
        if (!grid.dragging || scrollLeft > (grid.sbHScrollConfig.rangeStop - 2)) {
            return;
        }
        var draggedIndex = grid.renderOverridesCache.dragger.columnIndex;
        grid.scrollBy(1, 0);
        var newIndex = draggedIndex + 1;
        console.log(newIndex, draggedIndex);
        grid.swapColumns(newIndex, draggedIndex);
        grid.renderOverridesCache.dragger.columnIndex = newIndex;

        setTimeout(this._checkAutoScrollToRight.bind(this, grid, x), 250);
    },

    /**
     * @memberOf CellMoving.prototype
     * @desc autoscroll to the left if necessary
     * @param {Hypergrid} grid
     * @param {number} x - the start position
     */
    checkAutoScrollToLeft: function(grid, x) {
        if (this.columnDragAutoScrollingLeft) {
            return;
        }
        this.columnDragAutoScrollingLeft = true;
        this._checkAutoScrollToLeft(grid, x);
    },

    _checkAutoScrollToLeft: function(grid, x) {
        if (!this.columnDragAutoScrollingLeft) {
            return;
        }

        var scrollLeft = grid.getHScrollValue();
        if (!grid.dragging || scrollLeft < 1) {
            return;
        }
        var draggedIndex = grid.renderOverridesCache.dragger.columnIndex;
        grid.swapColumns(draggedIndex + scrollLeft, draggedIndex + scrollLeft - 1);
        grid.scrollBy(-1, 0);
        setTimeout(this._checkAutoScrollToLeft.bind(this, grid, x), 250);
    },

    /**
     * @memberOf CellMoving.prototype
     * @desc a column drag has completed, update data and cleanup
     * @param {Hypergrid} grid
     */
    endDragColumn: function(grid) {

        var fixedColumnCount = grid.getFixedColumnCount();
        var scrollLeft = grid.getHScrollValue();

        var columnIndex = grid.renderOverridesCache.dragger.columnIndex;

        if (columnIndex < fixedColumnCount) {
            scrollLeft = 0;
        }

        var renderer = grid.getRenderer();
        var columnEdges = renderer.getColumnEdges();
        var self = this;
        var startX = columnEdges[columnIndex - scrollLeft];
        var d = dragger;

        self.setCrossBrowserProperty(d, 'transition', (self.isWebkit ? '-webkit-' : '') + 'transform ' + columnAnimationTime + 'ms ease, box-shadow ' + columnAnimationTime + 'ms ease');
        self.setCrossBrowserProperty(d, 'transform', 'translate(' + startX + 'px, ' + -1 + 'px)');
        d.style.boxShadow = '0px 0px 0px #888888';

        setTimeout(function() {
            grid.renderOverridesCache.dragger = null;
            grid.repaint();
            requestAnimationFrame(function() {
                d.style.display = 'none';
                grid.endDragColumnNotification();
            });
        }, columnAnimationTime + 50);

    },

    /**
     * @memberOf CellMoving.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    isHeaderRow: function(grid, event) {
        var gridCell = event.viewPoint;
        var isFixed = gridCell.y === 0;
        return isFixed;
    }

});

module.exports = ColumnMoving;

},{"./Feature.js":63}],60:[function(require,module,exports){
'use strict';

var Feature = require('./Feature.js');

/**
 * @constructor
 */
var ColumnResizing = Feature.extend('ColumnResizing', {

    alias: 'ColumnResizing',

    /**
     * the index of the column wall were currently dragging
     * @type {number}
     * @default -2
     * @memberOf ColumnResizing.prototype
     */
    dragIndex: -2,

    /**
     * the pixel location of the where the drag was initiated
     * @type {number}
     * @default -1
     * @memberOf ColumnResizing.prototype
     */
    dragStart: -1,

    /**
     * the starting width/height of the row/column we are dragging
     * @type {number}
     * @default -1
     * @memberOf ColumnResizing.prototype
     */
    dragIndexStartingSize: -1,

    /**
     * @memberOf ColumnResizing.prototype
     * @desc get the mouse x,y coordinate
     * @returns {number}
     * @param {MouseEvent} event - the mouse event to query
     */
    getMouseValue: function(event) {
        return event.primitiveEvent.detail.mouse.x;
    },

    /**
     * @memberOf ColumnResizing.prototype
     * @desc get the grid cell x,y coordinate
     * @returns {number}
     * @param {window.fin.rectangular.Point} gridCell
     */
    getGridCellValue: function(gridCell) {
        return gridCell.y;
    },

    /**
     * @memberOf ColumnResizing.prototype
     * @desc return the grids x,y scroll value
     * @returns {number}
     * @param {Hypergrid} grid
     */
    getScrollValue: function(grid) {
        return grid.getHScrollValue();
    },

    /**
     * @memberOf ColumnResizing.prototype
     * @desc return the width/height of the row/column of interest
     * @returns {number}
     * @param {Hypergrid} grid
     * @param {number} index - the row/column index of interest
     */
    getAreaSize: function(grid, index) {
        return grid.getColumnWidth(index);
    },

    /**
     * @memberOf ColumnResizing.prototype
     * @desc set the width/height of the row/column at index
     * @returns {number}
     * @param {Hypergrid} grid
     * @param {number} index - the row/column index of interest
     * @param {number} value - the width/height to set to
     */
    setAreaSize: function(grid, index, value) {
        grid.setColumnWidth(index, value);
    },

    /**
     * @memberOf ColumnResizing.prototype
     * @desc return the recently rendered area's width/height
     * @returns {number}
     * @param {Hypergrid} grid
     * @param {number} index - the row/column index of interest
     */
    getPreviousAbsoluteSize: function(grid, index) {
        return grid.getRenderedWidth(index);
    },

    /**
     * @memberOf ColumnResizing.prototype
     * @desc returns the index of which divider I'm over
     * @returns {number}
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    overAreaDivider: function(grid, event) {
        return grid.overColumnDivider(event);
    },

    /**
     * @memberOf ColumnResizing.prototype
     * @desc am I over the column/row area
     * @returns {boolean}
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    isFirstFixedOtherArea: function(grid, event) {
        return this.isFirstFixedRow(grid, event);
    },

    /**
     * @memberOf ColumnResizing.prototype
     * @desc return the cursor name
     * @returns {string}
     */
    getCursorName: function() {
        return 'col-resize';
    },

    /**
     * @memberOf ColumnResizing.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseDrag: function(grid, event) {
        if (this.dragIndex > -2) {
            //var fixedAreaCount = this.getFixedAreaCount(grid);
            //var offset = this.getFixedAreaSize(grid, fixedAreaCount + areaIndex);
            var mouse = this.getMouseValue(event);
            var scrollValue = this.getScrollValue(grid);
            if (this.dragIndex < this.getFixedAreaCount(grid)) {
                scrollValue = 0;
            }
            var previous = this.getPreviousAbsoluteSize(grid, this.dragIndex - scrollValue);
            var distance = mouse - previous;
            this.setAreaSize(grid, this.dragIndex, distance);
        } else if (this.next) {
            this.next.handleMouseDrag(grid, event);
        }
    },

    /**
     * @memberOf ColumnResizing.prototype
     * @desc get the width/height of a specific row/column
     * @param {Hypergrid} grid
     * @param {number} areaIndex - the row/column index of interest
     */
    getSize: function(grid, areaIndex) {
        return this.getAreaSize(grid, areaIndex);
    },

    /**
     * @memberOf ColumnResizing.prototype
     * @desc return the fixed area rows/columns count
     * @returns {number}
     * @param {Hypergrid} grid
     */
    getOtherFixedAreaCount: function(grid) {
        return grid.getFixedRowCount();
    },

    /**
     * @memberOf ColumnResizing.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseDown: function(grid, event) {
        var isEnabled = this.isEnabled(grid);
        var overArea = this.overAreaDivider(grid, event);
        if (isEnabled && overArea > -1 && this.isFirstFixedOtherArea(grid, event)) {
            var scrollValue = this.getScrollValue(grid);
            if (overArea < this.getFixedAreaCount(grid)) {
                scrollValue = 0;
            }
            this.dragIndex = overArea - 1 + scrollValue;
            this.dragStart = this.getMouseValue(event);
            this.dragIndexStartingSize = 0;
            this.detachChain();
        } else if (this.next) {
            this.next.handleMouseDown(grid, event);
        }
    },

    /**
     * @memberOf ColumnResizing.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseUp: function(grid, event) {
        var isEnabled = this.isEnabled(grid);
        if (isEnabled && this.dragIndex > -2) {
            this.cursor = null;
            this.dragIndex = -2;

            event.primitiveEvent.stopPropagation();
            //delay here to give other events a chance to be dropped
            var self = this;
            grid.synchronizeScrollingBoundries();
            setTimeout(function() {
                self.attachChain();
            }, 200);
        } else if (this.next) {
            this.next.handleMouseUp(grid, event);
        }
    },

    /**
     * @memberOf ColumnResizing.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseMove: function(grid, event) {
        if (this.dragIndex > -2) {
            return;
        }
        this.cursor = null;
        if (this.next) {
            this.next.handleMouseMove(grid, event);
        }
        this.checkForAreaResizeCursorChange(grid, event);
    },

    /**
     * @memberOf ColumnResizing.prototype
     * @desc fill this in
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    checkForAreaResizeCursorChange: function(grid, event) {
        var isEnabled = this.isEnabled(grid);
        if (isEnabled && this.overAreaDivider(grid, event) > -1 && this.isFirstFixedOtherArea(grid, event)) {
            this.cursor = this.getCursorName();
        } else {
            this.cursor = null;
        }

    },

    /**
     * @param {Hypergrid} grid
     * @returns {number}
     * @default -2
     * @memberOf ColumnResizing.prototype
     */
    getFixedAreaCount: function(grid) {
        var count = grid.getFixedColumnCount() + (grid.isShowRowNumbers() ? 1 : 0) + (grid.hasHierarchyColumn() ? 1 : 0);
        return count;
    },

    /**
     * @param {Hypergrid} grid
     * @param event
     * @default -2
     * @memberOf ColumnResizing.prototype
     */
    handleDoubleClick: function(grid, event) {
        var isEnabled = this.isEnabled(grid);
        var hasCursor = this.overAreaDivider(grid, event) > -1; //this.cursor !== null;
        var headerRowCount = grid.getHeaderRowCount();
        //var headerColCount = grid.getHeaderColumnCount();
        var gridCell = event.gridCell;
        if (isEnabled && hasCursor && (gridCell.y <= headerRowCount)) {
            grid.autosizeColumn(gridCell.x - 1);
        } else if (this.next) {
            this.next.handleDoubleClick(grid, event);
        }
    },

    /**
     * @param {Hypergrid} grid
     * @returns {boolean}
     * @default -2
     * @memberOf ColumnResizing.prototype
     */
    isEnabled: function(grid) {
        return true;
    }

});

module.exports = ColumnResizing;

},{"./Feature.js":63}],61:[function(require,module,exports){
'use strict';

var Feature = require('./Feature.js');

/**
 * @constructor
 */
var ColumnSelection = Feature.extend('ColumnSelection', {

    alias: 'ColumnSelection',

    /**
     * The pixel location of the mouse pointer during a drag operation.
     * @type {window.fin.rectangular.Point}
     * @default null
     * @memberOf ColumnSelection.prototype
     */
    currentDrag: null,

    /**
     * The cell coordinates of the where the mouse pointer is during a drag operation.
     * @type {Object}
     * @default null
     * @memberOf ColumnSelection.prototype
     */
    lastDragCell: null,

    /**
     * a millisecond value representing the previous time an autoscroll started
     * @type {number}
     * @default 0
     * @memberOf ColumnSelection.prototype
     */
    sbLastAuto: 0,

    /**
     * a millisecond value representing the time the current autoscroll started
     * @type {number}
     * @default 0
     * @memberOf ColumnSelection.prototype
     */
    sbAutoStart: 0,


    /**
     * @memberOf ColumnSelection.prototype
     * @desc Handle this event down the feature chain of responsibility.
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseUp: function(grid, event) {
        if (this.dragging) {
            this.dragging = false;
        }
        if (this.next) {
            this.next.handleMouseUp(grid, event);
            return;
        }
    },

    /**
     * @memberOf ColumnSelection.prototype
     * @desc * @desc Handle this event down the feature chain of responsibility.
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseDown: function(grid, event) {

        if ((!grid.isColumnSelection() || event.mousePoint.y < 5) && this.next) {
            this.next.handleMouseDown(grid, event);
            return;
        }

        var isRightClick = event.primitiveEvent.detail.isRightClick;
        var cell = event.gridCell;
        var viewCell = event.viewPoint;
        var dx = cell.x;
        var dy = cell.y;

        var isHeader = grid.isShowHeaderRow() && dy === 0 && dx !== -1;

        if (isRightClick || !isHeader) {
            if (this.next) {
                this.next.handleMouseDown(grid, event);
            }
        } else {

            var numFixedColumns = grid.getFixedColumnCount();

            //if we are in the fixed area do not apply the scroll values
            //check both x and y values independently
            if (viewCell.x < numFixedColumns) {
                dx = viewCell.x;
            }

            var dCell = grid.newPoint(dx, 0);

            var primEvent = event.primitiveEvent;
            var keys = primEvent.detail.keys;
            this.dragging = true;
            this.extendSelection(grid, dCell, keys);
        }
    },

    /**
     * @memberOf ColumnSelection.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseDrag: function(grid, event) {

        if ((!grid.isColumnSelection() || this.isColumnDragging(grid)) && this.next) {
            this.next.handleMouseDrag(grid, event);
            return;
        }

        var isRightClick = event.primitiveEvent.detail.isRightClick;

        if (isRightClick || !this.dragging) {
            if (this.next) {
                this.next.handleMouseDrag(grid, event);
            }
        } else {

            var numFixedColumns = grid.getFixedColumnCount();

            var cell = event.gridCell;
            var viewCell = event.viewPoint;
            var dx = cell.x;
            var dy = cell.y;

            //if we are in the fixed area do not apply the scroll values
            //check both x and y values independently
            if (viewCell.x < numFixedColumns) {
                dx = viewCell.x;
            }

            var dCell = grid.newPoint(dx, dy);

            var primEvent = event.primitiveEvent;
            this.currentDrag = primEvent.detail.mouse;
            this.lastDragCell = dCell;

            this.checkDragScroll(grid, this.currentDrag);
            this.handleMouseDragCellSelection(grid, dCell, primEvent.detail.keys);
        }
    },

    /**
     * @memberOf ColumnSelection.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleKeyDown: function(grid, event) {
        if (grid.getLastSelectionType() !== 'column') {
            if (this.next) {
                this.next.handleKeyDown(grid, event);
            }
            return;
        }
        var command = 'handle' + event.detail.char;
        if (this[command]) {
            this[command].call(this, grid, event.detail);
        }
    },

    /**
     * @memberOf ColumnSelection.prototype
     * @desc Handle a mousedrag selection
     * @param {Hypergrid} grid
     * @param {Object} mouse - the event details
     * @param {Array} keys - array of the keys that are currently pressed down
     */
    handleMouseDragCellSelection: function(grid, gridCell, keys) {

        //var behavior = grid.getBehavior();
        var x = gridCell.x;
        //            var previousDragExtent = grid.getDragExtent();
        var mouseDown = grid.getMouseDown();

        var newX = x - mouseDown.x;
        //var newY = y - mouseDown.y;

        // if (previousDragExtent.x === newX && previousDragExtent.y === newY) {
        //     return;
        // }

        grid.clearMostRecentColumnSelection();

        grid.selectColumn(mouseDown.x, x);
        grid.setDragExtent(grid.newPoint(newX, 0));

        grid.repaint();
    },

    /**
     * @memberOf ColumnSelection.prototype
     * @desc this checks while were dragging if we go outside the visible bounds, if so, kick off the external autoscroll check function (above)
     * @param {Hypergrid} grid
     * @param {Object} mouse - the event details
     */
    checkDragScroll: function(grid, mouse) {
        if (!grid.resolveProperty('scrollingEnabled')) {
            return;
        }
        var b = grid.getDataBounds();
        var inside = b.contains(mouse);
        if (inside) {
            if (grid.isScrollingNow()) {
                grid.setScrollingNow(false);
            }
        } else if (!grid.isScrollingNow()) {
            grid.setScrollingNow(true);
            this.scrollDrag(grid);
        }
    },

    /**
     * @memberOf ColumnSelection.prototype
     * @desc this function makes sure that while we are dragging outside of the grid visible bounds, we srcroll accordingly
     * @param {Hypergrid} grid
     */
    scrollDrag: function(grid) {

        if (!grid.isScrollingNow()) {
            return;
        }

        var lastDragCell = this.lastDragCell;
        var b = grid.getDataBounds();
        var xOffset = 0;
        var yOffset = 0;

        var numFixedColumns = grid.getFixedColumnCount();
        var numFixedRows = grid.getFixedRowCount();

        var dragEndInFixedAreaX = lastDragCell.x < numFixedColumns;
        var dragEndInFixedAreaY = lastDragCell.y < numFixedRows;

        if (this.currentDrag.x < b.origin.x) {
            xOffset = -1;
        }

        if (this.currentDrag.x > b.origin.x + b.extent.x) {
            xOffset = 1;
        }

        var dragCellOffsetX = xOffset;
        var dragCellOffsetY = yOffset;

        if (dragEndInFixedAreaX) {
            dragCellOffsetX = 0;
        }

        if (dragEndInFixedAreaY) {
            dragCellOffsetY = 0;
        }

        this.lastDragCell = lastDragCell.plusXY(dragCellOffsetX, dragCellOffsetY);
        grid.scrollBy(xOffset, yOffset);
        this.handleMouseDragCellSelection(grid, lastDragCell, []); // update the selection
        grid.repaint();
        setTimeout(this.scrollDrag.bind(this, grid), 25);
    },

    /**
     * @memberOf ColumnSelection.prototype
     * @desc extend a selection or create one if there isnt yet
     * @param {Hypergrid} grid
     * @param {Object} gridCell - the event details
     * @param {Array} keys - array of the keys that are currently pressed down
     */
    extendSelection: function(grid, gridCell, keys) {
        grid.stopEditing();
        //var hasCTRL = keys.indexOf('CTRL') !== -1;
        var hasSHIFT = keys.indexOf('SHIFT') !== -1;

        // var scrollTop = grid.getVScrollValue();
        // var scrollLeft = grid.getHScrollValue();

        // var numFixedColumns = 0;//grid.getFixedColumnCount();
        // var numFixedRows = 0;//grid.getFixedRowCount();

        var mousePoint = grid.getMouseDown();
        var x = gridCell.x; // - numFixedColumns + scrollLeft;
        var y = gridCell.y; // - numFixedRows + scrollTop;

        //were outside of the grid do nothing
        if (x < 0 || y < 0) {
            return;
        }

        //we have repeated a click in the same spot deslect the value from last time
        // if (mousePoint && x === mousePoint.x && y === mousePoint.y) {
        //     grid.clearSelections();
        //     grid.popMouseDown();
        //     grid.repaint();
        //     return;
        // }

        // if (!hasCTRL && !hasSHIFT) {
        //     grid.clearSelections();
        // }

        if (hasSHIFT) {
            grid.clearMostRecentColumnSelection();
            grid.selectColumn(x, mousePoint.x);
            grid.setDragExtent(grid.newPoint(x - mousePoint.x, 0));
        } else {
            grid.toggleSelectColumn(x, keys);
            grid.setMouseDown(grid.newPoint(x, y));
            grid.setDragExtent(grid.newPoint(0, 0));
        }
        grid.repaint();
    },


    /**
     * @memberOf ColumnSelection.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     */
    handleDOWNSHIFT: function(grid) {},

    /**
     * @memberOf ColumnSelection.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleUPSHIFT: function(grid) {},

    /**
     * @memberOf ColumnSelection.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleLEFTSHIFT: function(grid) {
        this.moveShiftSelect(grid, -1);
    },

    /**
     * @memberOf ColumnSelection.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleRIGHTSHIFT: function(grid) {
        this.moveShiftSelect(grid, 1);
    },

    /**
     * @memberOf ColumnSelection.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleDOWN: function(grid) {

        // var mouseCorner = grid.getMouseDown().plus(grid.getDragExtent());
        // var maxRows = grid.getRowCount() - 1;

        // var newX = mouseCorner.x;
        // var newY = grid.getHeaderRowCount() + grid.getVScrollValue();

        // newY = Math.min(maxRows, newY);

        // grid.clearSelections();
        // grid.select(newX, newY, 0, 0);
        // grid.setMouseDown(new grid.rectangular.Point(newX, newY));
        // grid.setDragExtent(new grid.rectangular.Point(0, 0));

        // grid.repaint();
    },

    /**
     * @memberOf ColumnSelection.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleUP: function(grid) {},

    /**
     * @memberOf ColumnSelection.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleLEFT: function(grid) {
        this.moveSingleSelect(grid, -1);
    },

    /**
     * @memberOf ColumnSelection.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleRIGHT: function(grid) {
        this.moveSingleSelect(grid, 1);
    },

    /**
     * @memberOf ColumnSelection.prototype
     * @desc If we are holding down the same navigation key, accelerate the increment we scroll
     * #### returns: integer
     */
    getAutoScrollAcceleration: function() {
        var count = 1;
        var elapsed = this.getAutoScrollDuration() / 2000;
        count = Math.max(1, Math.floor(elapsed * elapsed * elapsed * elapsed));
        return count;
    },

    /**
     * @memberOf ColumnSelection.prototype
     * @desc set the start time to right now when we initiate an auto scroll
     */
    setAutoScrollStartTime: function() {
        this.sbAutoStart = Date.now();
    },

    /**
     * @memberOf ColumnSelection.prototype
     * @desc update the autoscroll start time if we haven't autoscrolled within the last 500ms otherwise update the current autoscroll time
     */
    pingAutoScroll: function() {
        var now = Date.now();
        if (now - this.sbLastAuto > 500) {
            this.setAutoScrollStartTime();
        }
        this.sbLastAuto = Date.now();
    },

    /**
     * @memberOf ColumnSelection.prototype
     * @desc answer how long we have been auto scrolling
     * #### returns: integer
     */
    getAutoScrollDuration: function() {
        if (Date.now() - this.sbLastAuto > 500) {
            return 0;
        }
        return Date.now() - this.sbAutoStart;
    },

    /**
     * @memberOf ColumnSelection.prototype
     * @desc Augment the most recent selection extent by (offsetX,offsetY) and scroll if necessary.
     * @param {Hypergrid} grid
     * @param {number} offsetX - x coordinate to start at
     * @param {number} offsetY - y coordinate to start at
     */
    moveShiftSelect: function(grid, offsetX) {

        var maxColumns = grid.getColumnCount() - 1;

        var maxViewableColumns = grid.getVisibleColumns() - 1;

        if (!grid.resolveProperty('scrollingEnabled')) {
            maxColumns = Math.min(maxColumns, maxViewableColumns);
        }

        var origin = grid.getMouseDown();
        var extent = grid.getDragExtent();

        var newX = extent.x + offsetX;
        //var newY = grid.getRowCount();

        newX = Math.min(maxColumns - origin.x, Math.max(-origin.x, newX));

        grid.clearMostRecentColumnSelection();
        grid.selectColumn(origin.x, origin.x + newX);

        grid.setDragExtent(grid.newPoint(newX, 0));

        if (grid.insureModelColIsVisible(newX + origin.x, offsetX)) {
            this.pingAutoScroll();
        }

        grid.repaint();

    },

    /**
     * @memberOf ColumnSelection.prototype
     * @desc Replace the most recent selection with a single cell selection that is moved (offsetX,offsetY) from the previous selection extent.
     * @param {Hypergrid} grid
     * @param {number} offsetX - x coordinate to start at
     * @param {number} offsetY - y coordinate to start at
     */
    moveSingleSelect: function(grid, offsetX) {

        var maxColumns = grid.getColumnCount() - 1;

        var maxViewableColumns = grid.getVisibleColumnsCount() - 1;

        if (!grid.resolveProperty('scrollingEnabled')) {
            maxColumns = Math.min(maxColumns, maxViewableColumns);
        }

        var mouseCorner = grid.getMouseDown().plus(grid.getDragExtent());

        var newX = mouseCorner.x + offsetX;
        //var newY = grid.getRowCount();

        newX = Math.min(maxColumns, Math.max(0, newX));

        grid.clearSelections();
        grid.selectColumn(newX);
        grid.setMouseDown(grid.newPoint(newX, 0));
        grid.setDragExtent(grid.newPoint(0, 0));

        if (grid.insureModelColIsVisible(newX, offsetX)) {
            this.pingAutoScroll();
        }

        grid.repaint();

    },

    isColumnDragging: function(grid) {
        var dragger = grid.lookupFeature('ColumnMoving');
        if (!dragger) {
            return false;
        }
        var isActivated = dragger.dragging && !this.dragging;
        return isActivated;
    }

});

module.exports = ColumnSelection;

},{"./Feature.js":63}],62:[function(require,module,exports){
'use strict';

var Feature = require('./Feature.js');

/**
 * @constructor
 */
var ColumnSorting = Feature.extend('ColumnSorting', {

    alias: 'ColumnSorting',

    /**
     * @memberOf ColumnSorting.prototype
     * @desc Handle this event down the feature chain of responsibility.
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */

    handleDoubleClick: function(grid, event) {
        var gridCell = event.gridCell;
        if (grid.isShowHeaderRow() && gridCell.y === 0 && gridCell.x !== -1) {
            var keys = event.primitiveEvent.detail.keys;
            grid.toggleSort(gridCell.x, keys);
        } else if (this.next) {
            this.next.handleDoubleClick(grid, event);
        }
    },

    /**
     * @memberOf ColumnSorting.prototype
     * @desc * @desc Handle this event down the feature chain of responsibility.
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseMove: function(grid, event) {
        var y = event.gridCell.y;
        if (this.isFixedRow(grid, event) && y < 1) {
            this.cursor = 'pointer';
        } else {
            this.cursor = null;
        }
        if (this.next) {
            this.next.handleMouseMove(grid, event);
        }
    }

});

module.exports = ColumnSorting;

},{"./Feature.js":63}],63:[function(require,module,exports){
'use strict';

var Base = require('extend-me').Base;

/**
 * @constructor
 * @desc instances of features are connected to one another to make a chain of responsibility for handling all the input to the hypergrid.
 */
var Feature = Base.extend('Feature', {

    /**
     * the next feature to be given a chance to handle incoming events
     * @type {Feature}
     * @default null
     * @memberOf Feature.prototype
     */
    next: null,

    /**
     * a temporary holding field for my next feature when I'm in a disconnected state
     * @type {Feature}
     * @default null
     * @memberOf Feature.prototype
     */
    detached: null,

    /**
     * the cursor I want to be displayed
     * @type {string}
     * @default null
     * @memberOf Feature.prototype
     */
    cursor: null,

    /**
     * the cell location where the cursor is currently
     * @type {Point}
     * @default null
     * @memberOf Feature.prototype
     */
    currentHoverCell: null,

    /**
     * @memberOf Feature.prototype
     * @desc set my next field, or if it's populated delegate to the feature in my next field
     * @param {Feature} nextFeature - this is how we build the chain of responsibility
     */
    setNext: function(nextFeature) {
        if (this.next) {
            this.next.setNext(nextFeature);
        } else {
            this.next = nextFeature;
            this.detached = nextFeature;
        }
    },

    /**
     * @memberOf Feature.prototype
     * @desc disconnect my child
     */
    detachChain: function() {
        this.next = null;
    },

    /**
     * @memberOf Feature.prototype
     * @desc reattach my child from the detached reference
     */
    attachChain: function() {
        this.next = this.detached;
    },

    /**
     * @memberOf Feature.prototype
     * @desc handle mouse move down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseMove: function(grid, event) {
        if (this.next) {
            this.next.handleMouseMove(grid, event);
        }
    },

    /**
     * @memberOf Feature.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseExit: function(grid, event) {
        if (this.next) {
            this.next.handleMouseExit(grid, event);
        }
    },

    /**
     * @memberOf Feature.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseEnter: function(grid, event) {
        if (this.next) {
            this.next.handleMouseEnter(grid, event);
        }
    },

    /**
     * @memberOf Feature.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseDown: function(grid, event) {
        if (this.next) {
            this.next.handleMouseDown(grid, event);
        }
    },

    /**
     * @memberOf Feature.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseUp: function(grid, event) {
        if (this.next) {
            this.next.handleMouseUp(grid, event);
        }
    },

    /**
     * @memberOf Feature.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleKeyDown: function(grid, event) {
        if (this.next) {
            this.next.handleKeyDown(grid, event);
        }
    },

    /**
     * @memberOf Feature.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleKeyUp: function(grid, event) {
        if (this.next) {
            this.next.handleKeyUp(grid, event);
        }
    },

    /**
     * @memberOf Feature.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleWheelMoved: function(grid, event) {
        if (this.next) {
            this.next.handleWheelMoved(grid, event);
        }
    },

    /**
     * @memberOf Feature.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleDoubleClick: function(grid, event) {
        if (this.next) {
            this.next.handleDoubleClick(grid, event);
        }
    },

    /**
     * @memberOf Feature.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleHoldPulse: function(grid, event) {
        if (this.next) {
            this.next.handleHoldPulse(grid, event);
        }
    },

    /**
     * @memberOf Feature.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleTap: function(grid, event) {
        if (this.next) {
            this.next.handleTap(grid, event);
        }
    },

    /**
     * @memberOf Feature.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseDrag: function(grid, event) {
        if (this.next) {
            this.next.handleMouseDrag(grid, event);
        }
    },

    /**
     * @memberOf Feature.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleContextMenu: function(grid, event) {
        if (this.next) {
            this.next.handleContextMenu(grid, event);
        }
    },

    /**
     * @memberOf Feature.prototype
     * @desc toggle the column picker
     */

    toggleColumnPicker: function(grid) {
        if (this.next) {
            this.next.toggleColumnPicker(grid);
        }
    },


    /**
     * @memberOf Feature.prototype
     * @desc toggle the column picker
     */

    moveSingleSelect: function(grid, x, y) {
        if (this.next) {
            this.next.moveSingleSelect(grid, x, y);
        }
    },

    /**
     * @memberOf Feature.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    isFixedRow: function(grid, event) {
        var gridCell = event.viewPoint;
        var isFixed = gridCell.y < grid.getFixedRowCount();
        return isFixed;
    },

    /**
     * @memberOf Feature.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    isFirstFixedRow: function(grid, event) {
        var gridCell = event.viewPoint;
        var isFixed = gridCell.y < 1;
        return isFixed;
    },

    /**
     * @memberOf Feature.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    isFixedColumn: function(grid, event) {
        var gridCell = event.viewPoint;
        var isFixed = gridCell.x < grid.getFixedColumnCount();
        return isFixed;
    },

    /**
     * @memberOf Feature.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    isFirstFixedColumn: function(grid, event) {
        var gridCell = event.viewPoint;
        var edge = grid.isShowRowNumbers() ? 0 : 1;
        var isFixed = gridCell.x < edge;
        return isFixed;
    },

    /**
     * @memberOf Feature.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    isTopLeft: function(grid, event) {
        var isTopLeft = this.isFixedRow(grid, event) && this.isFixedColumn(grid, event);
        return isTopLeft;
    },

    /**
     * @memberOf Feature.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    setCursor: function(grid) {
        if (this.next) {
            this.next.setCursor(grid);
        }
        if (this.cursor) {
            grid.beCursor(this.cursor);
        }
    },

    /**
     * @memberOf Feature.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    initializeOn: function(grid) {
        if (this.next) {
            this.next.initializeOn(grid);
        }
    }

});

module.exports = Feature;

},{"extend-me":3}],64:[function(require,module,exports){
'use strict';

var Feature = require('./Feature.js');

/**
 * @constructor
 */
var Filters = Feature.extend('Filters', {

    alias: 'Filters',

    handleTap: function(grid, event) {
        var gridCell = event.gridCell;
        if (grid.isFilterRow(gridCell.y) && gridCell.x !== -1) {
            grid.filterClicked(event);
        } else if (this.next) {
            this.next.handleTap(grid, event);
        }
    }

});

module.exports = Filters;

},{"./Feature.js":63}],65:[function(require,module,exports){
'use strict';

var Feature = require('./Feature.js');

var commands = {
    PAGEDOWN: function(grid) { grid.pageDown(); },
    PAGEUP: function(grid) { grid.pageUp(); },
    PAGELEFT: function(grid) { grid.pageLeft(); },
    PAGERIGHT: function(grid) { grid.pageRight(); }
};

/**
 * @constructor
 */
var KeyPaging = Feature.extend('KeyPaging', {

    alias: 'KeyPaging',

    /**
     * @desc Handle this event down the feature chain of responsibility.
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     * @memberOf KeyPaging.prototype
     */
    handleKeyDown: function(grid, event) {
        var detail = event.detail.char;
        var func = commands[detail];
        if (func) {
            func(grid);
        } else if (this.next) {
            this.next.handleKeyDown(grid, event);
        }
    }

});

module.exports = KeyPaging;

},{"./Feature.js":63}],66:[function(require,module,exports){
'use strict';

var Feature = require('./Feature.js');

/**
 * @constructor
 */
var OnHover = Feature.extend('OnHover', {

    alias: 'OnHover',

    /**
     * @desc Hhandle this event down the feature chain of responsibility.
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     * @memberOf OnHover.prototype
     */
    handleMouseMove: function(grid, event) {
        var currentHoverCell = grid.getHoverCell();
        if (!event.gridCell.equals(currentHoverCell)) {
            if (currentHoverCell) {
                this.handleMouseExit(grid, currentHoverCell);
            }
            this.handleMouseEnter(grid, event);
            grid.setHoverCell(event.gridCell);
        } else {
            if (this.next) {
                this.next.handleMouseMove(grid, event);
            }
        }
    }

});

module.exports = OnHover;

},{"./Feature.js":63}],67:[function(require,module,exports){
/* eslint-env browser */
/* global requestAnimationFrame */

'use strict';

var Feature = require('./Feature.js');

var ANIMATION_TIME = 200;

/**
 * @constructor
 */
var Overlay = Feature.extend('Overlay', {

    alias: 'Overlay',

    /**
     * is the editor open
     * @type {boolean}
     * @memberOf Overlay.prototype
     */
    openEditor: false,

    /**
     * @memberOf Overlay.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleKeyUp: function(grid, event) {
        var key = event.detail.char.toLowerCase();
        var keys = grid.resolveProperty('editorActivationKeys');
        if (keys.indexOf(key) > -1) {
            this.toggleColumnPicker(grid);
        }
    },

    /**
     * @memberOf Overlay.prototype
     * @desc toggle the column picker on/off
     * @param {Hypergrid} grid
     */
    toggleColumnPicker: function(grid) {
        if (this.isColumnPickerOpen(grid)) {
            this.closeColumnPicker(grid);
        } else {
            this.openColumnPicker(grid);
        }
    },

    /**
     * @memberOf Overlay.prototype
     * @desc returns true if the column picker is open
     * @returns {boolean}
     * @param {Hypergrid} grid
     */
    isColumnPickerOpen: function(grid) {
        return this.overlay.style.display !== 'none';
    },

    /**
     * @memberOf Overlay.prototype
     * @desc open the column picker
     * #### returns: type
     * @param {Hypergrid} grid
     */
    openColumnPicker: function(grid) {
        if (this.isColumnPickerOpen()) {
            return;
        }
        this.openEditor = true;
        if (grid.getBehavior().openEditor(this.overlay) === false) {
            return;
        }

        var self = this;
        this.overlay.style.backgroundColor = grid.resolveProperty('backgroundColor');

        this.overlay.style.top = '0%';
        this.overlay.style.right = '0%';
        this.overlay.style.bottom = '0%';
        this.overlay.style.left = '0%';

        this.overlay.style.marginTop = '15px';
        this.overlay.style.marginRight = '35px';
        this.overlay.style.marginBottom = '35px';
        this.overlay.style.marginLeft = '15px';

        self.overlay.style.display = '';


        if (!this._closer) {
            this._closer = function(e) {
                var key = self.getCharFor(grid, e.keyCode).toLowerCase();
                var keys = grid.resolveProperty('editorActivationKeys');
                if (keys.indexOf(key) > -1 || e.keyCode === 27) {
                    e.preventDefault();
                    self.closeColumnPicker(grid);
                }
            };
        }

        //grid.setFocusable(false);
        requestAnimationFrame(function() {
            self.overlay.style.opacity = 0.95;
            document.addEventListener('keydown', self._closer, false);
        });
        setTimeout(function() {
            self.overlay.focus();
        }, 100);
    },

    /**
     * @memberOf Overlay.prototype
     * @desc close the column picker
     * @param {Hypergrid} grid
     */
    closeColumnPicker: function(grid) {
        //grid.setFocusable(true);

        if (!this.isColumnPickerOpen()) {
            return;
        }
        if (this.openEditor) {
            this.openEditor = false;
        } else {
            return;
        }
        if (grid.getBehavior().closeEditor(this.overlay) === false) {
            return;
        }

        document.removeEventListener('keydown', this._closer, false);

        var self = this;

        requestAnimationFrame(function() {
            self.overlay.style.opacity = 0;
        });

        setTimeout(function() {
            self.overlay.innerHTML = '';
            self.overlay.style.display = 'none';
            grid.takeFocus();
        }, ANIMATION_TIME);
    },

    /**
     * @memberOf Overlay.prototype
     * @desc initialize myself into the grid
     * #### returns: type
     * @param {Hypergrid} grid
     */
    initializeOn: function(grid) {
        this.initializeOverlaySurface(grid);
        if (this.next) {
            this.next.initializeOn(grid);
        }
    },

    /**
     * @memberOf Overlay.prototype
     * @desc initialize the overlay surface into the grid
     * #### returns: type
     * @param {Hypergrid} grid
     */
    initializeOverlaySurface: function(grid) {
        this.overlay = document.createElement('div');
        this.overlay.setAttribute('tabindex', 0);
        this.overlay.style.outline = 'none';
        this.overlay.style.boxShadow = '0 19px 38px rgba(0,0,0,0.30), 0 15px 12px rgba(0,0,0,0.22)';
        this.overlay.style.position = 'absolute';
        this.overlay.style.display = 'none';
        this.overlay.style.transition = 'opacity ' + ANIMATION_TIME + 'ms ease-in';
        this.overlay.style.opacity = 0;
        this.overlay.style.zIndex = 10;
        grid.div.appendChild(this.overlay);
        //document.body.appendChild(this.overlay);
    },

    /**
     * @memberOf Overlay.prototype
     * @desc get a human readable description of the key pressed from it's integer representation
     * @returns {string}
     * @param {Hypergrid} grid
     * @param {number} integer - the integer we want the char for
     */
    getCharFor: function(grid, integer) {
        var charMap = grid.getCanvas().getCharMap();
        return charMap[integer][0];
    }

});

module.exports = Overlay;

},{"./Feature.js":63}],68:[function(require,module,exports){
'use strict';

var ColumnResizing = require('./ColumnResizing');

/**
 * @constructor
 */
var RowResizing = ColumnResizing.extend('RowResizing', {

    alias: 'RowResizing',

    /**
     * the index of the row/column we are dragging
     * @type {number}
     * @default -1
     * @memberOf RowResizing.prototype
     */
    dragArea: -1,

    /**
     * the pixel location of the where the drag was initiated
     * @type {number}
     * @default -1
     * @memberOf RowResizing.prototype
     */
    dragStart: -1,

    /**
     * the starting width/height of the row/column we are dragging
     * @type {number}
     * @default -1
     * @memberOf RowResizing.prototype
     */
    dragAreaStartingSize: -1,

    /**
     * @memberOf RowResizing.prototype
     * @desc get the mouse x,y coordinate
     * @returns {number}
     * @param {MouseEvent} event - the mouse event to query
     */
    getMouseValue: function(event) {
        return event.primitiveEvent.detail.mouse.y;
    },

    /**
     * @function
     * @memberOf RowResizing.prototype
     * @desc get the grid cell x,y coordinate
     * @returns {number}
     * @param {Point} gridCell
     */
    getGridCellValue: function(gridCell) {
        return gridCell.x;
    },

    /**
     * @function
     * @memberOf RowResizing.prototype
     * @desc return the grids x,y scroll value
     * @returns {number}
     * @param {Hypergrid} grid
     */
    getScrollValue: function(grid) {
        return grid.getVScrollValue();
    },

    /**
     * @function
     * @memberOf RowResizing.prototype
     * @desc return the width/height of the row/column of interest
     * @returns {number}
     * @param {Hypergrid} grid
     * @param {number} index - the row/column index of interest
     */
    getAreaSize: function(grid, index) {
        return grid.getRowHeight(index);
    },

    /**
     * @function
     * @memberOf RowResizing.prototype
     * @desc set the width/height of the row/column at index
     * @returns {number}
     * @param {Hypergrid} grid
     * @param {number} index - the row/column index of interest
     * @param {number} value - the width/height to set to
     */
    setAreaSize: function(grid, index, value) {
        grid.setRowHeight(index, value);
    },

    /**
     * @function
     * @memberOf RowResizing.prototype
     * @desc returns the index of which divider I'm over
     * @returns {number}
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    overAreaDivider: function(grid, event) {
        return grid.overRowDivider(event);
    },

    /**
     * @function
     * @memberOf RowResizing.prototype
     * @desc am I over the column/row area
     * @returns {boolean}
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    isFirstFixedOtherArea: function(grid, event) {
        return this.isFirstFixedColumn(grid, event);
    },

    /**
     * @function
     * @memberOf RowResizing.prototype
     * @desc return the cursor name
     * @returns {string}
     */
    getCursorName: function() {
        return 'row-resize';
    },

    /**
     * @function
     * @memberOf RowResizing.prototype
     * @desc return the recently rendered area's width/height
     * @returns {number}
     * @param {Hypergrid} grid
     * @param {number} index - the row/column index of interest
     */
    getPreviousAbsoluteSize: function(grid, index) {
        return grid.getRenderedHeight(index);
    },

    /**
     * @function
     * @memberOf RowResizing.prototype
     * @desc return the fixed area rows/columns count
     * @returns {number}
     * @param {Hypergrid} grid
     */
    getOtherFixedAreaCount: function(grid) {
        return grid.getFixedColumnCount();
    },

    /**
     *
     * @param {Hypergrid} grid
     * @returns {number}
     * @default -2
     * @memberOf ColumnResizing.prototype
     */
    getFixedAreaCount: function(grid) {
        return grid.getFixedRowCount() + grid.getHeaderRowCount();
    },

    /**
     *
     * @param {Hypergrid} grid
     * @returns {boolean}
     * @default -2
     * @memberOf ColumnResizing.prototype
     */
    isEnabled: function(grid) {
        return grid.isRowResizeable();
    }

});

module.exports = RowResizing;

},{"./ColumnResizing":60}],69:[function(require,module,exports){
'use strict';

var Feature = require('./Feature.js');

/**
 * @constructor
 */
var RowSelection = Feature.extend('RowSelection', {

    alias: 'RowSelection',

    /**
     * The pixel location of the mouse pointer during a drag operation.
     * @type {Point}
     * @default null
     * @memberOf RowSelection.prototype
     */
    currentDrag: null,

    /**
     * The cell coordinates of the where the mouse pointer is during a drag operation.
     * @type {Object}
     * @default null
     * @memberOf RowSelection.prototype
     */
    lastDragCell: null,

    /**
     * a millisecond value representing the previous time an autoscroll started
     * @type {number}
     * @default 0
     * @memberOf RowSelection.prototype
     */
    sbLastAuto: 0,

    /**
     * a millisecond value representing the time the current autoscroll started
     * @type {number}
     * @default 0
     * @memberOf RowSelection.prototype
     */
    sbAutoStart: 0,

    dragArmed: false,

    /**
     * @memberOf RowSelection.prototype
     * @desc Handle this event down the feature chain of responsibility.
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseUp: function(grid, event) {
        if (this.dragArmed) {
            this.dragArmed = false;
            //global row selection
            if (event.gridCell.x === -1 && event.gridCell.y === 0) {
                grid.toggleSelectAllRows();
            }
            grid.fireSyntheticRowSelectionChangedEvent();
        } else if (this.dragging) {
            this.dragging = false;
            grid.fireSyntheticRowSelectionChangedEvent();
        } else if (this.next) {
            this.next.handleMouseUp(grid, event);
        }
    },

    /**
     * @memberOf RowSelection.prototype
     * @desc * @desc Handle this event down the feature chain of responsibility.
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseDown: function(grid, event) {

        var isRightClick = event.primitiveEvent.detail.isRightClick;
        var cell = event.gridCell;
        var viewCell = event.viewPoint;
        var dx = cell.x;
        var dy = cell.y;


        var isHeader = grid.isShowRowNumbers() && dx < 0;

        if (!grid.isRowSelection() || isRightClick || !isHeader) {
            if (this.next) {
                this.next.handleMouseDown(grid, event);
            }
        } else {

            var numFixedRows = grid.getFixedRowCount();

            //if we are in the fixed area do not apply the scroll values
            //check both x and y values independently
            if (viewCell.y < numFixedRows) {
                dy = viewCell.y;
            }

            var dCell = grid.newPoint(0, dy);

            var primEvent = event.primitiveEvent;
            var keys = primEvent.detail.keys;
            this.dragArmed = true;
            this.extendSelection(grid, dCell, keys);
        }
    },

    /**
     * @memberOf RowSelection.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleMouseDrag: function(grid, event) {
        var isRightClick = event.primitiveEvent.detail.isRightClick;

        if (!this.dragArmed || !grid.isRowSelection() || isRightClick) {
            if (this.next) {
                this.next.handleMouseDrag(grid, event);
            }
        } else {
            this.dragging = true;
            var numFixedRows = grid.getFixedRowCount();

            var cell = event.gridCell;
            var viewCell = event.viewPoint;
            //var dx = cell.x;
            var dy = cell.y;

            //if we are in the fixed area do not apply the scroll values
            //check both x and y values independently
            if (viewCell.y < numFixedRows) {
                dy = viewCell.y;
            }

            var dCell = grid.newPoint(0, dy);

            var primEvent = event.primitiveEvent;
            this.currentDrag = primEvent.detail.mouse;
            this.lastDragCell = dCell;

            this.checkDragScroll(grid, this.currentDrag);
            this.handleMouseDragCellSelection(grid, dCell, primEvent.detail.keys);
        }
    },

    /**
     * @memberOf RowSelection.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleKeyDown: function(grid, event) {
        if (grid.getLastSelectionType() !== 'row') {
            if (this.next) {
                this.next.handleKeyDown(grid, event);
            }
            return;
        }
        var command = 'handle' + event.detail.char;
        if (this[command]) {
            this[command].call(this, grid, event.detail);
        }
    },

    /**
     * @memberOf RowSelection.prototype
     * @desc Handle a mousedrag selection
     * @param {Hypergrid} grid
     * @param {Object} mouse - the event details
     * @param {Array} keys - array of the keys that are currently pressed down
     */
    handleMouseDragCellSelection: function(grid, gridCell, keys) {

        //var behavior = grid.getBehavior();
        var y = gridCell.y;
        //            var previousDragExtent = grid.getDragExtent();
        var mouseDown = grid.getMouseDown();

        var newY = y - mouseDown.y;
        //var newY = y - mouseDown.y;

        // if (previousDragExtent.x === newX && previousDragExtent.y === newY) {
        //     return;
        // }

        grid.clearMostRecentRowSelection();

        grid.selectRow(mouseDown.y, y);
        grid.setDragExtent(grid.newPoint(0, newY));

        grid.repaint();
    },

    /**
     * @memberOf RowSelection.prototype
     * @desc this checks while were dragging if we go outside the visible bounds, if so, kick off the external autoscroll check function (above)
     * @param {Hypergrid} grid
     * @param {Object} mouse - the event details
     */
    checkDragScroll: function(grid, mouse) {
        if (!grid.resolveProperty('scrollingEnabled')) {
            return;
        }
        var b = grid.getDataBounds();
        var inside = b.contains(mouse);
        if (inside) {
            if (grid.isScrollingNow()) {
                grid.setScrollingNow(false);
            }
        } else if (!grid.isScrollingNow()) {
            grid.setScrollingNow(true);
            this.scrollDrag(grid);
        }
    },

    /**
     * @memberOf RowSelection.prototype
     * @desc this function makes sure that while we are dragging outside of the grid visible bounds, we srcroll accordingly
     * @param {Hypergrid} grid
     */
    scrollDrag: function(grid) {
        if (!grid.isScrollingNow()) {
            return;
        }

        var lastDragCell = this.lastDragCell;
        var b = grid.getDataBounds();
        var xOffset = 0;
        var yOffset = 0;

        var numFixedColumns = grid.getFixedColumnCount();
        var numFixedRows = grid.getFixedRowCount();

        var dragEndInFixedAreaX = lastDragCell.x < numFixedColumns;
        var dragEndInFixedAreaY = lastDragCell.y < numFixedRows;

        if (this.currentDrag.y < b.origin.y) {
            yOffset = -1;
        }

        if (this.currentDrag.y > b.origin.y + b.extent.y) {
            yOffset = 1;
        }

        var dragCellOffsetX = xOffset;
        var dragCellOffsetY = yOffset;

        if (dragEndInFixedAreaX) {
            dragCellOffsetX = 0;
        }

        if (dragEndInFixedAreaY) {
            dragCellOffsetY = 0;
        }

        this.lastDragCell = lastDragCell.plusXY(dragCellOffsetX, dragCellOffsetY);
        grid.scrollBy(xOffset, yOffset);
        this.handleMouseDragCellSelection(grid, lastDragCell, []); // update the selection
        grid.repaint();
        setTimeout(this.scrollDrag.bind(this, grid), 25);
    },

    /**
     * @memberOf RowSelection.prototype
     * @desc extend a selection or create one if there isnt yet
     * @param {Hypergrid} grid
     * @param {Object} gridCell - the event details
     * @param {Array} keys - array of the keys that are currently pressed down
     */
    extendSelection: function(grid, gridCell, keys) {
        grid.stopEditing();
        //var hasCTRL = keys.indexOf('CTRL') !== -1;
        var hasSHIFT = keys.indexOf('SHIFT') !== -1;

        var mousePoint = grid.getMouseDown();
        var x = gridCell.x; // - numFixedColumns + scrollLeft;
        var y = gridCell.y; // - numFixedRows + scrollTop;

        //were outside of the grid do nothing
        if (x < 0 || y < 0) {
            return;
        }

        if (hasSHIFT) {
            grid.clearMostRecentRowSelection();
            grid.selectRow(y, mousePoint.y);
            grid.setDragExtent(grid.newPoint(0, y - mousePoint.y));
        } else {
            grid.toggleSelectRow(y, keys);
            grid.setMouseDown(grid.newPoint(x, y));
            grid.setDragExtent(grid.newPoint(0, 0));
        }
        grid.repaint();
    },


    /**
     * @memberOf RowSelection.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     */
    handleDOWNSHIFT: function(grid) {
        this.moveShiftSelect(grid, 1);
    },

    /**
     * @memberOf RowSelection.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleUPSHIFT: function(grid) {
        this.moveShiftSelect(grid, -1);
    },

    /**
     * @memberOf RowSelection.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleLEFTSHIFT: function(grid) {},

    /**
     * @memberOf RowSelection.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleRIGHTSHIFT: function(grid) {},

    /**
     * @memberOf RowSelection.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleDOWN: function(grid) {
        this.moveSingleSelect(grid, 1);
    },

    /**
     * @memberOf RowSelection.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleUP: function(grid) {
        this.moveSingleSelect(grid, -1);
    },

    /**
     * @memberOf RowSelection.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleLEFT: function(grid) {},

    /**
     * @memberOf RowSelection.prototype
     * @desc handle this event
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleRIGHT: function(grid) {

        var mouseCorner = grid.getMouseDown().plus(grid.getDragExtent());
        var maxColumns = grid.getColumnCount() - 1;

        var newX = grid.getHeaderColumnCount() + grid.getHScrollValue();
        var newY = mouseCorner.y;

        newX = Math.min(maxColumns, newX);

        grid.clearSelections();
        grid.select(newX, newY, 0, 0);
        grid.setMouseDown(grid.newPoint(newX, newY));
        grid.setDragExtent(grid.newPoint(0, 0));

        grid.repaint();
    },

    /**
     * @memberOf RowSelection.prototype
     * @desc If we are holding down the same navigation key, accelerate the increment we scroll
     * #### returns: integer
     */
    getAutoScrollAcceleration: function() {
        var count = 1;
        var elapsed = this.getAutoScrollDuration() / 2000;
        count = Math.max(1, Math.floor(elapsed * elapsed * elapsed * elapsed));
        return count;
    },

    /**
     * @memberOf RowSelection.prototype
     * @desc set the start time to right now when we initiate an auto scroll
     */
    setAutoScrollStartTime: function() {
        this.sbAutoStart = Date.now();
    },

    /**
     * @memberOf RowSelection.prototype
     * @desc update the autoscroll start time if we haven't autoscrolled within the last 500ms otherwise update the current autoscroll time
     */
    pingAutoScroll: function() {
        var now = Date.now();
        if (now - this.sbLastAuto > 500) {
            this.setAutoScrollStartTime();
        }
        this.sbLastAuto = Date.now();
    },

    /**
     * @memberOf RowSelection.prototype
     * @desc answer how long we have been auto scrolling
     * #### returns: integer
     */
    getAutoScrollDuration: function() {
        if (Date.now() - this.sbLastAuto > 500) {
            return 0;
        }
        return Date.now() - this.sbAutoStart;
    },

    /**
     * @memberOf RowSelection.prototype
     * @desc Augment the most recent selection extent by (offsetX,offsetY) and scroll if necessary.
     * @param {Hypergrid} grid
     * @param {number} offsetX - x coordinate to start at
     * @param {number} offsetY - y coordinate to start at
     */
    moveShiftSelect: function(grid, offsetY) {

        var maxRows = grid.getRowCount() - 1;

        var maxViewableRows = grid.getVisibleRows() - 1;

        if (!grid.resolveProperty('scrollingEnabled')) {
            maxRows = Math.min(maxRows, maxViewableRows);
        }

        var origin = grid.getMouseDown();
        var extent = grid.getDragExtent();

        var newY = extent.y + offsetY;
        //var newY = grid.getRowCount();

        newY = Math.min(maxRows - origin.y, Math.max(-origin.y, newY));

        grid.clearMostRecentRowSelection();
        grid.selectRow(origin.y, origin.y + newY);

        grid.setDragExtent(grid.newPoint(0, newY));

        if (grid.insureModelRowIsVisible(newY + origin.y, offsetY)) {
            this.pingAutoScroll();
        }

        grid.fireSyntheticRowSelectionChangedEvent();
        grid.repaint();

    },

    /**
     * @memberOf RowSelection.prototype
     * @desc Replace the most recent selection with a single cell selection that is moved (offsetX,offsetY) from the previous selection extent.
     * @param {Hypergrid} grid
     * @param {number} offsetX - x coordinate to start at
     * @param {number} offsetY - y coordinate to start at
     */
    moveSingleSelect: function(grid, offsetY) {

        var maxRows = grid.getRowCount() - 1;

        var maxViewableRows = grid.getVisibleRowsCount() - 1;

        if (!grid.resolveProperty('scrollingEnabled')) {
            maxRows = Math.min(maxRows, maxViewableRows);
        }

        var mouseCorner = grid.getMouseDown().plus(grid.getDragExtent());

        var newY = mouseCorner.y + offsetY;
        //var newY = grid.getRowCount();

        newY = Math.min(maxRows, Math.max(0, newY));

        grid.clearSelections();
        grid.selectRow(newY);
        grid.setMouseDown(grid.newPoint(0, newY));
        grid.setDragExtent(grid.newPoint(0, 0));

        if (grid.insureModelRowIsVisible(newY, offsetY)) {
            this.pingAutoScroll();
        }

        grid.fireSyntheticRowSelectionChangedEvent();
        grid.repaint();

    },

    isSingleRowSelection: function() {
        return true;
    }

});

module.exports = RowSelection;

},{"./Feature.js":63}],70:[function(require,module,exports){
'use strict';

var Feature = require('./Feature.js');

/**
 * @constructor
 */
var ThumbwheelScrolling = Feature.extend('ThumbwheelScrolling', {

    alias: 'ThumbwheelScrolling',

    /**
     * @memberOf ThumbwheelScrolling.prototype
     * @desc handle this event down the feature chain of responsibility
     * @param {Hypergrid} grid
     * @param {Object} event - the event details
     */
    handleWheelMoved: function(grid, e) {
        if (!grid.resolveProperty('scrollingEnabled')) {
            return;
        }
        var primEvent = e.primitiveEvent;
        var deltaY = primEvent.wheelDeltaY || -primEvent.deltaY;
        var deltaX = primEvent.wheelDeltaX || -primEvent.deltaX;
        if (deltaY > 0) {
            grid.scrollBy(0, -1);
        } else if (deltaY < -0) {
            grid.scrollBy(0, 1);
        } else if (deltaX > 0) {
            grid.scrollBy(-1, 0);
        } else if (deltaX < -0) {
            grid.scrollBy(1, 0);
        }
    }

});


module.exports = ThumbwheelScrolling;

},{"./Feature.js":63}],71:[function(require,module,exports){
'use strict';

module.exports = {
    Feature: require('./Feature'), // abstract base class
    CellClick: require('./CellClick'),
    CellEditing: require('./CellEditing'),
    CellSelection: require('./CellSelection'),
    ColumnAutosizing: require('./ColumnAutosizing'),
    ColumnMoving: require('./ColumnMoving'),
    ColumnResizing: require('./ColumnResizing'),
    ColumnSelection: require('./ColumnSelection'),
    ColumnSorting: require('./ColumnSorting'),
    Filters: require('./Filters'),
    KeyPaging: require('./KeyPaging'),
    OnHover: require('./OnHover'),
    Overlay: require('./Overlay'),
    RowResizing: require('./RowResizing'),
    RowSelection: require('./RowSelection'),
    ThumbwheelScrolling: require('./ThumbwheelScrolling')
};
},{"./CellClick":55,"./CellEditing":56,"./CellSelection":57,"./ColumnAutosizing":58,"./ColumnMoving":59,"./ColumnResizing":60,"./ColumnSelection":61,"./ColumnSorting":62,"./Feature":63,"./Filters":64,"./KeyPaging":65,"./OnHover":66,"./Overlay":67,"./RowResizing":68,"./RowSelection":69,"./ThumbwheelScrolling":70}],72:[function(require,module,exports){
'use strict';

var cssInjector = require('css-injector');

var stylesheets = {
    grid: [
        'div#grid-container {',
        '    position: relative;',
        '    display: inline-block;',
        '    -webkit-user-select: none;',
        '    -moz-user-select: none;',
        '    -ms-user-select: none;',
        '    -o-user-select: none;',
        '    user-select: none;',
        '    overflow: hidden; }',
        'visible { opacity: 0.75; }',
        'hidden { opacity: 0.0; }',
        'editor {',
        '    position: absolute;',
        '    display: none;',
        '    border: solid 2px black;',
        '    outline: 0;',
        '    padding: 0;',
        '    z-index: 1000; }'
    ],
    dnd: [
        'div.dragon-list, li.dragon-pop {',
        '    font-family: Roboto, sans-serif;',
        '    text-transform: capitalize; }',
        'div.dragon-list {',
        '    position: absolute;',
        '    top: 4%;',
        '    left: 4%;',
        '    height: 92%;',
        '    width: 20%; }',
        'div.dragon-list:nth-child(2) { left: 28%; }',
        'div.dragon-list:nth-child(3) { left: 52%; }',
        'div.dragon-list:nth-child(4) { left: 76%; }',
        'div.dragon-list > div, div.dragon-list > ul > li, li.dragon-pop { line-height: 46px; }',
        'div.dragon-list > ul { top: 46px; }',
        'div.dragon-list > ul > li:not(:last-child)::before, li.dragon-pop::before {',
        '    content: \'\\2b24\';', // BLACK LARGE CIRCLE
        '    color: #b6b6b6;',
        '    font-size: 30px;',
        '    margin: 8px 14px 8px 8px; }',
        'li.dragon-pop { opacity:.8; }'
    ]
};

function addStylesheet(key, referenceElement) {
    cssInjector(stylesheets[key], key, referenceElement);
}

module.exports = addStylesheet;

},{"css-injector":2}]},{},[54])
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi9Vc2Vycy9zdGV2ZXdpcnRzL1Byb2plY3RzL2Rldi9maW4taHlwZXJncmlkL25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCIvVXNlcnMvc3RldmV3aXJ0cy9Qcm9qZWN0cy9kZXYvZmluLWh5cGVyZ3JpZC9pbWFnZXMvaW5kZXguanMiLCIvVXNlcnMvc3RldmV3aXJ0cy9Qcm9qZWN0cy9kZXYvZmluLWh5cGVyZ3JpZC9ub2RlX21vZHVsZXMvY3NzLWluamVjdG9yL2luZGV4LmpzIiwiL1VzZXJzL3N0ZXZld2lydHMvUHJvamVjdHMvZGV2L2Zpbi1oeXBlcmdyaWQvbm9kZV9tb2R1bGVzL2V4dGVuZC1tZS9pbmRleC5qcyIsIi9Vc2Vycy9zdGV2ZXdpcnRzL1Byb2plY3RzL2Rldi9maW4taHlwZXJncmlkL25vZGVfbW9kdWxlcy9maW5iYXJzL2luZGV4LmpzIiwiL1VzZXJzL3N0ZXZld2lydHMvUHJvamVjdHMvZGV2L2Zpbi1oeXBlcmdyaWQvbm9kZV9tb2R1bGVzL2ZpbmNhbnZhcy9pbmRleC5qcyIsIi9Vc2Vycy9zdGV2ZXdpcnRzL1Byb2plY3RzL2Rldi9maW4taHlwZXJncmlkL25vZGVfbW9kdWxlcy9maW5jYW52YXMvanMvR3JhcGhpY3NDb250ZXh0LmpzIiwiL1VzZXJzL3N0ZXZld2lydHMvUHJvamVjdHMvZGV2L2Zpbi1oeXBlcmdyaWQvbm9kZV9tb2R1bGVzL2ZpbmNhbnZhcy9qcy9nYy1jb25zb2xlLWxvZ2dlci5qcyIsIi9Vc2Vycy9zdGV2ZXdpcnRzL1Byb2plY3RzL2Rldi9maW4taHlwZXJncmlkL25vZGVfbW9kdWxlcy9maW5jYW52YXMvanMvcG9seW1lcmdlc3R1cmVzLmRldi5qcyIsIi9Vc2Vycy9zdGV2ZXdpcnRzL1Byb2plY3RzL2Rldi9maW4taHlwZXJncmlkL25vZGVfbW9kdWxlcy9oeXBlci1hbmFseXRpY3Mvc3JjL2pzL0RhdGFOb2RlQmFzZS5qcyIsIi9Vc2Vycy9zdGV2ZXdpcnRzL1Byb2plY3RzL2Rldi9maW4taHlwZXJncmlkL25vZGVfbW9kdWxlcy9oeXBlci1hbmFseXRpY3Mvc3JjL2pzL0RhdGFOb2RlR3JvdXAuanMiLCIvVXNlcnMvc3RldmV3aXJ0cy9Qcm9qZWN0cy9kZXYvZmluLWh5cGVyZ3JpZC9ub2RlX21vZHVsZXMvaHlwZXItYW5hbHl0aWNzL3NyYy9qcy9EYXRhTm9kZUxlYWYuanMiLCIvVXNlcnMvc3RldmV3aXJ0cy9Qcm9qZWN0cy9kZXYvZmluLWh5cGVyZ3JpZC9ub2RlX21vZHVsZXMvaHlwZXItYW5hbHl0aWNzL3NyYy9qcy9EYXRhTm9kZVRyZWUuanMiLCIvVXNlcnMvc3RldmV3aXJ0cy9Qcm9qZWN0cy9kZXYvZmluLWh5cGVyZ3JpZC9ub2RlX21vZHVsZXMvaHlwZXItYW5hbHl0aWNzL3NyYy9qcy9EYXRhU291cmNlLmpzIiwiL1VzZXJzL3N0ZXZld2lydHMvUHJvamVjdHMvZGV2L2Zpbi1oeXBlcmdyaWQvbm9kZV9tb2R1bGVzL2h5cGVyLWFuYWx5dGljcy9zcmMvanMvRGF0YVNvdXJjZUFnZ3JlZ2F0b3IuanMiLCIvVXNlcnMvc3RldmV3aXJ0cy9Qcm9qZWN0cy9kZXYvZmluLWh5cGVyZ3JpZC9ub2RlX21vZHVsZXMvaHlwZXItYW5hbHl0aWNzL3NyYy9qcy9EYXRhU291cmNlRmlsdGVyLmpzIiwiL1VzZXJzL3N0ZXZld2lydHMvUHJvamVjdHMvZGV2L2Zpbi1oeXBlcmdyaWQvbm9kZV9tb2R1bGVzL2h5cGVyLWFuYWx5dGljcy9zcmMvanMvRGF0YVNvdXJjZUdsb2JhbEZpbHRlci5qcyIsIi9Vc2Vycy9zdGV2ZXdpcnRzL1Byb2plY3RzL2Rldi9maW4taHlwZXJncmlkL25vZGVfbW9kdWxlcy9oeXBlci1hbmFseXRpY3Mvc3JjL2pzL0RhdGFTb3VyY2VJbmRleGVkLmpzIiwiL1VzZXJzL3N0ZXZld2lydHMvUHJvamVjdHMvZGV2L2Zpbi1oeXBlcmdyaWQvbm9kZV9tb2R1bGVzL2h5cGVyLWFuYWx5dGljcy9zcmMvanMvRGF0YVNvdXJjZVNvcnRlci5qcyIsIi9Vc2Vycy9zdGV2ZXdpcnRzL1Byb2plY3RzL2Rldi9maW4taHlwZXJncmlkL25vZGVfbW9kdWxlcy9oeXBlci1hbmFseXRpY3Mvc3JjL2pzL0RhdGFTb3VyY2VTb3J0ZXJDb21wb3NpdGUuanMiLCIvVXNlcnMvc3RldmV3aXJ0cy9Qcm9qZWN0cy9kZXYvZmluLWh5cGVyZ3JpZC9ub2RlX21vZHVsZXMvaHlwZXItYW5hbHl0aWNzL3NyYy9qcy9pbmRleC5qcyIsIi9Vc2Vycy9zdGV2ZXdpcnRzL1Byb2plY3RzL2Rldi9maW4taHlwZXJncmlkL25vZGVfbW9kdWxlcy9oeXBlci1hbmFseXRpY3Mvc3JjL2pzL3V0aWwvTWFwcHkuanMiLCIvVXNlcnMvc3RldmV3aXJ0cy9Qcm9qZWN0cy9kZXYvZmluLWh5cGVyZ3JpZC9ub2RlX21vZHVsZXMvaHlwZXItYW5hbHl0aWNzL3NyYy9qcy91dGlsL2FnZ3JlZ2F0aW9ucy5qcyIsIi9Vc2Vycy9zdGV2ZXdpcnRzL1Byb2plY3RzL2Rldi9maW4taHlwZXJncmlkL25vZGVfbW9kdWxlcy9oeXBlci1hbmFseXRpY3Mvc3JjL2pzL3V0aWwvaGVhZGVyaWZ5LmpzIiwiL1VzZXJzL3N0ZXZld2lydHMvUHJvamVjdHMvZGV2L2Zpbi1oeXBlcmdyaWQvbm9kZV9tb2R1bGVzL2h5cGVyLWFuYWx5dGljcy9zcmMvanMvdXRpbC9zdGFibGVTb3J0LmpzIiwiL1VzZXJzL3N0ZXZld2lydHMvUHJvamVjdHMvZGV2L2Zpbi1oeXBlcmdyaWQvbm9kZV9tb2R1bGVzL2xpc3QtZHJhZ29uL2luZGV4LmpzIiwiL1VzZXJzL3N0ZXZld2lydHMvUHJvamVjdHMvZGV2L2Zpbi1oeXBlcmdyaWQvbm9kZV9tb2R1bGVzL2xydS1jYWNoZS9saWIvbHJ1LWNhY2hlLmpzIiwiL1VzZXJzL3N0ZXZld2lydHMvUHJvamVjdHMvZGV2L2Zpbi1oeXBlcmdyaWQvbm9kZV9tb2R1bGVzL211c3RhY2hlL211c3RhY2hlLmpzIiwiL1VzZXJzL3N0ZXZld2lydHMvUHJvamVjdHMvZGV2L2Zpbi1oeXBlcmdyaWQvbm9kZV9tb2R1bGVzL29iamVjdC1pdGVyYXRvcnMvaW5kZXguanMiLCIvVXNlcnMvc3RldmV3aXJ0cy9Qcm9qZWN0cy9kZXYvZmluLWh5cGVyZ3JpZC9ub2RlX21vZHVsZXMvcmVjdGFuZ3VsYXIvaW5kZXguanMiLCIvVXNlcnMvc3RldmV3aXJ0cy9Qcm9qZWN0cy9kZXYvZmluLWh5cGVyZ3JpZC9ub2RlX21vZHVsZXMvc3BhcnNlLWJvb2xlYW4tYXJyYXkvaW5kZXguanMiLCIvVXNlcnMvc3RldmV3aXJ0cy9Qcm9qZWN0cy9kZXYvZmluLWh5cGVyZ3JpZC9ub2RlX21vZHVsZXMvdGVtcGxleC9pbmRleC5qcyIsIi9Vc2Vycy9zdGV2ZXdpcnRzL1Byb2plY3RzL2Rldi9maW4taHlwZXJncmlkL3NyYy9DZWxsUHJvdmlkZXIuanMiLCIvVXNlcnMvc3RldmV3aXJ0cy9Qcm9qZWN0cy9kZXYvZmluLWh5cGVyZ3JpZC9zcmMvSHlwZXJncmlkLmpzIiwiL1VzZXJzL3N0ZXZld2lydHMvUHJvamVjdHMvZGV2L2Zpbi1oeXBlcmdyaWQvc3JjL1JlbmRlcmVyLmpzIiwiL1VzZXJzL3N0ZXZld2lydHMvUHJvamVjdHMvZGV2L2Zpbi1oeXBlcmdyaWQvc3JjL1NlbGVjdGlvbk1vZGVsLmpzIiwiL1VzZXJzL3N0ZXZld2lydHMvUHJvamVjdHMvZGV2L2Zpbi1oeXBlcmdyaWQvc3JjL2JlaGF2aW9ycy9CZWhhdmlvci5qcyIsIi9Vc2Vycy9zdGV2ZXdpcnRzL1Byb2plY3RzL2Rldi9maW4taHlwZXJncmlkL3NyYy9iZWhhdmlvcnMvQ29sdW1uLmpzIiwiL1VzZXJzL3N0ZXZld2lydHMvUHJvamVjdHMvZGV2L2Zpbi1oeXBlcmdyaWQvc3JjL2JlaGF2aW9ycy9EYXRhTW9kZWxEZWNvcmF0b3IuanMiLCIvVXNlcnMvc3RldmV3aXJ0cy9Qcm9qZWN0cy9kZXYvZmluLWh5cGVyZ3JpZC9zcmMvYmVoYXZpb3JzL0pTT04uanMiLCIvVXNlcnMvc3RldmV3aXJ0cy9Qcm9qZWN0cy9kZXYvZmluLWh5cGVyZ3JpZC9zcmMvYmVoYXZpb3JzL051bGwuanMiLCIvVXNlcnMvc3RldmV3aXJ0cy9Qcm9qZWN0cy9kZXYvZmluLWh5cGVyZ3JpZC9zcmMvYmVoYXZpb3JzL2ltYWdlcy5qcyIsIi9Vc2Vycy9zdGV2ZXdpcnRzL1Byb2plY3RzL2Rldi9maW4taHlwZXJncmlkL3NyYy9iZWhhdmlvcnMvaW5kZXguanMiLCIvVXNlcnMvc3RldmV3aXJ0cy9Qcm9qZWN0cy9kZXYvZmluLWh5cGVyZ3JpZC9zcmMvY2VsbEVkaXRvcnMvQ2VsbEVkaXRvci5qcyIsIi9Vc2Vycy9zdGV2ZXdpcnRzL1Byb2plY3RzL2Rldi9maW4taHlwZXJncmlkL3NyYy9jZWxsRWRpdG9ycy9DaG9pY2UuanMiLCIvVXNlcnMvc3RldmV3aXJ0cy9Qcm9qZWN0cy9kZXYvZmluLWh5cGVyZ3JpZC9zcmMvY2VsbEVkaXRvcnMvQ29sb3IuanMiLCIvVXNlcnMvc3RldmV3aXJ0cy9Qcm9qZWN0cy9kZXYvZmluLWh5cGVyZ3JpZC9zcmMvY2VsbEVkaXRvcnMvRGF0ZS5qcyIsIi9Vc2Vycy9zdGV2ZXdpcnRzL1Byb2plY3RzL2Rldi9maW4taHlwZXJncmlkL3NyYy9jZWxsRWRpdG9ycy9TaW1wbGUuanMiLCIvVXNlcnMvc3RldmV3aXJ0cy9Qcm9qZWN0cy9kZXYvZmluLWh5cGVyZ3JpZC9zcmMvY2VsbEVkaXRvcnMvU2xpZGVyLmpzIiwiL1VzZXJzL3N0ZXZld2lydHMvUHJvamVjdHMvZGV2L2Zpbi1oeXBlcmdyaWQvc3JjL2NlbGxFZGl0b3JzL1NwaW5uZXIuanMiLCIvVXNlcnMvc3RldmV3aXJ0cy9Qcm9qZWN0cy9kZXYvZmluLWh5cGVyZ3JpZC9zcmMvY2VsbEVkaXRvcnMvVGV4dGZpZWxkLmpzIiwiL1VzZXJzL3N0ZXZld2lydHMvUHJvamVjdHMvZGV2L2Zpbi1oeXBlcmdyaWQvc3JjL2NlbGxFZGl0b3JzL2luZGV4LmpzIiwiL1VzZXJzL3N0ZXZld2lydHMvUHJvamVjdHMvZGV2L2Zpbi1oeXBlcmdyaWQvc3JjL2RhdGFNb2RlbHMvRGF0YU1vZGVsLmpzIiwiL1VzZXJzL3N0ZXZld2lydHMvUHJvamVjdHMvZGV2L2Zpbi1oeXBlcmdyaWQvc3JjL2RhdGFNb2RlbHMvSlNPTi5qcyIsIi9Vc2Vycy9zdGV2ZXdpcnRzL1Byb2plY3RzL2Rldi9maW4taHlwZXJncmlkL3NyYy9mYWtlXzIxNzg1MTg2LmpzIiwiL1VzZXJzL3N0ZXZld2lydHMvUHJvamVjdHMvZGV2L2Zpbi1oeXBlcmdyaWQvc3JjL2ZlYXR1cmVzL0NlbGxDbGljay5qcyIsIi9Vc2Vycy9zdGV2ZXdpcnRzL1Byb2plY3RzL2Rldi9maW4taHlwZXJncmlkL3NyYy9mZWF0dXJlcy9DZWxsRWRpdGluZy5qcyIsIi9Vc2Vycy9zdGV2ZXdpcnRzL1Byb2plY3RzL2Rldi9maW4taHlwZXJncmlkL3NyYy9mZWF0dXJlcy9DZWxsU2VsZWN0aW9uLmpzIiwiL1VzZXJzL3N0ZXZld2lydHMvUHJvamVjdHMvZGV2L2Zpbi1oeXBlcmdyaWQvc3JjL2ZlYXR1cmVzL0NvbHVtbkF1dG9zaXppbmcuanMiLCIvVXNlcnMvc3RldmV3aXJ0cy9Qcm9qZWN0cy9kZXYvZmluLWh5cGVyZ3JpZC9zcmMvZmVhdHVyZXMvQ29sdW1uTW92aW5nLmpzIiwiL1VzZXJzL3N0ZXZld2lydHMvUHJvamVjdHMvZGV2L2Zpbi1oeXBlcmdyaWQvc3JjL2ZlYXR1cmVzL0NvbHVtblJlc2l6aW5nLmpzIiwiL1VzZXJzL3N0ZXZld2lydHMvUHJvamVjdHMvZGV2L2Zpbi1oeXBlcmdyaWQvc3JjL2ZlYXR1cmVzL0NvbHVtblNlbGVjdGlvbi5qcyIsIi9Vc2Vycy9zdGV2ZXdpcnRzL1Byb2plY3RzL2Rldi9maW4taHlwZXJncmlkL3NyYy9mZWF0dXJlcy9Db2x1bW5Tb3J0aW5nLmpzIiwiL1VzZXJzL3N0ZXZld2lydHMvUHJvamVjdHMvZGV2L2Zpbi1oeXBlcmdyaWQvc3JjL2ZlYXR1cmVzL0ZlYXR1cmUuanMiLCIvVXNlcnMvc3RldmV3aXJ0cy9Qcm9qZWN0cy9kZXYvZmluLWh5cGVyZ3JpZC9zcmMvZmVhdHVyZXMvRmlsdGVycy5qcyIsIi9Vc2Vycy9zdGV2ZXdpcnRzL1Byb2plY3RzL2Rldi9maW4taHlwZXJncmlkL3NyYy9mZWF0dXJlcy9LZXlQYWdpbmcuanMiLCIvVXNlcnMvc3RldmV3aXJ0cy9Qcm9qZWN0cy9kZXYvZmluLWh5cGVyZ3JpZC9zcmMvZmVhdHVyZXMvT25Ib3Zlci5qcyIsIi9Vc2Vycy9zdGV2ZXdpcnRzL1Byb2plY3RzL2Rldi9maW4taHlwZXJncmlkL3NyYy9mZWF0dXJlcy9PdmVybGF5LmpzIiwiL1VzZXJzL3N0ZXZld2lydHMvUHJvamVjdHMvZGV2L2Zpbi1oeXBlcmdyaWQvc3JjL2ZlYXR1cmVzL1Jvd1Jlc2l6aW5nLmpzIiwiL1VzZXJzL3N0ZXZld2lydHMvUHJvamVjdHMvZGV2L2Zpbi1oeXBlcmdyaWQvc3JjL2ZlYXR1cmVzL1Jvd1NlbGVjdGlvbi5qcyIsIi9Vc2Vycy9zdGV2ZXdpcnRzL1Byb2plY3RzL2Rldi9maW4taHlwZXJncmlkL3NyYy9mZWF0dXJlcy9UaHVtYndoZWVsU2Nyb2xsaW5nLmpzIiwiL1VzZXJzL3N0ZXZld2lydHMvUHJvamVjdHMvZGV2L2Zpbi1oeXBlcmdyaWQvc3JjL2ZlYXR1cmVzL2luZGV4LmpzIiwiL1VzZXJzL3N0ZXZld2lydHMvUHJvamVjdHMvZGV2L2Zpbi1oeXBlcmdyaWQvc3JjL3N0eWxlc2hlZXRzLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy94QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeHJFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMva0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25uQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaFZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25HQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdmxCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxM0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pnQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFuREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3J0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeGlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdxQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hTQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6aEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25NQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hnQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3Rocm93IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIil9dmFyIGY9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGYuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sZixmLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIm1vZHVsZS5leHBvcnRzID0geyAvLyBUaGlzIGZpbGUgZ2VuZXJhdGVkIGJ5IGd1bHAtaW1hZ2luZS02NCBhdCAyOjAyOjM4IFBNIG9uIDExLzMwLzIwMTVcblx0XCIxLWFicy1kb3duXCI6IHtcblx0XHR0eXBlOiBcImltYWdlL3BuZ1wiLFxuXHRcdGRhdGE6IFwiaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUE0QUFBQUtDQVlBQUFDRTJXL0hBQUFBQkdkQlRVRUFBTEdQQy94aEJRQUFBQWx3U0ZsekFBQU93Z0FBRHNJQkZTaEtnQUFBQUJoMFJWaDBVMjltZEhkaGNtVUFjR0ZwYm5RdWJtVjBJRFF1TUM0MVpZVXlaUUFBQUZGSlJFRlVLRk5qUUFML29UVEQvLy8vQ1dKa2dGTWpFQWdEOFE0Z0xrTVNnd09zR29HZ0RDUUV4Y1JyUkZKSW1vMUlDcW1uRVVTaVlKZ2tNZ1lDckRZaWE4VFFCRlZJSjZjQ0FYSjBRREdERFFENjdPWVg5d2RwMHdBQUFBQkpSVTVFcmtKZ2dnPT1cIlxuXHR9LFxuXHRcIjEtYWJzLXVwXCI6IHtcblx0XHR0eXBlOiBcImltYWdlL3BuZ1wiLFxuXHRcdGRhdGE6IFwiaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUE0QUFBQUtDQVlBQUFDRTJXL0hBQUFBQkdkQlRVRUFBTEdQQy94aEJRQUFBQWx3U0ZsekFBQU93Z0FBRHNJQkZTaEtnQUFBQUJoMFJWaDBVMjltZEhkaGNtVUFjR0ZwYm5RdWJtVjBJRFF1TUM0MVpZVXlaUUFBQUV4SlJFRlVLRlB0allFSkFDQUlCTjJoZFpxcjJkcXUzdEI4QzVxZ2h6UHhsQVFaSjRpV0o5RThEcEFDT21oN1prTEx3b1dETlBKeFNNT05Td2E1ZnpTQkp5OHovOUI2UnBmVlphUk8yb28vekpWUkR2SUFBQUFBU1VWT1JLNUNZSUk9XCJcblx0fSxcblx0XCIxLWRvd25cIjoge1xuXHRcdHR5cGU6IFwiaW1hZ2UvcG5nXCIsXG5cdFx0ZGF0YTogXCJpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQTRBQUFBS0NBWUFBQUNFMlcvSEFBQUFCR2RCVFVFQUFMR1BDL3hoQlFBQUFBbHdTRmx6QUFBT3dnQUFEc0lCRlNoS2dBQUFBQmgwUlZoMFUyOW1kSGRoY21VQWNHRnBiblF1Ym1WMElEUXVNQzQxWllVeVpRQUFBR3RKUkVGVUtGT3Rqb0VKZ0RBUUE2dWlDN2lPYzNVMnQzc1Q2VXUrWHhEQndGbGlFdG9pc25ZV00zdkZ0UUc2bVdaUTJzRUpxdnk3dFFDNkZVemRxTGFNcENIMU9CMUtjWGdqQlo4SERoU0hFdUNJWmVXL0ljUnZ3RU1GeWpleTdIalFBMzE3S3N2TUl1VzRBRlRVRWd2cyszd2tBQUFBQUVsRlRrU3VRbUNDXCJcblx0fSxcblx0XCIxLXVwXCI6IHtcblx0XHR0eXBlOiBcImltYWdlL3BuZ1wiLFxuXHRcdGRhdGE6IFwiaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUE0QUFBQUtDQVlBQUFDRTJXL0hBQUFBQVhOU1IwSUFyczRjNlFBQUFBUm5RVTFCQUFDeGp3djhZUVVBQUFBSmNFaFpjd0FBRHNNQUFBN0RBY2R2cUdRQUFBQWFkRVZZZEZOdlpuUjNZWEpsQUZCaGFXNTBMazVGVkNCMk15NDFMakV4Ui9OQ053QUFBRkJKUkVGVUtGUHRqZHNOUUNFSVE5M0JkWnpMMmR3T2p3OUN1VjkzQUVtT0piWU54Y3cyREhMMlA1d0hjZFIwbUFvRHV2eEZ5WEh6QnJwNFVaUUFFb1V2VEw0b0JwTER5aXZlWFZuaDVXVkttNmlQUjhSYkh4TGhBQUFBQUVsRlRrU3VRbUNDXCJcblx0fSxcblx0XCIyLWFicy1kb3duXCI6IHtcblx0XHR0eXBlOiBcImltYWdlL3BuZ1wiLFxuXHRcdGRhdGE6IFwiaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUE0QUFBQUtDQVlBQUFDRTJXL0hBQUFBQkdkQlRVRUFBTEdQQy94aEJRQUFBQWx3U0ZsekFBQU93Z0FBRHNJQkZTaEtnQUFBQUJoMFJWaDBVMjltZEhkaGNtVUFjR0ZwYm5RdWJtVjBJRFF1TUM0MVpZVXlaUUFBQUg1SlJFRlVLRk9Wa0FzTmdEQU1ST2NCQnhqQUFFSndnQU1jWUdHbXNJQUdMSlM3cGlFM0ZqSjJ5UnZweHVzK1NXTHhUV2JXUkZPSnlBZ3l1RGdORGpEOUVXZXdBelpndkVsVFZDSnNoTEpmWEVEM2pqd3U3N3BHN1VLQkN2SFRBUGd3V2VZOEtuNUtMTjRpODFTeXlPT2RnSGZ6cU1peFFCYjlGV3ZTZGdOTjg3MUFId2JsVkFBQUFBQkpSVTVFcmtKZ2dnPT1cIlxuXHR9LFxuXHRcIjItYWJzLXVwXCI6IHtcblx0XHR0eXBlOiBcImltYWdlL3BuZ1wiLFxuXHRcdGRhdGE6IFwiaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUE0QUFBQUtDQVlBQUFDRTJXL0hBQUFBQkdkQlRVRUFBTEdQQy94aEJRQUFBQWx3U0ZsekFBQU93Z0FBRHNJQkZTaEtnQUFBQUJoMFJWaDBVMjltZEhkaGNtVUFjR0ZwYm5RdWJtVjBJRFF1TUM0MVpZVXlaUUFBQUpWSlJFRlVLRk45a0FFVmd6QU1SUEV3QnpPQWdRbkJ3UnpnWUJacUNndG93QUw3bDZWdElMQjc3emMwMXl0dEI3U2ZRUnIrMGo4dUF1Z0pCVGI1c01Cb25pL1FZTlNROTEvd0FXMGcyU2J1OVZBbGhpc3ViY1NVZVRDc2NZZHJndDhmZzBISmdRclNjWFhYdDgyRFFja0JnUjZnaHltdEYwektNU0JRQzJuUyttRUJKWVYwdkJWME4xUHp3aUpLQ3RvclpvYjVDeTJSRnZYRlFBS2xBQUFBQUVsRlRrU3VRbUNDXCJcblx0fSxcblx0XCIyLWRvd25cIjoge1xuXHRcdHR5cGU6IFwiaW1hZ2UvcG5nXCIsXG5cdFx0ZGF0YTogXCJpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQTRBQUFBS0NBWUFBQUNFMlcvSEFBQUFCR2RCVFVFQUFMR1BDL3hoQlFBQUFBbHdTRmx6QUFBT3dnQUFEc0lCRlNoS2dBQUFBQmgwUlZoMFUyOW1kSGRoY21VQWNHRnBiblF1Ym1WMElEUXVNQzQxWllVeVpRQUFBSnRKUkVGVUtGT0ZrQXNOQWpFUVJBc1hNSUFEREp3QmhPQUFCempBd3BuQ0FocXdVTjRzMnpKUUNKTzhiR2EzMDE4eDFheWwxdnFYcGkzSXJXVnN1SWNGN21yREZXWVBUaUMzZ1pVRkQzQUJiU0RGSmg2VXVtdEJKNldOc0IvQnR1Z2JxU004VDdRQlpRdzBrSzZydDU3QzI0QXlCZ1RhZ1Q1bXNWNjg3WTAyekFVOUpOUDdPZndWMHZWdW9MZUYrc3dXVVY2aDdNVXZqcFR6QTZmTTZTVlYyQ2JnQUFBQUFFbEZUa1N1UW1DQ1wiXG5cdH0sXG5cdFwiMi11cFwiOiB7XG5cdFx0dHlwZTogXCJpbWFnZS9wbmdcIixcblx0XHRkYXRhOiBcImlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFBNEFBQUFLQ0FZQUFBQ0UyVy9IQUFBQUFYTlNSMElBcnM0YzZRQUFBQVJuUVUxQkFBQ3hqd3Y4WVFVQUFBQUpjRWhaY3dBQURzTUFBQTdEQWNkdnFHUUFBQUFhZEVWWWRGTnZablIzWVhKbEFGQmhhVzUwTGs1RlZDQjJNeTQxTGpFeFIvTkNOd0FBQUl4SlJFRlVLRk9Wa0ZzUmdEQU1CT3NCQnhqQUFFSndnQU1jWUFGVFdFQURGc3BlK2lEUUg4ak1jclNYNnl2RUdBMEtTZjlmU0IrazhEQkQ2R0dEVXg3c01HVHZEaFZjY0lRVnRJREtGakhQTlNIM2JtOXlhU0dHLzRNVC9ONVJ4OVZkWnhzN0Eya0RndXBBRDdQVk9XY2l6NENnYWtpRE91OGFrQ2FrNHgyZ3UxbFZ6elVoVGRCZXNTVXNGL3VISHUxMTBiWlJBQUFBQUVsRlRrU3VRbUNDXCJcblx0fSxcblx0XCIzLWFicy1kb3duXCI6IHtcblx0XHR0eXBlOiBcImltYWdlL3BuZ1wiLFxuXHRcdGRhdGE6IFwiaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUE0QUFBQUtDQVlBQUFDRTJXL0hBQUFBQkdkQlRVRUFBTEdQQy94aEJRQUFBQWx3U0ZsekFBQU93Z0FBRHNJQkZTaEtnQUFBQUJoMFJWaDBVMjltZEhkaGNtVUFjR0ZwYm5RdWJtVjBJRFF1TUM0MVpZVXlaUUFBQUpWSlJFRlVLRk9Oa1FFTmhEQU1SZWNCQjJjQUF5aEF3VG5BQVE2d2dBYThuSVhUY0JiR2Y2TmR1aXlFZThsamFkbGZPa2lCYkd2S09UOGE2WUxpSlhmNW95Mi84djFQY0pLYjVBQllKUys4TG5UQnFNRkJGR09waktmZ0lCbDd0N3B5R3hRK0luZWNQY2l6TVlaOGt6RkxHblhVR0x3TE9UUzVhNlh1Q3FGRk1pYjNBMnArVGZtcTdHZ01RVTQrdkM4L1Z5K2xFekdkb3d3SGlXTTJBQUFBQUVsRlRrU3VRbUNDXCJcblx0fSxcblx0XCIzLWFicy11cFwiOiB7XG5cdFx0dHlwZTogXCJpbWFnZS9wbmdcIixcblx0XHRkYXRhOiBcImlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFBNEFBQUFLQ0FZQUFBQ0UyVy9IQUFBQUJHZEJUVUVBQUxHUEMveGhCUUFBQUFsd1NGbHpBQUFPd2dBQURzSUJGU2hLZ0FBQUFCaDBSVmgwVTI5bWRIZGhjbVVBY0dGcGJuUXVibVYwSURRdU1DNDFaWVV5WlFBQUFKdEpSRUZVS0ZPRmtRRVJ3akFNUmVzQkJ6T0FnU21ZQWh6Z0FBZFltQWE4WUFFTldJRDNTZ001c29OLzk1b202ZStsVzBPUGI1RExUejZiRFFPYVlJVzdmYmpCb2ZmR0FaZE9tRVo5aGpONGdUcUJqWjYvVFVFMkIwTmVaTExQRFVJMUJHZ0hqcjMyUERVSTFTQW9SdlNOUzYrbEpxR2FKR2tCQy85SDNaREZPUjhnRk5NUkhOUDNLWE4velpRUEVZclJyM2l4TjdpK2FxMDlBUkU3L0xMTzhMMjZBQUFBQUVsRlRrU3VRbUNDXCJcblx0fSxcblx0XCIzLWRvd25cIjoge1xuXHRcdHR5cGU6IFwiaW1hZ2UvcG5nXCIsXG5cdFx0ZGF0YTogXCJpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQTRBQUFBS0NBWUFBQUNFMlcvSEFBQUFCR2RCVFVFQUFMR1BDL3hoQlFBQUFBbHdTRmx6QUFBT3dnQUFEc0lCRlNoS2dBQUFBQmgwUlZoMFUyOW1kSGRoY21VQWNHRnBiblF1Ym1WMElEUXVNQzQxWllVeVpRQUFBS2RKUkVGVUtGTjFrUUVSd2pBTVJRc2NHTURCREdCZ0NxWUFCempBQVJhbUFTOVlRQU1XeW44aG9kbHQvWGZ2MHA4MHVYUXJTZFhqWDdYV0xxR1R3TzNOTlExaUZoOUIvUzJ1dWZFZ2NFZXhJK0VheFVNd0FOMEY5OEtiMmhqWHhtb013bHpNdVZSZnZpTWpuUVZyeitaVFFXSGRBRktzeUJzbnk2V2l3cm9Ka2laQndsYmxzS0RURkNJNVJySFhkQk9zeWZzUW5sOHo1RXNLcmNsemZNVW5OZWYxeTVYeUJZZ2R0d2wrTG0rTEFBQUFBRWxGVGtTdVFtQ0NcIlxuXHR9LFxuXHRcIjMtdXBcIjoge1xuXHRcdHR5cGU6IFwiaW1hZ2UvcG5nXCIsXG5cdFx0ZGF0YTogXCJpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQTRBQUFBS0NBWUFBQUNFMlcvSEFBQUFBWE5TUjBJQXJzNGM2UUFBQUFSblFVMUJBQUN4and2OFlRVUFBQUFKY0VoWmN3QUFEc01BQUE3REFjZHZxR1FBQUFBYWRFVllkRk52Wm5SM1lYSmxBRkJoYVc1MExrNUZWQ0IyTXk0MUxqRXhSL05DTndBQUFKcEpSRUZVS0ZPTmtRc1J3akFRQmVNQkJ6V0FnU3FvQWh6Z0FBZFlxQWE4WUFFTldBaTcrY0F4NlVEZnpQYWFlMzJaUzVweXpnVkVxZTk3cUE5SzU4dE1hWUlWbm5yd2dGUHpQcUZPQ001d0JUZFFGOUNZNHU3dndCWk5idVRpR0EzS0dPaWdBemoyV3RiQm9Jd0JRWDFFejdpVVhqQXBZMGlDRnJEeGY5UU4yWnpqQjVRaGRBYkg5SHpLdGIvbTk2MGliL0dtMTdqWFhrb3YzekVFdVE3aDEwb0FBQUFBU1VWT1JLNUNZSUk9XCJcblx0fSxcblx0XCJhZGQtY29sdW1uXCI6IHtcblx0XHR0eXBlOiBcImltYWdlL3BuZ1wiLFxuXHRcdGRhdGE6IFwiaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUJBQUFBQVFDQVlBQUFBZjgvOWhBQUFBQkdkQlRVRUFBTEdQQy94aEJRQUFBQWx3U0ZsekFBQU93UUFBRHNFQnVKRnI3UUFBQUJoMFJWaDBVMjltZEhkaGNtVUFjR0ZwYm5RdWJtVjBJRFF1TUM0MVpZVXlaUUFBQVBWSlJFRlVPRTlqVUt0bmNBYmkvMFJnWndac0FDUUJVbER3T2h3ckp0cUEzT2VoeUlyQkdFME12d0ZaajRPd1lxam1jOXJON0Z0MW10a25ROVdMUUxVakRFaS83NDlzR3hpRHhMU2IyTjZnaXdNTk93T2tJWVlBR1RqRFFMT1I1Uk5NRTB3TXhnY2FmQXhJaStBTUEzUSt1Z0ZRN0l3M0RFRGlNSTNvR01NQTlEQ0E4YkZwQm1Hb09vUUJ5YmQ4TURCVUVZcEJ5R0pBakRBZy9wb25paVNJRHd6RXJ6QSt1Z0hheld3bmdEUWlFR011dVdIRldrMnNIMkNhWUJpWUhzNEJhZFJvakRqcmpLSUlUZXc4VU5OTzNSYk9XVUIyTFJCakpxVFFrdzVZTVVnT2l2RW41YUNqdGxneDBRWVFnYkVZd01BQUFFcXFsU0dDancrYkFBQUFBRWxGVGtTdVFtQ0NcIlxuXHR9LFxuXHRcImJhY2tcIjoge1xuXHRcdHR5cGU6IFwiaW1hZ2UvcG5nXCIsXG5cdFx0ZGF0YTogXCJpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQkFBQUFBUUNBWUFBQUFmOC85aEFBQUQ4R2xEUTFCSlEwTWdVSEp2Wm1sc1pRQUFPSTJOVmQxdjIxUVVQNGx2WEtRV1A2Q3hqZzRWaTY5VlUxdTVHeHF0eGdaSms2WHBRaHE1emRncXBNbDFiaHBUMXphMjAyMVZuL1lDYnd6NEE0Q3lCeDZRZUVJYURNVDJzdTBCdEVsVFFSWFZKS1E5ZE5wQWFKUDJncXB3cnE5VHUxM0d1Skd2ZnpubmR6N3YwVFZBeDFlYTQ1aEpHV0RlOGwwMW41R1BuNWlXTzFZaENjOUJKL1JBcDZaN1RycGNMZ0l1eG9WSDFzTmZJY0hlTndmYTYvOXpkVmFwcHdNa25rSnNWejE5SHZGcGdKU3BPNjRQSU41RytmQXAzMEhjOFR6aUhTNG1pRmhoZUpiakxNTXpIQjhQT0ZQcUtHS1dpNlRYdFNyaUpjVDlNekg1YkF6ekhJSzFJMDh0NmhxNnpIcFJkdTJhWWRKWXVrOVEvODgxYnpaYThYcng2ZkxtSm8vaXU0L1ZYbmZIMUJCL3JtdTVTY1F2STc3bStCa21meFh4dmNaY0pZMTRMMER5bVpwN3BNTDV5VGNXNjFQdklONkp1R3I0aGFsUXZtak5sQ2E0YlhKNXpqNnFocHhydWplS1BZTVhFZCtxMDBLUjV5TkFsV1p6ckYrSWUrdU5zZEMvTU80dFRPWmFmaGJyb3lYdVIzRGYwOGJMaUhzUWYramE2Z1RQV1ZpbVpsN2wvb1Vyamw4T2N4RFdMYk5VNUQ2SlJMMmd4a0R1MTZmR3VDMDU0T01oY2xzeVhUT09GRUwra21NR3M0aTVrZk51UTYyRW5CdWFtOHR6UCtRK3RTcWh6OVN1cXBabHZSMUVmQmlPSlRTZ1lNTU03anBZc0FFeXFKQ0hETDRkY0ZGVEF3Tk1sRkRVVXBRWWlhZGhEbVh0ZWVXQXczSEVtQTJzMTVrMVJtblA0Ukh1aEJ5YmRCT0Y3TWZuSUNtU1EyU1lqSUJNM2lSdmtjTWtpOUlSY25EVHRoeUx6MkxkMmZUelBqVFFLK01kZzh5NW5rWmZGTytzZTlMUXIzLzA5eFpyKzVHY2FTdWZlQWZBd3c2MG1BUHgrcTh1L2JBcjhyRkNMcng3cyt2cUVrdzhxYitwMjZuMTFBcnVxNm0xaUpINlBiV0d2MVZJWTI1bWtORThQa2FRaHhmTElGN0RaWHg4MEhEL0EzbDJqTGNsWXMwNjF4TnBXQ2ZvQjZXSEpUamJIMG1WMzVRL2xSWGxDK1c4Y25kYmw5dDJTZmhVK0ZiNFVmaE8rRjc0R1dUaGtuQlorRW00SW53alhJeWQxZVBuWS9Qc2czcGIxVEpOdTE1VE1LV010RnQ2U2NwS0wwaXZTTVhJbjlRdERVbGowaDdVN040OHQzaThlQzBHbk1DOTFkWDJzVGl2Z2xvRFRnVVZlRUdITFRpemJmNURhOUpMaGtoaDI5UU9zMWx1TWNTY21CWFRJSXQ3eFJGeFNCeG51SldmdUFkMUk3am50a3lkL3BnS2FJd1ZyM01nbURvMnE4eDZJZEI1UUgxNjJtY1g3YWp0bkhHTjJib3Y3MU9VMStVMGZxcW9YTEQwd1g1Wk0wMDVVSG15U3ozcUx0RHFJTER2SUwraUg2akI5eTJ4ODNvazg5OEdPUFFYM2xrM0l0bDBBK0JyRDZEN3RValdoM2ZpczU4QlhEaWdOOXlGOE01UEpINEI4R3I3OS9GL1hSbThtMjQxbXcvd3Z1cjRCR0RqNDJiem4rVm1jK05MOUw4R2NNbjhGMWtBY1hnU3RlR0dBQUFCVVVsRVFWUTRFV05nR0xRZ1pZMTJlOW9hL1MvWUhJZ3N4NEpOUWR3aXJYYUcvNHpsakV5TWpPank2SEpNNkFyQ0ptcjBDUWp5VkJncjJESCsrZk1YUlJxYkhJb0xmT3BVNW5FTE15ZktDYXN5L1B2L2grSDNkNFFCdU9UZ0xuRElrbC9DSThhU3FDQ3R5UERteXd1R2I3OCtNZno2K2cvc0FueHlZQmRZUkVzLzRwTmtsUlZYNEdkNDl1NEp3Ly8vL3hrNFdUa1pmbjM1eDRCUERtUTYyQVcvZi95LytQdmJmNFlmUDM4eS9QcnhoK0hYOXo4TVgzNTladmdKZEFFK09iZ0JaOTgrQzN4eDdkdmErOGMvTVRDek1UTDgrL2VmNGZ2UGJ3dy9QLzFod0NjSE40RGhBTU9mOHh1Zmg3eTgvbTNWdzJOZkdGalltUmkrLy9nQkRNVC9ESGpsZ0NhZ3hNTEZyUy9DOWY1SS9QejM5MytzckNrM1BCQkJOdUdTUXpFQXBQRFN6aGR4bW44ay92Mzd5eEQvK3dja0ZrRGlJSUJQRHFJQ2lkUjBFSjJ0N3kwSjlBTW13Q2VIcVpyV0lnQVo0UFlEeGZ0R1lnQUFBQUJKUlU1RXJrSmdnZz09XCJcblx0fSxcblx0XCJjaGVja2VkXCI6IHtcblx0XHR0eXBlOiBcImltYWdlL3BuZ1wiLFxuXHRcdGRhdGE6IFwiaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUEwQUFBQVBDQVlBQUFBL0kwVjNBQUFBQkdkQlRVRUFBTEdQQy94aEJRQUFBQWx3U0ZsekFBQU93Z0FBRHNJQkZTaEtnQUFBQUJoMFJWaDBVMjltZEhkaGNtVUFjR0ZwYm5RdWJtVjBJRFF1TUM0MVpZVXlaUUFBQVlKSlJFRlVPRStOa3N0TGdsRVF4ZjBmYWhHMGlGclV4bTJFbEZEWUxvaENxQ0RhQ0FrV1BheElSYkZGRUpFYUdFS0xEQ29NRVRSRlVBTUx5YUlIQlVHNnNTS0lNdEtGcUVoTFQ4MThaVWdtRGh6dTNEUG45ejB1VjFScm1Vd215R1F5cU5WcWZGdlZpd0J4dTVSRlBadUxTeUdNS2h6L3FsRXNSVjE5Szh4bTZ5K3c3YnBCUEZuQWZlcmpqM2JkUVg2RHBIY0FVd2F2QUhVTjJSR0laeEJKWkhIMm1DL1RVZXlkd3dUWnZCZWdMRU5OZ3c3c1g2V2gxRnN3Tm1QRW1qUENEeUdSUndDdFc5RTN0TWdkQXRRdzdHWmpZY05YK2d6YTJ3SjNaWHNTWlV1UTB2V0NPVjhTSGZKSi91bHVoYkhVajF2OFBLTk1zeklvUU5STUhDU2hENldoOHp5aHJiT1B3ejh3K1NUS2xDQ0o3b1JOVXpRSDYza0JzNXRoQmdoZVBYeGxqMmFVb1N4RFBjdVhQTmlMQWM1RUVaNkhJa2JtVjJEWWlYQlBIczBvMDc5K0swRFRWai9zMTFtRTAwQTBMK2c0VmNEcDEwcUtaTUF6eXRCaE1hVFJhUG1ZZzg4NURsY1N6U2lqMGVvRWlJb3VvVXFscXFxYUwycmxFb2srQWQ0dmxmelBvVkRzQUFBQUFFbEZUa1N1UW1DQ1wiXG5cdH0sXG5cdFwiY29sbGFwc2VcIjoge1xuXHRcdHR5cGU6IFwiaW1hZ2UvcG5nXCIsXG5cdFx0ZGF0YTogXCJpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQkFBQUFBUUNBWUFBQUFmOC85aEFBQUFCR2RCVFVFQUFMR1BDL3hoQlFBQUFBbHdTRmx6QUFBT3dRQUFEc0VCdUpGcjdRQUFBQmgwUlZoMFUyOW1kSGRoY21VQWNHRnBiblF1Ym1WMElEUXVNQzQxWllVeVpRQUFBUE5KUkVGVU9FOWpjSW9xL1krTUdYQ0FDVWM2LzRNd2xJc0F5SnJ3R2FBM1VlRS9DRU81Q0VDTUFZRUwzZjRISExDRzRBV3VxR3BBbXBBeFZCZ09RTTQyWDZMMnYrQjFPQmlEMkgwSDI3RmFoQUZBbWpVblNQMVB2Ky8vUC9kNUtCaW4zZlAvcjk0dmdSRWVjQTZ5YS9RN2xmK0huckQvbi9VNENBV0R4S3ltNm1KM0Jjd2JoWnN6L2l1MEM4RXh5QlVnakN4V3NERWRiZ2lNZ1JJT01EWkljZkl0SHpBR3NjR1N1QURNK1RBTUVnTnBpci9tQ2NhNERNQnJLa2hUekNVM01DYmJCUkZubmNHWWtBdmdta0FBMllEUWt3NWdUSlFMb0V3VUE0S08yb0l4VVFZZ1k1QVlTQk15QmlzY0pJQ0JBUUNwUk9HWjZrcUhmd0FBQUFCSlJVNUVya0pnZ2c9PVwiXG5cdH0sXG5cdFwiZG93bi1hcnJvd1wiOiB7XG5cdFx0dHlwZTogXCJpbWFnZS9wbmdcIixcblx0XHRkYXRhOiBcImlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFBVUFBQUFLQ0FZQUFBQjhPWlF3QUFBQUFYTlNSMElBcnM0YzZRQUFBQVJuUVUxQkFBQ3hqd3Y4WVFVQUFBQUpjRWhaY3dBQURzTUFBQTdEQWNkdnFHUUFBQUFZZEVWWWRGTnZablIzWVhKbEFIQmhhVzUwTG01bGRDQTBMakF1TldXRk1tVUFBQUErU1VSQlZCaFhoWXZSQ2dBZ0NBT3RxUC8vNCtXV2h0QkRCMWR1cUJVUS8yVzVMTHRTTUZ5VzAyMHNrdWVjd09HajZRemZrdUV4dDFMbGNxSUNnRzNTN3ovU0wvalZwZ0FBQUFCSlJVNUVya0pnZ2c9PVwiXG5cdH0sXG5cdFwiZG93bi1yZWN0YW5nbGVcIjoge1xuXHRcdHR5cGU6IFwiaW1hZ2UvcG5nXCIsXG5cdFx0ZGF0YTogXCJpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQWtBQUFBRUNBWUFBQUJjRHhYT0FBQUFBWE5TUjBJQXJzNGM2UUFBQUFSblFVMUJBQUN4and2OFlRVUFBQUFKY0VoWmN3QUFEc01BQUE3REFjZHZxR1FBQUFBYWRFVllkRk52Wm5SM1lYSmxBRkJoYVc1MExrNUZWQ0IyTXk0MUxqRXhSL05DTndBQUFCcEpSRUZVR0ZkamdJTC9lREFLSUtnQUJnZ3FnQUUwQlF3TUFQVGxEL0ZwaTBKZkFBQUFBRWxGVGtTdVFtQ0NcIlxuXHR9LFxuXHRcImRvd25cIjoge1xuXHRcdHR5cGU6IFwiaW1hZ2UvcG5nXCIsXG5cdFx0ZGF0YTogXCJpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQkFBQUFBUUNBWUFBQUFmOC85aEFBQUQ4R2xEUTFCSlEwTWdVSEp2Wm1sc1pRQUFPSTJOVmQxdjIxUVVQNGx2WEtRV1A2Q3hqZzRWaTY5VlUxdTVHeHF0eGdaSms2WHBRaHE1emRncXBNbDFiaHBUMXphMjAyMVZuL1lDYnd6NEE0Q3lCeDZRZUVJYURNVDJzdTBCdEVsVFFSWFZKS1E5ZE5wQWFKUDJncXB3cnE5VHUxM0d1Skd2ZnpubmR6N3YwVFZBeDFlYTQ1aEpHV0RlOGwwMW41R1BuNWlXTzFZaENjOUJKL1JBcDZaN1RycGNMZ0l1eG9WSDFzTmZJY0hlTndmYTYvOXpkVmFwcHdNa25rSnNWejE5SHZGcGdKU3BPNjRQSU41RytmQXAzMEhjOFR6aUhTNG1pRmhoZUpiakxNTXpIQjhQT0ZQcUtHS1dpNlRYdFNyaUpjVDlNekg1YkF6ekhJSzFJMDh0NmhxNnpIcFJkdTJhWWRKWXVrOVEvODgxYnpaYThYcng2ZkxtSm8vaXU0L1ZYbmZIMUJCL3JtdTVTY1F2STc3bStCa21meFh4dmNaY0pZMTRMMER5bVpwN3BNTDV5VGNXNjFQdklONkp1R3I0aGFsUXZtak5sQ2E0YlhKNXpqNnFocHhydWplS1BZTVhFZCtxMDBLUjV5TkFsV1p6ckYrSWUrdU5zZEMvTU80dFRPWmFmaGJyb3lYdVIzRGYwOGJMaUhzUWYramE2Z1RQV1ZpbVpsN2wvb1Vyamw4T2N4RFdMYk5VNUQ2SlJMMmd4a0R1MTZmR3VDMDU0T01oY2xzeVhUT09GRUwra21NR3M0aTVrZk51UTYyRW5CdWFtOHR6UCtRK3RTcWh6OVN1cXBabHZSMUVmQmlPSlRTZ1lNTU03anBZc0FFeXFKQ0hETDRkY0ZGVEF3Tk1sRkRVVXBRWWlhZGhEbVh0ZWVXQXczSEVtQTJzMTVrMVJtblA0Ukh1aEJ5YmRCT0Y3TWZuSUNtU1EyU1lqSUJNM2lSdmtjTWtpOUlSY25EVHRoeUx6MkxkMmZUelBqVFFLK01kZzh5NW5rWmZGTytzZTlMUXIzLzA5eFpyKzVHY2FTdWZlQWZBd3c2MG1BUHgrcTh1L2JBcjhyRkNMcng3cyt2cUVrdzhxYitwMjZuMTFBcnVxNm0xaUpINlBiV0d2MVZJWTI1bWtORThQa2FRaHhmTElGN0RaWHg4MEhEL0EzbDJqTGNsWXMwNjF4TnBXQ2ZvQjZXSEpUamJIMG1WMzVRL2xSWGxDK1c4Y25kYmw5dDJTZmhVK0ZiNFVmaE8rRjc0R1dUaGtuQlorRW00SW53alhJeWQxZVBuWS9Qc2czcGIxVEpOdTE1VE1LV010RnQ2U2NwS0wwaXZTTVhJbjlRdERVbGowaDdVN040OHQzaThlQzBHbk1DOTFkWDJzVGl2Z2xvRFRnVVZlRUdITFRpemJmNURhOUpMaGtoaDI5UU9zMWx1TWNTY21CWFRJSXQ3eFJGeFNCeG51SldmdUFkMUk3am50a3lkL3BnS2FJd1ZyM01nbURvMnE4eDZJZEI1UUgxNjJtY1g3YWp0bkhHTjJib3Y3MU9VMStVMGZxcW9YTEQwd1g1Wk0wMDVVSG15U3ozcUx0RHFJTER2SUwraUg2akI5eTJ4ODNvazg5OEdPUFFYM2xrM0l0bDBBK0JyRDZEN3RValdoM2ZpczU4QlhEaWdOOXlGOE01UEpINEI4R3I3OS9GL1hSbThtMjQxbXcvd3Z1cjRCR0RqNDJiem4rVm1jK05MOUw4R2NNbjhGMWtBY1hnU3RlR0dBQUFCVjBsRVFWUTRFV05nR0dqQWlNMEJJdGw4LzdtRkdCaCtmV2RnK0EvRU1QQmk2aWNNOVN3d1NXUmExb3lISVRiS2p1SGVtOXNRNGE4TURIdFhQbUI0Z2F3SXlzWnF3Sy92L3hrNHYzSXcvQUJxQkFFT0lQNzFBOHpFSUpnd1JJQUNiSnlNREp4Y0lHMkVBVllYUUxSeGdtMEdzN25aR2Rod21JZmRBQzVXQms1V1RnWUdvRVlRQUxJWWZvTlptQVRjQUl1Rnh2OWZmci9Od0FyVUxDYkx4bkQzejNVR0xpNTJodi9mZmpLQUlvS0hrNDFCdnBYdlA4Z0lRVTVaaGd0RlY4RXhnaEl0aGd0Vi8zZkhwVEU4WWJqTGNQZlRUWWFmUU1VZ0EyQ0FBMmpndXVYM0dLNW1QSVRyZ3pOZ2l0UVdTdjJmRmxmSWNPclBNWVlQM3o3QWhCbEFubG01L0FiRHJZem5LSG93WXVGVy9EUEdyRVg5REdZc3pnd0NRQnRCR2tIMHlnMDNNVFREVGNmRzBOMGk5Zi9vL3luL0YveFArSysrV2dyc2QyenE4SW81bk5ENTd3N0VlQlVSa3F5NVVFbVpBWVFzQUFEYk9XRFRBeEJta1FBQUFBQkpSVTVFcmtKZ2dnPT1cIlxuXHR9LFxuXHRcImVtcHR5XCI6IHtcblx0XHR0eXBlOiBcImltYWdlL3BuZ1wiLFxuXHRcdGRhdGE6IFwiaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUFFQUFBQUJDQVlBQUFBZkZjU0pBQUFBQVhOU1IwSUFyczRjNlFBQUFBUm5RVTFCQUFDeGp3djhZUVVBQUFBSmNFaFpjd0FBRHNNQUFBN0RBY2R2cUdRQUFBQVlkRVZZZEZOdlpuUjNZWEpsQUhCaGFXNTBMbTVsZENBMExqQXVOV1dGTW1VQUFBQU5TVVJCVkJoWFkvai8vejhEQUFqOEF2NklYd2JnQUFBQUFFbEZUa1N1UW1DQ1wiXG5cdH0sXG5cdFwiZXhwYW5kXCI6IHtcblx0XHR0eXBlOiBcImltYWdlL3BuZ1wiLFxuXHRcdGRhdGE6IFwiaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUJBQUFBQVFDQVlBQUFBZjgvOWhBQUFBQkdkQlRVRUFBTEdQQy94aEJRQUFBQWx3U0ZsekFBQU93Z0FBRHNJQkZTaEtnQUFBQUJoMFJWaDBVMjltZEhkaGNtVUFjR0ZwYm5RdWJtVjBJRFF1TUM0MVpZVXlaUUFBQVE5SlJFRlVPRTlqY0lvcS9ZK01nWUNCRkF3MkFNYWhtUUVLN1VML2tUR3lIRkZlQUdrS09tb0x4aGdHSUhOd1laQ20wSk1PWUl6VkFDQ0FDMkp6RVVoVHhGbG5NQ2JvQW1SdklCc1FjOGtOalBHNkFFVGpNaUQrbWljWUUrVUNaQXdTQTJsS3Z1VUR4bmhkZ0l3TE5xV0RGY053K24xL01FWVdLOWlZanFvSmhHRTJPOFFVL0ZkcGxQc2Zlc0wrZjliaklCUU1Fck9hcWd0VWp1WUNFQTF6TmdoYnB5VDgxNXdnQmJZNTcwWG8vOXpub2YvVDd2bi9WKytYK045M3NCMmlCNllZaHBFTkFMRkJDczJYcVAwdmVCME94aUEyVERNSW8yZ0dZWmdYWUJna0ZyalE3WC9BQVdzSVh1QUtGb05oRk0zNHNONUVoZjhnL1BqOVF5QVhJWTZpQ0I4R09Sdlo2UkQ4bndFQS9aU2JtTENSaEVvQUFBQUFTVVZPUks1Q1lJST1cIlxuXHR9LFxuXHRcImZpbHRlci1vZmZcIjoge1xuXHRcdHR5cGU6IFwiaW1hZ2UvcG5nXCIsXG5cdFx0ZGF0YTogXCJpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQTRBQUFBTUNBWUFBQUJTZ0l6YUFBQUFBWE5TUjBJQXJzNGM2UUFBQUFSblFVMUJBQUN4and2OFlRVUFBQUFKY0VoWmN3QUFEc01BQUE3REFjZHZxR1FBQUFBWWRFVllkRk52Wm5SM1lYSmxBSEJoYVc1MExtNWxkQ0EwTGpBdU5XV0ZNbVVBQUFDaFNVUkJWQ2hUelpIQkNvVWdGRVQ5VHFFaXNrZ3lXb3V0UXZSTFJJcitjUjdYUUFqaUpXLzFCZ1ptTVVldlhzWTV4eTlPb0RFR01jWWlVemVCNjdxaWJWdXdRalZOQTYzMTFWK1dCZU00dnNMRE1FQXBkZS8xZlk5cG10STQ1M25lSEVLQWxCSmQxejBmWHRjMTZQYmpPREswN3p2bWVVWlZWZDhub29jNzV6SklPWDNHbTZpMGJWc0dLZjh4S0lSSXV5SlRMZ0pKM252UXpzalcyZ2VJc1EvcHI5aE1WclNuY0FBQUFBQkpSVTVFcmtKZ2dnPT1cIlxuXHR9LFxuXHRcImZpbHRlci1vblwiOiB7XG5cdFx0dHlwZTogXCJpbWFnZS9wbmdcIixcblx0XHRkYXRhOiBcImlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFBNEFBQUFNQ0FZQUFBQlNnSXphQUFBQUFYTlNSMElBcnM0YzZRQUFBQVJuUVUxQkFBQ3hqd3Y4WVFVQUFBQUpjRWhaY3dBQURzTUFBQTdEQWNkdnFHUUFBQUFZZEVWWWRGTnZablIzWVhKbEFIQmhhVzUwTG01bGRDQTBMakF1TldXRk1tVUFBQUNvU1VSQlZDaFRZM0JxZlAyZkhBeldtRGJqN2Y4cDI5NFJoVk9CYXNFYTAyZSsvZS9WQm1RUUNUeGFYLzlQbnZZR29qNXl3cHYvUWQyRU5mdDN2djRmMWdmVkJBUCtuVy8raC9hK0FUdG4xcTczS0hqeXR2ZGdnMzA3MERUQmdIdkw2LzhnMjJmc1FHaWFEbVNIQTIxeGF5YmdJcERIaXhhOGhXc3NuQThOREVJQXBDaDNMa0lqaUQySU5ZSkNMMlg2VzNCOGdkaEVhUVFCVU9DQTRneUU4K2U5eGFLSmdRRUEvNzRCTkUzY0Vsa0FBQUFBU1VWT1JLNUNZSUk9XCJcblx0fSxcblx0XCJmb3J0aFwiOiB7XG5cdFx0dHlwZTogXCJpbWFnZS9wbmdcIixcblx0XHRkYXRhOiBcImlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFCQUFBQUFRQ0FNQUFBQW9MUTlUQUFBQUIzUkpUVVVIMXdrYkN4VTd3d3pVQ1FBQUFBbHdTRmx6QUFBZXdRQUFIc0VCdzJsVVV3QUFBQVJuUVUxQkFBQ3hqd3Y4WVFVQUFBQ2NVRXhVUlFBQUFEaFVIM0N2T0hhM08yaWdORFpSSGwyT0x6aFVIenRZSUZGN0tqNWRJVUJnSWtObEpFaHRKWGk0UG5hMk96MWNJVU5sSkVodEprOTRLVkY4S2xOL0sxU0JLMVdDTEZhRUxWcUpMbHlPTDErU01HT1lNbW1pTkdtak5HK3NOMit0TjNHdk9IS3dPSEt4T1hPek9YUzBPblMxT25XMk8zZTNQWGk0UG4yOFJIKzlSb0MrUjRiQ1VJbkRWSkhIWHB2TWE1ek5icVRSZWFiU2ZWaGZna1FBQUFBUWRGSk9Vd0FFaDRlT201NmdvcVNwckxQaTlQNjR5UGVvQUFBQVprbEVRVlFZMDQzRlJ3S0NNQUFBd1VWQXFWWVVwQWpZWTZQOS8yOWVBdVNtY3huNGJhNnJBV0l4VVFJdTNkTVlBL0syT1U2SGdFUDlxVEs3RDBpcnUzZ2x2Z3lJMytWSjdEMFpzSHNVdDhqVlpNRG1lZzZkSVdCZGJxMHhZQlhNbElDbHFmYUhMM0hTQzZHWktpYkVBQUFBQUVsRlRrU3VRbUNDXCJcblx0fSxcblx0XCJwYXVzZVwiOiB7XG5cdFx0dHlwZTogXCJpbWFnZS9wbmdcIixcblx0XHRkYXRhOiBcImlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFCQUFBQUFRQ0FZQUFBQWY4LzloQUFBQjNrbEVRVlE0algyVHowc2JVUnpFM3dZOHhIK2ozaTFldkJTclVocFJRVXdVUmZ4WklpckVFaUY0azFpcVlDL1ZGandJNHNtWWxCYUNscUlIcVRGb2pLbW1acTJnb2RnV3ZlakJRZ1YvUnFadk51RVJZdFlIQThQTTdPZjBYU0g0TEZJZUtaL1VYRWIwcng3SUMwWFdLNVh5QzZ2bTE0S1dnSFpseUc4SlNsbmxSem01bHM1cnN3RmxCcjNiRnE3RXo5UVcvcVIrb0Nac0F6T3FKbHdsc3ozWmJZTWJJN2ZuQXZ4aXlLMzNJSG0zZ1Y5M094alUzWkNabDZML0xUTjJicjJYK1pCd1pBT2VwZ0V2OVc3czNZYVFURVhoMGZ2VGdJRHcwaWRUbTdKYkJUY0dvQ0VQd0pYb1F2eDZFYnZYWHpHUTZGTUErdDJiRmFOekpWNllBM3EvdDJIOTRpTmlsd3ZvMzNFcUFIM3M4ak1pRjUvQWpTbkFHVy9HOHI4WmhNNW4wUmR2VndENjBMblA2TGd4QlhSdTJURi9ObzR2ZnlmaDNHNVdBSHBtODJjVDRNWVUwQnFyaGUvRWk4REpDRHErMVNzQS9ZZlRVZGtOZ3h0VFFGUDBPYWFPM0pnKzlxQWxXcTBBOU16WWNYTWZrTGtEUjZRY2J3ODdNWEhvUkdQa21ib0RlbWJzSEpHS1BIZVFBZFN0UGNIckF6dEdEeHBSdjFhbUFQVE0ySEdUSHlEUHMzanBFY2IyMi9CbXZ4MlBsNHJVS2RNelk4Zk4vVk11TVFCV1NRNXFBWEZGMGZNSE04MXRJdWQxU0wyVGVwOFJ2ZXVCdkNEOTJYOU5lWGtXT0hGNzJnQUFBQUJKUlU1RXJrSmdnZz09XCJcblx0fSxcblx0XCJwbGF5XCI6IHtcblx0XHR0eXBlOiBcImltYWdlL3BuZ1wiLFxuXHRcdGRhdGE6IFwiaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUJBQUFBQVFDQVlBQUFBZjgvOWhBQUFBQkdkQlRVRUFBTmpyOVJ3VXFnQUFBQ0JqU0ZKTkFBQ0hEd0FBakEwQUFQbVRBQUNFNVFBQWU0SUFBT3QxQUFBL3RBQUFJbGgxYTE2Y0FBQUQ4R2xEUTFCSlEwTWdVSEp2Wm1sc1pRQUFTTWVOVmQxdjIxUVVQNGx2WEtRV1A2Q3hqZzRWaTY5VlUxdTVHeHF0eGdaSms2WHBRaHE1emRncXBNbDFiaHBUMXphMjAyMVZuL1lDYnd6NEE0Q3lCeDZRZUVJYURNVDJzdTBCdEVsVFFSWFZKS1E5ZE5wQWFKUDJncXB3cnE5VHUxM0d1Skd2ZnpubmR6N3YwVFZBeDFlYTQ1aEpHV0RlOGwwMW41R1BuNWlXTzFZaENjOUJKL1JBcDZaN1RycGNMZ0l1eG9WSDFzTmZJY0hlTndmYTYvOXpkVmFwcHdNa25rSnNWejE5SHZGcGdKU3BPNjRQSU41RytmQXAzMEhjOFR6aUhTNG1pRmhoZUpiakxNTXpIQjhQT0ZQcUtHS1dpNlRYdFNyaUpjVDlNekg1YkF6ekhJSzFJMDh0NmhxNnpIcFJkdTJhWWRKWXVrOVEvODgxYnpaYThYcng2ZkxtSm8vaXU0L1ZYbmZIMUJCL3JtdTVTY1F2STc3bStCa21meFh4dmNaY0pZMTRMMER5bVpwN3BNTDV5VGNXNjFQdklONkp1R3I0aGFsUXZtak5sQ2E0YlhKNXpqNnFocHhydWplS1BZTVhFZCtxMDBLUjV5TkFsV1p6ckYrSWUrdU5zZEMvTU80dFRPWmFmaGJyb3lYdVIzRGYwOGJMaUhzUWYramE2Z1RQV1ZpbVpsN2wvb1Vyamw4T2N4RFdMYk5VNUQ2SlJMMmd4a0R1MTZmR3VDMDU0T01oY2xzeVhUT09GRUwra21NR3M0aTVrZk51UTYyRW5CdWFtOHR6UCtRK3RTcWh6OVN1cXBabHZSMUVmQmlPSlRTZ1lNTU03anBZc0FFeXFKQ0hETDRkY0ZGVEF3Tk1sRkRVVXBRWWlhZGhEbVh0ZWVXQXczSEVtQTJzMTVrMVJtblA0Ukh1aEJ5YmRCT0Y3TWZuSUNtU1EyU1lqSUJNM2lSdmtjTWtpOUlSY25EVHRoeUx6MkxkMmZUelBqVFFLK01kZzh5NW5rWmZGTytzZTlMUXIzLzA5eFpyKzVHY2FTdWZlQWZBd3c2MG1BUHgrcTh1L2JBcjhyRkNMcng3cyt2cUVrdzhxYitwMjZuMTFBcnVxNm0xaUpINlBiV0d2MVZJWTI1bWtORThQa2FRaHhmTElGN0RaWHg4MEhEL0EzbDJqTGNsWXMwNjF4TnBXQ2ZvQjZXSEpUamJIMG1WMzVRL2xSWGxDK1c4Y25kYmw5dDJTZmhVK0ZiNFVmaE8rRjc0R1dUaGtuQlorRW00SW53alhJeWQxZVBuWS9Qc2czcGIxVEpOdTE1VE1LV010RnQ2U2NwS0wwaXZTTVhJbjlRdERVbGowaDdVN040OHQzaThlQzBHbk1DOTFkWDJzVGl2Z2xvRFRnVVZlRUdITFRpemJmNURhOUpMaGtoaDI5UU9zMWx1TWNTY21CWFRJSXQ3eFJGeFNCeG51SldmdUFkMUk3am50a3lkL3BnS2FJd1ZyM01nbURvMnE4eDZJZEI1UUgxNjJtY1g3YWp0bkhHTjJib3Y3MU9VMStVMGZxcW9YTEQwd1g1Wk0wMDVVSG15U3ozcUx0RHFJTER2SUwraUg2akI5eTJ4ODNvazg5OEdPUFFYM2xrM0l0bDBBK0JyRDZEN3RValdoM2ZpczU4QlhEaWdOOXlGOE01UEpINEI4R3I3OS9GL1hSbThtMjQxbXcvd3Z1cjRCR0RqNDJiem4rVm1jK05MOUw4R2NNbjhGMWtBY1hoTHU3aVBBQUFBQ1hCSVdYTUFBQTdEQUFBT3d3SEhiNmhrQUFBQUdIUkZXSFJUYjJaMGQyRnlaUUJ3WVdsdWRDNXVaWFFnTkM0d0xqVmxoVEpsQUFBQlBFbEVRVlE0VDJNQWdhb1RZdUpnQnJtZytyaGNYdXBDbWY5RmUyVERvVUtrZ1lwRENoa2dBK3BPS2Y0djJpbDNxV0MzcENaVWlqaFFCalVnNktqdC85Q1REdityRGl2OHo5c2t1elJoUGdNSFZBbCtVTHdYMVlDSXM4Ny9ZeTY1L1MvZXJmQS9aNzFNR1ZRWmJsQzRTeGFyQWZIWFBQOG4zL0lCdWtidWRmWTZLVmVvY2t4UXVCbS9BZW4zL2Y5blBRNzZuN1ZLK25ER0ttRnBxRFlFeU5sSW5BRzV6MFAvRjd3Ty81KzVWSG9tU3Zqa3JKUW15WURVUmRKYlkzZUtjME8xTXpDa0x5Zk9nS1Q1MHJkU2wwb2JRTFVoQU5CRXZBYWtMSkQrbVRSYklnNnFIQk1BVGNacVFNb2ltZit4MHlYN29NcHdnNFJaa2lnR2dOZ3hreVgzSjB3VmxZQXF3UThTWmtBTVNGc2k4ejk2b3RTejJFa1M5bEFwNGtEY05LbmN1S2xTLzhON0pQT2hRcVNCNkVsQ01tNGxTTkZDTkdCZ0FBQVkrdjdyajVqK1NnQUFBQUJKUlU1RXJrSmdnZz09XCJcblx0fSxcblx0XCJyZWN0YW5nbGUtc3BhY2VyXCI6IHtcblx0XHR0eXBlOiBcImltYWdlL3BuZ1wiLFxuXHRcdGRhdGE6IFwiaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUFrQUFBQUVDQVlBQUFCY0R4WE9BQUFBQkdkQlRVRUFBTEdQQy94aEJRQUFBQWx3U0ZsekFBQU93UUFBRHNFQnVKRnI3UUFBQUJoMFJWaDBVMjltZEhkaGNtVUFjR0ZwYm5RdWJtVjBJRFF1TUM0MVpZVXlaUUFBQUExSlJFRlVHRmRqR0hTQWdRRUFBSlFBQVk4THZMRUFBQUFBU1VWT1JLNUNZSUk9XCJcblx0fSxcblx0XCJyZXNldFwiOiB7XG5cdFx0dHlwZTogXCJpbWFnZS9wbmdcIixcblx0XHRkYXRhOiBcImlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFCQUFBQUFRQ0FZQUFBQWY4LzloQUFBQUFYTlNSMElBcnM0YzZRQUFBQVJuUVUxQkFBQ3hqd3Y4WVFVQUFBQUpjRWhaY3dBQURzTUFBQTdEQWNkdnFHUUFBQUFZZEVWWWRGTnZablIzWVhKbEFIQmhhVzUwTG01bGRDQTBMakF1TldXRk1tVUFBQUw4U1VSQlZEaFBiWkxaVHhOUkZNYm5EekQ2NUJzdXJDMnRTRmxFTmlHNEVBUkJndXpJR2tCRHdLQXNJcUErRUFJRTQ1SmdvZ2FDeHJkcWdpUW14aEFWaldJRXBFaW9DaFJLVUdtWlRwZVphU2xRNk9lZG9WWXhuT1NYZTg5M3ZuUHZ6Y21sL28rVjRXR0pyYk9tZ20rdFZMSk4rVXFlWUwxWnArVGJMcHkxcXo3dWQ5bTJEK3U5dGpxK3FZVG1MbWJadVV2WklPc21OVG5DYXVPdmxXdVg3N2RIdXV4L3d6UTZzSXZyYk96aUtyUEJscWE2NFpzcndGOHUyNkp4bDRwZzdXcHB4dVNiSGE1Mml1SnJ5OXJaZ3RPd1pDZHNVcGdLQzhuWHRScXNEUTJTeGd4WThwUGRkWmJVMmRyU2FySFpkcXNqeFhUcXFObDhNaFlDWEVrTzFqNTlBRmVlRDZmRkRNY1hGYXprUXNlRUNteEJ1dWdST1pNd3RYS3JRMEt4UmRsOTVtUFJNTWRGZ2kzS3hZWnVFV3RqbjJGSlQ0SFRUQTRZSHdON3JnVHI4L1Bra0hGWVVoTkZyemtoanJ5c3NJZ3lSa1dPbVlLRFlBb0x4VXIvTXppTlJtSTZEVUZ6bWt4d2pJNkllMHRXSnB3TUErNUtBMHdod2FKbVNrcnFwZ3dTdVpxUnlHQU1qeVkzcTJCWFBnRWprUk5rWkFaYXJMNTZMZTRGYmZYbEFHdzl2VEFHS0VUTktBMVFVa3hvbEpYMjhJRWhPQUpyNHhPd1BlaUJrQXN3TVNmQWhNZTZjL3ZUUHRnZVBnYnRMUmR6WTBvNlRlbTg1V3JkSGwvb3BZRllmZmVldkdJYytuMStFTFIvRVRUSHQrL2dXanVnODVTS0dxMElVMUsvNUNGdmYrNzFnd0RYY1FOTyt3ck1EVmZGL0YrNHp0dllJUE14Wk9TNnRhWDQ1QlpLbjVaMWQ4SExmMzJCQ0F2K0NsaWZ2OEE2VFlPOWN4ZDBUaUVNQmFXd2thZHZzQnpZN2w0cytNZ2hlSC9JZ3V4MFdrNGl4ZFRYZTh3ZERCdlM3SmRDWUU0V0RIMXRBNWFIUitBd01IRG85ZURKOEhUbnF6QXJWWWdlQVcxUWhKS3B1cjVUL0V5V25rZkhaOG13cGtoQllOcExocGtESWRBb0Rvdk15SUl3NWVudnJzOGVJY045MEJzdU52K0p4Wm9yNmRPSG9yV1RQbktubWd4cE83NzZIbkJvWXVKVlM3ZTdvbDF0VzJPKytKeHNOaU92Y1RJa1lsQk5icDd3OHNlRXR3emZJbUtoRGp6VXI4bk1xMTRzcnRydHNwT2dxTjl3YTBZdmN3elV1UUFBQUFCSlJVNUVya0pnZ2c9PVwiXG5cdH0sXG5cdFwic29ydGFibGVcIjoge1xuXHRcdHR5cGU6IFwiaW1hZ2UvcG5nXCIsXG5cdFx0ZGF0YTogXCJpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQTRBQUFBS0NBWUFBQUNFMlcvSEFBQUFBWE5TUjBJQXJzNGM2UUFBQUFSblFVMUJBQUN4and2OFlRVUFBQUFKY0VoWmN3QUFEc01BQUE3REFjZHZxR1FBQUFBWWRFVllkRk52Wm5SM1lYSmxBSEJoYVc1MExtNWxkQ0EwTGpBdU5XV0ZNbVVBQUFBeFNVUkJWQ2hUWThBRC9rTnBrZ0JJRXd3VERaQTFFYTBabXlZWUhtUUFteE5obUNBZ1N4TU1rS1VKQnZCb1ltQUFBSkNYSCtGVTFUOCtBQUFBQUVsRlRrU3VRbUNDXCJcblx0fSxcblx0XCJzd2FwXCI6IHtcblx0XHR0eXBlOiBcImltYWdlL3BuZ1wiLFxuXHRcdGRhdGE6IFwiaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUJBQUFBQVFDQVlBQUFBZjgvOWhBQUFBQkdkQlRVRUFBSy9JTndXSzZRQUFBQmwwUlZoMFUyOW1kSGRoY21VQVFXUnZZbVVnU1cxaFoyVlNaV0ZrZVhISlpUd0FBQUk5U1VSQlZEakxwWk5CUzlSaEVNWi91NjBhWkFkTlNYZExyY3hOUzgyRGFSUVZSQkNVR25nd3drT252a0IweUV0MHF5L1FLU3JxNURVU1FnTFRTaTAxZDgwZ2NyWFNUVGRUVmlUVS8vK2RlZDhPUmloRllENHdsK0ZoWU9ZM1Q4QTV4MllVM0lqNTRxT21wODMzem1YKzE0Q1doNDMxdm05T0dzKzhXOXNQWE9tNDlIc0hxeGFyRmhYYlo5VzJFUXhlRUNObnhVaDBXMlkya2R3SWN3dHpKQ2JIWTgrdXZhZ0JDQUcwVmwzRzRYRE9ZWjFqYlBiajBmZkowUzZ4UXJUNEFGc3pzeEMxcUZQeWN2SllYbDQ1Zk94RzdjdFhOd2VPQjUxeldCelcyVitsN01uYlMyMUpMZW1GTkJtaERJd0l4aHFNR293S3hnakdOeGtBSVN1V0IyL3VvcUlFN1JiMjU1ZHhNSEtJbk8wN0NMa014cE1UcE9abm1FN05FTjRaUVVWSVRJeVBETnlLMXdFRTFtSnN1ZCtRTFVhdmw0Y3IybzVFNjRnbGh1bUo5YWc2MjlUVjF0dFJkN1ZHTldRL0RkNk9sLzZWZ2d1Q0RUamlZekdXdkNXaVJlWDRQd3hlMmdQQVgvTHg1cngxZEFLdDdjMU9qQ0JHY09Jb3lDMWtNYjFJV1RqS3ZxSlNKcWJHR1I2TmswZ2tPQml0UU1ReU5EZzBrbWovWEEwUU1yN2hSUGtwMUNscUJiSEtYTlk4OFE5eGluZVZFQzZJVUZnUXdaNjJxRlVzRm0vRnE5cDlQdng2NnNsMFhkRDQ2eThzS2l3dUxaTDYvbzNudmQzTXArY1JKNGdWeENsaUZSRkZqQnFBUU1PZE0wNk1ZSHhCL0ZWRVlxUlBQRzN6MC83cUkva2F6Yy9QcDdLNmt1U1hKRVA5YjJNem5iTTFmMUQ0bDRvYUkvVXEycVZpSjFPZHM5RU5aMkh5OGRkK05kcXRSaXZYVWRoc25IOENuNlJzdENNMDFINEFBQUFBU1VWT1JLNUNZSUk9XCJcblx0fSxcblx0XCJ1bmNoZWNrZWRcIjoge1xuXHRcdHR5cGU6IFwiaW1hZ2UvcG5nXCIsXG5cdFx0ZGF0YTogXCJpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQTBBQUFBUENBWUFBQUEvSTBWM0FBQUFCR2RCVFVFQUFMR1BDL3hoQlFBQUFBbHdTRmx6QUFBT3dnQUFEc0lCRlNoS2dBQUFBQmgwUlZoMFUyOW1kSGRoY21VQWNHRnBiblF1Ym1WMElEUXVNQzQxWllVeVpRQUFBUkJKUkVGVU9FKzlrcnR1ZzFBUVJQbGRTaW83RlExdFpJbU9rb0tPQm9tR1QwRVVSQzVpbm81NHlUdzkwV3l3UWhUa0lrVldHb0YyenV4ZHJsRCt0MHpUaEtacFQwVm14YjhDUVJDZzZ6cjBmYjhyZXI3dmZ3Y1B4eGRjcngrWXBnbnpQR05abGg5aWJ4eEhsR1VKc2hMU2RWMGF0OXROcGc3RElCclg1K09rUE05QlZrS0dZU0JKRXRSMWpiWnJCZGlxYlZ0VVZZVTBUVUZXUXErbkUrSTR4dnZsSW1HYVc3Rkhqd3haQ1ZtV2hiZnpHVm1Xb1NnS1dYVXI5dWlSSVNzaHgzRmtFbGRvbXViWGF1elJJME5XUXA3bnlVUitORy9yZnIvalVYeG5qeDV2bUt5RWJOdVdveDlYdmlkNlpNaEs2SEE0d25WZGhHR0lLSXAyUlk4TVdRbXgrSnVvcXZwVVpGYjhMNlVvbnlZTDN1T3RyRkgrQUFBQUFFbEZUa1N1UW1DQ1wiXG5cdH0sXG5cdFwidXAtYXJyb3dcIjoge1xuXHRcdHR5cGU6IFwiaW1hZ2UvcG5nXCIsXG5cdFx0ZGF0YTogXCJpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQVVBQUFBS0NBWUFBQUI4T1pRd0FBQUFBWE5TUjBJQXJzNGM2UUFBQUFSblFVMUJBQUN4and2OFlRVUFBQUFKY0VoWmN3QUFEc01BQUE3REFjZHZxR1FBQUFBWWRFVllkRk52Wm5SM1lYSmxBSEJoYVc1MExtNWxkQ0EwTGpBdU5XV0ZNbVVBQUFBOVNVUkJWQmhYYll2UkNnQWdDQU90cVAvL1k5dEVsdzhORHJjRHpkMERCQ2Q3aVNMM0UwSXZHT3BmMmZLWGVaVUZLRGNZRk13QmxETldTNzZiWFVNNVA5SW41QXp5QUFBQUFFbEZUa1N1UW1DQ1wiXG5cdH0sXG5cdFwidXAtZG93bi1zcGluXCI6IHtcblx0XHR0eXBlOiBcImltYWdlL3BuZ1wiLFxuXHRcdGRhdGE6IFwiaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUE0QUFBQVBDQVlBQUFEVUZQNTBBQUFBQkdkQlRVRUFBTEdQQy94aEJRQUFBQWx3U0ZsekFBQU93UUFBRHNFQnVKRnI3UUFBQUJoMFJWaDBVMjltZEhkaGNtVUFjR0ZwYm5RdWJtVjBJRFF1TUM0MVpZVXlaUUFBQUdKSlJFRlVPRStsa3dFS0FDRUlCSDJaYi9Qbkhzb0dlYVZKRFVqR09nUlJwS3BraUlqK3k0TU1FM2VEUjdrYUtPVk5zSnlNTmpJSHpHeTlZblc2SjdxSWNycmlRaW1lQ3FPUk5BQmQwZnBSVGt0OHVWVWo3RXN4QzZ2cy9xM2UvUTZpRDJid25CeWpQWEhOQUFBQUFFbEZUa1N1UW1DQ1wiXG5cdH0sXG5cdFwidXAtZG93blwiOiB7XG5cdFx0dHlwZTogXCJpbWFnZS9wbmdcIixcblx0XHRkYXRhOiBcImlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFBNEFBQUFQQ0FZQUFBRFVGUDUwQUFBQUJHZEJUVUVBQUxHUEMveGhCUUFBQUFsd1NGbHpBQUFPd1FBQURzRUJ1SkZyN1FBQUFCaDBSVmgwVTI5bWRIZGhjbVVBY0dGcGJuUXVibVYwSURRdU1DNDFaWVV5WlFBQUFHRkpSRUZVT0UrbGtrRUtRQ0VJUkQyWkozUGgzaU40V0Q5R2ZscFloajBZWW93cEdnSm1iaWtkM2dqTURGb2t3YnVUMWlBaXVyRzVub21ncW81UWFQbzlFUlFSSTZKZjdzZkdqdWR5MmplMjMraTBXbDJvUTg1VE9kbGZySlFPYXpGOGJyK3JxVFhRS24wQUFBQUFTVVZPUks1Q1lJST1cIlxuXHR9LFxuXHRcInVwLXJlY3RhbmdsZVwiOiB7XG5cdFx0dHlwZTogXCJpbWFnZS9wbmdcIixcblx0XHRkYXRhOiBcImlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFBa0FBQUFFQ0FZQUFBQmNEeFhPQUFBQUJHZEJUVUVBQUxHUEMveGhCUUFBQUFsd1NGbHpBQUFPd2dBQURzSUJGU2hLZ0FBQUFCcDBSVmgwVTI5bWRIZGhjbVVBVUdGcGJuUXVUa1ZVSUhZekxqVXVNVEZIODBJM0FBQUFIa2xFUVZRWVYyUEFBdjVEYVp3QXBBQ0dzUUprQlZnVllsTUF4UXdNQUJPckQvR3ZQK0VXQUFBQUFFbEZUa1N1UW1DQ1wiXG5cdH0sXG5cdFwidXBcIjoge1xuXHRcdHR5cGU6IFwiaW1hZ2UvcG5nXCIsXG5cdFx0ZGF0YTogXCJpVkJPUncwS0dnb0FBQUFOU1VoRVVnQUFBQkFBQUFBUUNBWUFBQUFmOC85aEFBQUQ4R2xEUTFCSlEwTWdVSEp2Wm1sc1pRQUFPSTJOVmQxdjIxUVVQNGx2WEtRV1A2Q3hqZzRWaTY5VlUxdTVHeHF0eGdaSms2WHBRaHE1emRncXBNbDFiaHBUMXphMjAyMVZuL1lDYnd6NEE0Q3lCeDZRZUVJYURNVDJzdTBCdEVsVFFSWFZKS1E5ZE5wQWFKUDJncXB3cnE5VHUxM0d1Skd2ZnpubmR6N3YwVFZBeDFlYTQ1aEpHV0RlOGwwMW41R1BuNWlXTzFZaENjOUJKL1JBcDZaN1RycGNMZ0l1eG9WSDFzTmZJY0hlTndmYTYvOXpkVmFwcHdNa25rSnNWejE5SHZGcGdKU3BPNjRQSU41RytmQXAzMEhjOFR6aUhTNG1pRmhoZUpiakxNTXpIQjhQT0ZQcUtHS1dpNlRYdFNyaUpjVDlNekg1YkF6ekhJSzFJMDh0NmhxNnpIcFJkdTJhWWRKWXVrOVEvODgxYnpaYThYcng2ZkxtSm8vaXU0L1ZYbmZIMUJCL3JtdTVTY1F2STc3bStCa21meFh4dmNaY0pZMTRMMER5bVpwN3BNTDV5VGNXNjFQdklONkp1R3I0aGFsUXZtak5sQ2E0YlhKNXpqNnFocHhydWplS1BZTVhFZCtxMDBLUjV5TkFsV1p6ckYrSWUrdU5zZEMvTU80dFRPWmFmaGJyb3lYdVIzRGYwOGJMaUhzUWYramE2Z1RQV1ZpbVpsN2wvb1Vyamw4T2N4RFdMYk5VNUQ2SlJMMmd4a0R1MTZmR3VDMDU0T01oY2xzeVhUT09GRUwra21NR3M0aTVrZk51UTYyRW5CdWFtOHR6UCtRK3RTcWh6OVN1cXBabHZSMUVmQmlPSlRTZ1lNTU03anBZc0FFeXFKQ0hETDRkY0ZGVEF3Tk1sRkRVVXBRWWlhZGhEbVh0ZWVXQXczSEVtQTJzMTVrMVJtblA0Ukh1aEJ5YmRCT0Y3TWZuSUNtU1EyU1lqSUJNM2lSdmtjTWtpOUlSY25EVHRoeUx6MkxkMmZUelBqVFFLK01kZzh5NW5rWmZGTytzZTlMUXIzLzA5eFpyKzVHY2FTdWZlQWZBd3c2MG1BUHgrcTh1L2JBcjhyRkNMcng3cyt2cUVrdzhxYitwMjZuMTFBcnVxNm0xaUpINlBiV0d2MVZJWTI1bWtORThQa2FRaHhmTElGN0RaWHg4MEhEL0EzbDJqTGNsWXMwNjF4TnBXQ2ZvQjZXSEpUamJIMG1WMzVRL2xSWGxDK1c4Y25kYmw5dDJTZmhVK0ZiNFVmaE8rRjc0R1dUaGtuQlorRW00SW53alhJeWQxZVBuWS9Qc2czcGIxVEpOdTE1VE1LV010RnQ2U2NwS0wwaXZTTVhJbjlRdERVbGowaDdVN040OHQzaThlQzBHbk1DOTFkWDJzVGl2Z2xvRFRnVVZlRUdITFRpemJmNURhOUpMaGtoaDI5UU9zMWx1TWNTY21CWFRJSXQ3eFJGeFNCeG51SldmdUFkMUk3am50a3lkL3BnS2FJd1ZyM01nbURvMnE4eDZJZEI1UUgxNjJtY1g3YWp0bkhHTjJib3Y3MU9VMStVMGZxcW9YTEQwd1g1Wk0wMDVVSG15U3ozcUx0RHFJTER2SUwraUg2akI5eTJ4ODNvazg5OEdPUFFYM2xrM0l0bDBBK0JyRDZEN3RValdoM2ZpczU4QlhEaWdOOXlGOE01UEpINEI4R3I3OS9GL1hSbThtMjQxbXcvd3Z1cjRCR0RqNDJiem4rVm1jK05MOUw4R2NNbjhGMWtBY1hnU3RlR0dBQUFCVlVsRVFWUTRFV05nb0RXb3VWRDVINThkVFBna0hVN28vRC85WXpNK0piamxkTGRJL1QvNmY4ci9CZjhUL3F1dmxzTHBDa1pzUnFndGxQby9MYTZLNGRTZkxRemZ2LzFrNE9SaVoxaXc3QkxEcmZobkdPb3hCQ0NhQzRHYWp6RjgrUFlCYmo0N2tMVnkrUTJHV3huUFVmU2doSUhoUWxXZ3pZVU1UeGp1QW0yR2FQNFBkQUVJL3dEaThFZ05CdTBaOGlqZWdadG1zZEQ0Lzh2dnR4bFl1VmdaRk5XRUdPeU5kY0F1QUduK0RyVDl5UEw3RE8rL2Z3VzdTSkJUbHVGQzBWV3dYaGFZRzAvRW40VWJ4cjJhNTcreXVTYkQ0VzhId05LY1FQTEw5MThNRDZzL2dkVThaTGdLMDhhQTRnVzQ2TGZmRE45L0ErMzkraE9NUVM1Z2hVdWlNckFiQUZiem5lRUhrQVpoa0VHL3dBeXdCQXFCMVlCZjMvOERBeEdIRGhUdERBendNRUFXWitOa1pQak8vWU9CQStSMkVBQ0dIUnNIaElsT1lqWGc4YWt2REJQdmJHUDRCVFRnUDh3UWRKMkRoZzhBOVNTRDRFVElISzRBQUFBQVNVVk9SSzVDWUlJPVwiXG5cdH0sXG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cblxuKGZ1bmN0aW9uIChtb2R1bGUpIHsgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLWV4cHJlc3Npb25zXG5cbiAgICAvLyBUaGlzIGNsb3N1cmUgc3VwcG9ydHMgTm9kZUpTLWxlc3MgY2xpZW50IHNpZGUgaW5jbHVkZXMgd2l0aCA8c2NyaXB0PiB0YWdzLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2pvbmVpdC9tbm0uXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBJbnNlcnQgYmFzZSBzdHlsZXNoZWV0IGludG8gRE9NXG4gICAgICogQGRlc2MgQ3JlYXRlcyBhIG5ldyBgPHN0eWxlPi4uLjwvc3R5bGU+YCBlbGVtZW50IGZyb20gdGhlIG5hbWVkIHRleHQgc3RyaW5nKHMpIGFuZCBpbnNlcnRzIGl0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSBjc3NSdWxlc1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbSURdXG4gICAgICogQHBhcmFtIHtzdHJpbmd8RWxlbWVudHx1bmRlZmluZWR8bnVsbH0gW3JlZmVyZW5jZUVsZW1lbnRdXG4gICAgICogKiBgdW5kZWZpbmVkYCB0eXBlIChvciBvbWl0dGVkKTogaW5qZWN0cyBzdHlsZXNoZWV0IGF0IHRvcCBvZiBgPGhlYWQuLi48L2hlYWQ+YCBlbGVtZW50XG4gICAgICogKiBgbnVsbGAgdmFsdWU6IGluamVjdHMgc3R5bGVzaGVldCBhdCBib3R0b20gb2YgYDxoZWFkPi4uLjwvaGVhZD5gIGVsZW1lbnRcbiAgICAgKiAqIGBFbGVtZW50YCB0eXBlOiBpbmplY3RzIHN0eWxlc2hlZXQgaW1tZWRpYXRlbHkgYmVmb3JlIGdpdmVuIGVsZW1lbnRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjc3NJbmplY3Rvcihjc3NSdWxlcywgSUQsIHJlZmVyZW5jZUVsZW1lbnQpIHtcbiAgICAgICAgaWYgKElEKSB7XG4gICAgICAgICAgICBJRCA9IGNzc0luamVjdG9yLmlkUHJlZml4ICsgSUQ7XG5cbiAgICAgICAgICAgIGlmIChkb2N1bWVudC5nZXRFbGVtZW50QnlJZChJRCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47IC8vIHN0eWxlc2hlZXQgYWxyZWFkeSBpbiBET01cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgcmVmZXJlbmNlRWxlbWVudCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHJlZmVyZW5jZUVsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHJlZmVyZW5jZUVsZW1lbnQpO1xuICAgICAgICAgICAgaWYgKCFyZWZlcmVuY2VFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgJ0Nhbm5vdCBmaW5kIHJlZmVyZW5jZSBlbGVtZW50IGZvciBDU1MgaW5qZWN0aW9uLic7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAocmVmZXJlbmNlRWxlbWVudCAmJiAhKHJlZmVyZW5jZUVsZW1lbnQgaW5zdGFuY2VvZiBFbGVtZW50KSkge1xuICAgICAgICAgICAgdGhyb3cgJ0dpdmVuIHZhbHVlIG5vdCBhIHJlZmVyZW5jZSBlbGVtZW50Lic7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICAgICAgICBzdHlsZS50eXBlID0gJ3RleHQvY3NzJztcbiAgICAgICAgaWYgKElEKSB7XG4gICAgICAgICAgICBzdHlsZS5pZCA9IElEO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjc3NSdWxlcyBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICAgICAgICBjc3NSdWxlcyA9IGNzc1J1bGVzLmpvaW4oJ1xcbicpO1xuICAgICAgICB9XG4gICAgICAgIGNzc1J1bGVzID0gJ1xcbicgKyBjc3NSdWxlcyArICdcXG4nO1xuICAgICAgICBpZiAoc3R5bGUuc3R5bGVTaGVldCkge1xuICAgICAgICAgICAgc3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzUnVsZXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdHlsZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3NSdWxlcykpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNvbnRhaW5lciA9IHJlZmVyZW5jZUVsZW1lbnQgJiYgcmVmZXJlbmNlRWxlbWVudC5wYXJlbnROb2RlIHx8IGRvY3VtZW50LmhlYWQgfHwgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXTtcblxuICAgICAgICBpZiAocmVmZXJlbmNlRWxlbWVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZWZlcmVuY2VFbGVtZW50ID0gY29udGFpbmVyLmZpcnN0Q2hpbGQ7XG4gICAgICAgIH1cblxuICAgICAgICBjb250YWluZXIuaW5zZXJ0QmVmb3JlKHN0eWxlLCByZWZlcmVuY2VFbGVtZW50KTtcbiAgICB9XG5cbiAgICBjc3NJbmplY3Rvci5pZFByZWZpeCA9ICdpbmplY3RlZC1zdHlsZXNoZWV0LSc7XG5cbiAgICAvLyBJbnRlcmZhY2VcbiAgICBtb2R1bGUuZXhwb3J0cyA9IGNzc0luamVjdG9yO1xufSkoXG4gICAgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgbW9kdWxlIHx8ICh3aW5kb3cuY3NzSW5qZWN0b3IgPSB7fSksXG4gICAgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgbW9kdWxlLmV4cG9ydHMgfHwgKHdpbmRvdy5jc3NJbmplY3Rvci5leHBvcnRzID0ge30pXG4pIHx8IChcbiAgICB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyB8fCAod2luZG93LmNzc0luamVjdG9yID0gd2luZG93LmNzc0luamVjdG9yLmV4cG9ydHMpXG4pO1xuXG4vKiBBYm91dCB0aGUgYWJvdmUgSUlGRTpcbiAqIFRoaXMgZmlsZSBpcyBhIFwibW9kaWZpZWQgbm9kZSBtb2R1bGUuXCIgSXQgZnVuY3Rpb25zIGFzIHVzdWFsIGluIE5vZGUuanMgKmFuZCogaXMgYWxzbyB1c2FibGUgZGlyZWN0bHkgaW4gdGhlIGJyb3dzZXIuXG4gKiAxLiBOb2RlLmpzOiBUaGUgSUlGRSBpcyBzdXBlcmZsdW91cyBidXQgaW5ub2N1b3VzLlxuICogMi4gSW4gdGhlIGJyb3dzZXI6IFRoZSBJSUZFIGNsb3N1cmUgc2VydmVzIHRvIGtlZXAgaW50ZXJuYWwgZGVjbGFyYXRpb25zIHByaXZhdGUuXG4gKiAyLmEuIEluIHRoZSBicm93c2VyIGFzIGEgZ2xvYmFsOiBUaGUgbG9naWMgaW4gdGhlIGFjdHVhbCBwYXJhbWV0ZXIgZXhwcmVzc2lvbnMgKyB0aGUgcG9zdC1pbnZvY2F0aW9uIGV4cHJlc3Npb25cbiAqIHdpbGwgcHV0IHlvdXIgQVBJIGluIGB3aW5kb3cuY3NzSW5qZWN0b3JgLlxuICogMi5iLiBJbiB0aGUgYnJvd3NlciBhcyBhIG1vZHVsZTogSWYgeW91IHByZWRlZmluZSBhIGB3aW5kb3cubW9kdWxlYCBvYmplY3QsIHRoZSByZXN1bHRzIHdpbGwgYmUgaW4gYG1vZHVsZS5leHBvcnRzYC5cbiAqIFRoZSBib3dlciBjb21wb25lbnQgYG1ubWAgbWFrZXMgdGhpcyBlYXN5IGFuZCBhbHNvIHByb3ZpZGVzIGEgZ2xvYmFsIGByZXF1aXJlKClgIGZ1bmN0aW9uIGZvciByZWZlcmVuY2luZyB5b3VyIG1vZHVsZVxuICogZnJvbSBvdGhlciBjbG9zdXJlcy4gSW4gZWl0aGVyIGNhc2UsIHRoaXMgd29ya3Mgd2l0aCBib3RoIE5vZGVKcy1zdHlsZSBleHBvcnQgbWVjaGFuaXNtcyAtLSBhIHNpbmdsZSBBUEkgYXNzaWdubWVudCxcbiAqIGBtb2R1bGUuZXhwb3J0cyA9IHlvdXJBUElgICpvciogYSBzZXJpZXMgb2YgaW5kaXZpZHVhbCBwcm9wZXJ0eSBhc3NpZ25tZW50cywgYG1vZHVsZS5leHBvcnRzLnByb3BlcnR5ID0gcHJvcGVydHlgLlxuICpcbiAqIEJlZm9yZSB0aGUgSUlGRSBydW5zLCB0aGUgYWN0dWFsIHBhcmFtZXRlciBleHByZXNzaW9ucyBhcmUgZXhlY3V0ZWQ6XG4gKiAxLiBJZiBgbW9kdWxlYCBvYmplY3QgZGVmaW5lZCwgd2UncmUgaW4gTm9kZUpzIHNvIGFzc3VtZSB0aGVyZSBpcyBhIGBtb2R1bGVgIG9iamVjdCB3aXRoIGFuIGBleHBvcnRzYCBvYmplY3RcbiAqIDIuIElmIGBtb2R1bGVgIG9iamVjdCB1bmRlZmluZWQsIHdlJ3JlIGluIGJyb3dzZXIgc28gZGVmaW5lIGEgYHdpbmRvdy5jc3NJbmplY3RvcmAgb2JqZWN0IHdpdGggYW4gYGV4cG9ydHNgIG9iamVjdFxuICpcbiAqIEFmdGVyIHRoZSBJSUZFIHJldHVybnM6XG4gKiBCZWNhdXNlIGl0IGFsd2F5cyByZXR1cm5zIHVuZGVmaW5lZCwgdGhlIGV4cHJlc3Npb24gYWZ0ZXIgdGhlIHx8IHdpbGwgYWx3YXlzIGV4ZWN1dGU6XG4gKiAxLiBJZiBgbW9kdWxlYCBvYmplY3QgZGVmaW5lZCwgdGhlbiB3ZSdyZSBpbiBOb2RlSnMgc28gd2UncmUgZG9uZVxuICogMi4gSWYgYG1vZHVsZWAgb2JqZWN0IHVuZGVmaW5lZCwgdGhlbiB3ZSdyZSBpbiBicm93c2VyIHNvIHJlZGVmaW5lYHdpbmRvdy5jc3NJbmplY3RvcmAgYXMgaXRzIGBleHBvcnRzYCBvYmplY3RcbiAqL1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKiogQG5hbWVzcGFjZSBleHRlbmQtbWUgKiovXG5cbi8qKiBAc3VtbWFyeSBFeHRlbmRzIGFuIGV4aXN0aW5nIGNvbnN0cnVjdG9yIGludG8gYSBuZXcgY29uc3RydWN0b3IuXG4gKlxuICogQHJldHVybnMge0NoaWxkQ29uc3RydWN0b3J9IEEgbmV3IGNvbnN0cnVjdG9yLCBleHRlbmRlZCBmcm9tIHRoZSBnaXZlbiBjb250ZXh0LCBwb3NzaWJseSB3aXRoIHNvbWUgcHJvdG90eXBlIGFkZGl0aW9ucy5cbiAqXG4gKiBAZGVzYyBFeHRlbmRzIFwib2JqZWN0c1wiIChjb25zdHJ1Y3RvcnMpLCB3aXRoIG9wdGlvbmFsIGFkZGl0aW9uYWwgY29kZSwgb3B0aW9uYWwgcHJvdG90eXBlIGFkZGl0aW9ucywgYW5kIG9wdGlvbmFsIHByb3RvdHlwZSBtZW1iZXIgYWxpYXNlcy5cbiAqXG4gKiA+IENBVkVBVDogTm90IHRvIGJlIGNvbmZ1c2VkIHdpdGggVW5kZXJzY29yZS1zdHlsZSAuZXh0ZW5kKCkgd2hpY2ggaXMgc29tZXRoaW5nIGVsc2UgZW50aXJlbHkuIEkndmUgdXNlZCB0aGUgbmFtZSBcImV4dGVuZFwiIGhlcmUgYmVjYXVzZSBvdGhlciBwYWNrYWdlcyAobGlrZSBCYWNrYm9uZS5qcykgdXNlIGl0IHRoaXMgd2F5LiBZb3UgYXJlIGZyZWUgdG8gY2FsbCBpdCB3aGF0ZXZlciB5b3Ugd2FudCB3aGVuIHlvdSBcInJlcXVpcmVcIiBpdCwgc3VjaCBhcyBgdmFyIGluaGVyaXRzID0gcmVxdWlyZSgnZXh0ZW5kJylgLlxuICpcbiAqIFByb3ZpZGUgYSBjb25zdHJ1Y3RvciBhcyB0aGUgY29udGV4dCBhbmQgYW55IHByb3RvdHlwZSBhZGRpdGlvbnMgeW91IHJlcXVpcmUgaW4gdGhlIGZpcnN0IGFyZ3VtZW50LlxuICpcbiAqIEZvciBleGFtcGxlLCBpZiB5b3Ugd2lzaCB0byBiZSBhYmxlIHRvIGV4dGVuZCBgQmFzZUNvbnN0cnVjdG9yYCB0byBhIG5ldyBjb25zdHJ1Y3RvciB3aXRoIHByb3RvdHlwZSBvdmVycmlkZXMgYW5kL29yIGFkZGl0aW9ucywgYmFzaWMgdXNhZ2UgaXM6XG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogdmFyIEJhc2UgPSByZXF1aXJlKCdleHRlbmQtbWUnKS5CYXNlO1xuICogdmFyIEJhc2VDb25zdHJ1Y3RvciA9IEJhc2UuZXh0ZW5kKGJhc2VQcm90b3R5cGUpOyAvLyBtaXhlcyBpbiAuZXh0ZW5kXG4gKiB2YXIgQ2hpbGRDb25zdHJ1Y3RvciA9IEJhc2VDb25zdHJ1Y3Rvci5leHRlbmQoY2hpbGRQcm90b3R5cGVPdmVycmlkZXNBbmRBZGRpdGlvbnMpO1xuICogdmFyIEdyYW5kY2hpbGRDb25zdHJ1Y3RvciA9IENoaWxkQ29uc3RydWN0b3IuZXh0ZW5kKGdyYW5kY2hpbGRQcm90b3R5cGVPdmVycmlkZXNBbmRBZGRpdGlvbnMpO1xuICogYGBgXG4gKlxuICogVGhpcyBmdW5jdGlvbiAoYGV4dGVuZCgpYCkgaXMgYWRkZWQgdG8gdGhlIG5ldyBleHRlbmRlZCBvYmplY3QgY29uc3RydWN0b3IgYXMgYSBwcm9wZXJ0eSBgLmV4dGVuZGAsIGVzc2VudGlhbGx5IG1ha2luZyB0aGUgb2JqZWN0IGNvbnN0cnVjdG9yIGl0c2VsZiBlYXNpbHkgXCJleHRlbmRhYmxlLlwiIChOb3RlOiBUaGlzIGlzIGEgcHJvcGVydHkgb2YgZWFjaCBjb25zdHJ1Y3RvciBhbmQgbm90IGEgbWV0aG9kIG9mIGl0cyBwcm90b3R5cGUhKVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBbZXh0ZW5kZWRDbGFzc05hbWVdIC0gVGhpcyBpcyBzaW1wbHkgYWRkZWQgdG8gdGhlIHByb3RvdHlwZSBhcyAkJENMQVNTX05BTUUuIFVzZWZ1bCBmb3IgZGVidWdnaW5nIGJlY2F1c2UgYWxsIGRlcml2ZWQgY29uc3RydWN0b3JzIGFwcGVhciB0byBoYXZlIHRoZSBzYW1lIG5hbWUgKFwiQ29uc3RydWN0b3JcIikgaW4gdGhlIGRlYnVnZ2VyLiBUaGlzIHByb3BlcnR5IGlzIGlnbm9yZWQgdW5sZXNzIGBleHRlbmQuZGVidWdgIGlzIGV4cGxpY2l0bHkgc2V0IHRvIGEgdHJ1dGh5IHZhbHVlLlxuICpcbiAqIEBwYXJhbSB7ZXh0ZW5kZWRQcm90b3R5cGVBZGRpdGlvbnNPYmplY3R9IFtwcm90b3R5cGVBZGRpdGlvbnNdIC0gT2JqZWN0IHdpdGggbWVtYmVycyB0byBjb3B5IHRvIG5ldyBjb25zdHJ1Y3RvcidzIHByb3RvdHlwZS4gTW9zdCBtZW1iZXJzIHdpbGwgYmUgY29waWVkIHRvIHRoZSBwcm90b3R5cGUuIFNvbWUgbWVtYmVycywgaG93ZXZlciwgaGF2ZSBzcGVjaWFsIG1lYW5pbmdzIGFzIGV4cGxhaW5lZCBpbiB0aGUge0BsaW5rIGV4dGVuZGVkUHJvdG90eXBlQWRkaXRpb25zT2JqZWN0fHR5cGUgZGVmaW5pdGlvbn0gKGFuZCBtYXkgb3IgbWF5IG5vdCBiZSBjb3BpZWQgdG8gdGhlIHByb3RvdHlwZSkuXG4gKlxuICogQHByb3BlcnR5IHtib29sZWFufSBbZGVidWddIC0gU2VlIHBhcmFtZXRlciBgZXh0ZW5kZWRDbGFzc05hbWVgIF8oYWJvdmUpXy5cbiAqXG4gKiBAcHJvcGVydHkge29iamVjdH0gQmFzZSAtIEEgY29udmVuaWVudCBiYXNlIGNsYXNzIGZyb20gd2hpY2ggYWxsIG90aGVyIGNsYXNzZXMgY2FuIGJlIGV4dGVuZGVkLlxuICpcbiAqIEBtZW1iZXJPZiBleHRlbmQtbWVcbiAqL1xuZnVuY3Rpb24gZXh0ZW5kKGV4dGVuZGVkQ2xhc3NOYW1lLCBwcm90b3R5cGVBZGRpdGlvbnMpIHtcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgcHJvdG90eXBlQWRkaXRpb25zID0ge307XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgcHJvdG90eXBlQWRkaXRpb25zID0gZXh0ZW5kZWRDbGFzc05hbWU7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHByb3RvdHlwZUFkZGl0aW9ucyAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAnU2luZ2xlIHBhcmFtZXRlciBvdmVybG9hZCBtdXN0IGJlIG9iamVjdC4nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZXh0ZW5kZWRDbGFzc05hbWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgaWYgKHR5cGVvZiBleHRlbmRlZENsYXNzTmFtZSAhPT0gJ3N0cmluZycgfHwgdHlwZW9mIHByb3RvdHlwZUFkZGl0aW9ucyAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAnVHdvIHBhcmFtZXRlciBvdmVybG9hZCBtdXN0IGJlIHN0cmluZywgb2JqZWN0Lic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93ICdUb28gbWFueSBwYXJhbWV0ZXJzJztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBDb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgaWYgKHByb3RvdHlwZUFkZGl0aW9ucy5wcmVJbml0aWFsaXplKSB7XG4gICAgICAgICAgICBwcm90b3R5cGVBZGRpdGlvbnMucHJlSW5pdGlhbGl6ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaW5pdGlhbGl6ZVByb3RvdHlwZUNoYWluLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgICAgICAgaWYgKHByb3RvdHlwZUFkZGl0aW9ucy5wb3N0SW5pdGlhbGl6ZSkge1xuICAgICAgICAgICAgcHJvdG90eXBlQWRkaXRpb25zLnBvc3RJbml0aWFsaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBDb25zdHJ1Y3Rvci5leHRlbmQgPSBleHRlbmQ7XG5cbiAgICB2YXIgcHJvdG90eXBlID0gQ29uc3RydWN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZSh0aGlzLnByb3RvdHlwZSk7XG4gICAgcHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ29uc3RydWN0b3I7XG5cbiAgICBpZiAoZXh0ZW5kZWRDbGFzc05hbWUgJiYgZXh0ZW5kLmRlYnVnKSB7XG4gICAgICAgIHByb3RvdHlwZS4kJENMQVNTX05BTUUgPSBleHRlbmRlZENsYXNzTmFtZTtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gcHJvdG90eXBlQWRkaXRpb25zKSB7XG4gICAgICAgIGlmIChwcm90b3R5cGVBZGRpdGlvbnMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gcHJvdG90eXBlQWRkaXRpb25zW2tleV07XG4gICAgICAgICAgICBzd2l0Y2ggKGtleSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2luaXRpYWxpemVPd24nOlxuICAgICAgICAgICAgICAgICAgICAvLyBhbHJlYWR5IGNhbGxlZCBhYm92ZTsgbm90IG5lZWRlZCBpbiBwcm90b3R5cGVcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnYWxpYXNlcyc6XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGFsaWFzIGluIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsdWUuaGFzT3duUHJvcGVydHkoYWxpYXMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFrZUFsaWFzKHZhbHVlW2FsaWFzXSwgYWxpYXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIHZhbHVlWzBdID09PSAnIycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ha2VBbGlhcyh2YWx1ZSwga2V5LnN1YnN0cigxKSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm90b3R5cGVba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gQ29uc3RydWN0b3I7XG5cbiAgICBmdW5jdGlvbiBtYWtlQWxpYXModmFsdWUsIGtleSkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNoYWRvd1xuICAgICAgICBwcm90b3R5cGVba2V5XSA9IHByb3RvdHlwZUFkZGl0aW9uc1t2YWx1ZV07XG4gICAgfVxufVxuXG5leHRlbmQuQmFzZSA9IGZ1bmN0aW9uICgpIHt9O1xuZXh0ZW5kLkJhc2UuZXh0ZW5kID0gZXh0ZW5kO1xuXG4vKiogQHR5cGVkZWYge2Z1bmN0aW9ufSBleHRlbmRlZENvbnN0cnVjdG9yXG4gKiBAcHJvcGVydHkgcHJvdG90eXBlLnN1cGVyIC0gQSByZWZlcmVuY2UgdG8gdGhlIHByb3RvdHlwZSB0aGlzIGNvbnN0cnVjdG9yIHdhcyBleHRlbmRlZCBmcm9tLlxuICogQHByb3BlcnR5IFtleHRlbmRdIC0gSWYgYHByb3RvdHlwZUFkZGl0aW9ucy5leHRlbmRhYmxlYCB3YXMgdHJ1dGh5LCB0aGlzIHdpbGwgYmUgYSByZWZlcmVuY2UgdG8ge0BsaW5rIGV4dGVuZC5leHRlbmR8ZXh0ZW5kfS5cbiAqL1xuXG4vKiogQHR5cGVkZWYge29iamVjdH0gZXh0ZW5kZWRQcm90b3R5cGVBZGRpdGlvbnNPYmplY3RcbiAqIEBwcm9wZXJ0eSB7ZnVuY3Rpb259IFtpbml0aWFsaXplXSAtIEFkZGl0aW9uYWwgY29uc3RydWN0b3IgY29kZSBmb3IgbmV3IG9iamVjdC4gVGhpcyBtZXRob2QgaXMgYWRkZWQgdG8gdGhlIG5ldyBjb25zdHJ1Y3RvcidzIHByb3RvdHlwZS4gR2V0cyBwYXNzZWQgbmV3IG9iamVjdCBhcyBjb250ZXh0ICsgc2FtZSBhcmdzIGFzIGNvbnN0cnVjdG9yIGl0c2VsZi4gQ2FsbGVkIG9uIGluc3RhbnRpYXRpb24gYWZ0ZXIgc2ltaWxhciBmdW5jdGlvbiBpbiBhbGwgYW5jZXN0b3JzIGNhbGxlZCB3aXRoIHNhbWUgc2lnbmF0dXJlLlxuICogQHByb3BlcnR5IHtmdW5jdGlvbn0gW2luaXRpYWxpemVPd25dIC0gQWRkaXRpb25hbCBjb25zdHJ1Y3RvciBjb2RlIGZvciBuZXcgb2JqZWN0LiBUaGlzIG1ldGhvZCBpcyBhZGRlZCB0byB0aGUgbmV3IGNvbnN0cnVjdG9yJ3MgcHJvdG90eXBlLiBHZXRzIHBhc3NlZCBuZXcgb2JqZWN0IGFzIGNvbnRleHQgKyBzYW1lIGFyZ3MgYXMgY29uc3RydWN0b3IgaXRzZWxmLiBDYWxsZWQgb24gaW5zdGFudGlhdGlvbiBhZnRlciAoYWxsKSB0aGUgYGluaXRpYWxpemVgIGZ1bmN0aW9uKHMpLlxuICogQHByb3BlcnR5IHtvYmplY3R9IFthbGlhc2VzXSAtIEhhc2ggb2YgYWxpYXNlcyBmb3IgcHJvdG90eXBlIG1lbWJlcnMgaW4gZm9ybSBgeyBrZXk6ICdtZW1iZXInLCAuLi4gfWAgd2hlcmUgYGtleWAgaXMgdGhlIG5hbWUgb2YgYW4gYWxpZWFzIGFuZCBgJ21lbWJlcidgIGlzIHRoZSBuYW1lIG9mIGFuIGV4aXN0aW5nIG1lbWJlciBpbiB0aGUgcHJvdG90eXBlLiBFYWNoIHN1Y2gga2V5IGlzIGFkZGVkIHRvIHRoZSBwcm90b3R5cGUgYXMgYSByZWZlcmVuY2UgdG8gdGhlIG5hbWVkIG1lbWJlci4gKFRoZSBgYWxpYXNlc2Agb2JqZWN0IGl0c2VsZiBpcyAqbm90KiBhZGRlZCB0byBwcm90b3R5cGUuKSBBbHRlcm5hdGl2ZWx5OlxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtrZXlzXSAtIEFyYml0cmFyeSBwcm9wZXJ0eSBuYW1lcyBkZWZpbmVkIGhlcmUgd2l0aCBzdHJpbmcgdmFsdWVzIHN0YXJ0aW5nIHdpdGggYSBgI2AgY2hhcmFjdGVyIHdpbGwgYWxpYXMgdGhlIGFjdHVhbCBwcm9wZXJ0aWVzIG5hbWVkIGluIHRoZSBzdHJpbmdzIChmb2xsb3dpbmcgdGhlIGAjYCkuIFRoaXMgaXMgYW4gYWx0ZXJuYXRpdmUgdG8gcHJvdmlkaW5nIGFuIGBhbGlhc2VzYCBoYXNoLCBwZXJoYXBzIHNpbXBsZXIgKHRob3VnaCBzdWJ0bGVyKS4gKFVzZSBhcmJpdHJhcnkgaWRlbnRpZmllcnMgaGVyZTsgZG9uJ3QgdXNlIHRoZSBuYW1lIGBrZXlzYCEpXG4gKiBAcHJvcGVydHkgeyp9IFthcmJpdHJhcnlQcm9wZXJ0aWVzXSAtIEFueSBhZGRpdGlvbmFsIGFyYml0cmFyeSBwcm9wZXJ0aWVzIGRlZmluZWQgaGVyZSB3aWxsIGJlIGFkZGVkIHRvIHRoZSBuZXcgY29uc3RydWN0b3IncyBwcm90b3R5cGUuIChVc2UgYXJiaXRyYXJ5IGlkZW50aWZpZXJzIGhlcmU7IGRvbid0IHVzZSB0aGUgbmFtZSBgYXJpYml0cmFyeVByb3BlcnRpZXNgISlcbiAqL1xuXG4vKiogQHN1bW1hcnkgQ2FsbCBhbGwgYGluaXRpYWxpemVgIG1ldGhvZHMgZm91bmQgaW4gcHJvdG90eXBlIGNoYWluLlxuICogQGRlc2MgVGhpcyByZWN1cnNpdmUgcm91dGluZSBpcyBjYWxsZWQgYnkgdGhlIGNvbnN0cnVjdG9yLlxuICogMS4gV2Fsa3MgYmFjayB0aGUgcHJvdG90eXBlIGNoYWluIHRvIGBPYmplY3RgJ3MgcHJvdG90eXBlXG4gKiAyLiBXYWxrcyBmb3J3YXJkIHRvIG5ldyBvYmplY3QsIGNhbGxpbmcgYW55IGBpbml0aWFsaXplYCBtZXRob2RzIGl0IGZpbmRzIGFsb25nIHRoZSB3YXkgd2l0aCB0aGUgc2FtZSBjb250ZXh0IGFuZCBhcmd1bWVudHMgd2l0aCB3aGljaCB0aGUgY29uc3RydWN0b3Igd2FzIGNhbGxlZC5cbiAqIEBwcml2YXRlXG4gKiBAbWVtYmVyT2YgZXh0ZW5kLW1lXG4gKi9cbmZ1bmN0aW9uIGluaXRpYWxpemVQcm90b3R5cGVDaGFpbigpIHtcbiAgICB2YXIgdGVybSA9IHRoaXMsXG4gICAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgcmVjdXIodGVybSk7XG5cbiAgICBmdW5jdGlvbiByZWN1cihvYmopIHtcbiAgICAgICAgdmFyIHByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKG9iaik7XG4gICAgICAgIGlmIChwcm90by5jb25zdHJ1Y3RvciAhPT0gT2JqZWN0KSB7XG4gICAgICAgICAgICByZWN1cihwcm90byk7XG4gICAgICAgICAgICBpZiAocHJvdG8uaW5pdGlhbGl6ZSkge1xuICAgICAgICAgICAgICAgIHByb3RvLmluaXRpYWxpemUuYXBwbHkodGVybSwgYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZXh0ZW5kO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKiBlc2xpbnQtZW52IG5vZGUsIGJyb3dzZXIgKi9cblxudmFyIGNzc0luamVjdG9yID0gcmVxdWlyZSgnY3NzLWluamVjdG9yJyk7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yIEZpbkJhclxuICogQHN1bW1hcnkgQ3JlYXRlIGEgc2Nyb2xsYmFyIG9iamVjdC5cbiAqIEBkZXNjIENyZWF0aW5nIGEgc2Nyb2xsYmFyIGlzIGEgdGhyZWUtc3RlcCBwcm9jZXNzOlxuICpcbiAqIDEuIEluc3RhbnRpYXRlIHRoZSBzY3JvbGxiYXIgb2JqZWN0IGJ5IGNhbGxpbmcgdGhpcyBjb25zdHJ1Y3RvciBmdW5jdGlvbi4gVXBvbiBpbnN0YW50aWF0aW9uLCB0aGUgRE9NIGVsZW1lbnQgZm9yIHRoZSBzY3JvbGxiYXIgKHdpdGggYSBzaW5nbGUgY2hpbGQgZWxlbWVudCBmb3IgdGhlIHNjcm9sbGJhciBcInRodW1iXCIpIGlzIGNyZWF0ZWQgYnV0IGlzIG5vdCBpbnNlcnQgaXQgaW50byB0aGUgRE9NLlxuICogMi4gQWZ0ZXIgaW5zdGFudGlhdGlvbiwgaXQgaXMgdGhlIGNhbGxlcidzIHJlc3BvbnNpYmlsaXR5IHRvIGluc2VydCB0aGUgc2Nyb2xsYmFyLCB7QGxpbmsgRmluQmFyI2Jhcnx0aGlzLmJhcn0sIGludG8gdGhlIERPTS5cbiAqIDMuIEFmdGVyIGluc2VydGlvbiwgdGhlIGNhbGxlciBtdXN0IGNhbGwge0BsaW5rIEZpbkJhciNyZXNpemV8cmVzaXplKCl9IGF0IGxlYXN0IG9uY2UgdG8gc2l6ZSBhbmQgcG9zaXRpb24gdGhlIHNjcm9sbGJhciBhbmQgaXRzIHRodW1iLiBBZnRlciB0aGF0LCBgcmVzaXplKClgIHNob3VsZCBhbHNvIGJlIGNhbGxlZCByZXBlYXRlZGx5IG9uIHJlc2l6ZSBldmVudHMgKGFzIHRoZSBjb250ZW50IGVsZW1lbnQgaXMgYmVpbmcgcmVzaXplZCkuXG4gKlxuICogU3VnZ2VzdGVkIGNvbmZpZ3VyYXRpb25zOlxuICogKiBfKipVbmJvdW5kKipfPGJyLz5cbiAqIFRoZSBzY3JvbGxiYXIgc2VydmVzIG1lcmVseSBhcyBhIHNpbXBsZSByYW5nZSAoc2xpZGVyKSBjb250cm9sLiBPbWl0IGJvdGggYG9wdGlvbnMub25jaGFuZ2VgIGFuZCBgb3B0aW9ucy5jb250ZW50YC5cbiAqICogXyoqQm91bmQgdG8gdmlydHVhbCBjb250ZW50IGVsZW1lbnQqKl88YnIvPlxuICogVmlydHVhbCBjb250ZW50IGlzIHByb2plY3RlZCBpbnRvIHRoZSBlbGVtZW50IHVzaW5nIGEgY3VzdG9tIGV2ZW50IGhhbmRsZXIgc3VwcGxpZWQgYnkgdGhlIHByb2dyYW1tZXIgaW4gYG9wdGlvbnMub25jaGFuZ2VgLiBBIHR5cGljYWwgdXNlIGNhc2Ugd291bGQgYmUgdG8gaGFuZGxlIHNjcm9sbGluZyBvZiB0aGUgdmlydHVhbCBjb250ZW50LiBPdGhlciB1c2UgY2FzZXMgaW5jbHVkZSBkYXRhIHRyYW5zZm9ybWF0aW9ucywgZ3JhcGhpY3MgdHJhbnNmb3JtYXRpb25zLCBfZXRjLl9cbiAqICogXyoqQm91bmQgdG8gcmVhbCBjb250ZW50KipfPGJyLz5cbiAqIFNldCBgb3B0aW9ucy5jb250ZW50YCB0byB0aGUgXCJyZWFsXCIgY29udGVudCBlbGVtZW50IGJ1dCBvbWl0IGBvcHRpb25zLm9uY2hhbmdlYC4gVGhpcyB3aWxsIGNhdXNlIHRoZSBzY3JvbGxiYXIgdG8gdXNlIHRoZSBidWlsdC1pbiBldmVudCBoYW5kbGVyIChgdGhpcy5zY3JvbGxSZWFsQ29udGVudGApIHdoaWNoIGltcGxlbWVudHMgc21vb3RoIHNjcm9sbGluZyBvZiB0aGUgY29udGVudCBlbGVtZW50IHdpdGhpbiB0aGUgY29udGFpbmVyLlxuICpcbiAqIEBwYXJhbSB7ZmluYmFyT3B0aW9uc30gW29wdGlvbnM9e31dIC0gT3B0aW9ucyBvYmplY3QuIFNlZSB0aGUgdHlwZSBkZWZpbml0aW9uIGZvciBtZW1iZXIgZGV0YWlscy5cbiAqL1xuZnVuY3Rpb24gRmluQmFyKG9wdGlvbnMpIHtcblxuICAgIC8vIG1ha2UgYm91bmQgdmVyc2lvbnMgb2YgYWxsIHRoZSBtb3VzZSBldmVudCBoYW5kbGVyXG4gICAgdmFyIGJvdW5kID0gdGhpcy5fYm91bmQgPSB7fTtcbiAgICBmb3IgKGtleSBpbiBoYW5kbGVyc1RvQmVCb3VuZCkge1xuICAgICAgICBib3VuZFtrZXldID0gaGFuZGxlcnNUb0JlQm91bmRba2V5XS5iaW5kKHRoaXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBuYW1lIHRodW1iXG4gICAgICogQHN1bW1hcnkgVGhlIGdlbmVyYXRlZCBzY3JvbGxiYXIgdGh1bWIgZWxlbWVudC5cbiAgICAgKiBAZGVzYyBUaGUgdGh1bWIgZWxlbWVudCdzIHBhcmVudCBlbGVtZW50IGlzIGFsd2F5cyB0aGUge0BsaW5rIEZpbkJhciNiYXJ8YmFyfSBlbGVtZW50LlxuICAgICAqXG4gICAgICogVGhpcyBwcm9wZXJ0eSBpcyB0eXBpY2FsbHkgcmVmZXJlbmNlZCBpbnRlcm5hbGx5IG9ubHkuIFRoZSBzaXplIGFuZCBwb3NpdGlvbiBvZiB0aGUgdGh1bWIgZWxlbWVudCBpcyBtYWludGFpbmVkIGJ5IGBfY2FsY1RodW1iKClgLlxuICAgICAqIEB0eXBlIHtFbGVtZW50fVxuICAgICAqIEBtZW1iZXJPZiBGaW5CYXIucHJvdG90eXBlXG4gICAgICovXG4gICAgdmFyIHRodW1iID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgdGh1bWIuY2xhc3NMaXN0LmFkZCgndGh1bWInKTtcbiAgICB0aHVtYi5vbmNsaWNrID0gYm91bmQuc2hvcnRTdG9wO1xuICAgIHRodW1iLm9ubW91c2VvdmVyID0gYm91bmQub25tb3VzZW92ZXI7XG4gICAgdGhpcy50aHVtYiA9IHRodW1iO1xuXG4gICAgLyoqXG4gICAgICogQG5hbWUgYmFyXG4gICAgICogQHN1bW1hcnkgVGhlIGdlbmVyYXRlZCBzY3JvbGxiYXIgZWxlbWVudC5cbiAgICAgKiBAZGVzYyBUaGUgY2FsbGVyIGluc2VydHMgdGhpcyBlbGVtZW50IGludG8gdGhlIERPTSAodHlwaWNhbGx5IGludG8gdGhlIGNvbnRlbnQgY29udGFpbmVyKSBhbmQgdGhlbiBjYWxscyBpdHMge0BsaW5rIEZpbkJhciNyZXNpemV8cmVzaXplKCl9IG1ldGhvZC5cbiAgICAgKlxuICAgICAqIFRodXMgdGhlIG5vZGUgdHJlZSBpcyB0eXBpY2FsbHk6XG4gICAgICogKiBBICoqY29udGVudCBjb250YWluZXIqKiBlbGVtZW50LCB3aGljaCBjb250YWluczpcbiAgICAgKiAgICAqIFRoZSBjb250ZW50IGVsZW1lbnQocylcbiAgICAgKiAgICAqIFRoaXMgKipzY3JvbGxiYXIgZWxlbWVudCoqLCB3aGljaCBpbiB0dXJuIGNvbnRhaW5zOlxuICAgICAqICAgICAgICAqIFRoZSAqKnRodW1iIGVsZW1lbnQqKlxuICAgICAqXG4gICAgICogQHR5cGUge0VsZW1lbnR9XG4gICAgICogQG1lbWJlck9mIEZpbkJhci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICB2YXIgYmFyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cbiAgICBiYXIuY2xhc3NMaXN0LmFkZCgnZmluYmFyLXZlcnRpY2FsJyk7XG5cbiAgICBiYXIuYXBwZW5kQ2hpbGQodGh1bWIpO1xuICAgIGlmICh0aGlzLnBhZ2luZykge1xuICAgICAgICBiYXIub25jbGljayA9IGJvdW5kLm9uY2xpY2s7XG4gICAgfVxuICAgIHRoaXMuYmFyID0gYmFyO1xuXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAvLyBwcmVzZXRzXG4gICAgdGhpcy5vcmllbnRhdGlvbiA9ICd2ZXJ0aWNhbCc7XG4gICAgdGhpcy5fbWluID0gdGhpcy5faW5kZXggPSAwO1xuICAgIHRoaXMuX21heCA9IDEwMDtcblxuICAgIC8vIG9wdGlvbnNcbiAgICBmb3IgKHZhciBrZXkgaW4gb3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICB2YXIgb3B0aW9uID0gb3B0aW9uc1trZXldO1xuICAgICAgICAgICAgc3dpdGNoIChrZXkpIHtcblxuICAgICAgICAgICAgY2FzZSAnaW5kZXgnOlxuICAgICAgICAgICAgICAgIHRoaXMuX2luZGV4ID0gb3B0aW9uO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdyYW5nZSc6XG4gICAgICAgICAgICAgICAgdmFsaWRSYW5nZShvcHRpb24pO1xuICAgICAgICAgICAgICAgIHRoaXMuX21pbiA9IG9wdGlvbi5taW47XG4gICAgICAgICAgICAgICAgdGhpcy5fbWF4ID0gb3B0aW9uLm1heDtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRlbnRTaXplID0gb3B0aW9uLm1heCAtIG9wdGlvbi5taW4gKyAxO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAga2V5LmNoYXJBdCgwKSAhPT0gJ18nICYmXG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiBGaW5CYXIucHJvdG90eXBlW2tleV0gIT09ICdmdW5jdGlvbidcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gb3ZlcnJpZGUgcHJvdG90eXBlIGRlZmF1bHRzIGZvciBzdGFuZGFyZCA7XG4gICAgICAgICAgICAgICAgICAgIC8vIGV4dGVuZCB3aXRoIGFkZGl0aW9uYWwgcHJvcGVydGllcyAoZm9yIHVzZSBpbiBvbmNoYW5nZSBldmVudCBoYW5kbGVycylcbiAgICAgICAgICAgICAgICAgICAgdGhpc1trZXldID0gb3B0aW9uO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgY3NzSW5qZWN0b3IoY3NzRmluQmFycywgJ2ZpbmJhci1iYXNlJywgb3B0aW9ucy5jc3NTdHlsZXNoZWV0UmVmZXJlbmNlRWxlbWVudCk7XG59XG5cbkZpbkJhci5wcm90b3R5cGUgPSB7XG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBUaGUgc2Nyb2xsYmFyIG9yaWVudGF0aW9uLlxuICAgICAqIEBkZXNjIFNldCBieSB0aGUgY29uc3RydWN0b3IgdG8gZWl0aGVyIGAndmVydGljYWwnYCBvciBgJ2hvcml6b250YWwnYC4gU2VlIHRoZSBzaW1pbGFybHkgbmFtZWQgcHJvcGVydHkgaW4gdGhlIHtAbGluayBmaW5iYXJPcHRpb25zfSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBVc2VmdWwgdmFsdWVzIGFyZSBgJ3ZlcnRpY2FsJ2AgKHRoZSBkZWZhdWx0KSBvciBgJ2hvcml6b250YWwnYC5cbiAgICAgKlxuICAgICAqIFNldHRpbmcgdGhpcyBwcm9wZXJ0eSByZXNldHMgYHRoaXMub2hgIGFuZCBgdGhpcy5kZWx0YVByb3BgIGFuZCBjaGFuZ2VzIHRoZSBjbGFzcyBuYW1lcyBzbyBhcyB0byByZXBvc2l0aW9uIHRoZSBzY3JvbGxiYXIgYXMgcGVyIHRoZSBDU1MgcnVsZXMgZm9yIHRoZSBuZXcgb3JpZW50YXRpb24uXG4gICAgICogQGRlZmF1bHQgJ3ZlcnRpY2FsJ1xuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQG1lbWJlck9mIEZpbkJhci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBzZXQgb3JpZW50YXRpb24ob3JpZW50YXRpb24pIHtcbiAgICAgICAgaWYgKG9yaWVudGF0aW9uID09PSB0aGlzLl9vcmllbnRhdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fb3JpZW50YXRpb24gPSBvcmllbnRhdGlvbjtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJlYWRvbmx5XG4gICAgICAgICAqIEBuYW1lIG9oXG4gICAgICAgICAqIEBzdW1tYXJ5IDx1Pk88L3U+cmllbnRhdGlvbiA8dT5oPC91PmFzaCBmb3IgdGhpcyBzY3JvbGxiYXIuXG4gICAgICAgICAqIEBkZXNjIFNldCBieSB0aGUgYG9yaWVudGF0aW9uYCBzZXR0ZXIgdG8gZWl0aGVyIHRoZSB2ZXJ0aWNhbCBvciB0aGUgaG9yaXpvbnRhbCBvcmllbnRhdGlvbiBoYXNoLiBUaGUgcHJvcGVydHkgc2hvdWxkIGFsd2F5cyBiZSBzeW5jaHJvbml6ZWQgd2l0aCBgb3JpZW50YXRpb25gOyBkbyBub3QgdXBkYXRlIGRpcmVjdGx5IVxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIG9iamVjdCBpcyB1c2VkIGludGVybmFsbHkgdG8gYWNjZXNzIHNjcm9sbGJhcnMnIERPTSBlbGVtZW50IHByb3BlcnRpZXMgaW4gYSBnZW5lcmFsaXplZCB3YXkgd2l0aG91dCBuZWVkaW5nIHRvIGNvbnN0YW50bHkgcXVlcnkgdGhlIHNjcm9sbGJhciBvcmllbnRhdGlvbi4gRm9yIGV4YW1wbGUsIGluc3RlYWQgb2YgZXhwbGljaXRseSBjb2RpbmcgYHRoaXMuYmFyLnRvcGAgZm9yIGEgdmVydGljYWwgc2Nyb2xsYmFyIGFuZCBgdGhpcy5iYXIubGVmdGAgZm9yIGEgaG9yaXpvbnRhbCBzY3JvbGxiYXIsIHNpbXBseSBjb2RlIGB0aGlzLmJhclt0aGlzLm9oLmxlYWRpbmddYCBpbnN0ZWFkLiBTZWUgdGhlIHtAbGluayBvcmllbnRhdGlvbkhhc2hUeXBlfSBkZWZpbml0aW9uIGZvciBkZXRhaWxzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGlzIG9iamVjdCBpcyB1c2VmdWwgZXh0ZXJuYWxseSBmb3IgY29kaW5nIGdlbmVyYWxpemVkIHtAbGluayBmaW5iYXJPbkNoYW5nZX0gZXZlbnQgaGFuZGxlciBmdW5jdGlvbnMgdGhhdCBzZXJ2ZSBib3RoIGhvcml6b250YWwgYW5kIHZlcnRpY2FsIHNjcm9sbGJhcnMuXG4gICAgICAgICAqIEB0eXBlIHtvcmllbnRhdGlvbkhhc2hUeXBlfVxuICAgICAgICAgKiBAbWVtYmVyT2YgRmluQmFyLnByb3RvdHlwZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5vaCA9IG9yaWVudGF0aW9uSGFzaGVzW3RoaXMuX29yaWVudGF0aW9uXTtcblxuICAgICAgICBpZiAoIXRoaXMub2gpIHtcbiAgICAgICAgICAgIGVycm9yKCdJbnZhbGlkIHZhbHVlIGZvciBgb3B0aW9ucy5fb3JpZW50YXRpb24uJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQG5hbWUgZGVsdGFQcm9wXG4gICAgICAgICAqIEBzdW1tYXJ5IFRoZSBuYW1lIG9mIHRoZSBgV2hlZWxFdmVudGAgcHJvcGVydHkgdGhpcyBzY3JvbGxiYXIgc2hvdWxkIGxpc3RlbiB0by5cbiAgICAgICAgICogQGRlc2MgU2V0IGJ5IHRoZSBjb25zdHJ1Y3Rvci4gU2VlIHRoZSBzaW1pbGFybHkgbmFtZWQgcHJvcGVydHkgaW4gdGhlIHtAbGluayBmaW5iYXJPcHRpb25zfSBvYmplY3QuXG4gICAgICAgICAqXG4gICAgICAgICAqIFVzZWZ1bCB2YWx1ZXMgYXJlIGAnZGVsdGFYJ2AsIGAnZGVsdGFZJ2AsIG9yIGAnZGVsdGFaJ2AuIEEgdmFsdWUgb2YgYG51bGxgIG1lYW5zIHRvIGlnbm9yZSBtb3VzZSB3aGVlbCBldmVudHMgZW50aXJlbHkuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSBtb3VzZSB3aGVlbCBpcyBvbmUtZGltZW5zaW9uYWwgYW5kIG9ubHkgZW1pdHMgZXZlbnRzIHdpdGggYGRlbHRhWWAgZGF0YS4gVGhpcyBwcm9wZXJ0eSBpcyBwcm92aWRlZCBzbyB0aGF0IHlvdSBjYW4gb3ZlcnJpZGUgdGhlIGRlZmF1bHQgb2YgYCdkZWx0YVgnYCB3aXRoIGEgdmFsdWUgb2YgYCdkZWx0YVknYCBvbiB5b3VyIGhvcml6b250YWwgc2Nyb2xsYmFyIHByaW1hcmlseSB0byBhY2NvbW1vZGF0ZSBjZXJ0YWluIFwicGFub3JhbWljXCIgaW50ZXJmYWNlIGRlc2lnbnMgd2hlcmUgdGhlIG1vdXNlIHdoZWVsIHNob3VsZCBjb250cm9sIGhvcml6b250YWwgcmF0aGVyIHRoYW4gdmVydGljYWwgc2Nyb2xsaW5nLiBKdXN0IGdpdmUgYHsgZGVsdGFQcm9wOiAnZGVsdGFZJyB9YCBpbiB5b3VyIGhvcml6b250YWwgc2Nyb2xsYmFyIGluc3RhbnRpYXRpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIENhdmVhdDogTm90ZSB0aGF0IGEgMi1maW5nZXIgZHJhZyBvbiBhbiBBcHBsZSB0cmFja3BhZCBlbWl0cyBldmVudHMgd2l0aCBfYm90aF8gYGRlbHRhWCBgIGFuZCBgZGVsdGFZYCBkYXRhIHNvIHlvdSBtaWdodCB3YW50IHRvIGRlbGF5IG1ha2luZyB0aGUgYWJvdmUgYWRqdXN0bWVudCB1bnRpbCB5b3UgY2FuIGRldGVybWluZSB0aGF0IHlvdSBhcmUgZ2V0dGluZyBZIGRhdGEgb25seSB3aXRoIG5vIFggZGF0YSBhdCBhbGwgKHdoaWNoIGlzIGEgc3VyZSBiZXQgeW91IG9uIGEgbW91c2Ugd2hlZWwgcmF0aGVyIHRoYW4gYSB0cmFja3BhZCkuXG5cbiAgICAgICAgICogQHR5cGUge29iamVjdHxudWxsfVxuICAgICAgICAgKiBAbWVtYmVyT2YgRmluQmFyLnByb3RvdHlwZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5kZWx0YVByb3AgPSB0aGlzLm9oLmRlbHRhO1xuXG4gICAgICAgIHRoaXMuYmFyLmNsYXNzTmFtZSA9IHRoaXMuYmFyLmNsYXNzTmFtZS5yZXBsYWNlKC8odmVydGljYWx8aG9yaXpvbnRhbCkvZywgb3JpZW50YXRpb24pO1xuXG4gICAgICAgIGlmICh0aGlzLmJhci5zdHlsZS5jc3NUZXh0IHx8IHRoaXMudGh1bWIuc3R5bGUuY3NzVGV4dCkge1xuICAgICAgICAgICAgdGhpcy5iYXIucmVtb3ZlQXR0cmlidXRlKCdzdHlsZScpO1xuICAgICAgICAgICAgdGhpcy50aHVtYi5yZW1vdmVBdHRyaWJ1dGUoJ3N0eWxlJyk7XG4gICAgICAgICAgICB0aGlzLnJlc2l6ZSgpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBnZXQgb3JpZW50YXRpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9vcmllbnRhdGlvbjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgQ2FsbGJhY2sgZm9yIHNjcm9sbCBldmVudHMuXG4gICAgICogQGRlc2MgU2V0IGJ5IHRoZSBjb25zdHJ1Y3RvciB2aWEgdGhlIHNpbWlsYXJseSBuYW1lZCBwcm9wZXJ0eSBpbiB0aGUge0BsaW5rIGZpbmJhck9wdGlvbnN9IG9iamVjdC4gQWZ0ZXIgaW5zdGFudGlhdGlvbiwgYHRoaXMub25jaGFuZ2VgIG1heSBiZSB1cGRhdGVkIGRpcmVjdGx5LlxuICAgICAqXG4gICAgICogVGhpcyBldmVudCBoYW5kbGVyIGlzIGNhbGxlZCB3aGVuZXZlciB0aGUgdmFsdWUgb2YgdGhlIHNjcm9sbGJhciBpcyBjaGFuZ2VkIHRocm91Z2ggdXNlciBpbnRlcmFjdGlvbi4gVGhlIHR5cGljYWwgdXNlIGNhc2UgaXMgd2hlbiB0aGUgY29udGVudCBpcyBzY3JvbGxlZC4gSXQgaXMgY2FsbGVkIHdpdGggdGhlIGBGaW5CYXJgIG9iamVjdCBhcyBpdHMgY29udGV4dCBhbmQgdGhlIGN1cnJlbnQgdmFsdWUgb2YgdGhlIHNjcm9sbGJhciAoaXRzIGluZGV4LCByb3VuZGVkKSBhcyB0aGUgb25seSBwYXJhbWV0ZXIuXG4gICAgICpcbiAgICAgKiBTZXQgdGhpcyBwcm9wZXJ0eSB0byBgbnVsbGAgdG8gc3RvcCBlbWl0dGluZyBzdWNoIGV2ZW50cy5cbiAgICAgKiBAdHlwZSB7ZnVuY3Rpb24obnVtYmVyKXxudWxsfVxuICAgICAqIEBtZW1iZXJPZiBGaW5CYXIucHJvdG90eXBlXG4gICAgICovXG4gICAgb25jaGFuZ2U6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBBZGQgYSBDU1MgY2xhc3MgbmFtZSB0byB0aGUgYmFyIGVsZW1lbnQncyBjbGFzcyBsaXN0LlxuICAgICAqIEBkZXNjIFNldCBieSB0aGUgY29uc3RydWN0b3IuIFNlZSB0aGUgc2ltaWxhcmx5IG5hbWVkIHByb3BlcnR5IGluIHRoZSB7QGxpbmsgZmluYmFyT3B0aW9uc30gb2JqZWN0LlxuICAgICAqXG4gICAgICogVGhlIGJhciBlbGVtZW50J3MgY2xhc3MgbGlzdCB3aWxsIGFsd2F5cyBpbmNsdWRlIGBmaW5iYXItdmVydGljYWxgIChvciBgZmluYmFyLWhvcml6b250YWxgIGJhc2VkIG9uIHRoZSBjdXJyZW50IG9yaWVudGF0aW9uKS4gV2hlbmV2ZXIgdGhpcyBwcm9wZXJ0eSBpcyBzZXQgdG8gc29tZSB2YWx1ZSwgZmlyc3QgdGhlIG9sZCBwcmVmaXgrb3JpZW50YXRpb24gaXMgcmVtb3ZlZCBmcm9tIHRoZSBiYXIgZWxlbWVudCdzIGNsYXNzIGxpc3Q7IHRoZW4gdGhlIG5ldyBwcmVmaXgrb3JpZW50YXRpb24gaXMgYWRkZWQgdG8gdGhlIGJhciBlbGVtZW50J3MgY2xhc3MgbGlzdC4gVGhpcyBwcm9wZXJ0eSBjYXVzZXMgX2FuIGFkZGl0aW9uYWxfIGNsYXNzIG5hbWUgdG8gYmUgYWRkZWQgdG8gdGhlIGJhciBlbGVtZW50J3MgY2xhc3MgbGlzdC4gVGhlcmVmb3JlLCB0aGlzIHByb3BlcnR5IHdpbGwgb25seSBhZGQgYXQgbW9zdCBvbmUgYWRkaXRpb25hbCBjbGFzcyBuYW1lIHRvIHRoZSBsaXN0LlxuICAgICAqXG4gICAgICogVG8gcmVtb3ZlIF9jbGFzc25hbWUtb3JpZW50YXRpb25fIGZyb20gdGhlIGJhciBlbGVtZW50J3MgY2xhc3MgbGlzdCwgc2V0IHRoaXMgcHJvcGVydHkgdG8gYSBmYWxzeSB2YWx1ZSwgc3VjaCBhcyBgbnVsbGAuXG4gICAgICpcbiAgICAgKiA+IE5PVEU6IFlvdSBvbmx5IG5lZWQgdG8gc3BlY2lmeSBhbiBhZGRpdGlvbmFsIGNsYXNzIG5hbWUgd2hlbiB5b3UgbmVlZCB0byBoYXZlIG11bGx0aXBsZSBkaWZmZXJlbnQgc3R5bGVzIG9mIHNjcm9sbGJhcnMgb24gdGhlIHNhbWUgcGFnZS4gSWYgdGhpcyBpcyBub3QgYSByZXF1aXJlbWVudCwgdGhlbiB5b3UgZG9uJ3QgbmVlZCB0byBtYWtlIGEgbmV3IGNsYXNzOyB5b3Ugd291bGQganVzdCBjcmVhdGUgc29tZSBhZGRpdGlvbmFsIHJ1bGVzIHVzaW5nIHRoZSBzYW1lIHNlbGVjdG9ycyBpbiB0aGUgYnVpbHQtaW4gc3R5bGVzaGVldCAoLi4vY3NzL2ZpbmJhcnMuY3NzKTpcbiAgICAgKiAqYGRpdi5maW5iYXItdmVydGljYWxgIChvciBgZGl2LmZpbmJhci1ob3Jpem9udGFsYCkgZm9yIHRoZSBzY3JvbGxiYXJcbiAgICAgKiAqYGRpdi5maW5iYXItdmVydGljYWwgPiBkaXZgIChvciBgZGl2LmZpbmJhci1ob3Jpem9udGFsID4gZGl2YCkgZm9yIHRoZSBcInRodW1iLlwiXG4gICAgICpcbiAgICAgKiBPZiBjb3Vyc2UsIHlvdXIgcnVsZXMgc2hvdWxkIGNvbWUgYWZ0ZXIgdGhlIGJ1aWx0LWlucy5cbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBtZW1iZXJPZiBGaW5CYXIucHJvdG90eXBlXG4gICAgICovXG4gICAgc2V0IGNsYXNzUHJlZml4KHByZWZpeCkge1xuICAgICAgICBpZiAodGhpcy5fY2xhc3NQcmVmaXgpIHtcbiAgICAgICAgICAgIHRoaXMuYmFyLmNsYXNzTGlzdC5yZW1vdmUodGhpcy5fY2xhc3NQcmVmaXggKyB0aGlzLm9yaWVudGF0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2NsYXNzUHJlZml4ID0gcHJlZml4O1xuXG4gICAgICAgIGlmIChwcmVmaXgpIHtcbiAgICAgICAgICAgIHRoaXMuYmFyLmNsYXNzTGlzdC5hZGQocHJlZml4ICsgJy0nICsgdGhpcy5vcmllbnRhdGlvbik7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGdldCBjbGFzc1ByZWZpeCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NsYXNzUHJlZml4O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBpbmNyZW1lbnRcbiAgICAgKiBAc3VtbWFyeSBOdW1iZXIgb2Ygc2Nyb2xsYmFyIGluZGV4IHVuaXRzIHJlcHJlc2VudGluZyBhIHBhZ2VmdWwuIFVzZWQgZXhjbHVzaXZlbHkgZm9yIHBhZ2luZyB1cCBhbmQgZG93biBhbmQgZm9yIHNldHRpbmcgdGh1bWIgc2l6ZSByZWxhdGl2ZSB0byBjb250ZW50IHNpemUuXG4gICAgICogQGRlc2MgU2V0IGJ5IHRoZSBjb25zdHJ1Y3Rvci4gU2VlIHRoZSBzaW1pbGFybHkgbmFtZWQgcHJvcGVydHkgaW4gdGhlIHtAbGluayBmaW5iYXJPcHRpb25zfSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBDYW4gYWxzbyBiZSBnaXZlbiBhcyBhIHBhcmFtZXRlciB0byB0aGUge0BsaW5rIEZpbkJhciNyZXNpemV8cmVzaXplfSBtZXRob2QsIHdoaWNoIGlzIHBlcnRpbmVudCBiZWNhdXNlIGNvbnRlbnQgYXJlYSBzaXplIGNoYW5nZXMgYWZmZWN0IHRoZSBkZWZpbml0aW9uIG9mIGEgXCJwYWdlZnVsLlwiIEhvd2V2ZXIsIHlvdSBvbmx5IG5lZWQgdG8gZG8gdGhpcyBpZiB0aGlzIHZhbHVlIGlzIGJlaW5nIHVzZWQuIEl0IG5vdCB1c2VkIHdoZW46XG4gICAgICogKiB5b3UgZGVmaW5lIGBwYWdpbmcudXBgIGFuZCBgcGFnaW5nLmRvd25gXG4gICAgICogKiB5b3VyIHNjcm9sbGJhciBpcyB1c2luZyBgc2Nyb2xsUmVhbENvbnRlbnRgXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAbWVtYmVyT2YgRmluQmFyLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGluY3JlbWVudDogMSxcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIGJhclN0eWxlc1xuICAgICAqIEBzdW1tYXJ5IFNjcm9sbGJhciBzdHlsZXMgdG8gYmUgYXBwbGllZCBieSB7QGxpbmsgRmluQmFyI3Jlc2l6ZXxyZXNpemUoKX0uXG4gICAgICogQGRlc2MgU2V0IGJ5IHRoZSBjb25zdHJ1Y3Rvci4gU2VlIHRoZSBzaW1pbGFybHkgbmFtZWQgcHJvcGVydHkgaW4gdGhlIHtAbGluayBmaW5iYXJPcHRpb25zfSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBUaGlzIGlzIGEgdmFsdWUgdG8gYmUgYXNzaWduZWQgdG8ge0BsaW5rIEZpbkJhciNzdHlsZXN8c3R5bGVzfSBvbiBlYWNoIGNhbGwgdG8ge0BsaW5rIEZpbkJhciNyZXNpemV8cmVzaXplKCl9LiBUaGF0IGlzLCBhIGhhc2ggb2YgdmFsdWVzIHRvIGJlIGNvcGllZCB0byB0aGUgc2Nyb2xsYmFyIGVsZW1lbnQncyBzdHlsZSBvYmplY3Qgb24gcmVzaXplOyBvciBgbnVsbGAgZm9yIG5vbmUuXG4gICAgICpcbiAgICAgKiBAc2VlIHtAbGluayBGaW5CYXIjc3R5bGV8c3R5bGV9XG4gICAgICogQHR5cGUge2ZpbmJhclN0eWxlc3xudWxsfVxuICAgICAqIEBtZW1iZXJPZiBGaW5CYXIucHJvdG90eXBlXG4gICAgICovXG4gICAgYmFyU3R5bGVzOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgc3R5bGVcbiAgICAgKiBAc3VtbWFyeSBBZGRpdGlvbmFsIHNjcm9sbGJhciBzdHlsZXMuXG4gICAgICogQGRlc2MgU2VlIHR5cGUgZGVmaW5pdGlvbiBmb3IgbW9yZSBkZXRhaWxzLiBUaGVzZSBzdHlsZXMgYXJlIGFwcGxpZWQgZGlyZWN0bHkgdG8gdGhlIHNjcm9sbGJhcidzIGBiYXJgIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBWYWx1ZXMgYXJlIGFkanVzdGVkIGFzIGZvbGxvd3MgYmVmb3JlIGJlaW5nIGFwcGxpZWQgdG8gdGhlIGVsZW1lbnQ6XG4gICAgICogMS4gSW5jbHVkZWQgXCJwc2V1ZG8tcHJvcGVydHlcIiBuYW1lcyBmcm9tIHRoZSBzY3JvbGxiYXIncyBvcmllbnRhdGlvbiBoYXNoLCB7QGxpbmsgRmluQmFyI29ofG9ofSwgYXJlIHRyYW5zbGF0ZWQgdG8gYWN0dWFsIHByb3BlcnR5IG5hbWVzIGJlZm9yZSBiZWluZyBhcHBsaWVkLlxuICAgICAqIDIuIFdoZW4gdGhlcmUgYXJlIG1hcmdpbnMsIHBlcmNlbnRhZ2VzIGFyZSB0cmFuc2xhdGVkIHRvIGFic29sdXRlIHBpeGVsIHZhbHVlcyBiZWNhdXNlIENTUyBpZ25vcmVzIG1hcmdpbnMgaW4gaXRzIHBlcmNlbnRhZ2UgY2FsY3VsYXRpb25zLlxuICAgICAqIDMuIElmIHlvdSBnaXZlIGEgdmFsdWUgd2l0aG91dCBhIHVuaXQgKGEgcmF3IG51bWJlciksIFwicHhcIiB1bml0IGlzIGFwcGVuZGVkLlxuICAgICAqXG4gICAgICogR2VuZXJhbCBub3RlczpcbiAgICAgKiAxLiBJdCBpcyBhbHdheXMgcHJlZmVyYWJsZSB0byBzcGVjaWZ5IHN0eWxlcyB2aWEgYSBzdHlsZXNoZWV0LiBPbmx5IHNldCB0aGlzIHByb3BlcnR5IHdoZW4geW91IG5lZWQgdG8gc3BlY2lmaWNhbGx5IG92ZXJyaWRlIChhKSBzdHlsZXNoZWV0IHZhbHVlKHMpLlxuICAgICAqIDIuIENhbiBiZSBzZXQgZGlyZWN0bHkgb3IgdmlhIGNhbGxzIHRvIHRoZSB7QGxpbmsgRmluQmFyI3Jlc2l6ZXxyZXNpemV9IG1ldGhvZC5cbiAgICAgKiAzLiBTaG91bGQgb25seSBiZSBzZXQgYWZ0ZXIgdGhlIHNjcm9sbGJhciBoYXMgYmVlbiBpbnNlcnRlZCBpbnRvIHRoZSBET00uXG4gICAgICogNC4gQmVmb3JlIGFwcGx5aW5nIHRoZXNlIG5ldyB2YWx1ZXMgdG8gdGhlIGVsZW1lbnQsIF9hbGxfIGluLWxpbmUgc3R5bGUgdmFsdWVzIGFyZSByZXNldCAoYnkgcmVtb3ZpbmcgdGhlIGVsZW1lbnQncyBgc3R5bGVgIGF0dHJpYnV0ZSksIGV4cG9zaW5nIGluaGVyaXRlZCB2YWx1ZXMgKGZyb20gc3R5bGVzaGVldHMpLlxuICAgICAqIDUuIEVtcHR5IG9iamVjdCBoYXMgbm8gZWZmZWN0LlxuICAgICAqIDYuIEZhbHNleSB2YWx1ZSBpbiBwbGFjZSBvZiBvYmplY3QgaGFzIG5vIGVmZmVjdC5cbiAgICAgKlxuICAgICAqID4gQ0FWRUFUOiBEbyBub3QgYXR0ZW1wdCB0byB0cmVhdCB0aGUgb2JqZWN0IHlvdSBhc3NpZ24gdG8gdGhpcyBwcm9wZXJ0eSBhcyBpZiBpdCB3ZXJlIGB0aGlzLmJhci5zdHlsZWAuIFNwZWNpZmljYWxseSwgY2hhbmdpbmcgdGhpcyBvYmplY3QgYWZ0ZXIgYXNzaWduaW5nIGl0IHdpbGwgaGF2ZSBubyBlZmZlY3Qgb24gdGhlIHNjcm9sbGJhci4gWW91IG11c3QgYXNzaWduIGl0IGFnYWluIGlmIHlvdSB3YW50IGl0IHRvIGhhdmUgYW4gZWZmZWN0LlxuICAgICAqXG4gICAgICogQHNlZSB7QGxpbmsgRmluQmFyI2JhclN0eWxlc3xiYXJTdHlsZXN9XG4gICAgICogQHR5cGUge2ZpbmJhclN0eWxlc31cbiAgICAgKiBAbWVtYmVyT2YgRmluQmFyLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHNldCBzdHlsZShzdHlsZXMpIHtcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhzdHlsZXMgPSBleHRlbmQoe30sIHN0eWxlcywgdGhpcy5fYXV4U3R5bGVzKSk7XG5cbiAgICAgICAgaWYgKGtleXMubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgYmFyID0gdGhpcy5iYXIsXG4gICAgICAgICAgICAgICAgYmFyUmVjdCA9IGJhci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgICAgICAgICAgICBjb250YWluZXIgPSB0aGlzLmNvbnRhaW5lciB8fCBiYXIucGFyZW50RWxlbWVudCxcbiAgICAgICAgICAgICAgICBjb250YWluZXJSZWN0ID0gY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgICAgICAgICAgIG9oID0gdGhpcy5vaDtcblxuICAgICAgICAgICAgLy8gQmVmb3JlIGFwcGx5aW5nIG5ldyBzdHlsZXMsIHJldmVydCBhbGwgc3R5bGVzIHRvIHZhbHVlcyBpbmhlcml0ZWQgZnJvbSBzdHlsZXNoZWV0c1xuICAgICAgICAgICAgYmFyLnJlbW92ZUF0dHJpYnV0ZSgnc3R5bGUnKTtcblxuICAgICAgICAgICAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsID0gc3R5bGVzW2tleV07XG5cbiAgICAgICAgICAgICAgICBpZiAoa2V5IGluIG9oKSB7XG4gICAgICAgICAgICAgICAgICAgIGtleSA9IG9oW2tleV07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKCFpc05hTihOdW1iZXIodmFsKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsID0gKHZhbCB8fCAwKSArICdweCc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICgvJSQvLnRlc3QodmFsKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBXaGVuIGJhciBzaXplIGdpdmVuIGFzIHBlcmNlbnRhZ2Ugb2YgY29udGFpbmVyLCBpZiBiYXIgaGFzIG1hcmdpbnMsIHJlc3RhdGUgc2l6ZSBpbiBwaXhlbHMgbGVzcyBtYXJnaW5zLlxuICAgICAgICAgICAgICAgICAgICAvLyAoSWYgbGVmdCBhcyBwZXJjZW50YWdlLCBDU1MncyBjYWxjdWxhdGlvbiB3aWxsIG5vdCBleGNsdWRlIG1hcmdpbnMuKVxuICAgICAgICAgICAgICAgICAgICB2YXIgb3JpZW50ZWQgPSBheGlzW2tleV0sXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXJnaW5zID0gYmFyUmVjdFtvcmllbnRlZC5tYXJnaW5MZWFkaW5nXSArIGJhclJlY3Rbb3JpZW50ZWQubWFyZ2luVHJhaWxpbmddO1xuICAgICAgICAgICAgICAgICAgICBpZiAobWFyZ2lucykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gcGFyc2VJbnQodmFsLCAxMCkgLyAxMDAgKiBjb250YWluZXJSZWN0W29yaWVudGVkLnNpemVdIC0gbWFyZ2lucyArICdweCc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBiYXIuc3R5bGVba2V5XSA9IHZhbDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEByZWFkb25seVxuICAgICAqIEBuYW1lIHBhZ2luZ1xuICAgICAqIEBzdW1tYXJ5IEVuYWJsZSBwYWdlIHVwL2RuIGNsaWNrcy5cbiAgICAgKiBAZGVzYyBTZXQgYnkgdGhlIGNvbnN0cnVjdG9yLiBTZWUgdGhlIHNpbWlsYXJseSBuYW1lZCBwcm9wZXJ0eSBpbiB0aGUge0BsaW5rIGZpbmJhck9wdGlvbnN9IG9iamVjdC5cbiAgICAgKlxuICAgICAqIElmIHRydXRoeSwgbGlzdGVuIGZvciBjbGlja3MgaW4gcGFnZS11cCBhbmQgcGFnZS1kb3duIHJlZ2lvbnMgb2Ygc2Nyb2xsYmFyLlxuICAgICAqXG4gICAgICogSWYgYW4gb2JqZWN0LCBjYWxsIGAucGFnaW5nLnVwKClgIG9uIHBhZ2UtdXAgY2xpY2tzIGFuZCBgLnBhZ2luZy5kb3duKClgIHdpbGwgYmUgY2FsbGVkIG9uIHBhZ2UtZG93biBjbGlja3MuXG4gICAgICpcbiAgICAgKiBDaGFuZ2luZyB0aGUgdHJ1dGhpbmVzcyBvZiB0aGlzIHZhbHVlIGFmdGVyIGluc3RhbnRpYXRpb24gY3VycmVudGx5IGhhcyBubyBlZmZlY3QuXG4gICAgICogQHR5cGUge2Jvb2xlYW58b2JqZWN0fVxuICAgICAqIEBtZW1iZXJPZiBGaW5CYXIucHJvdG90eXBlXG4gICAgICovXG4gICAgcGFnaW5nOiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogQG5hbWUgcmFuZ2VcbiAgICAgKiBAc3VtbWFyeSBTZXR0ZXIgZm9yIHRoZSBtaW5pbXVtIGFuZCBtYXhpbXVtIHNjcm9sbCB2YWx1ZXMuXG4gICAgICogQGRlc2MgU2V0IGJ5IHRoZSBjb25zdHJ1Y3Rvci4gVGhlc2UgdmFsdWVzIGFyZSB0aGUgbGltaXRzIGZvciB7QGxpbmsgRm9vQmFyI2luZGV4fGluZGV4fS5cbiAgICAgKlxuICAgICAqIFRoZSBzZXR0ZXIgYWNjZXB0cyBhbiBvYmplY3Qgd2l0aCBleGFjdGx5IHR3byBudW1lcmljIHByb3BlcnRpZXM6IGAubWluYCB3aGljaCBtdXN0IGJlIGxlc3MgdGhhbiBgLm1heGAuIFRoZSB2YWx1ZXMgYXJlIGV4dHJhY3RlZCBhbmQgdGhlIG9iamVjdCBpcyBkaXNjYXJkZWQuXG4gICAgICpcbiAgICAgKiBUaGUgZ2V0dGVyIHJldHVybnMgYSBuZXcgb2JqZWN0IHdpdGggYC5taW5gIGFuZCAnLm1heGAuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7cmFuZ2VUeXBlfVxuICAgICAqIEBtZW1iZXJPZiBGaW5CYXIucHJvdG90eXBlXG4gICAgICovXG4gICAgc2V0IHJhbmdlKHJhbmdlKSB7XG4gICAgICAgIHZhbGlkUmFuZ2UocmFuZ2UpO1xuICAgICAgICB0aGlzLl9taW4gPSByYW5nZS5taW47XG4gICAgICAgIHRoaXMuX21heCA9IHJhbmdlLm1heDtcbiAgICAgICAgdGhpcy5jb250ZW50U2l6ZSA9IHJhbmdlLm1heCAtIHJhbmdlLm1pbiArIDE7XG4gICAgICAgIHRoaXMuaW5kZXggPSB0aGlzLmluZGV4OyAvLyByZS1jbGFtcFxuICAgIH0sXG4gICAgZ2V0IHJhbmdlKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbWluOiB0aGlzLl9taW4sXG4gICAgICAgICAgICBtYXg6IHRoaXMuX21heFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBJbmRleCB2YWx1ZSBvZiB0aGUgc2Nyb2xsYmFyLlxuICAgICAqIEBkZXNjIFRoaXMgaXMgdGhlIHBvc2l0aW9uIG9mIHRoZSBzY3JvbGwgdGh1bWIuXG4gICAgICpcbiAgICAgKiBTZXR0aW5nIHRoaXMgdmFsdWUgY2xhbXBzIGl0IHRvIHtAbGluayBGaW5CYXIjbWlufG1pbn0uLntAbGluayBGaW5CYXIjbWF4fG1heH0sIHNjcm9sbCB0aGUgY29udGVudCwgYW5kIG1vdmVzIHRodW1iLlxuICAgICAqXG4gICAgICogR2V0dGluZyB0aGlzIHZhbHVlIHJldHVybnMgdGhlIGN1cnJlbnQgaW5kZXguIFRoZSByZXR1cm5lZCB2YWx1ZSB3aWxsIGJlIGluIHRoZSByYW5nZSBgbWluYC4uYG1heGAuIEl0IGlzIGludGVudGlvbmFsbHkgbm90IHJvdW5kZWQuXG4gICAgICpcbiAgICAgKiBVc2UgdGhpcyB2YWx1ZSBhcyBhbiBhbHRlcm5hdGl2ZSB0byAob3IgaW4gYWRkaXRpb24gdG8pIHVzaW5nIHRoZSB7QGxpbmsgRmluQmFyI29uY2hhbmdlfG9uY2hhbmdlfSBjYWxsYmFjayBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBzZWUge0BsaW5rIEZpbkJhciNfc2V0U2Nyb2xsfF9zZXRTY3JvbGx9XG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAbWVtYmVyT2YgRmluQmFyLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHNldCBpbmRleChpZHgpIHtcbiAgICAgICAgaWR4ID0gTWF0aC5taW4odGhpcy5fbWF4LCBNYXRoLm1heCh0aGlzLl9taW4sIGlkeCkpOyAvLyBjbGFtcCBpdFxuICAgICAgICB0aGlzLl9zZXRTY3JvbGwoaWR4KTtcbiAgICAgICAgLy8gdGhpcy5fc2V0VGh1bWJTaXplKCk7XG4gICAgfSxcbiAgICBnZXQgaW5kZXgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pbmRleDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAc3VtbWFyeSBNb3ZlIHRoZSB0aHVtYi5cbiAgICAgKiBAZGVzYyBBbHNvIGRpc3BsYXlzIHRoZSBpbmRleCB2YWx1ZSBpbiB0aGUgdGVzdCBwYW5lbCBhbmQgaW52b2tlcyB0aGUgY2FsbGJhY2suXG4gICAgICogQHBhcmFtIGlkeCAtIFRoZSBuZXcgc2Nyb2xsIGluZGV4LCBhIHZhbHVlIGluIHRoZSByYW5nZSBgbWluYC4uYG1heGAuXG4gICAgICogQHBhcmFtIFtzY2FsZWQ9ZihpZHgpXSAtIFRoZSBuZXcgdGh1bWIgcG9zaXRpb24gaW4gcGl4ZWxzIGFuZCBzY2FsZWQgcmVsYXRpdmUgdG8gdGhlIGNvbnRhaW5pbmcge0BsaW5rIEZpbkJhciNiYXJ8YmFyfSBlbGVtZW50LCBpLmUuLCBhIHByb3BvcnRpb25hbCBudW1iZXIgaW4gdGhlIHJhbmdlIGAwYC4uYHRodW1iTWF4YC4gV2hlbiBvbWl0dGVkLCBhIGZ1bmN0aW9uIG9mIGBpZHhgIGlzIHVzZWQuXG4gICAgICogQG1lbWJlck9mIEZpbkJhci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBfc2V0U2Nyb2xsOiBmdW5jdGlvbiAoaWR4LCBzY2FsZWQpIHtcbiAgICAgICAgdGhpcy5faW5kZXggPSBpZHg7XG5cbiAgICAgICAgLy8gRGlzcGxheSB0aGUgaW5kZXggdmFsdWUgaW4gdGhlIHRlc3QgcGFuZWxcbiAgICAgICAgaWYgKHRoaXMudGVzdFBhbmVsSXRlbSAmJiB0aGlzLnRlc3RQYW5lbEl0ZW0uaW5kZXggaW5zdGFuY2VvZiBFbGVtZW50KSB7XG4gICAgICAgICAgICB0aGlzLnRlc3RQYW5lbEl0ZW0uaW5kZXguaW5uZXJIVE1MID0gTWF0aC5yb3VuZChpZHgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2FsbCB0aGUgY2FsbGJhY2tcbiAgICAgICAgaWYgKHRoaXMub25jaGFuZ2UpIHtcbiAgICAgICAgICAgIHRoaXMub25jaGFuZ2UuY2FsbCh0aGlzLCBNYXRoLnJvdW5kKGlkeCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTW92ZSB0aGUgdGh1bWJcbiAgICAgICAgaWYgKHNjYWxlZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBzY2FsZWQgPSAoaWR4IC0gdGhpcy5fbWluKSAvICh0aGlzLl9tYXggLSB0aGlzLl9taW4pICogdGhpcy5fdGh1bWJNYXg7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50aHVtYi5zdHlsZVt0aGlzLm9oLmxlYWRpbmddID0gc2NhbGVkICsgJ3B4JztcbiAgICB9LFxuXG4gICAgc2Nyb2xsUmVhbENvbnRlbnQ6IGZ1bmN0aW9uIChpZHgpIHtcbiAgICAgICAgdmFyIGNvbnRhaW5lclJlY3QgPSB0aGlzLmNvbnRlbnQucGFyZW50RWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgICAgICAgIHNpemVQcm9wID0gdGhpcy5vaC5zaXplLFxuICAgICAgICAgICAgbWF4U2Nyb2xsID0gTWF0aC5tYXgoMCwgdGhpcy5jb250ZW50W3NpemVQcm9wXSAtIGNvbnRhaW5lclJlY3Rbc2l6ZVByb3BdKSxcbiAgICAgICAgICAgIC8vc2Nyb2xsID0gTWF0aC5taW4oaWR4LCBtYXhTY3JvbGwpO1xuICAgICAgICAgICAgc2Nyb2xsID0gKGlkeCAtIHRoaXMuX21pbikgLyAodGhpcy5fbWF4IC0gdGhpcy5fbWluKSAqIG1heFNjcm9sbDtcbiAgICAgICAgLy9jb25zb2xlLmxvZygnc2Nyb2xsOiAnICsgc2Nyb2xsKTtcbiAgICAgICAgdGhpcy5jb250ZW50LnN0eWxlW3RoaXMub2gubGVhZGluZ10gPSAtc2Nyb2xsICsgJ3B4JztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgUmVjYWxjdWxhdGUgdGh1bWIgcG9zaXRpb24uXG4gICAgICpcbiAgICAgKiBAZGVzYyBUaGlzIG1ldGhvZCByZWNhbGN1bGF0ZXMgdGhlIHRodW1iIHNpemUgYW5kIHBvc2l0aW9uLiBDYWxsIGl0IG9uY2UgYWZ0ZXIgaW5zZXJ0aW5nIHlvdXIgc2Nyb2xsYmFyIGludG8gdGhlIERPTSwgYW5kIHJlcGVhdGVkbHkgd2hpbGUgcmVzaXppbmcgdGhlIHNjcm9sbGJhciAod2hpY2ggdHlwaWNhbGx5IGhhcHBlbnMgd2hlbiB0aGUgc2Nyb2xsYmFyJ3MgcGFyZW50IGlzIHJlc2l6ZWQgYnkgdXNlci5cbiAgICAgKlxuICAgICAqID4gVGhpcyBmdW5jdGlvbiBzaGlmdHMgYXJncyBpZiBmaXJzdCBhcmcgb21pdHRlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbaW5jcmVtZW50PXRoaXMuaW5jcmVtZW50XSAtIFJlc2V0cyB7QGxpbmsgRm9vQmFyI2luY3JlbWVudHxpbmNyZW1lbnR9IChzZWUpLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtmaW5iYXJTdHlsZXN9IFtiYXJTdHlsZXM9dGhpcy5iYXJTdHlsZXNdIC0gKFNlZSB0eXBlIGRlZmluaXRpb24gZm9yIGRldGFpbHMuKSBTY3JvbGxiYXIgc3R5bGVzIHRvIGJlIGFwcGxpZWQgdG8gdGhlIGJhciBlbGVtZW50LlxuICAgICAqXG4gICAgICogT25seSBzcGVjaWZ5IGEgYGJhclN0eWxlc2Agb2JqZWN0IHdoZW4geW91IG5lZWQgdG8gb3ZlcnJpZGUgc3R5bGVzaGVldCB2YWx1ZXMuIElmIHByb3ZpZGVkLCBiZWNvbWVzIHRoZSBuZXcgZGVmYXVsdCAoYHRoaXMuYmFyU3R5bGVzYCksIGZvciB1c2UgYXMgYSBkZWZhdWx0IG9uIHN1YnNlcXVlbnQgY2FsbHMuXG4gICAgICpcbiAgICAgKiBJdCBpcyBnZW5lcmFsbHkgdGhlIGNhc2UgdGhhdCB0aGUgc2Nyb2xsYmFyJ3MgbmV3IHBvc2l0aW9uIGlzIHN1ZmZpY2llbnRseSBkZXNjcmliZWQgYnkgdGhlIGN1cnJlbnQgc3R5bGVzLiBUaGVyZWZvcmUsIGl0IGlzIHVudXN1YWwgdG8gbmVlZCB0byBwcm92aWRlIGEgYGJhclN0eWxlc2Agb2JqZWN0IG9uIGV2ZXJ5IGNhbGwgdG8gYHJlc2l6ZWAuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7RmluQmFyfSBTZWxmIGZvciBjaGFpbmluZy5cbiAgICAgKiBAbWVtYmVyT2YgRmluQmFyLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHJlc2l6ZTogZnVuY3Rpb24gKGluY3JlbWVudCwgYmFyU3R5bGVzKSB7XG4gICAgICAgIHZhciBiYXIgPSB0aGlzLmJhcjtcblxuICAgICAgICBpZiAoIWJhci5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICByZXR1cm47IC8vIG5vdCBpbiBET00geWV0IHNvIG5vdGhpbmcgdG8gZG9cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjb250YWluZXIgPSB0aGlzLmNvbnRhaW5lciB8fCBiYXIucGFyZW50RWxlbWVudCxcbiAgICAgICAgICAgIGNvbnRhaW5lclJlY3QgPSBjb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICAgICAgLy8gc2hpZnQgYXJncyBpZiBpZiAxc3QgYXJnIG9taXR0ZWRcbiAgICAgICAgaWYgKHR5cGVvZiBpbmNyZW1lbnQgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBiYXJTdHlsZXMgPSBpbmNyZW1lbnQ7XG4gICAgICAgICAgICBpbmNyZW1lbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnN0eWxlID0gdGhpcy5iYXJTdHlsZXMgPSBiYXJTdHlsZXMgfHwgdGhpcy5iYXJTdHlsZXM7XG5cbiAgICAgICAgLy8gQm91bmQgdG8gcmVhbCBjb250ZW50OiBDb250ZW50IHdhcyBnaXZlbiBidXQgbm8gb25jaGFuZ2UgaGFuZGxlci5cbiAgICAgICAgLy8gU2V0IHVwIC5vbmNoYW5nZSwgLmNvbnRhaW5lclNpemUsIGFuZCAuaW5jcmVtZW50LlxuICAgICAgICAvLyBOb3RlIHRoaXMgb25seSBtYWtlcyBzZW5zZSBpZiB5b3VyIGluZGV4IHVuaXQgaXMgcGl4ZWxzLlxuICAgICAgICBpZiAodGhpcy5jb250ZW50KSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMub25jaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uY2hhbmdlID0gdGhpcy5zY3JvbGxSZWFsQ29udGVudDtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRlbnRTaXplID0gdGhpcy5jb250ZW50W3RoaXMub2guc2l6ZV07XG4gICAgICAgICAgICAgICAgdGhpcy5fbWluID0gMDtcbiAgICAgICAgICAgICAgICB0aGlzLl9tYXggPSB0aGlzLmNvbnRlbnRTaXplIC0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vbmNoYW5nZSA9PT0gdGhpcy5zY3JvbGxSZWFsQ29udGVudCkge1xuICAgICAgICAgICAgdGhpcy5jb250YWluZXJTaXplID0gY29udGFpbmVyUmVjdFt0aGlzLm9oLnNpemVdO1xuICAgICAgICAgICAgdGhpcy5pbmNyZW1lbnQgPSB0aGlzLmNvbnRhaW5lclNpemUgLyAodGhpcy5jb250ZW50U2l6ZSAtIHRoaXMuY29udGFpbmVyU2l6ZSkgKiAodGhpcy5fbWF4IC0gdGhpcy5fbWluKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY29udGFpbmVyU2l6ZSA9IDE7XG4gICAgICAgICAgICB0aGlzLmluY3JlbWVudCA9IGluY3JlbWVudCB8fCB0aGlzLmluY3JlbWVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpbmRleCA9IHRoaXMuaW5kZXg7XG4gICAgICAgIHRoaXMudGVzdFBhbmVsSXRlbSA9IHRoaXMudGVzdFBhbmVsSXRlbSB8fCB0aGlzLl9hZGRUZXN0UGFuZWxJdGVtKCk7XG4gICAgICAgIHRoaXMuX3NldFRodW1iU2l6ZSgpO1xuICAgICAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG5cbiAgICAgICAgaWYgKHRoaXMuZGVsdGFQcm9wICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcignd2hlZWwnLCB0aGlzLl9ib3VuZC5vbndoZWVsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBTaG9ydGVuIHRyYWlsaW5nIGVuZCBvZiBzY3JvbGxiYXIgYnkgdGhpY2tuZXNzIG9mIHNvbWUgb3RoZXIgc2Nyb2xsYmFyLlxuICAgICAqIEBkZXNjIEluIHRoZSBcImNsYXNzaWNhbFwiIHNjZW5hcmlvIHdoZXJlIHZlcnRpY2FsIHNjcm9sbCBiYXIgaXMgb24gdGhlIHJpZ2h0IGFuZCBob3Jpem9udGFsIHNjcm9sbGJhciBpcyBvbiB0aGUgYm90dG9tLCB5b3Ugd2FudCB0byBzaG9ydGVuIHRoZSBcInRyYWlsaW5nIGVuZFwiIChib3R0b20gYW5kIHJpZ2h0IGVuZHMsIHJlc3BlY3RpdmVseSkgb2YgYXQgbGVhc3Qgb25lIG9mIHRoZW0gc28gdGhleSBkb24ndCBvdmVybGF5LlxuICAgICAqXG4gICAgICogVGhpcyBjb252ZW5pZW5jZSBmdW5jdGlvbiBpcyBhbiBwcm9ncmFtbWF0aWMgYWx0ZXJuYXRpdmUgdG8gaGFyZGNvZGluZyB0aGUgY29ycmVjdCBzdHlsZSB3aXRoIHRoZSBjb3JyZWN0IHZhbHVlIGluIHlvdXIgc3R5bGVzaGVldDsgb3Igc2V0dGluZyB0aGUgY29ycmVjdCBzdHlsZSB3aXRoIHRoZSBjb3JyZWN0IHZhbHVlIGluIHRoZSB7QGxpbmsgRmluQmFyI2JhclN0eWxlc3xiYXJTdHlsZXN9IG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzZWUge0BsaW5rIEZpbkJhciNmb3Jlc2hvcnRlbkJ5fGZvcmVzaG9ydGVuQnl9LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtGaW5CYXJ8bnVsbH0gb3RoZXJGaW5CYXIgLSBPdGhlciBzY3JvbGxiYXIgdG8gYXZvaWQgYnkgc2hvcnRlbmluZyB0aGlzIG9uZTsgYG51bGxgIHJlbW92ZXMgdGhlIHRyYWlsaW5nIHNwYWNlXG4gICAgICogQHJldHVybnMge0ZpbkJhcn0gRm9yIGNoYWluaW5nXG4gICAgICovXG4gICAgc2hvcnRlbkJ5OiBmdW5jdGlvbiAob3RoZXJGaW5CYXIpIHsgcmV0dXJuIHRoaXMuc2hvcnRlbkVuZEJ5KCd0cmFpbGluZycsIG90aGVyRmluQmFyKTsgfSxcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IFNob3J0ZW4gbGVhZGluZyBlbmQgb2Ygc2Nyb2xsYmFyIGJ5IHRoaWNrbmVzcyBvZiBzb21lIG90aGVyIHNjcm9sbGJhci5cbiAgICAgKiBAZGVzYyBTdXBwb3J0cyBub24tY2xhc3NpY2FsIHNjcm9sbGJhciBzY2VuYXJpb3Mgd2hlcmUgdmVydGljYWwgc2Nyb2xsIGJhciBtYXkgYmUgb24gbGVmdCBhbmQgaG9yaXpvbnRhbCBzY3JvbGxiYXIgbWF5IGJlIG9uIHRvcCwgaW4gd2hpY2ggY2FzZSB5b3Ugd2FudCB0byBzaG9ydGVuIHRoZSBcImxlYWRpbmcgZW5kXCIgcmF0aGVyIHRoYW4gdGhlIHRyYWlsaW5nIGVuZC5cbiAgICAgKiBAc2VlIHtAbGluayBGaW5CYXIjc2hvcnRlbkJ5fHNob3J0ZW5CeX0uXG4gICAgICogQHBhcmFtIHtGaW5CYXJ8bnVsbH0gb3RoZXJGaW5CYXIgLSBPdGhlciBzY3JvbGxiYXIgdG8gYXZvaWQgYnkgc2hvcnRlbmluZyB0aGlzIG9uZTsgYG51bGxgIHJlbW92ZXMgdGhlIHRyYWlsaW5nIHNwYWNlXG4gICAgICogQHJldHVybnMge0ZpbkJhcn0gRm9yIGNoYWluaW5nXG4gICAgICovXG4gICAgZm9yZXNob3J0ZW5CeTogZnVuY3Rpb24gKG90aGVyRmluQmFyKSB7IHJldHVybiB0aGlzLnNob3J0ZW5FbmRCeSgnbGVhZGluZycsIG90aGVyRmluQmFyKTsgfSxcblxuICAgIC8qKlxuICAgICAqIEBzdW1tYXJ5IEdlbmVyYWxpemVkIHNob3J0ZW5pbmcgZnVuY3Rpb24uXG4gICAgICogQHNlZSB7QGxpbmsgRmluQmFyI3Nob3J0ZW5CeXxzaG9ydGVuQnl9LlxuICAgICAqIEBzZWUge0BsaW5rIEZpbkJhciNmb3Jlc2hvcnRlbkJ5fGZvcmVzaG9ydGVuQnl9LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB3aGljaEVuZCAtIGEgQ1NTIHN0eWxlIHByb3BlcnR5IG5hbWUgb3IgYW4gb3JpZW50YXRpb24gaGFzaCBuYW1lIHRoYXQgdHJhbnNsYXRlcyB0byBhIENTUyBzdHlsZSBwcm9wZXJ0eSBuYW1lLlxuICAgICAqIEBwYXJhbSB7RmluQmFyfG51bGx9IG90aGVyRmluQmFyIC0gT3RoZXIgc2Nyb2xsYmFyIHRvIGF2b2lkIGJ5IHNob3J0ZW5pbmcgdGhpcyBvbmU7IGBudWxsYCByZW1vdmVzIHRoZSB0cmFpbGluZyBzcGFjZVxuICAgICAqIEByZXR1cm5zIHtGaW5CYXJ9IEZvciBjaGFpbmluZ1xuICAgICAqL1xuICAgIHNob3J0ZW5FbmRCeTogZnVuY3Rpb24gKHdoaWNoRW5kLCBvdGhlckZpbkJhcikge1xuICAgICAgICBpZiAoIW90aGVyRmluQmFyKSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fYXV4U3R5bGVzO1xuICAgICAgICB9IGVsc2UgaWYgKG90aGVyRmluQmFyIGluc3RhbmNlb2YgRmluQmFyICYmIG90aGVyRmluQmFyLm9yaWVudGF0aW9uICE9PSB0aGlzLm9yaWVudGF0aW9uKSB7XG4gICAgICAgICAgICB2YXIgb3RoZXJTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKG90aGVyRmluQmFyLmJhciksXG4gICAgICAgICAgICAgICAgb29oID0gb3JpZW50YXRpb25IYXNoZXNbb3RoZXJGaW5CYXIub3JpZW50YXRpb25dO1xuICAgICAgICAgICAgdGhpcy5fYXV4U3R5bGVzID0ge307XG4gICAgICAgICAgICB0aGlzLl9hdXhTdHlsZXNbd2hpY2hFbmRdID0gb3RoZXJTdHlsZVtvb2gudGhpY2tuZXNzXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpczsgLy8gZm9yIGNoYWluaW5nXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHN1bW1hcnkgU2V0cyB0aGUgcHJvcG9ydGlvbmFsIHRodW1iIHNpemUgYW5kIGhpZGVzIHRodW1iIHdoZW4gMTAwJS5cbiAgICAgKiBAZGVzYyBUaGUgdGh1bWIgc2l6ZSBoYXMgYW4gYWJzb2x1dGUgbWluaW11bSBvZiAyMCAocGl4ZWxzKS5cbiAgICAgKiBAbWVtYmVyT2YgRmluQmFyLnByb3RvdHlwZVxuICAgICAqL1xuICAgIF9zZXRUaHVtYlNpemU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG9oID0gdGhpcy5vaCxcbiAgICAgICAgICAgIHRodW1iQ29tcCA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRoaXMudGh1bWIpLFxuICAgICAgICAgICAgdGh1bWJNYXJnaW5MZWFkaW5nID0gcGFyc2VJbnQodGh1bWJDb21wW29oLm1hcmdpbkxlYWRpbmddKSxcbiAgICAgICAgICAgIHRodW1iTWFyZ2luVHJhaWxpbmcgPSBwYXJzZUludCh0aHVtYkNvbXBbb2gubWFyZ2luVHJhaWxpbmddKSxcbiAgICAgICAgICAgIHRodW1iTWFyZ2lucyA9IHRodW1iTWFyZ2luTGVhZGluZyArIHRodW1iTWFyZ2luVHJhaWxpbmcsXG4gICAgICAgICAgICBiYXJTaXplID0gdGhpcy5iYXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClbb2guc2l6ZV0sXG4gICAgICAgICAgICB0aHVtYlNpemUgPSBNYXRoLm1heCgyMCwgYmFyU2l6ZSAqIHRoaXMuY29udGFpbmVyU2l6ZSAvIHRoaXMuY29udGVudFNpemUpO1xuXG4gICAgICAgIGlmICh0aGlzLmNvbnRhaW5lclNpemUgPCB0aGlzLmNvbnRlbnRTaXplKSB7XG4gICAgICAgICAgICB0aGlzLmJhci5zdHlsZS52aXNpYmlsaXR5ID0gJ3Zpc2libGUnO1xuICAgICAgICAgICAgdGhpcy50aHVtYi5zdHlsZVtvaC5zaXplXSA9IHRodW1iU2l6ZSArICdweCc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmJhci5zdHlsZS52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICogQG5hbWUgX3RodW1iTWF4XG4gICAgICAgICAqIEBzdW1tYXJ5IE1heGltdW0gb2Zmc2V0IG9mIHRodW1iJ3MgbGVhZGluZyBlZGdlLlxuICAgICAgICAgKiBAZGVzYyBUaGlzIGlzIHRoZSBwaXhlbCBvZmZzZXQgd2l0aGluIHRoZSBzY3JvbGxiYXIgb2YgdGhlIHRodW1iIHdoZW4gaXQgaXMgYXQgaXRzIG1heGltdW0gcG9zaXRpb24gYXQgdGhlIGV4dHJlbWUgZW5kIG9mIGl0cyByYW5nZS5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyB2YWx1ZSB0YWtlcyBpbnRvIGFjY291bnQgdGhlIG5ld2x5IGNhbGN1bGF0ZWQgc2l6ZSBvZiB0aGUgdGh1bWIgZWxlbWVudCAoaW5jbHVkaW5nIGl0cyBtYXJnaW5zKSBhbmQgdGhlIGlubmVyIHNpemUgb2YgdGhlIHNjcm9sbGJhciAodGhlIHRodW1iJ3MgY29udGFpbmluZyBlbGVtZW50LCBpbmNsdWRpbmcgX2l0c18gbWFyZ2lucykuXG4gICAgICAgICAqXG4gICAgICAgICAqIE5PVEU6IFNjcm9sbGJhciBwYWRkaW5nIGlzIG5vdCB0YWtlbiBpbnRvIGFjY291bnQgYW5kIGFzc3VtZWQgdG8gYmUgMCBpbiB0aGUgY3VycmVudCBpbXBsZW1lbnRhdGlvbiBhbmQgaXMgYXNzdW1lZCB0byBiZSBgMGA7IHVzZSB0aHVtYiBtYXJnaW5zIGluIHBsYWNlIG9mIHNjcm9sbGJhciBwYWRkaW5nLlxuICAgICAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAgICAgKiBAbWVtYmVyT2YgRmluQmFyLnByb3RvdHlwZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5fdGh1bWJNYXggPSBiYXJTaXplIC0gdGh1bWJTaXplIC0gdGh1bWJNYXJnaW5zO1xuXG4gICAgICAgIHRoaXMuX3RodW1iTWFyZ2luTGVhZGluZyA9IHRodW1iTWFyZ2luTGVhZGluZzsgLy8gdXNlZCBpbiBtb3VzZWRvd25cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgUmVtb3ZlIHRoZSBzY3JvbGxiYXIuXG4gICAgICogQGRlc2MgVW5ob29rcyBhbGwgdGhlIGV2ZW50IGhhbmRsZXJzIGFuZCB0aGVuIHJlbW92ZXMgdGhlIGVsZW1lbnQgZnJvbSB0aGUgRE9NLiBBbHdheXMgY2FsbCB0aGlzIG1ldGhvZCBwcmlvciB0byBkaXNwb3Npbmcgb2YgdGhlIHNjcm9sbGJhciBvYmplY3QuXG4gICAgICogQG1lbWJlck9mIEZpbkJhci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICByZW1vdmU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fcmVtb3ZlRXZ0KCdtb3VzZWRvd24nKTtcbiAgICAgICAgdGhpcy5fcmVtb3ZlRXZ0KCdtb3VzZW1vdmUnKTtcbiAgICAgICAgdGhpcy5fcmVtb3ZlRXZ0KCdtb3VzZXVwJyk7XG5cbiAgICAgICAgKHRoaXMuY29udGFpbmVyIHx8IHRoaXMuYmFyLnBhcmVudEVsZW1lbnQpLl9yZW1vdmVFdnQoJ3doZWVsJywgdGhpcy5fYm91bmQub253aGVlbCk7XG5cbiAgICAgICAgdGhpcy5iYXIub25jbGljayA9XG4gICAgICAgICAgICB0aGlzLnRodW1iLm9uY2xpY2sgPVxuICAgICAgICAgICAgICAgIHRoaXMudGh1bWIub25tb3VzZW92ZXIgPVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnRodW1iLnRyYW5zaXRpb25lbmQgPVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy50aHVtYi5vbm1vdXNlb3V0ID0gbnVsbDtcblxuICAgICAgICB0aGlzLmJhci5yZW1vdmUoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAZnVuY3Rpb24gX2FkZFRlc3RQYW5lbEl0ZW1cbiAgICAgKiBAc3VtbWFyeSBBcHBlbmQgYSB0ZXN0IHBhbmVsIGVsZW1lbnQuXG4gICAgICogQGRlc2MgSWYgdGhlcmUgaXMgYSB0ZXN0IHBhbmVsIGluIHRoZSBET00gKHR5cGljYWxseSBhbiBgPG9sPi4uLjwvb2w+YCBlbGVtZW50KSB3aXRoIGNsYXNzIG5hbWVzIG9mIGJvdGggYHRoaXMuY2xhc3NQcmVmaXhgIGFuZCBgJ3Rlc3QtcGFuZWwnYCAob3IsIGJhcnJpbmcgdGhhdCwgYW55IGVsZW1lbnQgd2l0aCBjbGFzcyBuYW1lIGAndGVzdC1wYW5lbCdgKSwgYW4gYDxsaT4uLi48L2xpPmAgZWxlbWVudCB3aWxsIGJlIGNyZWF0ZWQgYW5kIGFwcGVuZGVkIHRvIGl0LiBUaGlzIG5ldyBlbGVtZW50IHdpbGwgY29udGFpbiBhIHNwYW4gZm9yIGVhY2ggY2xhc3MgbmFtZSBnaXZlbi5cbiAgICAgKlxuICAgICAqIFlvdSBzaG91bGQgZGVmaW5lIGEgQ1NTIHNlbGVjdG9yIGAubGlzdGVuaW5nYCBmb3IgdGhlc2Ugc3BhbnMuIFRoaXMgY2xhc3Mgd2lsbCBiZSBhZGRlZCB0byB0aGUgc3BhbnMgdG8gYWx0ZXIgdGhlaXIgYXBwZWFyYW5jZSB3aGVuIGEgbGlzdGVuZXIgaXMgYWRkZWQgd2l0aCB0aGF0IGNsYXNzIG5hbWUgKHByZWZpeGVkIHdpdGggJ29uJykuXG4gICAgICpcbiAgICAgKiAoVGhpcyBpcyBhbiBpbnRlcm5hbCBmdW5jdGlvbiB0aGF0IGlzIGNhbGxlZCBvbmNlIGJ5IHRoZSBjb25zdHJ1Y3RvciBvbiBldmVyeSBpbnN0YW50aWF0aW9uLilcbiAgICAgKiBAcmV0dXJucyB7RWxlbWVudHx1bmRlZmluZWR9IFRoZSBhcHBlbmRlZCBgPGxpPi4uLjwvbGk+YCBlbGVtZW50IG9yIGB1bmRlZmluZWRgIGlmIHRoZXJlIGlzIG5vIHRlc3QgcGFuZWwuXG4gICAgICogQG1lbWJlck9mIEZpbkJhci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBfYWRkVGVzdFBhbmVsSXRlbTogZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdGVzdFBhbmVsSXRlbSxcbiAgICAgICAgICAgIHRlc3RQYW5lbEVsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuJyArIHRoaXMuX2NsYXNzUHJlZml4ICsgJy50ZXN0LXBhbmVsJykgfHwgZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLnRlc3QtcGFuZWwnKTtcblxuICAgICAgICBpZiAodGVzdFBhbmVsRWxlbWVudCkge1xuICAgICAgICAgICAgdmFyIHRlc3RQYW5lbEl0ZW1QYXJ0TmFtZXMgPSBbICdtb3VzZWRvd24nLCAnbW91c2Vtb3ZlJywgJ21vdXNldXAnLCAnaW5kZXgnIF0sXG4gICAgICAgICAgICAgICAgaXRlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xpJyk7XG5cbiAgICAgICAgICAgIHRlc3RQYW5lbEl0ZW1QYXJ0TmFtZXMuZm9yRWFjaChmdW5jdGlvbiAocGFydE5hbWUpIHtcbiAgICAgICAgICAgICAgICBpdGVtLmlubmVySFRNTCArPSAnPHNwYW4gY2xhc3M9XCInICsgcGFydE5hbWUgKyAnXCI+JyArIHBhcnROYW1lLnJlcGxhY2UoJ21vdXNlJywgJycpICsgJzwvc3Bhbj4nO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHRlc3RQYW5lbEVsZW1lbnQuYXBwZW5kQ2hpbGQoaXRlbSk7XG5cbiAgICAgICAgICAgIHRlc3RQYW5lbEl0ZW0gPSB7fTtcbiAgICAgICAgICAgIHRlc3RQYW5lbEl0ZW1QYXJ0TmFtZXMuZm9yRWFjaChmdW5jdGlvbiAocGFydE5hbWUpIHtcbiAgICAgICAgICAgICAgICB0ZXN0UGFuZWxJdGVtW3BhcnROYW1lXSA9IGl0ZW0uZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShwYXJ0TmFtZSlbMF07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0ZXN0UGFuZWxJdGVtO1xuICAgIH0sXG5cbiAgICBfYWRkRXZ0OiBmdW5jdGlvbiAoZXZ0TmFtZSkge1xuICAgICAgICB2YXIgc3B5ID0gdGhpcy50ZXN0UGFuZWxJdGVtICYmIHRoaXMudGVzdFBhbmVsSXRlbVtldnROYW1lXTtcbiAgICAgICAgaWYgKHNweSkgeyBzcHkuY2xhc3NMaXN0LmFkZCgnbGlzdGVuaW5nJyk7IH1cbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoZXZ0TmFtZSwgdGhpcy5fYm91bmRbJ29uJyArIGV2dE5hbWVdKTtcbiAgICB9LFxuXG4gICAgX3JlbW92ZUV2dDogZnVuY3Rpb24gKGV2dE5hbWUpIHtcbiAgICAgICAgdmFyIHNweSA9IHRoaXMudGVzdFBhbmVsSXRlbSAmJiB0aGlzLnRlc3RQYW5lbEl0ZW1bZXZ0TmFtZV07XG4gICAgICAgIGlmIChzcHkpIHsgc3B5LmNsYXNzTGlzdC5yZW1vdmUoJ2xpc3RlbmluZycpOyB9XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKGV2dE5hbWUsIHRoaXMuX2JvdW5kWydvbicgKyBldnROYW1lXSk7XG4gICAgfVxufTtcblxuZnVuY3Rpb24gZXh0ZW5kKG9iaikge1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBvYmpuID0gYXJndW1lbnRzW2ldO1xuICAgICAgICBpZiAob2Jqbikge1xuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIG9iam4pIHtcbiAgICAgICAgICAgICAgICBvYmpba2V5XSA9IG9iam5ba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqO1xufVxuXG5mdW5jdGlvbiB2YWxpZFJhbmdlKHJhbmdlKSB7XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhyYW5nZSksXG4gICAgICAgIHZhbGlkID0gIGtleXMubGVuZ3RoID09PSAyICYmXG4gICAgICAgICAgICB0eXBlb2YgcmFuZ2UubWluID09PSAnbnVtYmVyJyAmJlxuICAgICAgICAgICAgdHlwZW9mIHJhbmdlLm1heCA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgICAgIHJhbmdlLm1pbiA8PSByYW5nZS5tYXg7XG5cbiAgICBpZiAoIXZhbGlkKSB7XG4gICAgICAgIGVycm9yKCdJbnZhbGlkIC5yYW5nZSBvYmplY3QuJyk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBwcml2YXRlXG4gKiBAbmFtZSBoYW5kbGVyc1RvQmVCb3VuZFxuICogQHR5cGUge29iamVjdH1cbiAqIEBkZXNjIFRoZSBmdW5jdGlvbnMgZGVmaW5lZCBpbiB0aGlzIG9iamVjdCBhcmUgYWxsIERPTSBldmVudCBoYW5kbGVycyB0aGF0IGFyZSBib3VuZCBieSB0aGUgRmluQmFyIGNvbnN0cnVjdG9yIHRvIGVhY2ggbmV3IGluc3RhbmNlLiBJbiBvdGhlciB3b3JkcywgdGhlIGB0aGlzYCB2YWx1ZSBvZiB0aGVzZSBoYW5kbGVycywgb25jZSBib3VuZCwgcmVmZXIgdG8gdGhlIEZpbkJhciBvYmplY3QgYW5kIG5vdCB0byB0aGUgZXZlbnQgZW1pdHRlci4gXCJEbyBub3QgY29uc3VtZSByYXcuXCJcbiAqL1xudmFyIGhhbmRsZXJzVG9CZUJvdW5kID0ge1xuICAgIHNob3J0U3RvcDogZnVuY3Rpb24gKGV2dCkge1xuICAgICAgICBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfSxcblxuICAgIG9ud2hlZWw6IGZ1bmN0aW9uIChldnQpIHtcbiAgICAgICAgdGhpcy5pbmRleCArPSBldnRbdGhpcy5kZWx0YVByb3BdO1xuICAgICAgICBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH0sXG5cbiAgICBvbmNsaWNrOiBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICAgIHZhciB0aHVtYkJveCA9IHRoaXMudGh1bWIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICAgICAgICBnb2luZ1VwID0gZXZ0W3RoaXMub2guY29vcmRpbmF0ZV0gPCB0aHVtYkJveFt0aGlzLm9oLmxlYWRpbmddO1xuXG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5wYWdpbmcgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICB0aGlzLmluZGV4ID0gdGhpcy5wYWdpbmdbZ29pbmdVcCA/ICd1cCcgOiAnZG93biddKE1hdGgucm91bmQodGhpcy5pbmRleCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5pbmRleCArPSBnb2luZ1VwID8gLXRoaXMuaW5jcmVtZW50IDogdGhpcy5pbmNyZW1lbnQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBtYWtlIHRoZSB0aHVtYiBnbG93IG1vbWVudGFyaWx5XG4gICAgICAgIHRoaXMudGh1bWIuY2xhc3NMaXN0LmFkZCgnaG92ZXInKTtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB0aGlzLnRodW1iLmFkZEV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCBmdW5jdGlvbiB3YWl0Rm9ySXQoKSB7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCB3YWl0Rm9ySXQpO1xuICAgICAgICAgICAgc2VsZi5fYm91bmQub25tb3VzZXVwKGV2dCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGV2dC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICB9LFxuXG4gICAgb25tb3VzZW92ZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy50aHVtYi5jbGFzc0xpc3QuYWRkKCdob3ZlcicpO1xuICAgICAgICB0aGlzLnRodW1iLm9ubW91c2VvdXQgPSB0aGlzLl9ib3VuZC5vbm1vdXNlb3V0O1xuICAgICAgICB0aGlzLl9hZGRFdnQoJ21vdXNlZG93bicpO1xuICAgIH0sXG5cbiAgICBvbm1vdXNlb3V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX3JlbW92ZUV2dCgnbW91c2Vkb3duJyk7XG4gICAgICAgIHRoaXMudGh1bWIub25tb3VzZW92ZXIgPSB0aGlzLl9ib3VuZC5vbm1vdXNlb3ZlcjtcbiAgICAgICAgdGhpcy50aHVtYi5jbGFzc0xpc3QucmVtb3ZlKCdob3ZlcicpO1xuICAgIH0sXG5cbiAgICBvbm1vdXNlZG93bjogZnVuY3Rpb24gKGV2dCkge1xuICAgICAgICB0aGlzLl9yZW1vdmVFdnQoJ21vdXNlZG93bicpO1xuICAgICAgICB0aGlzLnRodW1iLm9ubW91c2VvdmVyID0gdGhpcy50aHVtYi5vbm1vdXNlb3V0ID0gbnVsbDtcblxuICAgICAgICB2YXIgdGh1bWJCb3ggPSB0aGlzLnRodW1iLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICB0aGlzLnBpbk9mZnNldCA9IGV2dFt0aGlzLm9oLmF4aXNdIC0gdGh1bWJCb3hbdGhpcy5vaC5sZWFkaW5nXSArIHRoaXMuYmFyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpW3RoaXMub2gubGVhZGluZ10gKyB0aGlzLl90aHVtYk1hcmdpbkxlYWRpbmc7XG4gICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5jdXJzb3IgPSAnZGVmYXVsdCc7XG5cbiAgICAgICAgdGhpcy5fYWRkRXZ0KCdtb3VzZW1vdmUnKTtcbiAgICAgICAgdGhpcy5fYWRkRXZ0KCdtb3VzZXVwJyk7XG5cbiAgICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9LFxuXG4gICAgb25tb3VzZW1vdmU6IGZ1bmN0aW9uIChldnQpIHtcbiAgICAgICAgdmFyIHNjYWxlZCA9IE1hdGgubWluKHRoaXMuX3RodW1iTWF4LCBNYXRoLm1heCgwLCBldnRbdGhpcy5vaC5heGlzXSAtIHRoaXMucGluT2Zmc2V0KSk7XG4gICAgICAgIHZhciBpZHggPSBzY2FsZWQgLyB0aGlzLl90aHVtYk1heCAqICh0aGlzLl9tYXggLSB0aGlzLl9taW4pICsgdGhpcy5fbWluO1xuXG4gICAgICAgIHRoaXMuX3NldFNjcm9sbChpZHgsIHNjYWxlZCk7XG5cbiAgICAgICAgZXZ0LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9LFxuXG4gICAgb25tb3VzZXVwOiBmdW5jdGlvbiAoZXZ0KSB7XG4gICAgICAgIHRoaXMuX3JlbW92ZUV2dCgnbW91c2Vtb3ZlJyk7XG4gICAgICAgIHRoaXMuX3JlbW92ZUV2dCgnbW91c2V1cCcpO1xuXG4gICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5jdXJzb3IgPSAnYXV0byc7XG5cbiAgICAgICAgdmFyIHRodW1iQm94ID0gdGhpcy50aHVtYi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgdGh1bWJCb3gubGVmdCA8PSBldnQuY2xpZW50WCAmJiBldnQuY2xpZW50WCA8PSB0aHVtYkJveC5yaWdodCAmJlxuICAgICAgICAgICAgdGh1bWJCb3gudG9wIDw9IGV2dC5jbGllbnRZICYmIGV2dC5jbGllbnRZIDw9IHRodW1iQm94LmJvdHRvbVxuICAgICAgICApIHtcbiAgICAgICAgICAgIHRoaXMuX2JvdW5kLm9ubW91c2VvdmVyKGV2dCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9ib3VuZC5vbm1vdXNlb3V0KGV2dCk7XG4gICAgICAgIH1cblxuICAgICAgICBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbn07XG5cbnZhciBvcmllbnRhdGlvbkhhc2hlcyA9IHtcbiAgICB2ZXJ0aWNhbDoge1xuICAgICAgICBjb29yZGluYXRlOiAgICAgJ2NsaWVudFknLFxuICAgICAgICBheGlzOiAgICAgICAgICAgJ3BhZ2VZJyxcbiAgICAgICAgc2l6ZTogICAgICAgICAgICdoZWlnaHQnLFxuICAgICAgICBvdXRzaWRlOiAgICAgICAgJ3JpZ2h0JyxcbiAgICAgICAgaW5zaWRlOiAgICAgICAgICdsZWZ0JyxcbiAgICAgICAgbGVhZGluZzogICAgICAgICd0b3AnLFxuICAgICAgICB0cmFpbGluZzogICAgICAgJ2JvdHRvbScsXG4gICAgICAgIG1hcmdpbkxlYWRpbmc6ICAnbWFyZ2luVG9wJyxcbiAgICAgICAgbWFyZ2luVHJhaWxpbmc6ICdtYXJnaW5Cb3R0b20nLFxuICAgICAgICB0aGlja25lc3M6ICAgICAgJ3dpZHRoJyxcbiAgICAgICAgZGVsdGE6ICAgICAgICAgICdkZWx0YVknXG4gICAgfSxcbiAgICBob3Jpem9udGFsOiB7XG4gICAgICAgIGNvb3JkaW5hdGU6ICAgICAnY2xpZW50WCcsXG4gICAgICAgIGF4aXM6ICAgICAgICAgICAncGFnZVgnLFxuICAgICAgICBzaXplOiAgICAgICAgICAgJ3dpZHRoJyxcbiAgICAgICAgb3V0c2lkZTogICAgICAgICdib3R0b20nLFxuICAgICAgICBpbnNpZGU6ICAgICAgICAgJ3RvcCcsXG4gICAgICAgIGxlYWRpbmc6ICAgICAgICAnbGVmdCcsXG4gICAgICAgIHRyYWlsaW5nOiAgICAgICAncmlnaHQnLFxuICAgICAgICBtYXJnaW5MZWFkaW5nOiAgJ21hcmdpbkxlZnQnLFxuICAgICAgICBtYXJnaW5UcmFpbGluZzogJ21hcmdpblJpZ2h0JyxcbiAgICAgICAgdGhpY2tuZXNzOiAgICAgICdoZWlnaHQnLFxuICAgICAgICBkZWx0YTogICAgICAgICAgJ2RlbHRhWCdcbiAgICB9XG59O1xuXG52YXIgYXhpcyA9IHtcbiAgICB0b3A6ICAgICd2ZXJ0aWNhbCcsXG4gICAgYm90dG9tOiAndmVydGljYWwnLFxuICAgIGhlaWdodDogJ3ZlcnRpY2FsJyxcbiAgICBsZWZ0OiAgICdob3Jpem9udGFsJyxcbiAgICByaWdodDogICdob3Jpem9udGFsJyxcbiAgICB3aWR0aDogICdob3Jpem9udGFsJ1xufTtcblxudmFyIGNzc0ZpbkJhcnM7IC8vIGRlZmluaXRpb24gaW5zZXJ0ZWQgYnkgZ3VscGZpbGUgYmV0d2VlbiBmb2xsb3dpbmcgY29tbWVudHNcbi8qIGluamVjdDpjc3MgKi9cbmNzc0ZpbkJhcnMgPSAnZGl2LmZpbmJhci1ob3Jpem9udGFsLGRpdi5maW5iYXItdmVydGljYWx7cG9zaXRpb246YWJzb2x1dGU7bWFyZ2luOjNweH1kaXYuZmluYmFyLWhvcml6b250YWw+LnRodW1iLGRpdi5maW5iYXItdmVydGljYWw+LnRodW1ie3Bvc2l0aW9uOmFic29sdXRlO2JhY2tncm91bmQtY29sb3I6I2QzZDNkMzstd2Via2l0LWJveC1zaGFkb3c6MCAwIDFweCAjMDAwOy1tb3otYm94LXNoYWRvdzowIDAgMXB4ICMwMDA7Ym94LXNoYWRvdzowIDAgMXB4ICMwMDA7Ym9yZGVyLXJhZGl1czo0cHg7bWFyZ2luOjJweDtvcGFjaXR5Oi40O3RyYW5zaXRpb246b3BhY2l0eSAuNXN9ZGl2LmZpbmJhci1ob3Jpem9udGFsPi50aHVtYi5ob3ZlcixkaXYuZmluYmFyLXZlcnRpY2FsPi50aHVtYi5ob3ZlcntvcGFjaXR5OjE7dHJhbnNpdGlvbjpvcGFjaXR5IC41c31kaXYuZmluYmFyLXZlcnRpY2Fse3RvcDowO2JvdHRvbTowO3JpZ2h0OjA7d2lkdGg6MTFweH1kaXYuZmluYmFyLXZlcnRpY2FsPi50aHVtYnt0b3A6MDtyaWdodDowO3dpZHRoOjdweH1kaXYuZmluYmFyLWhvcml6b250YWx7bGVmdDowO3JpZ2h0OjA7Ym90dG9tOjA7aGVpZ2h0OjExcHh9ZGl2LmZpbmJhci1ob3Jpem9udGFsPi50aHVtYntsZWZ0OjA7Ym90dG9tOjA7aGVpZ2h0OjdweH0nO1xuLyogZW5kaW5qZWN0ICovXG5cbmZ1bmN0aW9uIGVycm9yKG1zZykge1xuICAgIHRocm93ICdmaW5iYXJzOiAnICsgbXNnO1xufVxuXG4vLyBJbnRlcmZhY2Vcbm1vZHVsZS5leHBvcnRzID0gRmluQmFyO1xuIiwiLyogZXNsaW50LWVudiBicm93c2VyICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHJlY3Rhbmd1bGFyID0gcmVxdWlyZSgncmVjdGFuZ3VsYXInKTtcblxudmFyIGdlc3R1cmVzID0gcmVxdWlyZSgnLi9qcy9wb2x5bWVyZ2VzdHVyZXMuZGV2LmpzJyk7XG52YXIgR3JhcGhpY3NDb250ZXh0ID0gcmVxdWlyZSgnLi9qcy9HcmFwaGljc0NvbnRleHQuanMnKTtcblxudmFyIFJFU0laRV9QT0xMSU5HX0lOVEVSVkFMID0gMjAwLFxuICAgIHBhaW50YWJsZXMgPSBbXSxcbiAgICByZXNpemFibGVzID0gW10sXG4gICAgcGFpbnRMb29wUnVubmluZyA9IHRydWUsXG4gICAgcmVzaXplTG9vcFJ1bm5pbmcgPSB0cnVlLFxuICAgIGNoYXJNYXAgPSBtYWtlQ2hhck1hcCgpO1xuXG5mdW5jdGlvbiBDYW52YXMoZGl2LCBjb21wb25lbnQpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICB0aGlzLmRpdiA9IGRpdjtcbiAgICB0aGlzLl9jb21wb25lbnQgPSBjb21wb25lbnQ7XG5cbiAgICB0aGlzLmRyYWdFbmR0aW1lID0gRGF0ZS5ub3coKTtcblxuICAgIHRoaXMuY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgdGhpcy5kaXYuYXBwZW5kQ2hpbGQodGhpcy5jYW52YXMpO1xuXG4gICAgdGhpcy5jYW52YXMuc3R5bGUub3V0bGluZSA9ICdub25lJztcblxuICAgIC8vIHRoaXMuZm9jdXNlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpO1xuICAgIC8vIHRoaXMuZm9jdXNlci5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgLy8gdGhpcy5mb2N1c2VyLnN0eWxlLnRvcCA9ICcwcHgnO1xuICAgIC8vIHRoaXMuZm9jdXNlci5zdHlsZS5sZWZ0ID0gJzBweCc7XG4gICAgLy8gdGhpcy5mb2N1c2VyLnN0eWxlLnpJbmRleCA9ICctMSc7XG4gICAgLy8gdGhpcy5mb2N1c2VyLnN0eWxlLm91dGxpbmUgPSAnbm9uZSc7XG4gICAgLy8gdGhpcy5kaXYuYXBwZW5kQ2hpbGQodGhpcy5mb2N1c2VyKTtcblxuICAgIHRoaXMuY2FudmFzQ1RYID0gdGhpcy5jYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICB0aGlzLmdjID0gbmV3IEdyYXBoaWNzQ29udGV4dCh0aGlzLmNhbnZhc0NUWCk7XG5cbiAgICB0aGlzLmJ1ZmZlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgIHRoaXMuYnVmZmVyQ1RYID0gdGhpcy5idWZmZXIuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICB0aGlzLmJ1ZmZlckdDID0gbmV3IEdyYXBoaWNzQ29udGV4dCh0aGlzLmJ1ZmZlckNUWCk7XG5cbiAgICB0aGlzLm1vdXNlTG9jYXRpb24gPSBuZXcgcmVjdGFuZ3VsYXIuUG9pbnQoLTEsIC0xKTtcbiAgICB0aGlzLmRyYWdzdGFydCA9IG5ldyByZWN0YW5ndWxhci5Qb2ludCgtMSwgLTEpO1xuICAgIC8vdGhpcy5vcmlnaW4gPSBuZXcgcmVjdGFuZ3VsYXIuUG9pbnQoMCwgMCk7XG4gICAgdGhpcy5ib3VuZHMgPSBuZXcgcmVjdGFuZ3VsYXIuUmVjdGFuZ2xlKDAsIDAsIDAsIDApO1xuICAgIHRoaXMuaGFzTW91c2UgPSBmYWxzZTtcblxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYgKHNlbGYuaGFzTW91c2UgfHwgc2VsZi5pc0RyYWdnaW5nKCkpIHtcbiAgICAgICAgICAgIHNlbGYuZmlubW91c2Vtb3ZlKGUpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgc2VsZi5maW5tb3VzZXVwKGUpO1xuICAgIH0pO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3doZWVsJywgZnVuY3Rpb24oZSkge1xuICAgICAgICBzZWxmLmZpbndoZWVsbW92ZWQoZSk7XG4gICAgfSk7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgc2VsZi5maW5rZXlkb3duKGUpO1xuICAgIH0pO1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleXVwJywgZnVuY3Rpb24oZSkge1xuICAgICAgICBzZWxmLmZpbmtleXVwKGUpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5jYW52YXMub25tb3VzZW92ZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgc2VsZi5oYXNNb3VzZSA9IHRydWU7XG4gICAgfTtcbiAgICB0aGlzLmNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdmb2N1cycsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgc2VsZi5maW5mb2N1c2dhaW5lZChlKTtcbiAgICB9KTtcbiAgICB0aGlzLmNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdibHVyJywgZnVuY3Rpb24oZSkge1xuICAgICAgICBzZWxmLmZpbmZvY3VzbG9zdChlKTtcbiAgICB9KTtcbiAgICB0aGlzLmNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIHNlbGYuZmlubW91c2Vkb3duKGUpO1xuICAgIH0pO1xuICAgIHRoaXMuY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlb3V0JywgZnVuY3Rpb24oZSkge1xuICAgICAgICBzZWxmLmhhc01vdXNlID0gZmFsc2U7XG4gICAgICAgIHNlbGYuZmlubW91c2VvdXQoZSk7XG4gICAgfSk7XG4gICAgdGhpcy5jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIHNlbGYuZmluY2xpY2soZSk7XG4gICAgfSk7XG4gICAgdGhpcy5jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcignY29udGV4dG1lbnUnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIHNlbGYuZmluY29udGV4dG1lbnUoZSk7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0pO1xuXG4gICAgZ2VzdHVyZXMuYWRkRXZlbnRMaXN0ZW5lcih0aGlzLmNhbnZhcywgJ3RhcCcsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgc2VsZi5maW50YXAoZSk7XG4gICAgfSk7XG4gICAgZ2VzdHVyZXMuYWRkRXZlbnRMaXN0ZW5lcih0aGlzLmNhbnZhcywgJ2hvbGRwdWxzZScsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgc2VsZi5maW5ob2xkcHVsc2UoZSk7XG4gICAgfSk7XG4gICAgZ2VzdHVyZXMuYWRkRXZlbnRMaXN0ZW5lcih0aGlzLmNhbnZhcywgJ2ZsaWNrJywgZnVuY3Rpb24oZSkge1xuICAgICAgICBzZWxmLmZpbmZsaWNrKGUpO1xuICAgIH0pO1xuICAgIGdlc3R1cmVzLmFkZEV2ZW50TGlzdGVuZXIodGhpcy5jYW52YXMsICdyZWxlYXNlJywgZnVuY3Rpb24oZSkge1xuICAgICAgICBzZWxmLmZpbnJlbGVhc2UoZSk7XG4gICAgfSk7XG4gICAgZ2VzdHVyZXMuYWRkRXZlbnRMaXN0ZW5lcih0aGlzLmNhbnZhcywgJ3RyYWNrc3RhcnQnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIHNlbGYuZmludHJhY2tzdGFydChlKTtcbiAgICB9KTtcbiAgICBnZXN0dXJlcy5hZGRFdmVudExpc3RlbmVyKHRoaXMuY2FudmFzLCAndHJhY2snLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIHNlbGYuZmludHJhY2soZSk7XG4gICAgfSk7XG4gICAgZ2VzdHVyZXMuYWRkRXZlbnRMaXN0ZW5lcih0aGlzLmNhbnZhcywgJ3RyYWNrZW5kJywgZnVuY3Rpb24oZSkge1xuICAgICAgICBzZWxmLmZpbnRyYWNrZW5kKGUpO1xuICAgIH0pO1xuXG4gICAgdGhpcy5jYW52YXMuc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsIDApO1xuICAgIHRoaXMuY2FudmFzLmNvbnRlbnRFZGl0YWJsZSA9IHRydWU7XG5cbiAgICB0aGlzLnJlc2l6ZSgpO1xuXG4gICAgdGhpcy5iZWdpblJlc2l6aW5nKCk7XG4gICAgdGhpcy5iZWdpblBhaW50aW5nKCk7XG59XG5cbkNhbnZhcy5wcm90b3R5cGUgPSB7XG4gICAgY29uc3RydWN0b3I6IENhbnZhcy5wcm90b3R5cGUuY29uc3RydWN0b3IsXG4gICAgZGl2OiBudWxsLFxuICAgIF9jb21wb25lbnQ6IG51bGwsXG4gICAgZ2VzdHVyZXM6IGdlc3R1cmVzLCAvLyBUT0RPOiB3aHkgZG8gd2UgbmVlZCB0aGlzPyAod2FzIHByZXZpb3VzbHkgYXQgYm90dG9tIG9mIGZpbGUpXG4gICAgY2FudmFzOiBudWxsLFxuICAgIGNhbnZhc0NUWDogbnVsbCxcbiAgICBmb2N1c2VyOiBudWxsLFxuICAgIGJ1ZmZlcjogbnVsbCxcbiAgICBjdHg6IG51bGwsXG4gICAgbW91c2VMb2NhdGlvbjogbnVsbCxcbiAgICBob2xkUHVsc2VDb3VudDogLTEsXG4gICAgZHJhZ3N0YXJ0OiBudWxsLFxuICAgIG9yaWdpbjogbnVsbCxcbiAgICBib3VuZHM6IG51bGwsXG4gICAgZGlydHk6IGZhbHNlLFxuICAgIHNpemU6IG51bGwsXG4gICAgbW91c2Vkb3duOiBmYWxzZSxcbiAgICBkcmFnZ2luZzogZmFsc2UsXG4gICAgcmVwZWF0S2V5Q291bnQ6IDAsXG4gICAgcmVwZWF0S2V5OiBudWxsLFxuICAgIHJlcGVhdEtleVN0YXJ0VGltZTogMCxcbiAgICBjdXJyZW50S2V5czogW10sXG4gICAgaGFzTW91c2U6IGZhbHNlLFxuICAgIGxhc3REb3VibGVDbGlja1RpbWU6IDAsXG4gICAgZHJhZ0VuZFRpbWU6IDAsXG4gICAgbGFzdFJlcGFpbnRUaW1lOiAwLFxuXG4gICAgYWRkRXZlbnRMaXN0ZW5lcjogZnVuY3Rpb24obmFtZSwgY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihuYW1lLCBjYWxsYmFjayk7XG4gICAgfSxcblxuICAgIHN0b3BQYWludExvb3A6IGZ1bmN0aW9uKCkge1xuICAgICAgICBwYWludExvb3BSdW5uaW5nID0gZmFsc2U7XG4gICAgfSxcblxuICAgIHJlc3RhcnRQYWludExvb3A6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAocGFpbnRMb29wUnVubmluZykge1xuICAgICAgICAgICAgcmV0dXJuOyAvLyBhbHJlYWR5IHJ1bm5pbmdcbiAgICAgICAgfVxuICAgICAgICBwYWludExvb3BSdW5uaW5nID0gdHJ1ZTtcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKHBhaW50TG9vcEZ1bmN0aW9uKTtcbiAgICB9LFxuXG4gICAgc3RvcFJlc2l6ZUxvb3A6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXNpemVMb29wUnVubmluZyA9IGZhbHNlO1xuICAgIH0sXG5cbiAgICByZXN0YXJ0UmVzaXplTG9vcDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChyZXNpemVMb29wUnVubmluZykge1xuICAgICAgICAgICAgcmV0dXJuOyAvLyBhbHJlYWR5IHJ1bm5pbmdcbiAgICAgICAgfVxuICAgICAgICByZXNpemVMb29wUnVubmluZyA9IHRydWU7XG4gICAgICAgIHNldEludGVydmFsKHJlc2l6YWJsZXNMb29wRnVuY3Rpb24sIDIwMCk7XG4gICAgfSxcblxuICAgIGRldGFjaGVkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5zdG9wUGFpbnRpbmcoKTtcbiAgICAgICAgdGhpcy5zdG9wUmVzaXppbmcoKTtcbiAgICB9LFxuXG4gICAgdXNlSGlEUEk6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29tcG9uZW50LnJlc29sdmVQcm9wZXJ0eSgndXNlSGlEUEknKTtcbiAgICB9LFxuXG4gICAgdXNlQml0QmxpdDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb21wb25lbnQucmVzb2x2ZVByb3BlcnR5KCd1c2VCaXRCbGl0Jyk7XG4gICAgfSxcblxuICAgIGdldEZQUzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBmcHMgPSB0aGlzLl9jb21wb25lbnQucmVzb2x2ZVByb3BlcnR5KCdyZXBhaW50SW50ZXJ2YWxSYXRlJyk7XG4gICAgICAgIHJldHVybiBmcHMgPyBwYXJzZUludChmcHMpIDogMDtcbiAgICB9LFxuXG4gICAgdGlja1BhaW50OiBmdW5jdGlvbihub3cpIHtcbiAgICAgICAgdmFyIGZwcyA9IHRoaXMuZ2V0RlBTKCk7XG4gICAgICAgIGlmIChmcHMgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaW50ZXJ2YWwgPSAxMDAwIC8gZnBzO1xuXG4gICAgICAgIHZhciBlbGFwc2VkID0gbm93IC0gdGhpcy5sYXN0UmVwYWludFRpbWU7XG4gICAgICAgIGlmIChlbGFwc2VkID4gaW50ZXJ2YWwgJiYgdGhpcy5kaXJ0eSkge1xuICAgICAgICAgICAgdGhpcy5sYXN0UmVwYWludFRpbWUgPSBub3cgLSAoZWxhcHNlZCAlIGludGVydmFsKTtcbiAgICAgICAgICAgIHRoaXMucGFpbnROb3coKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBiZWdpblBhaW50aW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy50aWNrUGFpbnRlciA9IGZ1bmN0aW9uKG5vdykge1xuICAgICAgICAgICAgc2VsZi50aWNrUGFpbnQobm93KTtcbiAgICAgICAgfTtcbiAgICAgICAgcGFpbnRhYmxlcy5wdXNoKHRoaXMpO1xuICAgIH0sXG5cbiAgICBzdG9wUGFpbnRpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICBwYWludGFibGVzLnNwbGljZShwYWludGFibGVzLmluZGV4T2YodGhpcyksIDEpO1xuICAgIH0sXG5cbiAgICBiZWdpblJlc2l6aW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB0aGlzLnRpY2tSZXNpemVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBzZWxmLmNoZWNrc2l6ZSgpO1xuICAgICAgICB9O1xuICAgICAgICByZXNpemFibGVzLnB1c2godGhpcyk7XG4gICAgfSxcblxuICAgIHN0b3BSZXNpemluZzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlc2l6YWJsZXMuc3BsaWNlKHJlc2l6YWJsZXMuaW5kZXhPZih0aGlzKSwgMSk7XG4gICAgfSxcblxuICAgIHN0YXJ0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5iZWdpblBhaW50aW5nKCk7XG4gICAgICAgIHRoaXMuYmVnaW5SZXNpemluZygpO1xuICAgIH0sXG5cbiAgICBzdG9wOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5zdG9wUGFpbnRpbmcoKTtcbiAgICAgICAgdGhpcy5zdG9wUmVzaXppbmcoKTtcbiAgICB9LFxuXG4gICAgY2hlY2tzaXplOiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy90aGlzIGlzIGV4cGVuc2l2ZSBsZXRzIGRvIGl0IGF0IHNvbWUgbW9kdWxvXG4gICAgICAgIHZhciBzaXplTm93ID0gdGhpcy5kaXYuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGlmIChzaXplTm93LndpZHRoICE9PSB0aGlzLnNpemUud2lkdGggfHwgc2l6ZU5vdy5oZWlnaHQgIT09IHRoaXMuc2l6ZS5oZWlnaHQpIHtcbiAgICAgICAgICAgIHRoaXMuc2l6ZUNoYW5nZWROb3RpZmljYXRpb24oKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBzaXplQ2hhbmdlZE5vdGlmaWNhdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMucmVzaXplKCk7XG4gICAgfSxcblxuICAgIHJlc2l6ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBib3ggPSB0aGlzLnNpemUgPSB0aGlzLmRpdi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgICAgICB0aGlzLmNhbnZhcy53aWR0aCA9IHRoaXMuYnVmZmVyLndpZHRoID0gYm94LndpZHRoO1xuICAgICAgICB0aGlzLmNhbnZhcy5oZWlnaHQgPSB0aGlzLmJ1ZmZlci5oZWlnaHQgPSBib3guaGVpZ2h0O1xuXG4gICAgICAgIC8vZml4IGFsYSBzaXIgc3BpbmthLCBzZWVcbiAgICAgICAgLy9odHRwOi8vd3d3Lmh0bWw1cm9ja3MuY29tL2VuL3R1dG9yaWFscy9jYW52YXMvaGlkcGkvXG4gICAgICAgIC8vanVzdCBhZGQgJ2hkcGknIGFzIGFuIGF0dHJpYnV0ZSB0byB0aGUgZmluLWNhbnZhcyB0YWdcbiAgICAgICAgdmFyIHJhdGlvID0gMTtcbiAgICAgICAgdmFyIHVzZUJpdEJsaXQgPSB0aGlzLnVzZUJpdEJsaXQoKTtcbiAgICAgICAgdmFyIGlzSElEUEkgPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyAmJiB0aGlzLnVzZUhpRFBJKCk7XG4gICAgICAgIGlmIChpc0hJRFBJKSB7XG4gICAgICAgICAgICB2YXIgZGV2aWNlUGl4ZWxSYXRpbyA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDE7XG4gICAgICAgICAgICB2YXIgYmFja2luZ1N0b3JlUmF0aW8gPSB0aGlzLmNhbnZhc0NUWC53ZWJraXRCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5jYW52YXNDVFgubW96QmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fFxuICAgICAgICAgICAgICAgIHRoaXMuY2FudmFzQ1RYLm1zQmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fFxuICAgICAgICAgICAgICAgIHRoaXMuY2FudmFzQ1RYLm9CYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5jYW52YXNDVFguYmFja2luZ1N0b3JlUGl4ZWxSYXRpbyB8fCAxO1xuXG4gICAgICAgICAgICByYXRpbyA9IGRldmljZVBpeGVsUmF0aW8gLyBiYWNraW5nU3RvcmVSYXRpbztcbiAgICAgICAgICAgIC8vdGhpcy5jYW52YXNDVFguc2NhbGUocmF0aW8sIHJhdGlvKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgd2lkdGggPSB0aGlzLmNhbnZhcy5nZXRBdHRyaWJ1dGUoJ3dpZHRoJyk7XG4gICAgICAgIHZhciBoZWlnaHQgPSB0aGlzLmNhbnZhcy5nZXRBdHRyaWJ1dGUoJ2hlaWdodCcpO1xuICAgICAgICB0aGlzLmNhbnZhcy53aWR0aCA9IHdpZHRoICogcmF0aW87XG4gICAgICAgIHRoaXMuY2FudmFzLmhlaWdodCA9IGhlaWdodCAqIHJhdGlvO1xuICAgICAgICB0aGlzLmJ1ZmZlci53aWR0aCA9IHdpZHRoICogcmF0aW87XG4gICAgICAgIHRoaXMuYnVmZmVyLmhlaWdodCA9IGhlaWdodCAqIHJhdGlvO1xuXG4gICAgICAgIHRoaXMuY2FudmFzLnN0eWxlLndpZHRoID0gd2lkdGggKyAncHgnO1xuICAgICAgICB0aGlzLmNhbnZhcy5zdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyAncHgnO1xuICAgICAgICB0aGlzLmJ1ZmZlci5zdHlsZS53aWR0aCA9IHdpZHRoICsgJ3B4JztcbiAgICAgICAgdGhpcy5idWZmZXIuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4JztcblxuICAgICAgICB0aGlzLmJ1ZmZlckNUWC5zY2FsZShyYXRpbywgcmF0aW8pO1xuICAgICAgICBpZiAoaXNISURQSSAmJiAhdXNlQml0QmxpdCkge1xuICAgICAgICAgICAgdGhpcy5jYW52YXNDVFguc2NhbGUocmF0aW8sIHJhdGlvKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vdGhpcy5vcmlnaW4gPSBuZXcgcmVjdGFuZ3VsYXIuUG9pbnQoTWF0aC5yb3VuZCh0aGlzLnNpemUubGVmdCksIE1hdGgucm91bmQodGhpcy5zaXplLnRvcCkpO1xuICAgICAgICB0aGlzLmJvdW5kcyA9IG5ldyByZWN0YW5ndWxhci5SZWN0YW5nbGUoMCwgMCwgYm94LndpZHRoLCBib3guaGVpZ2h0KTtcbiAgICAgICAgLy9zZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY29tcCA9IHRoaXMuX2NvbXBvbmVudDtcbiAgICAgICAgaWYgKGNvbXApIHtcbiAgICAgICAgICAgIGNvbXAuc2V0Qm91bmRzKHRoaXMuYm91bmRzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlc2l6ZU5vdGlmaWNhdGlvbigpO1xuICAgICAgICB0aGlzLnBhaW50Tm93KCk7XG4gICAgICAgIC8vfSk7XG4gICAgfSxcblxuICAgIHJlc2l6ZU5vdGlmaWNhdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vdG8gYmUgb3ZlcnJpZGRlblxuICAgIH0sXG5cbiAgICBnZXRCb3VuZHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ib3VuZHM7XG4gICAgfSxcblxuICAgIHBhaW50Tm93OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB0aGlzLnNhZmVQYWludEltbWVkaWF0ZWx5KGZ1bmN0aW9uKGdjKSB7XG4gICAgICAgICAgICBnYy5jbGVhclJlY3QoMCwgMCwgc2VsZi5jYW52YXMud2lkdGgsIHNlbGYuY2FudmFzLmhlaWdodCk7XG5cbiAgICAgICAgICAgIHZhciBjb21wID0gc2VsZi5fY29tcG9uZW50O1xuICAgICAgICAgICAgaWYgKGNvbXApIHtcbiAgICAgICAgICAgICAgICBjb21wLl9wYWludChnYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNlbGYuZGlydHkgPSBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIHNhZmVQYWludEltbWVkaWF0ZWx5OiBmdW5jdGlvbihwYWludEZ1bmN0aW9uKSB7XG4gICAgICAgIHZhciB1c2VCaXRCbGl0ID0gdGhpcy51c2VCaXRCbGl0KCksXG4gICAgICAgICAgICBnYyA9IHVzZUJpdEJsaXQgPyB0aGlzLmJ1ZmZlckdDIDogdGhpcy5nYztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGdjLnNhdmUoKTtcbiAgICAgICAgICAgIHBhaW50RnVuY3Rpb24oZ2MpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgZ2MucmVzdG9yZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1c2VCaXRCbGl0KSB7XG4gICAgICAgICAgICB0aGlzLmZsdXNoQnVmZmVyKCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZmx1c2hCdWZmZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5idWZmZXIud2lkdGggPiAwICYmIHRoaXMuYnVmZmVyLmhlaWdodCA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuY2FudmFzQ1RYLmRyYXdJbWFnZSh0aGlzLmJ1ZmZlciwgMCwgMCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZGlzcGF0Y2hOZXdFdmVudDogZnVuY3Rpb24oZXZlbnQsIG5hbWUsIGRldGFpbCkge1xuICAgICAgICBkZXRhaWwgPSB7XG4gICAgICAgICAgICBkZXRhaWw6IGRldGFpbCB8fCB7fVxuICAgICAgICB9O1xuICAgICAgICBkZXRhaWwuZGV0YWlsLnByaW1pdGl2ZUV2ZW50ID0gZXZlbnQ7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbnZhcy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudChuYW1lLCBkZXRhaWwpKTtcbiAgICB9LFxuXG4gICAgZGlzcGF0Y2hOZXdNb3VzZUtleXNFdmVudDogZnVuY3Rpb24oZXZlbnQsIG5hbWUsIGRldGFpbCkge1xuICAgICAgICBkZXRhaWwgPSBkZXRhaWwgfHwge307XG4gICAgICAgIGRldGFpbC5tb3VzZSA9IHRoaXMubW91c2VMb2NhdGlvbjtcbiAgICAgICAgZGV0YWlsLmtleXMgPSB0aGlzLmN1cnJlbnRLZXlzO1xuICAgICAgICByZXR1cm4gdGhpcy5kaXNwYXRjaE5ld0V2ZW50KGV2ZW50LCBuYW1lLCBkZXRhaWwpO1xuICAgIH0sXG5cbiAgICBmaW5tb3VzZW1vdmU6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzRHJhZ2dpbmcoKSAmJiB0aGlzLm1vdXNlZG93bikge1xuICAgICAgICAgICAgdGhpcy5iZURyYWdnaW5nKCk7XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoTmV3TW91c2VLZXlzRXZlbnQoZSwgJ2Zpbi1jYW52YXMtZHJhZ3N0YXJ0Jywge1xuICAgICAgICAgICAgICAgIGlzUmlnaHRDbGljazogdGhpcy5pc1JpZ2h0Q2xpY2soZSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5kcmFnc3RhcnQgPSBuZXcgcmVjdGFuZ3VsYXIuUG9pbnQodGhpcy5tb3VzZUxvY2F0aW9uLngsIHRoaXMubW91c2VMb2NhdGlvbi55KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1vdXNlTG9jYXRpb24gPSB0aGlzLmdldExvY2FsKGUpO1xuICAgICAgICAvL2NvbnNvbGUubG9nKHRoaXMubW91c2VMb2NhdGlvbik7XG4gICAgICAgIGlmICh0aGlzLmlzRHJhZ2dpbmcoKSkge1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaE5ld01vdXNlS2V5c0V2ZW50KGUsICdmaW4tY2FudmFzLWRyYWcnLCB7XG4gICAgICAgICAgICAgICAgZHJhZ3N0YXJ0OiB0aGlzLmRyYWdzdGFydCxcbiAgICAgICAgICAgICAgICBpc1JpZ2h0Q2xpY2s6IHRoaXMuaXNSaWdodENsaWNrKGUpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5ib3VuZHMuY29udGFpbnModGhpcy5tb3VzZUxvY2F0aW9uKSkge1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaE5ld01vdXNlS2V5c0V2ZW50KGUsICdmaW4tY2FudmFzLW1vdXNlbW92ZScpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGZpbm1vdXNlZG93bjogZnVuY3Rpb24oZSkge1xuICAgICAgICB0aGlzLm1vdXNlTG9jYXRpb24gPSB0aGlzLmdldExvY2FsKGUpO1xuICAgICAgICB0aGlzLm1vdXNlZG93biA9IHRydWU7XG5cbiAgICAgICAgdGhpcy5kaXNwYXRjaE5ld01vdXNlS2V5c0V2ZW50KGUsICdmaW4tY2FudmFzLW1vdXNlZG93bicsIHtcbiAgICAgICAgICAgIGlzUmlnaHRDbGljazogdGhpcy5pc1JpZ2h0Q2xpY2soZSlcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudGFrZUZvY3VzKCk7XG4gICAgfSxcblxuICAgIGZpbm1vdXNldXA6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNEcmFnZ2luZygpKSB7XG4gICAgICAgICAgICB0aGlzLmRpc3BhdGNoTmV3TW91c2VLZXlzRXZlbnQoZSwgJ2Zpbi1jYW52YXMtZHJhZ2VuZCcsIHtcbiAgICAgICAgICAgICAgICBkcmFnc3RhcnQ6IHRoaXMuZHJhZ3N0YXJ0LFxuICAgICAgICAgICAgICAgIGlzUmlnaHRDbGljazogdGhpcy5pc1JpZ2h0Q2xpY2soZSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5iZU5vdERyYWdnaW5nKCk7XG4gICAgICAgICAgICB0aGlzLmRyYWdFbmR0aW1lID0gRGF0ZS5ub3coKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1vdXNlZG93biA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRpc3BhdGNoTmV3TW91c2VLZXlzRXZlbnQoZSwgJ2Zpbi1jYW52YXMtbW91c2V1cCcsIHtcbiAgICAgICAgICAgIGlzUmlnaHRDbGljazogdGhpcy5pc1JpZ2h0Q2xpY2soZSlcbiAgICAgICAgfSk7XG4gICAgICAgIC8vdGhpcy5tb3VzZUxvY2F0aW9uID0gbmV3IHJlY3Rhbmd1bGFyLlBvaW50KC0xLCAtMSk7XG4gICAgfSxcblxuICAgIGZpbm1vdXNlb3V0OiBmdW5jdGlvbihlKSB7XG4gICAgICAgIGlmICghdGhpcy5tb3VzZWRvd24pIHtcbiAgICAgICAgICAgIHRoaXMubW91c2VMb2NhdGlvbiA9IG5ldyByZWN0YW5ndWxhci5Qb2ludCgtMSwgLTEpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hOZXdNb3VzZUtleXNFdmVudChlLCAnZmluLWNhbnZhcy1tb3VzZW91dCcpO1xuICAgIH0sXG5cbiAgICBmaW53aGVlbG1vdmVkOiBmdW5jdGlvbihlKSB7XG4gICAgICAgIGlmICh0aGlzLmlzRHJhZ2dpbmcoKSB8fCAhdGhpcy5oYXNGb2N1cygpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB0aGlzLmRpc3BhdGNoTmV3TW91c2VLZXlzRXZlbnQoZSwgJ2Zpbi1jYW52YXMtd2hlZWxtb3ZlZCcsIHtcbiAgICAgICAgICAgIGlzUmlnaHRDbGljazogdGhpcy5pc1JpZ2h0Q2xpY2soZSlcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIGZpbmNsaWNrOiBmdW5jdGlvbihlKSB7XG4gICAgICAgIGlmIChEYXRlLm5vdygpIC0gdGhpcy5sYXN0Q2xpY2tUaW1lIDwgMjUwKSB7XG4gICAgICAgICAgICAvL3RoaXMgaXMgYSBkb3VibGUgY2xpY2suLi5cbiAgICAgICAgICAgIHRoaXMuZmluZGJsY2xpY2soZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tb3VzZUxvY2F0aW9uID0gdGhpcy5nZXRMb2NhbChlKTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaE5ld01vdXNlS2V5c0V2ZW50KGUsICdmaW4tY2FudmFzLWNsaWNrJywge1xuICAgICAgICAgICAgaXNSaWdodENsaWNrOiB0aGlzLmlzUmlnaHRDbGljayhlKVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5sYXN0Q2xpY2tUaW1lID0gRGF0ZS5ub3coKTtcbiAgICB9LFxuXG4gICAgZmlucmVsZWFzZTogZnVuY3Rpb24oZSkge1xuICAgICAgICB0aGlzLmhvbGRQdWxzZUNvdW50ID0gMDtcbiAgICAgICAgdGhpcy5tb3VzZUxvY2F0aW9uID0gdGhpcy5nZXRMb2NhbChlKTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaE5ld01vdXNlS2V5c0V2ZW50KGUsICdmaW4tY2FudmFzLXJlbGVhc2UnKTtcbiAgICB9LFxuXG4gICAgZmluZmxpY2s6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmhhc0ZvY3VzKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1vdXNlTG9jYXRpb24gPSB0aGlzLmdldExvY2FsKGUpO1xuICAgICAgICB0aGlzLmRpc3BhdGNoTmV3TW91c2VLZXlzRXZlbnQoZSwgJ2Zpbi1jYW52YXMtZmxpY2snLCB7XG4gICAgICAgICAgICBpc1JpZ2h0Q2xpY2s6IHRoaXMuaXNSaWdodENsaWNrKGUpXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBmaW50cmFja3N0YXJ0OiBmdW5jdGlvbihlKSB7XG4gICAgICAgIGlmICghdGhpcy5oYXNGb2N1cygpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5tb3VzZUxvY2F0aW9uID0gdGhpcy5nZXRMb2NhbChlKTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaE5ld01vdXNlS2V5c0V2ZW50KGUsICdmaW4tY2FudmFzLXRyYWNrc3RhcnQnKTtcbiAgICB9LFxuXG4gICAgZmludHJhY2s6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmhhc0ZvY3VzKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1vdXNlTG9jYXRpb24gPSB0aGlzLmdldExvY2FsKGUpO1xuICAgICAgICB0aGlzLmRpc3BhdGNoTmV3TW91c2VLZXlzRXZlbnQoZSwgJ2Zpbi1jYW52YXMtdHJhY2snKTtcbiAgICB9LFxuXG4gICAgZmludHJhY2tlbmQ6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdGhpcy5tb3VzZUxvY2F0aW9uID0gdGhpcy5nZXRMb2NhbChlKTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaE5ld01vdXNlS2V5c0V2ZW50KGUsICdmaW4tY2FudmFzLXRyYWNrZW5kJyk7XG4gICAgfSxcblxuICAgIGZpbmhvbGQ6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdGhpcy5tb3VzZUxvY2F0aW9uID0gdGhpcy5nZXRMb2NhbChlKTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaE5ld01vdXNlS2V5c0V2ZW50KGUsICdmaW4tY2FudmFzLWhvbGQnLCB7XG4gICAgICAgICAgICBpc1JpZ2h0Q2xpY2s6IHRoaXMuaXNSaWdodENsaWNrKGUpXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBmaW5ob2xkcHVsc2U6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdGhpcy5tb3VzZUxvY2F0aW9uID0gdGhpcy5nZXRMb2NhbChlKTtcbiAgICAgICAgdGhpcy5kaXNwYXRjaE5ld01vdXNlS2V5c0V2ZW50KGUsICdmaW4tY2FudmFzLWhvbGRwdWxzZScsIHtcbiAgICAgICAgICAgIGNvdW50OiB0aGlzLmhvbGRQdWxzZUNvdW50KytcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIGZpbnRhcDogZnVuY3Rpb24oZSkge1xuICAgICAgICAvL3RoaXMgbm9uc2Vuc2UgaXMgdG8gaG9sZCBhIHRhcCBpZiBpdCdzIHJlYWxseSBhIGRvdWJsZSBjbGlja1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBub3cgPSBEYXRlLm5vdygpO1xuICAgICAgICB2YXIgZGlmID0gbm93IC0gdGhpcy5sYXN0RG91YmxlQ2xpY2tUaW1lO1xuICAgICAgICBpZiAoZGlmIDwgMzAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy9kcmFnZW5kIGlzIGFsc28gY2F1c2luZyBhIHRhcFxuICAgICAgICAvL2xldHMgZml4IHRoaXMgaGVyZVxuICAgICAgICBpZiAobm93IC0gdGhpcy5kcmFnRW5kdGltZSA8IDEwMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBzZWxmLl9maW50YXAoZSk7XG4gICAgICAgIH0sIDE4MCk7XG4gICAgfSxcblxuICAgIF9maW50YXA6IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgLy90aGlzIG5vbnNlbnNlIGlzIHRvIGhvbGQgYSB0YXAgaWYgaXQncyByZWFsbHkgYSBkb3VibGUgY2xpY2tcbiAgICAgICAgdmFyIG5vdyA9IERhdGUubm93KCk7XG4gICAgICAgIHZhciBkaWYgPSBub3cgLSB0aGlzLmxhc3REb3VibGVDbGlja1RpbWU7XG4gICAgICAgIGlmIChkaWYgPCAzMDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvL3RoaXMubW91c2VMb2NhdGlvbiA9IHRoaXMuZ2V0TG9jYWwoZSk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hOZXdNb3VzZUtleXNFdmVudChlLCAnZmluLWNhbnZhcy10YXAnLCB7XG4gICAgICAgICAgICBpc1JpZ2h0Q2xpY2s6IHRoaXMuaXNSaWdodENsaWNrKGUpXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBmaW5kYmxjbGljazogZnVuY3Rpb24oZSkge1xuICAgICAgICB0aGlzLm1vdXNlTG9jYXRpb24gPSB0aGlzLmdldExvY2FsKGUpO1xuICAgICAgICB0aGlzLmxhc3REb3VibGVDbGlja1RpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICB0aGlzLmRpc3BhdGNoTmV3TW91c2VLZXlzRXZlbnQoZSwgJ2Zpbi1jYW52YXMtZGJsY2xpY2snLCB7XG4gICAgICAgICAgICBpc1JpZ2h0Q2xpY2s6IHRoaXMuaXNSaWdodENsaWNrKGUpXG4gICAgICAgIH0pO1xuICAgICAgICAvL2NvbnNvbGUubG9nKCdkYmxjbGljaycsIHRoaXMuY3VycmVudEtleXMpO1xuICAgIH0sXG5cbiAgICBnZXRDaGFyTWFwOiBmdW5jdGlvbigpIHsgLy9UT0RPOiBUaGlzIGlzIHN0YXRpYy4gTWFrZSBpdCBhIHByb3BlcnR5IG9mIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgICAgcmV0dXJuIGNoYXJNYXA7XG4gICAgfSxcblxuICAgIGZpbmtleWRvd246IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYgKCF0aGlzLmhhc0ZvY3VzKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB2YXIga2V5Q2hhciA9IGUuc2hpZnRLZXkgPyBjaGFyTWFwW2Uua2V5Q29kZV1bMV0gOiBjaGFyTWFwW2Uua2V5Q29kZV1bMF07XG4gICAgICAgIGlmIChlLnJlcGVhdCkge1xuICAgICAgICAgICAgaWYgKHRoaXMucmVwZWF0S2V5ID09PSBrZXlDaGFyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXBlYXRLZXlDb3VudCsrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlcGVhdEtleSA9IGtleUNoYXI7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXBlYXRLZXlTdGFydFRpbWUgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5yZXBlYXRLZXkgPSBudWxsO1xuICAgICAgICAgICAgdGhpcy5yZXBlYXRLZXlDb3VudCA9IDA7XG4gICAgICAgICAgICB0aGlzLnJlcGVhdEtleVN0YXJ0VGltZSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY3VycmVudEtleXMuaW5kZXhPZihrZXlDaGFyKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudEtleXMucHVzaChrZXlDaGFyKTtcbiAgICAgICAgfVxuICAgICAgICAvL2NvbnNvbGUubG9nKGtleUNoYXIsIGUua2V5Q29kZSk7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hOZXdFdmVudChlLCAnZmluLWNhbnZhcy1rZXlkb3duJywge1xuICAgICAgICAgICAgYWx0OiBlLmFsdEtleSxcbiAgICAgICAgICAgIGN0cmw6IGUuY3RybEtleSxcbiAgICAgICAgICAgIGNoYXI6IGtleUNoYXIsXG4gICAgICAgICAgICBjb2RlOiBlLmNoYXJDb2RlLFxuICAgICAgICAgICAga2V5OiBlLmtleUNvZGUsXG4gICAgICAgICAgICBtZXRhOiBlLm1ldGFLZXksXG4gICAgICAgICAgICByZXBlYXRDb3VudDogdGhpcy5yZXBlYXRLZXlDb3VudCxcbiAgICAgICAgICAgIHJlcGVhdFN0YXJ0VGltZTogdGhpcy5yZXBlYXRLZXlTdGFydFRpbWUsXG4gICAgICAgICAgICBzaGlmdDogZS5zaGlmdEtleSxcbiAgICAgICAgICAgIGlkZW50aWZpZXI6IGUua2V5SWRlbnRpZmllcixcbiAgICAgICAgICAgIGN1cnJlbnRLZXlzOiB0aGlzLmN1cnJlbnRLZXlzLnNsaWNlKDApXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBmaW5rZXl1cDogZnVuY3Rpb24oZSkge1xuICAgICAgICB2YXIga2V5Q2hhciA9IGUuc2hpZnRLZXkgPyBjaGFyTWFwW2Uua2V5Q29kZV1bMV0gOiBjaGFyTWFwW2Uua2V5Q29kZV1bMF07XG4gICAgICAgIHRoaXMuY3VycmVudEtleXMuc3BsaWNlKHRoaXMuY3VycmVudEtleXMuaW5kZXhPZihrZXlDaGFyKSwgMSk7XG4gICAgICAgIGlmICghdGhpcy5oYXNGb2N1cygpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZXBlYXRLZXlDb3VudCA9IDA7XG4gICAgICAgIHRoaXMucmVwZWF0S2V5ID0gbnVsbDtcbiAgICAgICAgdGhpcy5yZXBlYXRLZXlTdGFydFRpbWUgPSAwO1xuICAgICAgICB0aGlzLmRpc3BhdGNoTmV3RXZlbnQoZSwgJ2Zpbi1jYW52YXMta2V5dXAnLCB7XG4gICAgICAgICAgICBhbHQ6IGUuYWx0S2V5LFxuICAgICAgICAgICAgY3RybDogZS5jdHJsS2V5LFxuICAgICAgICAgICAgY2hhcjoga2V5Q2hhcixcbiAgICAgICAgICAgIGNvZGU6IGUuY2hhckNvZGUsXG4gICAgICAgICAgICBrZXk6IGUua2V5Q29kZSxcbiAgICAgICAgICAgIG1ldGE6IGUubWV0YUtleSxcbiAgICAgICAgICAgIHJlcGVhdDogZS5yZXBlYXQsXG4gICAgICAgICAgICBzaGlmdDogZS5zaGlmdEtleSxcbiAgICAgICAgICAgIGlkZW50aWZpZXI6IGUua2V5SWRlbnRpZmllcixcbiAgICAgICAgICAgIGN1cnJlbnRLZXlzOiB0aGlzLmN1cnJlbnRLZXlzLnNsaWNlKDApXG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBmaW5mb2N1c2dhaW5lZDogZnVuY3Rpb24oZSkge1xuICAgICAgICB0aGlzLmRpc3BhdGNoTmV3RXZlbnQoZSwgJ2Zpbi1jYW52YXMtZm9jdXMtZ2FpbmVkJyk7XG4gICAgfSxcblxuICAgIGZpbmZvY3VzbG9zdDogZnVuY3Rpb24oZSkge1xuICAgICAgICB0aGlzLmRpc3BhdGNoTmV3RXZlbnQoZSwgJ2Zpbi1jYW52YXMtZm9jdXMtbG9zdCcpO1xuICAgIH0sXG5cbiAgICBmaW5jb250ZXh0bWVudTogZnVuY3Rpb24oZSkge1xuICAgICAgICBpZiAoZS5jdHJsS2V5ICYmIHRoaXMuY3VycmVudEtleXMuaW5kZXhPZignQ1RSTCcpID09PSAtMSkge1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50S2V5cy5wdXNoKCdDVFJMJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKERhdGUubm93KCkgLSB0aGlzLmxhc3RDbGlja1RpbWUgPCAyNTApIHtcbiAgICAgICAgICAgIC8vdGhpcyBpcyBhIGRvdWJsZSBjbGljay4uLlxuICAgICAgICAgICAgdGhpcy5maW5kYmxjbGljayhlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRpc3BhdGNoTmV3TW91c2VLZXlzRXZlbnQoZSwgJ2Zpbi1jYW52YXMtY29udGV4dC1tZW51Jywge1xuICAgICAgICAgICAgaXNSaWdodENsaWNrOiB0aGlzLmlzUmlnaHRDbGljayhlKVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5sYXN0Q2xpY2tUaW1lID0gRGF0ZS5ub3coKTtcbiAgICB9LFxuXG4gICAgcmVwYWludDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBmcHMgPSB0aGlzLmdldEZQUygpO1xuICAgICAgICB0aGlzLmRpcnR5ID0gdHJ1ZTtcbiAgICAgICAgaWYgKCFwYWludExvb3BSdW5uaW5nIHx8IGZwcyA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5wYWludE5vdygpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGdldE1vdXNlTG9jYXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tb3VzZUxvY2F0aW9uO1xuICAgIH0sXG5cbiAgICBnZXRPcmlnaW46IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcmVjdCA9IHRoaXMuY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICB2YXIgcCA9IG5ldyByZWN0YW5ndWxhci5Qb2ludChyZWN0LmxlZnQsIHJlY3QudG9wKTtcbiAgICAgICAgcmV0dXJuIHA7XG4gICAgfSxcblxuICAgIGdldExvY2FsOiBmdW5jdGlvbihlKSB7XG4gICAgICAgIHZhciByZWN0ID0gdGhpcy5jYW52YXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHZhciBwID0gbmV3IHJlY3Rhbmd1bGFyLlBvaW50KGUuY2xpZW50WCAtIHJlY3QubGVmdCwgZS5jbGllbnRZIC0gcmVjdC50b3ApO1xuICAgICAgICByZXR1cm4gcDtcbiAgICB9LFxuXG4gICAgaGFzRm9jdXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PT0gdGhpcy5jYW52YXM7XG4gICAgfSxcblxuICAgIHRha2VGb2N1czogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgaWYgKCF0aGlzLmhhc0ZvY3VzKCkpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5jYW52YXMuZm9jdXMoKTtcbiAgICAgICAgICAgIH0sIDEwKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBiZURyYWdnaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5kcmFnZ2luZyA9IHRydWU7XG4gICAgICAgIHRoaXMuZGlzYWJsZURvY3VtZW50RWxlbWVudFNlbGVjdGlvbigpO1xuICAgIH0sXG5cbiAgICBiZU5vdERyYWdnaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5kcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmVuYWJsZURvY3VtZW50RWxlbWVudFNlbGVjdGlvbigpO1xuICAgIH0sXG5cbiAgICBpc0RyYWdnaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZHJhZ2dpbmc7XG4gICAgfSxcblxuICAgIGRpc2FibGVEb2N1bWVudEVsZW1lbnRTZWxlY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc3R5bGUgPSBkb2N1bWVudC5ib2R5LnN0eWxlO1xuICAgICAgICBzdHlsZS5jc3NUZXh0ID0gc3R5bGUuY3NzVGV4dCArICctd2Via2l0LXVzZXItc2VsZWN0OiBub25lJztcbiAgICB9LFxuXG4gICAgZW5hYmxlRG9jdW1lbnRFbGVtZW50U2VsZWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHN0eWxlID0gZG9jdW1lbnQuYm9keS5zdHlsZTtcbiAgICAgICAgc3R5bGUuY3NzVGV4dCA9IHN0eWxlLmNzc1RleHQucmVwbGFjZSgnLXdlYmtpdC11c2VyLXNlbGVjdDogbm9uZScsICcnKTtcbiAgICB9LFxuXG4gICAgc2V0Rm9jdXNhYmxlOiBmdW5jdGlvbih0cnV0aHkpIHtcbiAgICAgICAgdGhpcy5mb2N1c2VyLnN0eWxlLmRpc3BsYXkgPSB0cnV0aHkgPyAnJyA6ICdub25lJztcbiAgICB9LFxuXG4gICAgaXNSaWdodENsaWNrOiBmdW5jdGlvbihlKSB7XG4gICAgICAgIHZhciBpc1JpZ2h0TUI7XG4gICAgICAgIGUgPSBlIHx8IHdpbmRvdy5ldmVudDtcblxuICAgICAgICBpZiAoJ3doaWNoJyBpbiBlKSB7IC8vIEdlY2tvIChGaXJlZm94KSwgV2ViS2l0IChTYWZhcmkvQ2hyb21lKSAmIE9wZXJhXG4gICAgICAgICAgICBpc1JpZ2h0TUIgPSBlLndoaWNoID09PSAzO1xuICAgICAgICB9IGVsc2UgaWYgKCdidXR0b24nIGluIGUpIHsgLy8gSUUsIE9wZXJhXG4gICAgICAgICAgICBpc1JpZ2h0TUIgPSBlLmJ1dHRvbiA9PT0gMjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaXNSaWdodE1CO1xuICAgIH0sXG5cbiAgICBkaXNwYXRjaEV2ZW50OiBmdW5jdGlvbihlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbnZhcy5kaXNwYXRjaEV2ZW50KGUpO1xuICAgIH1cbn07XG5cbmZ1bmN0aW9uIHBhaW50TG9vcEZ1bmN0aW9uKG5vdykge1xuICAgIGlmICghcGFpbnRMb29wUnVubmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFpbnRhYmxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcGFpbnRhYmxlc1tpXS50aWNrUGFpbnRlcihub3cpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShwYWludExvb3BGdW5jdGlvbik7XG59XG5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUocGFpbnRMb29wRnVuY3Rpb24pO1xuXG5mdW5jdGlvbiByZXNpemFibGVzTG9vcEZ1bmN0aW9uKG5vdykge1xuICAgIGlmICghcmVzaXplTG9vcFJ1bm5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJlc2l6YWJsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc2l6YWJsZXNbaV0udGlja1Jlc2l6ZXIobm93KTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbnNldEludGVydmFsKHJlc2l6YWJsZXNMb29wRnVuY3Rpb24sIFJFU0laRV9QT0xMSU5HX0lOVEVSVkFMKTtcblxuZnVuY3Rpb24gbWFrZUNoYXJNYXAoKSB7XG4gICAgdmFyIG1hcCA9IFtdO1xuXG4gICAgdmFyIGVtcHR5ID0gWycnLCAnJ107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDI1NjsgaSsrKSB7XG4gICAgICAgIG1hcFtpXSA9IGVtcHR5O1xuICAgIH1cblxuICAgIG1hcFsyN10gPSBbJ0VTQycsICdFU0NTSElGVCddO1xuICAgIG1hcFsxOTJdID0gWydgJywgJ34nXTtcbiAgICBtYXBbNDldID0gWycxJywgJyEnXTtcbiAgICBtYXBbNTBdID0gWycyJywgJ0AnXTtcbiAgICBtYXBbNTFdID0gWyczJywgJyMnXTtcbiAgICBtYXBbNTJdID0gWyc0JywgJyQnXTtcbiAgICBtYXBbNTNdID0gWyc1JywgJyUnXTtcbiAgICBtYXBbNTRdID0gWyc2JywgJ14nXTtcbiAgICBtYXBbNTVdID0gWyc3JywgJyYnXTtcbiAgICBtYXBbNTZdID0gWyc4JywgJyonXTtcbiAgICBtYXBbNTddID0gWyc5JywgJygnXTtcbiAgICBtYXBbNDhdID0gWycwJywgJyknXTtcbiAgICBtYXBbMTg5XSA9IFsnLScsICdfJ107XG4gICAgbWFwWzE4N10gPSBbJz0nLCAnKyddO1xuICAgIG1hcFs4XSA9IFsnREVMRVRFJywgJ0RFTEVURVNISUZUJ107XG4gICAgbWFwWzldID0gWydUQUInLCAnVEFCU0hJRlQnXTtcbiAgICBtYXBbODFdID0gWydxJywgJ1EnXTtcbiAgICBtYXBbODddID0gWyd3JywgJ1cnXTtcbiAgICBtYXBbNjldID0gWydlJywgJ0UnXTtcbiAgICBtYXBbODJdID0gWydyJywgJ1InXTtcbiAgICBtYXBbODRdID0gWyd0JywgJ1QnXTtcbiAgICBtYXBbODldID0gWyd5JywgJ1knXTtcbiAgICBtYXBbODVdID0gWyd1JywgJ1UnXTtcbiAgICBtYXBbNzNdID0gWydpJywgJ0knXTtcbiAgICBtYXBbNzldID0gWydvJywgJ08nXTtcbiAgICBtYXBbODBdID0gWydwJywgJ1AnXTtcbiAgICBtYXBbMjE5XSA9IFsnWycsICd7J107XG4gICAgbWFwWzIyMV0gPSBbJ10nLCAnfSddO1xuICAgIG1hcFsyMjBdID0gWydcXFxcJywgJ3wnXTtcbiAgICBtYXBbMjIwXSA9IFsnQ0FQU0xPQ0snLCAnQ0FQU0xPQ0tTSElGVCddO1xuICAgIG1hcFs2NV0gPSBbJ2EnLCAnQSddO1xuICAgIG1hcFs4M10gPSBbJ3MnLCAnUyddO1xuICAgIG1hcFs2OF0gPSBbJ2QnLCAnRCddO1xuICAgIG1hcFs3MF0gPSBbJ2YnLCAnRiddO1xuICAgIG1hcFs3MV0gPSBbJ2cnLCAnRyddO1xuICAgIG1hcFs3Ml0gPSBbJ2gnLCAnSCddO1xuICAgIG1hcFs3NF0gPSBbJ2onLCAnSiddO1xuICAgIG1hcFs3NV0gPSBbJ2snLCAnSyddO1xuICAgIG1hcFs3Nl0gPSBbJ2wnLCAnTCddO1xuICAgIG1hcFsxODZdID0gWyc7JywgJzonXTtcbiAgICBtYXBbMjIyXSA9IFsnXFwnJywgJ3wnXTtcbiAgICBtYXBbMTNdID0gWydSRVRVUk4nLCAnUkVUVVJOU0hJRlQnXTtcbiAgICBtYXBbMTZdID0gWydTSElGVCcsICdTSElGVCddO1xuICAgIG1hcFs5MF0gPSBbJ3onLCAnWiddO1xuICAgIG1hcFs4OF0gPSBbJ3gnLCAnWCddO1xuICAgIG1hcFs2N10gPSBbJ2MnLCAnQyddO1xuICAgIG1hcFs4Nl0gPSBbJ3YnLCAnViddO1xuICAgIG1hcFs2Nl0gPSBbJ2InLCAnQiddO1xuICAgIG1hcFs3OF0gPSBbJ24nLCAnTiddO1xuICAgIG1hcFs3N10gPSBbJ20nLCAnTSddO1xuICAgIG1hcFsxODhdID0gWycsJywgJzwnXTtcbiAgICBtYXBbMTkwXSA9IFsnLicsICc+J107XG4gICAgbWFwWzE5MV0gPSBbJy8nLCAnPyddO1xuICAgIG1hcFsxNl0gPSBbJ1NISUZUJywgJ1NISUZUJ107XG4gICAgbWFwWzE3XSA9IFsnQ1RSTCcsICdDVFJMU0hJRlQnXTtcbiAgICBtYXBbMThdID0gWydBTFQnLCAnQUxUU0hJRlQnXTtcbiAgICBtYXBbOTFdID0gWydDT01NQU5ETEVGVCcsICdDT01NQU5ETEVGVFNISUZUJ107XG4gICAgbWFwWzMyXSA9IFsnU1BBQ0UnLCAnU1BBQ0VTSElGVCddO1xuICAgIG1hcFs5M10gPSBbJ0NPTU1BTkRSSUdIVCcsICdDT01NQU5EUklHSFRTSElGVCddO1xuICAgIG1hcFsxOF0gPSBbJ0FMVCcsICdBTFRTSElGVCddO1xuICAgIG1hcFszOF0gPSBbJ1VQJywgJ1VQU0hJRlQnXTtcbiAgICBtYXBbMzddID0gWydMRUZUJywgJ0xFRlRTSElGVCddO1xuICAgIG1hcFs0MF0gPSBbJ0RPV04nLCAnRE9XTlNISUZUJ107XG4gICAgbWFwWzM5XSA9IFsnUklHSFQnLCAnUklHSFRTSElGVCddO1xuXG4gICAgbWFwWzMzXSA9IFsnUEFHRVVQJywgJ1BBR0VVUFNISUZUJ107XG4gICAgbWFwWzM0XSA9IFsnUEFHRURPV04nLCAnUEFHRURPV05TSElGVCddO1xuICAgIG1hcFszNV0gPSBbJ1BBR0VSSUdIVCcsICdQQUdFUklHSFRTSElGVCddO1xuICAgIG1hcFszNl0gPSBbJ1BBR0VMRUZUJywgJ1BBR0VMRUZUU0hJRlQnXTtcblxuICAgIHJldHVybiBtYXA7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQ2FudmFzO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY29uc29sZUxvZ2dlciA9IHJlcXVpcmUoJy4vZ2MtY29uc29sZS1sb2dnZXInKTtcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSBnYyAtIFRoZSAyLUQgZ3JhcGhpY3MgY29udGV4dCBmcm9tIHlvdXIgY2FudmFzXG4gKiBAcGFyYW0ge2Jvb2xlYW58YXBpTG9nZ2VyfSBbbG9nZ2VyPXRydWVdXG4gKiAqIGB0cnVlYCB1c2VzIGBnYy1jb25zb2xlLWxvZ2dlcmAgZnVuY3Rpb24gYm91bmQgdG8gJ2djLicgYXMgcHJlZml4XG4gKiAqIHN0cmluZyB1c2VzIGBnYy1jb25zb2xlLWxvZ2dlcmAgZnVuY3Rpb24gYm91bmQgdG8gc3RyaW5nXG4gKiAqIGZ1bmN0aW9uIHVzZWQgYXMgaXNcbiAqL1xuZnVuY3Rpb24gR3JhcGhpY3NDb250ZXh0KGdjLCBsb2dnZXIpIHtcbiAgICB0aGlzLmdjID0gZ2M7XG5cbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHJlV0VCS0lUID0gL153ZWJraXQvO1xuXG4gICAgc3dpdGNoICh0eXBlb2YgbG9nZ2VyKSB7XG5cbiAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgIGxvZ2dlciA9ICBjb25zb2xlTG9nZ2VyLmJpbmQodW5kZWZpbmVkLCBsb2dnZXIgKyAnLicpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgICAgICBpZiAobG9nZ2VyID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyID0gY29uc29sZUxvZ2dlci5iaW5kKHVuZGVmaW5lZCwgJ2djLicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnZnVuY3Rpb24nOlxuICAgICAgICAgICAgaWYgKGxvZ2dlci5sZW5ndGggIT09IDMpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyAnR3JhcGhpY3NDb250ZXh0OiBVc2VyLXN1cHBsaWVkIEFQSSBsb2dnZXIgZnVuY3Rpb24gZG9lcyBub3QgYWNjZXB0IHRocmVlIHBhcmFtZXRlcnMuJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBsb2dnZXIgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBTdHViIG91dCBhbGwgdGhlIHByb3RvdHlwZSBtZW1iZXJzIG9mIHRoZSBjYW52YXMgMkQgZ3JhcGhpY3MgY29udGV4dDpcbiAgICBPYmplY3Qua2V5cyhPYmplY3QuZ2V0UHJvdG90eXBlT2YoZ2MpKS5mb3JFYWNoKE1ha2VTdHViKTtcblxuICAgIC8vIFNvbWUgb2xkZXIgYnJvd3NlcnMgKGUuZy4sIENocm9tZSA0MCkgZGlkIG5vdCBoYXZlIGFsbCBtZW1iZXJzIG9mIGNhbnZhc1xuICAgIC8vIDJEIGdyYXBoaWNzIGNvbnRleHQgaW4gdGhlIHByb3RvdHlwZSBzbyB3ZSBtYWtlIHRoaXMgYWRkaXRpb25hbCBjYWxsOlxuICAgIE9iamVjdC5rZXlzKGdjKS5mb3JFYWNoKE1ha2VTdHViKTtcblxuICAgIGZ1bmN0aW9uIE1ha2VTdHViKGtleSkge1xuICAgICAgICBpZiAoa2V5IGluIEdyYXBoaWNzQ29udGV4dC5wcm90b3R5cGUgfHwgcmVXRUJLSVQudGVzdChrZXkpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBnY1trZXldID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBzZWxmW2tleV0gPSAhbG9nZ2VyID8gZ2Nba2V5XS5iaW5kKGdjKSA6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBsb2dnZXIoa2V5LCBhcmd1bWVudHMsIGdjW2tleV0uYXBwbHkoZ2MsIGFyZ3VtZW50cykpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShzZWxmLCBrZXksIHtcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gZ2Nba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGxvZ2dlciA/IGxvZ2dlcihrZXksICdnZXR0ZXInLCByZXN1bHQpIDogcmVzdWx0O1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICBnY1trZXldID0gbG9nZ2VyID8gbG9nZ2VyKGtleSwgJ3NldHRlcicsIHZhbHVlKSA6IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEdyYXBoaWNzQ29udGV4dDtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFlJRUxEUyA9ICdcXHUyN0Y5JzsgLy8gTE9ORyBSSUdIVFdBUkRTIERPVUJMRSBBUlJPV1xuXG5mdW5jdGlvbiBjb25zb2xlTG9nZ2VyKHByZWZpeCwgbmFtZSwgYXJncywgdmFsdWUpIHtcbiAgICB2YXIgcmVzdWx0ID0gdmFsdWU7XG5cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXN1bHQgPSAnXCInICsgcmVzdWx0ICsgJ1wiJztcbiAgICB9XG5cbiAgICBuYW1lID0gcHJlZml4ICsgbmFtZTtcblxuICAgIHN3aXRjaCAoYXJncykge1xuICAgICAgICBjYXNlICdnZXR0ZXInOlxuICAgICAgICAgICAgY29uc29sZS5sb2cobmFtZSwgJz0nLCByZXN1bHQpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSAnc2V0dGVyJzpcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKG5hbWUsIFlJRUxEUywgcmVzdWx0KTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6IC8vIG1ldGhvZCBjYWxsXG4gICAgICAgICAgICBuYW1lICs9ICcoJyArIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3MpLmpvaW4oJywgJykgKyAnKSc7XG4gICAgICAgICAgICBpZiAocmVzdWx0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhuYW1lKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2cobmFtZSwgWUlFTERTLCByZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb25zb2xlTG9nZ2VyO1xuIiwiLyogZXNsaW50LWRpc2FibGUgKi9cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IChjKSAyMDE0IFRoZSBQb2x5bWVyIFByb2plY3QgQXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqIFRoaXMgY29kZSBtYXkgb25seSBiZSB1c2VkIHVuZGVyIHRoZSBCU0Qgc3R5bGUgbGljZW5zZSBmb3VuZCBhdCBodHRwOi8vcG9seW1lci5naXRodWIuaW8vTElDRU5TRS50eHRcbiAqIFRoZSBjb21wbGV0ZSBzZXQgb2YgYXV0aG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0FVVEhPUlMudHh0XG4gKiBUaGUgY29tcGxldGUgc2V0IG9mIGNvbnRyaWJ1dG9ycyBtYXkgYmUgZm91bmQgYXQgaHR0cDovL3BvbHltZXIuZ2l0aHViLmlvL0NPTlRSSUJVVE9SUy50eHRcbiAqIENvZGUgZGlzdHJpYnV0ZWQgYnkgR29vZ2xlIGFzIHBhcnQgb2YgdGhlIHBvbHltZXIgcHJvamVjdCBpcyBhbHNvXG4gKiBzdWJqZWN0IHRvIGFuIGFkZGl0aW9uYWwgSVAgcmlnaHRzIGdyYW50IGZvdW5kIGF0IGh0dHA6Ly9wb2x5bWVyLmdpdGh1Yi5pby9QQVRFTlRTLnR4dFxuICovXG4vL21vZHVsZS5leHBvcnRzID0ge307XG5cbihmdW5jdGlvbihzY29wZSkge1xuICAgIHZhciBoYXNGdWxsUGF0aCA9IGZhbHNlO1xuXG4gICAgLy8gdGVzdCBmb3IgZnVsbCBldmVudCBwYXRoIHN1cHBvcnRcbiAgICB2YXIgcGF0aFRlc3QgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdtZXRhJyk7XG4gICAgaWYgKHBhdGhUZXN0LmNyZWF0ZVNoYWRvd1Jvb3QpIHtcbiAgICAgICAgdmFyIHNyID0gcGF0aFRlc3QuY3JlYXRlU2hhZG93Um9vdCgpO1xuICAgICAgICB2YXIgcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgICAgc3IuYXBwZW5kQ2hpbGQocyk7XG4gICAgICAgIHBhdGhUZXN0LmFkZEV2ZW50TGlzdGVuZXIoJ3Rlc3RwYXRoJywgZnVuY3Rpb24oZXYpIHtcbiAgICAgICAgICAgIGlmIChldi5wYXRoKSB7XG4gICAgICAgICAgICAgICAgLy8gaWYgdGhlIHNwYW4gaXMgaW4gdGhlIGV2ZW50IHBhdGgsIHRoZW4gcGF0aFswXSBpcyB0aGUgcmVhbCBzb3VyY2UgZm9yIGFsbCBldmVudHNcbiAgICAgICAgICAgICAgICBoYXNGdWxsUGF0aCA9IGV2LnBhdGhbMF0gPT09IHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBldi5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBldiA9IG5ldyBDdXN0b21FdmVudCgndGVzdHBhdGgnLCB7XG4gICAgICAgICAgICBidWJibGVzOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBtdXN0IGFkZCBub2RlIHRvIERPTSB0byB0cmlnZ2VyIGV2ZW50IGxpc3RlbmVyXG4gICAgICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQocGF0aFRlc3QpO1xuICAgICAgICBzLmRpc3BhdGNoRXZlbnQoZXYpO1xuICAgICAgICBwYXRoVGVzdC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHBhdGhUZXN0KTtcbiAgICAgICAgc3IgPSBzID0gbnVsbDtcbiAgICB9XG4gICAgcGF0aFRlc3QgPSBudWxsO1xuXG4gICAgdmFyIHRhcmdldCA9IHtcbiAgICAgICAgc2hhZG93OiBmdW5jdGlvbihpbkVsKSB7XG4gICAgICAgICAgICBpZiAoaW5FbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBpbkVsLnNoYWRvd1Jvb3QgfHwgaW5FbC53ZWJraXRTaGFkb3dSb290O1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjYW5UYXJnZXQ6IGZ1bmN0aW9uKHNoYWRvdykge1xuICAgICAgICAgICAgcmV0dXJuIHNoYWRvdyAmJiBCb29sZWFuKHNoYWRvdy5lbGVtZW50RnJvbVBvaW50KTtcbiAgICAgICAgfSxcbiAgICAgICAgdGFyZ2V0aW5nU2hhZG93OiBmdW5jdGlvbihpbkVsKSB7XG4gICAgICAgICAgICB2YXIgcyA9IHRoaXMuc2hhZG93KGluRWwpO1xuICAgICAgICAgICAgaWYgKHRoaXMuY2FuVGFyZ2V0KHMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG9sZGVyU2hhZG93OiBmdW5jdGlvbihzaGFkb3cpIHtcbiAgICAgICAgICAgIHZhciBvcyA9IHNoYWRvdy5vbGRlclNoYWRvd1Jvb3Q7XG4gICAgICAgICAgICBpZiAoIW9zKSB7XG4gICAgICAgICAgICAgICAgdmFyIHNlID0gc2hhZG93LnF1ZXJ5U2VsZWN0b3IoJ3NoYWRvdycpO1xuICAgICAgICAgICAgICAgIGlmIChzZSkge1xuICAgICAgICAgICAgICAgICAgICBvcyA9IHNlLm9sZGVyU2hhZG93Um9vdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb3M7XG4gICAgICAgIH0sXG4gICAgICAgIGFsbFNoYWRvd3M6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgICAgIHZhciBzaGFkb3dzID0gW10sXG4gICAgICAgICAgICAgICAgcyA9IHRoaXMuc2hhZG93KGVsZW1lbnQpO1xuICAgICAgICAgICAgd2hpbGUgKHMpIHtcbiAgICAgICAgICAgICAgICBzaGFkb3dzLnB1c2gocyk7XG4gICAgICAgICAgICAgICAgcyA9IHRoaXMub2xkZXJTaGFkb3cocyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc2hhZG93cztcbiAgICAgICAgfSxcbiAgICAgICAgc2VhcmNoUm9vdDogZnVuY3Rpb24oaW5Sb290LCB4LCB5KSB7XG4gICAgICAgICAgICB2YXIgdCwgc3QsIHNyLCBvcztcbiAgICAgICAgICAgIGlmIChpblJvb3QpIHtcbiAgICAgICAgICAgICAgICB0ID0gaW5Sb290LmVsZW1lbnRGcm9tUG9pbnQoeCwgeSk7XG4gICAgICAgICAgICAgICAgaWYgKHQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZm91bmQgZWxlbWVudCwgY2hlY2sgaWYgaXQgaGFzIGEgU2hhZG93Um9vdFxuICAgICAgICAgICAgICAgICAgICBzciA9IHRoaXMudGFyZ2V0aW5nU2hhZG93KHQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaW5Sb290ICE9PSBkb2N1bWVudCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBjaGVjayBmb3Igc2libGluZyByb290c1xuICAgICAgICAgICAgICAgICAgICBzciA9IHRoaXMub2xkZXJTaGFkb3coaW5Sb290KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gc2VhcmNoIG90aGVyIHJvb3RzLCBmYWxsIGJhY2sgdG8gbGlnaHQgZG9tIGVsZW1lbnRcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZWFyY2hSb290KHNyLCB4LCB5KSB8fCB0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBvd25lcjogZnVuY3Rpb24oZWxlbWVudCkge1xuICAgICAgICAgICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHMgPSBlbGVtZW50O1xuICAgICAgICAgICAgLy8gd2FsayB1cCB1bnRpbCB5b3UgaGl0IHRoZSBzaGFkb3cgcm9vdCBvciBkb2N1bWVudFxuICAgICAgICAgICAgd2hpbGUgKHMucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgIHMgPSBzLnBhcmVudE5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyB0aGUgb3duZXIgZWxlbWVudCBpcyBleHBlY3RlZCB0byBiZSBhIERvY3VtZW50IG9yIFNoYWRvd1Jvb3RcbiAgICAgICAgICAgIGlmIChzLm5vZGVUeXBlICE9IE5vZGUuRE9DVU1FTlRfTk9ERSAmJiBzLm5vZGVUeXBlICE9IE5vZGUuRE9DVU1FTlRfRlJBR01FTlRfTk9ERSkge1xuICAgICAgICAgICAgICAgIHMgPSBkb2N1bWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBzO1xuICAgICAgICB9LFxuICAgICAgICBmaW5kVGFyZ2V0OiBmdW5jdGlvbihpbkV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoaGFzRnVsbFBhdGggJiYgaW5FdmVudC5wYXRoICYmIGluRXZlbnQucGF0aC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW5FdmVudC5wYXRoWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHggPSBpbkV2ZW50LmNsaWVudFgsXG4gICAgICAgICAgICAgICAgeSA9IGluRXZlbnQuY2xpZW50WTtcbiAgICAgICAgICAgIC8vIGlmIHRoZSBsaXN0ZW5lciBpcyBpbiB0aGUgc2hhZG93IHJvb3QsIGl0IGlzIG11Y2ggZmFzdGVyIHRvIHN0YXJ0IHRoZXJlXG4gICAgICAgICAgICB2YXIgcyA9IHRoaXMub3duZXIoaW5FdmVudC50YXJnZXQpO1xuICAgICAgICAgICAgLy8gaWYgeCwgeSBpcyBub3QgaW4gdGhpcyByb290LCBmYWxsIGJhY2sgdG8gZG9jdW1lbnQgc2VhcmNoXG4gICAgICAgICAgICBpZiAoIXMuZWxlbWVudEZyb21Qb2ludCh4LCB5KSkge1xuICAgICAgICAgICAgICAgIHMgPSBkb2N1bWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNlYXJjaFJvb3QocywgeCwgeSk7XG4gICAgICAgIH0sXG4gICAgICAgIGZpbmRUb3VjaEFjdGlvbjogZnVuY3Rpb24oaW5FdmVudCkge1xuICAgICAgICAgICAgdmFyIG47XG4gICAgICAgICAgICBpZiAoaGFzRnVsbFBhdGggJiYgaW5FdmVudC5wYXRoICYmIGluRXZlbnQucGF0aC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB2YXIgcGF0aCA9IGluRXZlbnQucGF0aDtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbiA9IHBhdGhbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChuLm5vZGVUeXBlID09PSBOb2RlLkVMRU1FTlRfTk9ERSAmJiBuLmhhc0F0dHJpYnV0ZSgndG91Y2gtYWN0aW9uJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBuLmdldEF0dHJpYnV0ZSgndG91Y2gtYWN0aW9uJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG4gPSBpbkV2ZW50LnRhcmdldDtcbiAgICAgICAgICAgICAgICB3aGlsZSAobikge1xuICAgICAgICAgICAgICAgICAgICBpZiAobi5ub2RlVHlwZSA9PT0gTm9kZS5FTEVNRU5UX05PREUgJiYgbi5oYXNBdHRyaWJ1dGUoJ3RvdWNoLWFjdGlvbicpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbi5nZXRBdHRyaWJ1dGUoJ3RvdWNoLWFjdGlvbicpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG4gPSBuLnBhcmVudE5vZGUgfHwgbi5ob3N0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGF1dG8gaXMgZGVmYXVsdFxuICAgICAgICAgICAgcmV0dXJuIFwiYXV0b1wiO1xuICAgICAgICB9LFxuICAgICAgICBMQ0E6IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgICAgIGlmIChhID09PSBiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoYSAmJiAhYikge1xuICAgICAgICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGIgJiYgIWEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghYiAmJiAhYSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkb2N1bWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGZhc3QgY2FzZSwgYSBpcyBhIGRpcmVjdCBkZXNjZW5kYW50IG9mIGIgb3IgdmljZSB2ZXJzYVxuICAgICAgICAgICAgaWYgKGEuY29udGFpbnMgJiYgYS5jb250YWlucyhiKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGIuY29udGFpbnMgJiYgYi5jb250YWlucyhhKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGFkZXB0aCA9IHRoaXMuZGVwdGgoYSk7XG4gICAgICAgICAgICB2YXIgYmRlcHRoID0gdGhpcy5kZXB0aChiKTtcbiAgICAgICAgICAgIHZhciBkID0gYWRlcHRoIC0gYmRlcHRoO1xuICAgICAgICAgICAgaWYgKGQgPj0gMCkge1xuICAgICAgICAgICAgICAgIGEgPSB0aGlzLndhbGsoYSwgZCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGIgPSB0aGlzLndhbGsoYiwgLWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKGEgJiYgYiAmJiBhICE9PSBiKSB7XG4gICAgICAgICAgICAgICAgYSA9IGEucGFyZW50Tm9kZSB8fCBhLmhvc3Q7XG4gICAgICAgICAgICAgICAgYiA9IGIucGFyZW50Tm9kZSB8fCBiLmhvc3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYTtcbiAgICAgICAgfSxcbiAgICAgICAgd2FsazogZnVuY3Rpb24obiwgdSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IG4gJiYgKGkgPCB1KTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgbiA9IG4ucGFyZW50Tm9kZSB8fCBuLmhvc3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbjtcbiAgICAgICAgfSxcbiAgICAgICAgZGVwdGg6IGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgICAgIHZhciBkID0gMDtcbiAgICAgICAgICAgIHdoaWxlIChuKSB7XG4gICAgICAgICAgICAgICAgZCsrO1xuICAgICAgICAgICAgICAgIG4gPSBuLnBhcmVudE5vZGUgfHwgbi5ob3N0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGQ7XG4gICAgICAgIH0sXG4gICAgICAgIGRlZXBDb250YWluczogZnVuY3Rpb24oYSwgYikge1xuICAgICAgICAgICAgdmFyIGNvbW1vbiA9IHRoaXMuTENBKGEsIGIpO1xuICAgICAgICAgICAgLy8gaWYgYSBpcyB0aGUgY29tbW9uIGFuY2VzdG9yLCBpdCBtdXN0IFwiZGVlcGx5XCIgY29udGFpbiBiXG4gICAgICAgICAgICByZXR1cm4gY29tbW9uID09PSBhO1xuICAgICAgICB9LFxuICAgICAgICBpbnNpZGVOb2RlOiBmdW5jdGlvbihub2RlLCB4LCB5KSB7XG4gICAgICAgICAgICB2YXIgcmVjdCA9IG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICByZXR1cm4gKHJlY3QubGVmdCA8PSB4KSAmJiAoeCA8PSByZWN0LnJpZ2h0KSAmJiAocmVjdC50b3AgPD0geSkgJiYgKHkgPD0gcmVjdC5ib3R0b20pO1xuICAgICAgICB9LFxuICAgICAgICBwYXRoOiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgdmFyIHA7XG4gICAgICAgICAgICBpZiAoaGFzRnVsbFBhdGggJiYgZXZlbnQucGF0aCAmJiBldmVudC5wYXRoLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHAgPSBldmVudC5wYXRoO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwID0gW107XG4gICAgICAgICAgICAgICAgdmFyIG4gPSB0aGlzLmZpbmRUYXJnZXQoZXZlbnQpO1xuICAgICAgICAgICAgICAgIHdoaWxlIChuKSB7XG4gICAgICAgICAgICAgICAgICAgIHAucHVzaChuKTtcbiAgICAgICAgICAgICAgICAgICAgbiA9IG4ucGFyZW50Tm9kZSB8fCBuLmhvc3Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHA7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHNjb3BlLnRhcmdldEZpbmRpbmcgPSB0YXJnZXQ7XG4gICAgLyoqXG4gICAgICogR2l2ZW4gYW4gZXZlbnQsIGZpbmRzIHRoZSBcImRlZXBlc3RcIiBub2RlIHRoYXQgY291bGQgaGF2ZSBiZWVuIHRoZSBvcmlnaW5hbCB0YXJnZXQgYmVmb3JlIFNoYWRvd0RPTSByZXRhcmdldHRpbmdcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RXZlbnR9IEV2ZW50IEFuIGV2ZW50IG9iamVjdCB3aXRoIGNsaWVudFggYW5kIGNsaWVudFkgcHJvcGVydGllc1xuICAgICAqIEByZXR1cm4ge0VsZW1lbnR9IFRoZSBwcm9iYWJsZSBldmVudCBvcmlnbmluYXRvclxuICAgICAqL1xuICAgIHNjb3BlLmZpbmRUYXJnZXQgPSB0YXJnZXQuZmluZFRhcmdldC5iaW5kKHRhcmdldCk7XG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyBpZiB0aGUgXCJjb250YWluZXJcIiBub2RlIGRlZXBseSBjb250YWlucyB0aGUgXCJjb250YWluZWVcIiBub2RlLCBpbmNsdWRpbmcgc2l0dWF0aW9ucyB3aGVyZSB0aGUgXCJjb250YWluZWVcIiBpcyBjb250YWluZWQgYnkgb25lIG9yIG1vcmUgU2hhZG93RE9NXG4gICAgICogcm9vdHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge05vZGV9IGNvbnRhaW5lclxuICAgICAqIEBwYXJhbSB7Tm9kZX0gY29udGFpbmVlXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBzY29wZS5kZWVwQ29udGFpbnMgPSB0YXJnZXQuZGVlcENvbnRhaW5zLmJpbmQodGFyZ2V0KTtcblxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgaWYgdGhlIHgveSBwb3NpdGlvbiBpcyBpbnNpZGUgdGhlIGdpdmVuIG5vZGUuXG4gICAgICpcbiAgICAgKiBFeGFtcGxlOlxuICAgICAqXG4gICAgICogICAgIGZ1bmN0aW9uIHVwSGFuZGxlcihldmVudCkge1xuICAgICAqICAgICAgIHZhciBpbm5vZGUgPSBQb2x5bWVyR2VzdHVyZXMuaW5zaWRlTm9kZShldmVudC50YXJnZXQsIGV2ZW50LmNsaWVudFgsIGV2ZW50LmNsaWVudFkpO1xuICAgICAqICAgICAgIGlmIChpbm5vZGUpIHtcbiAgICAgKiAgICAgICAgIC8vIHdhaXQgZm9yIHRhcD9cbiAgICAgKiAgICAgICB9IGVsc2Uge1xuICAgICAqICAgICAgICAgLy8gdGFwIHdpbGwgbmV2ZXIgaGFwcGVuXG4gICAgICogICAgICAgfVxuICAgICAqICAgICB9XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAgICAgKiBAcGFyYW0ge051bWJlcn0geCBTY3JlZW4gWCBwb3NpdGlvblxuICAgICAqIEBwYXJhbSB7TnVtYmVyfSB5IHNjcmVlbiBZIHBvc2l0aW9uXG4gICAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBzY29wZS5pbnNpZGVOb2RlID0gdGFyZ2V0Lmluc2lkZU5vZGU7XG5cbn0pKGV4cG9ydHMpO1xuXG4oZnVuY3Rpb24oKSB7XG4gICAgZnVuY3Rpb24gc2hhZG93U2VsZWN0b3Iodikge1xuICAgICAgICByZXR1cm4gJ2h0bWwgL2RlZXAvICcgKyBzZWxlY3Rvcih2KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBzZWxlY3Rvcih2KSB7XG4gICAgICAgIHJldHVybiAnW3RvdWNoLWFjdGlvbj1cIicgKyB2ICsgJ1wiXSc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcnVsZSh2KSB7XG4gICAgICAgIHJldHVybiAneyAtbXMtdG91Y2gtYWN0aW9uOiAnICsgdiArICc7IHRvdWNoLWFjdGlvbjogJyArIHYgKyAnO30nO1xuICAgIH1cbiAgICB2YXIgYXR0cmliMmNzcyA9IFtcbiAgICAgICAgJ25vbmUnLFxuICAgICAgICAnYXV0bycsXG4gICAgICAgICdwYW4teCcsXG4gICAgICAgICdwYW4teScsIHtcbiAgICAgICAgICAgIHJ1bGU6ICdwYW4teCBwYW4teScsXG4gICAgICAgICAgICBzZWxlY3RvcnM6IFtcbiAgICAgICAgICAgICAgICAncGFuLXggcGFuLXknLFxuICAgICAgICAgICAgICAgICdwYW4teSBwYW4teCdcbiAgICAgICAgICAgIF1cbiAgICAgICAgfSxcbiAgICAgICAgJ21hbmlwdWxhdGlvbidcbiAgICBdO1xuICAgIHZhciBzdHlsZXMgPSAnJztcbiAgICAvLyBvbmx5IGluc3RhbGwgc3R5bGVzaGVldCBpZiB0aGUgYnJvd3NlciBoYXMgdG91Y2ggYWN0aW9uIHN1cHBvcnRcbiAgICB2YXIgaGFzVG91Y2hBY3Rpb24gPSB0eXBlb2YgZG9jdW1lbnQuaGVhZC5zdHlsZS50b3VjaEFjdGlvbiA9PT0gJ3N0cmluZyc7XG4gICAgLy8gb25seSBhZGQgc2hhZG93IHNlbGVjdG9ycyBpZiBzaGFkb3dkb20gaXMgc3VwcG9ydGVkXG4gICAgdmFyIGhhc1NoYWRvd1Jvb3QgPSAhd2luZG93LlNoYWRvd0RPTVBvbHlmaWxsICYmIGRvY3VtZW50LmhlYWQuY3JlYXRlU2hhZG93Um9vdDtcblxuICAgIGlmIChoYXNUb3VjaEFjdGlvbikge1xuICAgICAgICBhdHRyaWIyY3NzLmZvckVhY2goZnVuY3Rpb24ocikge1xuICAgICAgICAgICAgaWYgKFN0cmluZyhyKSA9PT0gcikge1xuICAgICAgICAgICAgICAgIHN0eWxlcyArPSBzZWxlY3RvcihyKSArIHJ1bGUocikgKyAnXFxuJztcbiAgICAgICAgICAgICAgICBpZiAoaGFzU2hhZG93Um9vdCkge1xuICAgICAgICAgICAgICAgICAgICBzdHlsZXMgKz0gc2hhZG93U2VsZWN0b3IocikgKyBydWxlKHIpICsgJ1xcbic7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdHlsZXMgKz0gci5zZWxlY3RvcnMubWFwKHNlbGVjdG9yKSArIHJ1bGUoci5ydWxlKSArICdcXG4nO1xuICAgICAgICAgICAgICAgIGlmIChoYXNTaGFkb3dSb290KSB7XG4gICAgICAgICAgICAgICAgICAgIHN0eWxlcyArPSByLnNlbGVjdG9ycy5tYXAoc2hhZG93U2VsZWN0b3IpICsgcnVsZShyLnJ1bGUpICsgJ1xcbic7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICAgICAgICBlbC50ZXh0Q29udGVudCA9IHN0eWxlcztcbiAgICAgICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChlbCk7XG4gICAgfVxufSkoKTtcblxuLyoqXG4gKiBUaGlzIGlzIHRoZSBjb25zdHJ1Y3RvciBmb3IgbmV3IFBvaW50ZXJFdmVudHMuXG4gKlxuICogTmV3IFBvaW50ZXIgRXZlbnRzIG11c3QgYmUgZ2l2ZW4gYSB0eXBlLCBhbmQgYW4gb3B0aW9uYWwgZGljdGlvbmFyeSBvZlxuICogaW5pdGlhbGl6YXRpb24gcHJvcGVydGllcy5cbiAqXG4gKiBEdWUgdG8gY2VydGFpbiBwbGF0Zm9ybSByZXF1aXJlbWVudHMsIGV2ZW50cyByZXR1cm5lZCBmcm9tIHRoZSBjb25zdHJ1Y3RvclxuICogaWRlbnRpZnkgYXMgTW91c2VFdmVudHMuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge1N0cmluZ30gaW5UeXBlIFRoZSB0eXBlIG9mIHRoZSBldmVudCB0byBjcmVhdGUuXG4gKiBAcGFyYW0ge09iamVjdH0gW2luRGljdF0gQW4gb3B0aW9uYWwgZGljdGlvbmFyeSBvZiBpbml0aWFsIGV2ZW50IHByb3BlcnRpZXMuXG4gKiBAcmV0dXJuIHtFdmVudH0gQSBuZXcgUG9pbnRlckV2ZW50IG9mIHR5cGUgYGluVHlwZWAgYW5kIGluaXRpYWxpemVkIHdpdGggcHJvcGVydGllcyBmcm9tIGBpbkRpY3RgLlxuICovXG4oZnVuY3Rpb24oc2NvcGUpIHtcblxuICAgIHZhciBNT1VTRV9QUk9QUyA9IFtcbiAgICAgICAgJ2J1YmJsZXMnLFxuICAgICAgICAnY2FuY2VsYWJsZScsXG4gICAgICAgICd2aWV3JyxcbiAgICAgICAgJ2RldGFpbCcsXG4gICAgICAgICdzY3JlZW5YJyxcbiAgICAgICAgJ3NjcmVlblknLFxuICAgICAgICAnY2xpZW50WCcsXG4gICAgICAgICdjbGllbnRZJyxcbiAgICAgICAgJ2N0cmxLZXknLFxuICAgICAgICAnYWx0S2V5JyxcbiAgICAgICAgJ3NoaWZ0S2V5JyxcbiAgICAgICAgJ21ldGFLZXknLFxuICAgICAgICAnYnV0dG9uJyxcbiAgICAgICAgJ3JlbGF0ZWRUYXJnZXQnLFxuICAgICAgICAncGFnZVgnLFxuICAgICAgICAncGFnZVknXG4gICAgXTtcblxuICAgIHZhciBNT1VTRV9ERUZBVUxUUyA9IFtcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIGZhbHNlLFxuICAgICAgICBudWxsLFxuICAgICAgICBudWxsLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICAwLFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIGZhbHNlLFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgMCxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgMCxcbiAgICAgICAgMFxuICAgIF07XG5cbiAgICB2YXIgTk9QX0ZBQ1RPUlkgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge307XG4gICAgfTtcblxuICAgIHZhciBldmVudEZhY3RvcnkgPSB7XG4gICAgICAgIC8vIFRPRE8oZGZyZWVkbSk6IHRoaXMgaXMgb3ZlcnJpZGRlbiBieSB0YXAgcmVjb2duaXplciwgbmVlZHMgcmV2aWV3XG4gICAgICAgIHByZXZlbnRUYXA6IE5PUF9GQUNUT1JZLFxuICAgICAgICBtYWtlQmFzZUV2ZW50OiBmdW5jdGlvbihpblR5cGUsIGluRGljdCkge1xuICAgICAgICAgICAgdmFyIGUgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnRXZlbnQnKTtcbiAgICAgICAgICAgIGUuaW5pdEV2ZW50KGluVHlwZSwgaW5EaWN0LmJ1YmJsZXMgfHwgZmFsc2UsIGluRGljdC5jYW5jZWxhYmxlIHx8IGZhbHNlKTtcbiAgICAgICAgICAgIGUucHJldmVudFRhcCA9IGV2ZW50RmFjdG9yeS5wcmV2ZW50VGFwKGUpO1xuICAgICAgICAgICAgcmV0dXJuIGU7XG4gICAgICAgIH0sXG4gICAgICAgIG1ha2VHZXN0dXJlRXZlbnQ6IGZ1bmN0aW9uKGluVHlwZSwgaW5EaWN0KSB7XG4gICAgICAgICAgICBpbkRpY3QgPSBpbkRpY3QgfHwgT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAgICAgICAgICAgdmFyIGUgPSB0aGlzLm1ha2VCYXNlRXZlbnQoaW5UeXBlLCBpbkRpY3QpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGtleXMgPSBPYmplY3Qua2V5cyhpbkRpY3QpLCBrOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGsgPSBrZXlzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChrICE9PSAnYnViYmxlcycgJiYgayAhPT0gJ2NhbmNlbGFibGUnKSB7XG4gICAgICAgICAgICAgICAgICAgIGVba10gPSBpbkRpY3Rba107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGU7XG4gICAgICAgIH0sXG4gICAgICAgIG1ha2VQb2ludGVyRXZlbnQ6IGZ1bmN0aW9uKGluVHlwZSwgaW5EaWN0KSB7XG4gICAgICAgICAgICBpbkRpY3QgPSBpbkRpY3QgfHwgT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAgICAgICAgICAgdmFyIGUgPSB0aGlzLm1ha2VCYXNlRXZlbnQoaW5UeXBlLCBpbkRpY3QpO1xuICAgICAgICAgICAgLy8gZGVmaW5lIGluaGVyaXRlZCBNb3VzZUV2ZW50IHByb3BlcnRpZXNcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAyLCBwOyBpIDwgTU9VU0VfUFJPUFMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBwID0gTU9VU0VfUFJPUFNbaV07XG4gICAgICAgICAgICAgICAgZVtwXSA9IGluRGljdFtwXSB8fCBNT1VTRV9ERUZBVUxUU1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGUuYnV0dG9ucyA9IGluRGljdC5idXR0b25zIHx8IDA7XG5cbiAgICAgICAgICAgIC8vIFNwZWMgcmVxdWlyZXMgdGhhdCBwb2ludGVycyB3aXRob3V0IHByZXNzdXJlIHNwZWNpZmllZCB1c2UgMC41IGZvciBkb3duXG4gICAgICAgICAgICAvLyBzdGF0ZSBhbmQgMCBmb3IgdXAgc3RhdGUuXG4gICAgICAgICAgICB2YXIgcHJlc3N1cmUgPSAwO1xuICAgICAgICAgICAgaWYgKGluRGljdC5wcmVzc3VyZSkge1xuICAgICAgICAgICAgICAgIHByZXNzdXJlID0gaW5EaWN0LnByZXNzdXJlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwcmVzc3VyZSA9IGUuYnV0dG9ucyA/IDAuNSA6IDA7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGFkZCB4L3kgcHJvcGVydGllcyBhbGlhc2VkIHRvIGNsaWVudFgvWVxuICAgICAgICAgICAgZS54ID0gZS5jbGllbnRYO1xuICAgICAgICAgICAgZS55ID0gZS5jbGllbnRZO1xuXG4gICAgICAgICAgICAvLyBkZWZpbmUgdGhlIHByb3BlcnRpZXMgb2YgdGhlIFBvaW50ZXJFdmVudCBpbnRlcmZhY2VcbiAgICAgICAgICAgIGUucG9pbnRlcklkID0gaW5EaWN0LnBvaW50ZXJJZCB8fCAwO1xuICAgICAgICAgICAgZS53aWR0aCA9IGluRGljdC53aWR0aCB8fCAwO1xuICAgICAgICAgICAgZS5oZWlnaHQgPSBpbkRpY3QuaGVpZ2h0IHx8IDA7XG4gICAgICAgICAgICBlLnByZXNzdXJlID0gcHJlc3N1cmU7XG4gICAgICAgICAgICBlLnRpbHRYID0gaW5EaWN0LnRpbHRYIHx8IDA7XG4gICAgICAgICAgICBlLnRpbHRZID0gaW5EaWN0LnRpbHRZIHx8IDA7XG4gICAgICAgICAgICBlLnBvaW50ZXJUeXBlID0gaW5EaWN0LnBvaW50ZXJUeXBlIHx8ICcnO1xuICAgICAgICAgICAgZS5od1RpbWVzdGFtcCA9IGluRGljdC5od1RpbWVzdGFtcCB8fCAwO1xuICAgICAgICAgICAgZS5pc1ByaW1hcnkgPSBpbkRpY3QuaXNQcmltYXJ5IHx8IGZhbHNlO1xuICAgICAgICAgICAgZS5fc291cmNlID0gaW5EaWN0Ll9zb3VyY2UgfHwgJyc7XG4gICAgICAgICAgICByZXR1cm4gZTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBzY29wZS5ldmVudEZhY3RvcnkgPSBldmVudEZhY3Rvcnk7XG59KShleHBvcnRzKTtcblxuLyoqXG4gKiBUaGlzIG1vZHVsZSBpbXBsZW1lbnRzIGFuIG1hcCBvZiBwb2ludGVyIHN0YXRlc1xuICovXG4oZnVuY3Rpb24oc2NvcGUpIHtcbiAgICB2YXIgVVNFX01BUCA9IHdpbmRvdy5NYXAgJiYgd2luZG93Lk1hcC5wcm90b3R5cGUuZm9yRWFjaDtcbiAgICB2YXIgUE9JTlRFUlNfRk4gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2l6ZTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gUG9pbnRlck1hcCgpIHtcbiAgICAgICAgaWYgKFVTRV9NQVApIHtcbiAgICAgICAgICAgIHZhciBtID0gbmV3IE1hcCgpO1xuICAgICAgICAgICAgbS5wb2ludGVycyA9IFBPSU5URVJTX0ZOO1xuICAgICAgICAgICAgcmV0dXJuIG07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmtleXMgPSBbXTtcbiAgICAgICAgICAgIHRoaXMudmFsdWVzID0gW107XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBQb2ludGVyTWFwLnByb3RvdHlwZSA9IHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbihpbklkLCBpbkV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgaSA9IHRoaXMua2V5cy5pbmRleE9mKGluSWQpO1xuICAgICAgICAgICAgaWYgKGkgPiAtMSkge1xuICAgICAgICAgICAgICAgIHRoaXMudmFsdWVzW2ldID0gaW5FdmVudDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5rZXlzLnB1c2goaW5JZCk7XG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZXMucHVzaChpbkV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgaGFzOiBmdW5jdGlvbihpbklkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5rZXlzLmluZGV4T2YoaW5JZCkgPiAtMTtcbiAgICAgICAgfSxcbiAgICAgICAgJ2RlbGV0ZSc6IGZ1bmN0aW9uKGluSWQpIHtcbiAgICAgICAgICAgIHZhciBpID0gdGhpcy5rZXlzLmluZGV4T2YoaW5JZCk7XG4gICAgICAgICAgICBpZiAoaSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5rZXlzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICB0aGlzLnZhbHVlcy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGdldDogZnVuY3Rpb24oaW5JZCkge1xuICAgICAgICAgICAgdmFyIGkgPSB0aGlzLmtleXMuaW5kZXhPZihpbklkKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZhbHVlc1tpXTtcbiAgICAgICAgfSxcbiAgICAgICAgY2xlYXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhpcy5rZXlzLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICB0aGlzLnZhbHVlcy5sZW5ndGggPSAwO1xuICAgICAgICB9LFxuICAgICAgICAvLyByZXR1cm4gdmFsdWUsIGtleSwgbWFwXG4gICAgICAgIGZvckVhY2g6IGZ1bmN0aW9uKGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlcy5mb3JFYWNoKGZ1bmN0aW9uKHYsIGkpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjay5jYWxsKHRoaXNBcmcsIHYsIHRoaXMua2V5c1tpXSwgdGhpcyk7XG4gICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgfSxcbiAgICAgICAgcG9pbnRlcnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMua2V5cy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgc2NvcGUuUG9pbnRlck1hcCA9IFBvaW50ZXJNYXA7XG59KShleHBvcnRzKTtcblxuKGZ1bmN0aW9uKHNjb3BlKSB7XG4gICAgdmFyIENMT05FX1BST1BTID0gW1xuICAgICAgICAvLyBNb3VzZUV2ZW50XG4gICAgICAgICdidWJibGVzJyxcbiAgICAgICAgJ2NhbmNlbGFibGUnLFxuICAgICAgICAndmlldycsXG4gICAgICAgICdkZXRhaWwnLFxuICAgICAgICAnc2NyZWVuWCcsXG4gICAgICAgICdzY3JlZW5ZJyxcbiAgICAgICAgJ2NsaWVudFgnLFxuICAgICAgICAnY2xpZW50WScsXG4gICAgICAgICdjdHJsS2V5JyxcbiAgICAgICAgJ2FsdEtleScsXG4gICAgICAgICdzaGlmdEtleScsXG4gICAgICAgICdtZXRhS2V5JyxcbiAgICAgICAgJ2J1dHRvbicsXG4gICAgICAgICdyZWxhdGVkVGFyZ2V0JyxcbiAgICAgICAgLy8gRE9NIExldmVsIDNcbiAgICAgICAgJ2J1dHRvbnMnLFxuICAgICAgICAvLyBQb2ludGVyRXZlbnRcbiAgICAgICAgJ3BvaW50ZXJJZCcsXG4gICAgICAgICd3aWR0aCcsXG4gICAgICAgICdoZWlnaHQnLFxuICAgICAgICAncHJlc3N1cmUnLFxuICAgICAgICAndGlsdFgnLFxuICAgICAgICAndGlsdFknLFxuICAgICAgICAncG9pbnRlclR5cGUnLFxuICAgICAgICAnaHdUaW1lc3RhbXAnLFxuICAgICAgICAnaXNQcmltYXJ5JyxcbiAgICAgICAgLy8gZXZlbnQgaW5zdGFuY2VcbiAgICAgICAgJ3R5cGUnLFxuICAgICAgICAndGFyZ2V0JyxcbiAgICAgICAgJ2N1cnJlbnRUYXJnZXQnLFxuICAgICAgICAnd2hpY2gnLFxuICAgICAgICAncGFnZVgnLFxuICAgICAgICAncGFnZVknLFxuICAgICAgICAndGltZVN0YW1wJyxcbiAgICAgICAgLy8gZ2VzdHVyZSBhZGRvbnNcbiAgICAgICAgJ3ByZXZlbnRUYXAnLFxuICAgICAgICAndGFwUHJldmVudGVkJyxcbiAgICAgICAgJ19zb3VyY2UnXG4gICAgXTtcblxuICAgIHZhciBDTE9ORV9ERUZBVUxUUyA9IFtcbiAgICAgICAgLy8gTW91c2VFdmVudFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIG51bGwsXG4gICAgICAgIG51bGwsXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIDAsXG4gICAgICAgIGZhbHNlLFxuICAgICAgICBmYWxzZSxcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIGZhbHNlLFxuICAgICAgICAwLFxuICAgICAgICBudWxsLFxuICAgICAgICAvLyBET00gTGV2ZWwgM1xuICAgICAgICAwLFxuICAgICAgICAvLyBQb2ludGVyRXZlbnRcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgJycsXG4gICAgICAgIDAsXG4gICAgICAgIGZhbHNlLFxuICAgICAgICAvLyBldmVudCBpbnN0YW5jZVxuICAgICAgICAnJyxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgbnVsbCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgZnVuY3Rpb24oKSB7fSxcbiAgICAgICAgZmFsc2VcbiAgICBdO1xuXG4gICAgdmFyIEhBU19TVkdfSU5TVEFOQ0UgPSAodHlwZW9mIFNWR0VsZW1lbnRJbnN0YW5jZSAhPT0gJ3VuZGVmaW5lZCcpO1xuXG4gICAgdmFyIGV2ZW50RmFjdG9yeSA9IHNjb3BlLmV2ZW50RmFjdG9yeTtcblxuICAgIC8vIHNldCBvZiByZWNvZ25pemVycyB0byBydW4gZm9yIHRoZSBjdXJyZW50bHkgaGFuZGxlZCBldmVudFxuICAgIHZhciBjdXJyZW50R2VzdHVyZXM7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1vZHVsZSBpcyBmb3Igbm9ybWFsaXppbmcgZXZlbnRzLiBNb3VzZSBhbmQgVG91Y2ggZXZlbnRzIHdpbGwgYmVcbiAgICAgKiBjb2xsZWN0ZWQgaGVyZSwgYW5kIGZpcmUgUG9pbnRlckV2ZW50cyB0aGF0IGhhdmUgdGhlIHNhbWUgc2VtYW50aWNzLCBub1xuICAgICAqIG1hdHRlciB0aGUgc291cmNlLlxuICAgICAqIEV2ZW50cyBmaXJlZDpcbiAgICAgKiAgIC0gcG9pbnRlcmRvd246IGEgcG9pbnRpbmcgaXMgYWRkZWRcbiAgICAgKiAgIC0gcG9pbnRlcnVwOiBhIHBvaW50ZXIgaXMgcmVtb3ZlZFxuICAgICAqICAgLSBwb2ludGVybW92ZTogYSBwb2ludGVyIGlzIG1vdmVkXG4gICAgICogICAtIHBvaW50ZXJvdmVyOiBhIHBvaW50ZXIgY3Jvc3NlcyBpbnRvIGFuIGVsZW1lbnRcbiAgICAgKiAgIC0gcG9pbnRlcm91dDogYSBwb2ludGVyIGxlYXZlcyBhbiBlbGVtZW50XG4gICAgICogICAtIHBvaW50ZXJjYW5jZWw6IGEgcG9pbnRlciB3aWxsIG5vIGxvbmdlciBnZW5lcmF0ZSBldmVudHNcbiAgICAgKi9cbiAgICB2YXIgZGlzcGF0Y2hlciA9IHtcbiAgICAgICAgSVNfSU9TOiBmYWxzZSxcbiAgICAgICAgcG9pbnRlcm1hcDogbmV3IHNjb3BlLlBvaW50ZXJNYXAoKSxcbiAgICAgICAgcmVxdWlyZWRHZXN0dXJlczogbmV3IHNjb3BlLlBvaW50ZXJNYXAoKSxcbiAgICAgICAgZXZlbnRNYXA6IE9iamVjdC5jcmVhdGUobnVsbCksXG4gICAgICAgIC8vIFNjb3BlIG9iamVjdHMgZm9yIG5hdGl2ZSBldmVudHMuXG4gICAgICAgIC8vIFRoaXMgZXhpc3RzIGZvciBlYXNlIG9mIHRlc3RpbmcuXG4gICAgICAgIGV2ZW50U291cmNlczogT2JqZWN0LmNyZWF0ZShudWxsKSxcbiAgICAgICAgZXZlbnRTb3VyY2VMaXN0OiBbXSxcbiAgICAgICAgZ2VzdHVyZXM6IFtdLFxuICAgICAgICAvLyBtYXAgZ2VzdHVyZSBldmVudCAtPiB7bGlzdGVuZXJzOiBpbnQsIGluZGV4OiBnZXN0dXJlc1tpbnRdfVxuICAgICAgICBkZXBlbmRlbmN5TWFwOiB7XG4gICAgICAgICAgICAvLyBtYWtlIHN1cmUgZG93biBhbmQgdXAgYXJlIGluIHRoZSBtYXAgdG8gdHJpZ2dlciBcInJlZ2lzdGVyXCJcbiAgICAgICAgICAgIGRvd246IHtcbiAgICAgICAgICAgICAgICBsaXN0ZW5lcnM6IDAsXG4gICAgICAgICAgICAgICAgaW5kZXg6IC0xXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdXA6IHtcbiAgICAgICAgICAgICAgICBsaXN0ZW5lcnM6IDAsXG4gICAgICAgICAgICAgICAgaW5kZXg6IC0xXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGdlc3R1cmVRdWV1ZTogW10sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBZGQgYSBuZXcgZXZlbnQgc291cmNlIHRoYXQgd2lsbCBnZW5lcmF0ZSBwb2ludGVyIGV2ZW50cy5cbiAgICAgICAgICpcbiAgICAgICAgICogYGluU291cmNlYCBtdXN0IGNvbnRhaW4gYW4gYXJyYXkgb2YgZXZlbnQgbmFtZXMgbmFtZWQgYGV2ZW50c2AsIGFuZFxuICAgICAgICAgKiBmdW5jdGlvbnMgd2l0aCB0aGUgbmFtZXMgc3BlY2lmaWVkIGluIHRoZSBgZXZlbnRzYCBhcnJheS5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgQSBuYW1lIGZvciB0aGUgZXZlbnQgc291cmNlXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgQSBuZXcgc291cmNlIG9mIHBsYXRmb3JtIGV2ZW50cy5cbiAgICAgICAgICovXG4gICAgICAgIHJlZ2lzdGVyU291cmNlOiBmdW5jdGlvbihuYW1lLCBzb3VyY2UpIHtcbiAgICAgICAgICAgIHZhciBzID0gc291cmNlO1xuICAgICAgICAgICAgdmFyIG5ld0V2ZW50cyA9IHMuZXZlbnRzO1xuICAgICAgICAgICAgaWYgKG5ld0V2ZW50cykge1xuICAgICAgICAgICAgICAgIG5ld0V2ZW50cy5mb3JFYWNoKGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNbZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZXZlbnRNYXBbZV0gPSBzW2VdLmJpbmQocyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgICAgICAgICB0aGlzLmV2ZW50U291cmNlc1tuYW1lXSA9IHM7XG4gICAgICAgICAgICAgICAgdGhpcy5ldmVudFNvdXJjZUxpc3QucHVzaChzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcmVnaXN0ZXJHZXN0dXJlOiBmdW5jdGlvbihuYW1lLCBzb3VyY2UpIHtcbiAgICAgICAgICAgIHZhciBvYmogPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgICAgb2JqLmxpc3RlbmVycyA9IDA7XG4gICAgICAgICAgICBvYmouaW5kZXggPSB0aGlzLmdlc3R1cmVzLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBnOyBpIDwgc291cmNlLmV4cG9zZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBnID0gc291cmNlLmV4cG9zZXNbaV0udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmRlcGVuZGVuY3lNYXBbZ10gPSBvYmo7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmdlc3R1cmVzLnB1c2goc291cmNlKTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVnaXN0ZXI6IGZ1bmN0aW9uKGVsZW1lbnQsIGluaXRpYWwpIHtcbiAgICAgICAgICAgIHZhciBsID0gdGhpcy5ldmVudFNvdXJjZUxpc3QubGVuZ3RoO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGVzO1xuICAgICAgICAgICAgICAgIChpIDwgbCkgJiYgKGVzID0gdGhpcy5ldmVudFNvdXJjZUxpc3RbaV0pOyBpKyspIHtcbiAgICAgICAgICAgICAgICAvLyBjYWxsIGV2ZW50c291cmNlIHJlZ2lzdGVyXG4gICAgICAgICAgICAgICAgZXMucmVnaXN0ZXIuY2FsbChlcywgZWxlbWVudCwgaW5pdGlhbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHVucmVnaXN0ZXI6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgICAgICAgIHZhciBsID0gdGhpcy5ldmVudFNvdXJjZUxpc3QubGVuZ3RoO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGVzO1xuICAgICAgICAgICAgICAgIChpIDwgbCkgJiYgKGVzID0gdGhpcy5ldmVudFNvdXJjZUxpc3RbaV0pOyBpKyspIHtcbiAgICAgICAgICAgICAgICAvLyBjYWxsIGV2ZW50c291cmNlIHJlZ2lzdGVyXG4gICAgICAgICAgICAgICAgZXMudW5yZWdpc3Rlci5jYWxsKGVzLCBlbGVtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLy8gRVZFTlRTXG4gICAgICAgIGRvd246IGZ1bmN0aW9uKGluRXZlbnQpIHtcbiAgICAgICAgICAgIHRoaXMucmVxdWlyZWRHZXN0dXJlcy5zZXQoaW5FdmVudC5wb2ludGVySWQsIGN1cnJlbnRHZXN0dXJlcyk7XG4gICAgICAgICAgICB0aGlzLmZpcmVFdmVudCgnZG93bicsIGluRXZlbnQpO1xuICAgICAgICB9LFxuICAgICAgICBtb3ZlOiBmdW5jdGlvbihpbkV2ZW50KSB7XG4gICAgICAgICAgICAvLyBwaXBlIG1vdmUgZXZlbnRzIGludG8gZ2VzdHVyZSBxdWV1ZSBkaXJlY3RseVxuICAgICAgICAgICAgaW5FdmVudC50eXBlID0gJ21vdmUnO1xuICAgICAgICAgICAgdGhpcy5maWxsR2VzdHVyZVF1ZXVlKGluRXZlbnQpO1xuICAgICAgICB9LFxuICAgICAgICB1cDogZnVuY3Rpb24oaW5FdmVudCkge1xuICAgICAgICAgICAgdGhpcy5maXJlRXZlbnQoJ3VwJywgaW5FdmVudCk7XG4gICAgICAgICAgICB0aGlzLnJlcXVpcmVkR2VzdHVyZXMuZGVsZXRlKGluRXZlbnQucG9pbnRlcklkKTtcbiAgICAgICAgfSxcbiAgICAgICAgY2FuY2VsOiBmdW5jdGlvbihpbkV2ZW50KSB7XG4gICAgICAgICAgICBpbkV2ZW50LnRhcFByZXZlbnRlZCA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmZpcmVFdmVudCgndXAnLCBpbkV2ZW50KTtcbiAgICAgICAgICAgIHRoaXMucmVxdWlyZWRHZXN0dXJlcy5kZWxldGUoaW5FdmVudC5wb2ludGVySWQpO1xuICAgICAgICB9LFxuICAgICAgICBhZGRHZXN0dXJlRGVwZW5kZW5jeTogZnVuY3Rpb24obm9kZSwgY3VycmVudEdlc3R1cmVzKSB7XG4gICAgICAgICAgICB2YXIgZ2VzdHVyZXNXYW50ZWQgPSBub2RlLl9wZ0V2ZW50cztcbiAgICAgICAgICAgIGlmIChnZXN0dXJlc1dhbnRlZCAmJiBjdXJyZW50R2VzdHVyZXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgZ2sgPSBPYmplY3Qua2V5cyhnZXN0dXJlc1dhbnRlZCk7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIHIsIHJpLCBnOyBpIDwgZ2subGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZ2VzdHVyZVxuICAgICAgICAgICAgICAgICAgICBnID0gZ2tbaV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChnZXN0dXJlc1dhbnRlZFtnXSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGxvb2t1cCBnZXN0dXJlIHJlY29nbml6ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIHIgPSB0aGlzLmRlcGVuZGVuY3lNYXBbZ107XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByZWNvZ25pemVyIGluZGV4XG4gICAgICAgICAgICAgICAgICAgICAgICByaSA9IHIgPyByLmluZGV4IDogLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50R2VzdHVyZXNbcmldID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLy8gTElTVEVORVIgTE9HSUNcbiAgICAgICAgZXZlbnRIYW5kbGVyOiBmdW5jdGlvbihpbkV2ZW50KSB7XG4gICAgICAgICAgICAvLyBUaGlzIGlzIHVzZWQgdG8gcHJldmVudCBtdWx0aXBsZSBkaXNwYXRjaCBvZiBldmVudHMgZnJvbVxuICAgICAgICAgICAgLy8gcGxhdGZvcm0gZXZlbnRzLiBUaGlzIGNhbiBoYXBwZW4gd2hlbiB0d28gZWxlbWVudHMgaW4gZGlmZmVyZW50IHNjb3Blc1xuICAgICAgICAgICAgLy8gYXJlIHNldCB1cCB0byBjcmVhdGUgcG9pbnRlciBldmVudHMsIHdoaWNoIGlzIHJlbGV2YW50IHRvIFNoYWRvdyBET00uXG5cbiAgICAgICAgICAgIHZhciB0eXBlID0gaW5FdmVudC50eXBlO1xuXG4gICAgICAgICAgICAvLyBvbmx5IGdlbmVyYXRlIHRoZSBsaXN0IG9mIGRlc2lyZWQgZXZlbnRzIG9uIFwiZG93blwiXG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gJ3RvdWNoc3RhcnQnIHx8IHR5cGUgPT09ICdtb3VzZWRvd24nIHx8IHR5cGUgPT09ICdwb2ludGVyZG93bicgfHwgdHlwZSA9PT0gJ01TUG9pbnRlckRvd24nKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpbkV2ZW50Ll9oYW5kbGVkQnlQRykge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50R2VzdHVyZXMgPSB7fTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBpbiBJT1MgbW9kZSwgdGhlcmUgaXMgb25seSBhIGxpc3RlbmVyIG9uIHRoZSBkb2N1bWVudCwgc28gdGhpcyBpcyBub3QgcmUtZW50cmFudFxuICAgICAgICAgICAgICAgIGlmICh0aGlzLklTX0lPUykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZXYgPSBpbkV2ZW50O1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gJ3RvdWNoc3RhcnQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY3QgPSBpbkV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2V0IHVwIGEgZmFrZSBldmVudCB0byBnaXZlIHRvIHRoZSBwYXRoIGJ1aWxkZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldDogaW5FdmVudC50YXJnZXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpZW50WDogY3QuY2xpZW50WCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGllbnRZOiBjdC5jbGllbnRZLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdGg6IGluRXZlbnQucGF0aFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyB1c2UgZXZlbnQgcGF0aCBpZiBhdmFpbGFibGUsIG90aGVyd2lzZSBidWlsZCBhIHBhdGggZnJvbSB0YXJnZXQgZmluZGluZ1xuICAgICAgICAgICAgICAgICAgICB2YXIgbm9kZXMgPSBpbkV2ZW50LnBhdGggfHwgc2NvcGUudGFyZ2V0RmluZGluZy5wYXRoKGV2KTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIG47IGkgPCBub2Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbiA9IG5vZGVzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRHZXN0dXJlRGVwZW5kZW5jeShuLCBjdXJyZW50R2VzdHVyZXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5hZGRHZXN0dXJlRGVwZW5kZW5jeShpbkV2ZW50LmN1cnJlbnRUYXJnZXQsIGN1cnJlbnRHZXN0dXJlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoaW5FdmVudC5faGFuZGxlZEJ5UEcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZm4gPSB0aGlzLmV2ZW50TWFwICYmIHRoaXMuZXZlbnRNYXBbdHlwZV07XG4gICAgICAgICAgICBpZiAoZm4pIHtcbiAgICAgICAgICAgICAgICBmbihpbkV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGluRXZlbnQuX2hhbmRsZWRCeVBHID0gdHJ1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gc2V0IHVwIGV2ZW50IGxpc3RlbmVyc1xuICAgICAgICBsaXN0ZW46IGZ1bmN0aW9uKHRhcmdldCwgZXZlbnRzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGV2ZW50cy5sZW5ndGgsIGU7XG4gICAgICAgICAgICAgICAgKGkgPCBsKSAmJiAoZSA9IGV2ZW50c1tpXSk7IGkrKykge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkRXZlbnQodGFyZ2V0LCBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLy8gcmVtb3ZlIGV2ZW50IGxpc3RlbmVyc1xuICAgICAgICB1bmxpc3RlbjogZnVuY3Rpb24odGFyZ2V0LCBldmVudHMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gZXZlbnRzLmxlbmd0aCwgZTtcbiAgICAgICAgICAgICAgICAoaSA8IGwpICYmIChlID0gZXZlbnRzW2ldKTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVFdmVudCh0YXJnZXQsIGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBhZGRFdmVudDogZnVuY3Rpb24odGFyZ2V0LCBldmVudE5hbWUpIHtcbiAgICAgICAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgdGhpcy5ib3VuZEhhbmRsZXIpO1xuICAgICAgICB9LFxuICAgICAgICByZW1vdmVFdmVudDogZnVuY3Rpb24odGFyZ2V0LCBldmVudE5hbWUpIHtcbiAgICAgICAgICAgIHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgdGhpcy5ib3VuZEhhbmRsZXIpO1xuICAgICAgICB9LFxuICAgICAgICAvLyBFVkVOVCBDUkVBVElPTiBBTkQgVFJBQ0tJTkdcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENyZWF0ZXMgYSBuZXcgRXZlbnQgb2YgdHlwZSBgaW5UeXBlYCwgYmFzZWQgb24gdGhlIGluZm9ybWF0aW9uIGluXG4gICAgICAgICAqIGBpbkV2ZW50YC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGluVHlwZSBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHR5cGUgb2YgZXZlbnQgdG8gY3JlYXRlXG4gICAgICAgICAqIEBwYXJhbSB7RXZlbnR9IGluRXZlbnQgQSBwbGF0Zm9ybSBldmVudCB3aXRoIGEgdGFyZ2V0XG4gICAgICAgICAqIEByZXR1cm4ge0V2ZW50fSBBIFBvaW50ZXJFdmVudCBvZiB0eXBlIGBpblR5cGVgXG4gICAgICAgICAqL1xuICAgICAgICBtYWtlRXZlbnQ6IGZ1bmN0aW9uKGluVHlwZSwgaW5FdmVudCkge1xuICAgICAgICAgICAgdmFyIGUgPSBldmVudEZhY3RvcnkubWFrZVBvaW50ZXJFdmVudChpblR5cGUsIGluRXZlbnQpO1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCA9IGluRXZlbnQucHJldmVudERlZmF1bHQ7XG4gICAgICAgICAgICBlLnRhcFByZXZlbnRlZCA9IGluRXZlbnQudGFwUHJldmVudGVkO1xuICAgICAgICAgICAgZS5fdGFyZ2V0ID0gZS5fdGFyZ2V0IHx8IGluRXZlbnQudGFyZ2V0O1xuICAgICAgICAgICAgcmV0dXJuIGU7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIG1ha2UgYW5kIGRpc3BhdGNoIGFuIGV2ZW50IGluIG9uZSBjYWxsXG4gICAgICAgIGZpcmVFdmVudDogZnVuY3Rpb24oaW5UeXBlLCBpbkV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgZSA9IHRoaXMubWFrZUV2ZW50KGluVHlwZSwgaW5FdmVudCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kaXNwYXRjaEV2ZW50KGUpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogUmV0dXJucyBhIHNuYXBzaG90IG9mIGluRXZlbnQsIHdpdGggd3JpdGFibGUgcHJvcGVydGllcy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtFdmVudH0gaW5FdmVudCBBbiBldmVudCB0aGF0IGNvbnRhaW5zIHByb3BlcnRpZXMgdG8gY29weS5cbiAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSBBbiBvYmplY3QgY29udGFpbmluZyBzaGFsbG93IGNvcGllcyBvZiBgaW5FdmVudGAnc1xuICAgICAgICAgKiAgICBwcm9wZXJ0aWVzLlxuICAgICAgICAgKi9cbiAgICAgICAgY2xvbmVFdmVudDogZnVuY3Rpb24oaW5FdmVudCkge1xuICAgICAgICAgICAgdmFyIGV2ZW50Q29weSA9IE9iamVjdC5jcmVhdGUobnVsbCksXG4gICAgICAgICAgICAgICAgcDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgQ0xPTkVfUFJPUFMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBwID0gQ0xPTkVfUFJPUFNbaV07XG4gICAgICAgICAgICAgICAgZXZlbnRDb3B5W3BdID0gaW5FdmVudFtwXSB8fCBDTE9ORV9ERUZBVUxUU1tpXTtcbiAgICAgICAgICAgICAgICAvLyBXb3JrIGFyb3VuZCBTVkdJbnN0YW5jZUVsZW1lbnQgc2hhZG93IHRyZWVcbiAgICAgICAgICAgICAgICAvLyBSZXR1cm4gdGhlIDx1c2U+IGVsZW1lbnQgdGhhdCBpcyByZXByZXNlbnRlZCBieSB0aGUgaW5zdGFuY2UgZm9yIFNhZmFyaSwgQ2hyb21lLCBJRS5cbiAgICAgICAgICAgICAgICAvLyBUaGlzIGlzIHRoZSBiZWhhdmlvciBpbXBsZW1lbnRlZCBieSBGaXJlZm94LlxuICAgICAgICAgICAgICAgIGlmIChwID09PSAndGFyZ2V0JyB8fCBwID09PSAncmVsYXRlZFRhcmdldCcpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKEhBU19TVkdfSU5TVEFOQ0UgJiYgZXZlbnRDb3B5W3BdIGluc3RhbmNlb2YgU1ZHRWxlbWVudEluc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudENvcHlbcF0gPSBldmVudENvcHlbcF0uY29ycmVzcG9uZGluZ1VzZUVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBrZWVwIHRoZSBzZW1hbnRpY3Mgb2YgcHJldmVudERlZmF1bHRcbiAgICAgICAgICAgIGV2ZW50Q29weS5wcmV2ZW50RGVmYXVsdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGluRXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXR1cm4gZXZlbnRDb3B5O1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogRGlzcGF0Y2hlcyB0aGUgZXZlbnQgdG8gaXRzIHRhcmdldC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtFdmVudH0gaW5FdmVudCBUaGUgZXZlbnQgdG8gYmUgZGlzcGF0Y2hlZC5cbiAgICAgICAgICogQHJldHVybiB7Qm9vbGVhbn0gVHJ1ZSBpZiBhbiBldmVudCBoYW5kbGVyIHJldHVybnMgdHJ1ZSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAgICAgKi9cbiAgICAgICAgZGlzcGF0Y2hFdmVudDogZnVuY3Rpb24oaW5FdmVudCkge1xuICAgICAgICAgICAgdmFyIHQgPSBpbkV2ZW50Ll90YXJnZXQ7XG4gICAgICAgICAgICBpZiAodCkge1xuICAgICAgICAgICAgICAgIHQuZGlzcGF0Y2hFdmVudChpbkV2ZW50KTtcbiAgICAgICAgICAgICAgICAvLyBjbG9uZSB0aGUgZXZlbnQgZm9yIHRoZSBnZXN0dXJlIHN5c3RlbSB0byBwcm9jZXNzXG4gICAgICAgICAgICAgICAgLy8gY2xvbmUgYWZ0ZXIgZGlzcGF0Y2ggdG8gcGljayB1cCBnZXN0dXJlIHByZXZlbnRpb24gY29kZVxuICAgICAgICAgICAgICAgIHZhciBjbG9uZSA9IHRoaXMuY2xvbmVFdmVudChpbkV2ZW50KTtcbiAgICAgICAgICAgICAgICBjbG9uZS50YXJnZXQgPSB0O1xuICAgICAgICAgICAgICAgIHRoaXMuZmlsbEdlc3R1cmVRdWV1ZShjbG9uZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGdlc3R1cmVUcmlnZ2VyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIHByb2Nlc3MgdGhlIGdlc3R1cmUgcXVldWVcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBlLCByZzsgaSA8IHRoaXMuZ2VzdHVyZVF1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgZSA9IHRoaXMuZ2VzdHVyZVF1ZXVlW2ldO1xuICAgICAgICAgICAgICAgIHJnID0gZS5fcmVxdWlyZWRHZXN0dXJlcztcbiAgICAgICAgICAgICAgICBpZiAocmcpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDAsIGcsIGZuOyBqIDwgdGhpcy5nZXN0dXJlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gb25seSBydW4gcmVjb2duaXplciBpZiBhbiBlbGVtZW50IGluIHRoZSBzb3VyY2UgZXZlbnQncyBwYXRoIGlzIGxpc3RlbmluZyBmb3IgdGhvc2UgZ2VzdHVyZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZ1tqXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGcgPSB0aGlzLmdlc3R1cmVzW2pdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZuID0gZ1tlLnR5cGVdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbi5jYWxsKGcsIGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZ2VzdHVyZVF1ZXVlLmxlbmd0aCA9IDA7XG4gICAgICAgIH0sXG4gICAgICAgIGZpbGxHZXN0dXJlUXVldWU6IGZ1bmN0aW9uKGV2KSB7XG4gICAgICAgICAgICAvLyBvbmx5IHRyaWdnZXIgdGhlIGdlc3R1cmUgcXVldWUgb25jZVxuICAgICAgICAgICAgaWYgKCF0aGlzLmdlc3R1cmVRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy5ib3VuZEdlc3R1cmVUcmlnZ2VyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGV2Ll9yZXF1aXJlZEdlc3R1cmVzID0gdGhpcy5yZXF1aXJlZEdlc3R1cmVzLmdldChldi5wb2ludGVySWQpO1xuICAgICAgICAgICAgdGhpcy5nZXN0dXJlUXVldWUucHVzaChldik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGRpc3BhdGNoZXIuYm91bmRIYW5kbGVyID0gZGlzcGF0Y2hlci5ldmVudEhhbmRsZXIuYmluZChkaXNwYXRjaGVyKTtcbiAgICBkaXNwYXRjaGVyLmJvdW5kR2VzdHVyZVRyaWdnZXIgPSBkaXNwYXRjaGVyLmdlc3R1cmVUcmlnZ2VyLmJpbmQoZGlzcGF0Y2hlcik7XG4gICAgc2NvcGUuZGlzcGF0Y2hlciA9IGRpc3BhdGNoZXI7XG5cbiAgICAvKipcbiAgICAgKiBMaXN0ZW4gZm9yIGBnZXN0dXJlYCBvbiBgbm9kZWAgd2l0aCB0aGUgYGhhbmRsZXJgIGZ1bmN0aW9uXG4gICAgICpcbiAgICAgKiBJZiBgaGFuZGxlcmAgaXMgdGhlIGZpcnN0IGxpc3RlbmVyIGZvciBgZ2VzdHVyZWAsIHRoZSB1bmRlcmx5aW5nIGdlc3R1cmUgcmVjb2duaXplciBpcyB0aGVuIGVuYWJsZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IG5vZGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZ2VzdHVyZVxuICAgICAqIEByZXR1cm4gQm9vbGVhbiBgZ2VzdHVyZWAgaXMgYSB2YWxpZCBnZXN0dXJlXG4gICAgICovXG4gICAgc2NvcGUuYWN0aXZhdGVHZXN0dXJlID0gZnVuY3Rpb24obm9kZSwgZ2VzdHVyZSkge1xuICAgICAgICB2YXIgZyA9IGdlc3R1cmUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgdmFyIGRlcCA9IGRpc3BhdGNoZXIuZGVwZW5kZW5jeU1hcFtnXTtcbiAgICAgICAgaWYgKGRlcCkge1xuICAgICAgICAgICAgdmFyIHJlY29nbml6ZXIgPSBkaXNwYXRjaGVyLmdlc3R1cmVzW2RlcC5pbmRleF07XG4gICAgICAgICAgICBpZiAoIW5vZGUuX3BnTGlzdGVuZXJzKSB7XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2hlci5yZWdpc3Rlcihub2RlKTtcbiAgICAgICAgICAgICAgICBub2RlLl9wZ0xpc3RlbmVycyA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBUT0RPKGRmcmVlZG0pOiByZS1ldmFsdWF0ZSBib29ra2VlcGluZyB0byBhdm9pZCB1c2luZyBhdHRyaWJ1dGVzXG4gICAgICAgICAgICBpZiAocmVjb2duaXplcikge1xuICAgICAgICAgICAgICAgIHZhciB0b3VjaEFjdGlvbiA9IHJlY29nbml6ZXIuZGVmYXVsdEFjdGlvbnMgJiYgcmVjb2duaXplci5kZWZhdWx0QWN0aW9uc1tnXTtcbiAgICAgICAgICAgICAgICB2YXIgYWN0aW9uTm9kZTtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKG5vZGUubm9kZVR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBOb2RlLkVMRU1FTlRfTk9ERTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbk5vZGUgPSBub2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgTm9kZS5ET0NVTUVOVF9GUkFHTUVOVF9OT0RFOlxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uTm9kZSA9IG5vZGUuaG9zdDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uTm9kZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRvdWNoQWN0aW9uICYmIGFjdGlvbk5vZGUgJiYgIWFjdGlvbk5vZGUuaGFzQXR0cmlidXRlKCd0b3VjaC1hY3Rpb24nKSkge1xuICAgICAgICAgICAgICAgICAgICBhY3Rpb25Ob2RlLnNldEF0dHJpYnV0ZSgndG91Y2gtYWN0aW9uJywgdG91Y2hBY3Rpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghbm9kZS5fcGdFdmVudHMpIHtcbiAgICAgICAgICAgICAgICBub2RlLl9wZ0V2ZW50cyA9IHt9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9kZS5fcGdFdmVudHNbZ10gPSAobm9kZS5fcGdFdmVudHNbZ10gfHwgMCkgKyAxO1xuICAgICAgICAgICAgbm9kZS5fcGdMaXN0ZW5lcnMrKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQm9vbGVhbihkZXApO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIExpc3RlbiBmb3IgYGdlc3R1cmVgIGZyb20gYG5vZGVgIHdpdGggYGhhbmRsZXJgIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtFbGVtZW50fSBub2RlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGdlc3R1cmVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBjYXB0dXJlXG4gICAgICovXG4gICAgc2NvcGUuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKG5vZGUsIGdlc3R1cmUsIGhhbmRsZXIsIGNhcHR1cmUpIHtcbiAgICAgICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgICAgICAgIHNjb3BlLmFjdGl2YXRlR2VzdHVyZShub2RlLCBnZXN0dXJlKTtcbiAgICAgICAgICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcihnZXN0dXJlLCBoYW5kbGVyLCBjYXB0dXJlKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBUZWFycyBkb3duIHRoZSBnZXN0dXJlIGNvbmZpZ3VyYXRpb24gZm9yIGBub2RlYFxuICAgICAqXG4gICAgICogSWYgYGhhbmRsZXJgIGlzIHRoZSBsYXN0IGxpc3RlbmVyIGZvciBgZ2VzdHVyZWAsIHRoZSB1bmRlcmx5aW5nIGdlc3R1cmUgcmVjb2duaXplciBpcyBkaXNhYmxlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBnZXN0dXJlXG4gICAgICogQHJldHVybiBCb29sZWFuIGBnZXN0dXJlYCBpcyBhIHZhbGlkIGdlc3R1cmVcbiAgICAgKi9cbiAgICBzY29wZS5kZWFjdGl2YXRlR2VzdHVyZSA9IGZ1bmN0aW9uKG5vZGUsIGdlc3R1cmUpIHtcbiAgICAgICAgdmFyIGcgPSBnZXN0dXJlLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHZhciBkZXAgPSBkaXNwYXRjaGVyLmRlcGVuZGVuY3lNYXBbZ107XG4gICAgICAgIGlmIChkZXApIHtcbiAgICAgICAgICAgIGlmIChub2RlLl9wZ0xpc3RlbmVycyA+IDApIHtcbiAgICAgICAgICAgICAgICBub2RlLl9wZ0xpc3RlbmVycy0tO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vZGUuX3BnTGlzdGVuZXJzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2hlci51bnJlZ2lzdGVyKG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG5vZGUuX3BnRXZlbnRzKSB7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUuX3BnRXZlbnRzW2ddID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBub2RlLl9wZ0V2ZW50c1tnXS0tO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuX3BnRXZlbnRzW2ddID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEJvb2xlYW4oZGVwKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogU3RvcCBsaXN0ZW5pbmcgZm9yIGBnZXN0dXJlYCBmcm9tIGBub2RlYCB3aXRoIGBoYW5kbGVyYCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RWxlbWVudH0gbm9kZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBnZXN0dXJlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlclxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gY2FwdHVyZVxuICAgICAqL1xuICAgIHNjb3BlLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbihub2RlLCBnZXN0dXJlLCBoYW5kbGVyLCBjYXB0dXJlKSB7XG4gICAgICAgIGlmIChoYW5kbGVyKSB7XG4gICAgICAgICAgICBzY29wZS5kZWFjdGl2YXRlR2VzdHVyZShub2RlLCBnZXN0dXJlKTtcbiAgICAgICAgICAgIG5vZGUucmVtb3ZlRXZlbnRMaXN0ZW5lcihnZXN0dXJlLCBoYW5kbGVyLCBjYXB0dXJlKTtcbiAgICAgICAgfVxuICAgIH07XG59KShleHBvcnRzKTtcblxuKGZ1bmN0aW9uKHNjb3BlKSB7XG4gICAgdmFyIGRpc3BhdGNoZXIgPSBzY29wZS5kaXNwYXRjaGVyO1xuICAgIHZhciBwb2ludGVybWFwID0gZGlzcGF0Y2hlci5wb2ludGVybWFwO1xuICAgIC8vIHJhZGl1cyBhcm91bmQgdG91Y2hlbmQgdGhhdCBzd2FsbG93cyBtb3VzZSBldmVudHNcbiAgICB2YXIgREVEVVBfRElTVCA9IDI1O1xuXG4gICAgdmFyIFdISUNIX1RPX0JVVFRPTlMgPSBbMCwgMSwgNCwgMl07XG5cbiAgICB2YXIgY3VycmVudEJ1dHRvbnMgPSAwO1xuXG4gICAgdmFyIEZJUkVGT1hfTElOVVggPSAvTGludXguKkZpcmVmb3hcXC8vaTtcblxuICAgIHZhciBIQVNfQlVUVE9OUyA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gZmlyZWZveCBvbiBsaW51eCByZXR1cm5zIHNwZWMtaW5jb3JyZWN0IHZhbHVlcyBmb3IgbW91c2V1cC5idXR0b25zXG4gICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9Nb3VzZUV2ZW50LmJ1dHRvbnMjU2VlX2Fsc29cbiAgICAgICAgLy8gaHR0cHM6Ly9jb2RlcmV2aWV3LmNocm9taXVtLm9yZy83Mjc1OTMwMDMvI21zZzE2XG4gICAgICAgIGlmIChGSVJFRk9YX0xJTlVYLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBNb3VzZUV2ZW50KCd0ZXN0Jywge1xuICAgICAgICAgICAgICAgIGJ1dHRvbnM6IDFcbiAgICAgICAgICAgIH0pLmJ1dHRvbnMgPT09IDE7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH0pKCk7XG5cbiAgICAvLyBoYW5kbGVyIGJsb2NrIGZvciBuYXRpdmUgbW91c2UgZXZlbnRzXG4gICAgdmFyIG1vdXNlRXZlbnRzID0ge1xuICAgICAgICBQT0lOVEVSX0lEOiAxLFxuICAgICAgICBQT0lOVEVSX1RZUEU6ICdtb3VzZScsXG4gICAgICAgIGV2ZW50czogW1xuICAgICAgICAgICAgJ21vdXNlZG93bicsXG4gICAgICAgICAgICAnbW91c2Vtb3ZlJyxcbiAgICAgICAgICAgICdtb3VzZXVwJ1xuICAgICAgICBdLFxuICAgICAgICBleHBvc2VzOiBbXG4gICAgICAgICAgICAnZG93bicsXG4gICAgICAgICAgICAndXAnLFxuICAgICAgICAgICAgJ21vdmUnXG4gICAgICAgIF0sXG4gICAgICAgIHJlZ2lzdGVyOiBmdW5jdGlvbih0YXJnZXQpIHtcbiAgICAgICAgICAgIGRpc3BhdGNoZXIubGlzdGVuKHRhcmdldCwgdGhpcy5ldmVudHMpO1xuICAgICAgICB9LFxuICAgICAgICB1bnJlZ2lzdGVyOiBmdW5jdGlvbih0YXJnZXQpIHtcbiAgICAgICAgICAgIGlmICh0YXJnZXQubm9kZVR5cGUgPT09IE5vZGUuRE9DVU1FTlRfTk9ERSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRpc3BhdGNoZXIudW5saXN0ZW4odGFyZ2V0LCB0aGlzLmV2ZW50cyk7XG4gICAgICAgIH0sXG4gICAgICAgIGxhc3RUb3VjaGVzOiBbXSxcbiAgICAgICAgLy8gY29sbGlkZSB3aXRoIHRoZSBnbG9iYWwgbW91c2UgbGlzdGVuZXJcbiAgICAgICAgaXNFdmVudFNpbXVsYXRlZEZyb21Ub3VjaDogZnVuY3Rpb24oaW5FdmVudCkge1xuICAgICAgICAgICAgdmFyIGx0cyA9IHRoaXMubGFzdFRvdWNoZXM7XG4gICAgICAgICAgICB2YXIgeCA9IGluRXZlbnQuY2xpZW50WCxcbiAgICAgICAgICAgICAgICB5ID0gaW5FdmVudC5jbGllbnRZO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBsdHMubGVuZ3RoLCB0OyBpIDwgbCAmJiAodCA9IGx0c1tpXSk7IGkrKykge1xuICAgICAgICAgICAgICAgIC8vIHNpbXVsYXRlZCBtb3VzZSBldmVudHMgd2lsbCBiZSBzd2FsbG93ZWQgbmVhciBhIHByaW1hcnkgdG91Y2hlbmRcbiAgICAgICAgICAgICAgICB2YXIgZHggPSBNYXRoLmFicyh4IC0gdC54KSxcbiAgICAgICAgICAgICAgICAgICAgZHkgPSBNYXRoLmFicyh5IC0gdC55KTtcbiAgICAgICAgICAgICAgICBpZiAoZHggPD0gREVEVVBfRElTVCAmJiBkeSA8PSBERURVUF9ESVNUKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcHJlcGFyZUV2ZW50OiBmdW5jdGlvbihpbkV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgZSA9IGRpc3BhdGNoZXIuY2xvbmVFdmVudChpbkV2ZW50KTtcbiAgICAgICAgICAgIGUucG9pbnRlcklkID0gdGhpcy5QT0lOVEVSX0lEO1xuICAgICAgICAgICAgZS5pc1ByaW1hcnkgPSB0cnVlO1xuICAgICAgICAgICAgZS5wb2ludGVyVHlwZSA9IHRoaXMuUE9JTlRFUl9UWVBFO1xuICAgICAgICAgICAgZS5fc291cmNlID0gJ21vdXNlJztcbiAgICAgICAgICAgIGlmICghSEFTX0JVVFRPTlMpIHtcbiAgICAgICAgICAgICAgICB2YXIgdHlwZSA9IGluRXZlbnQudHlwZTtcbiAgICAgICAgICAgICAgICB2YXIgYml0ID0gV0hJQ0hfVE9fQlVUVE9OU1tpbkV2ZW50LndoaWNoXSB8fCAwO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSAnbW91c2Vkb3duJykge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50QnV0dG9ucyB8PSBiaXQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnbW91c2V1cCcpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudEJ1dHRvbnMgJj0gfmJpdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZS5idXR0b25zID0gY3VycmVudEJ1dHRvbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZTtcbiAgICAgICAgfSxcbiAgICAgICAgbW91c2Vkb3duOiBmdW5jdGlvbihpbkV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuaXNFdmVudFNpbXVsYXRlZEZyb21Ub3VjaChpbkV2ZW50KSkge1xuICAgICAgICAgICAgICAgIHZhciBwID0gcG9pbnRlcm1hcC5oYXModGhpcy5QT0lOVEVSX0lEKTtcbiAgICAgICAgICAgICAgICB2YXIgZSA9IHRoaXMucHJlcGFyZUV2ZW50KGluRXZlbnQpO1xuICAgICAgICAgICAgICAgIGUudGFyZ2V0ID0gc2NvcGUuZmluZFRhcmdldChpbkV2ZW50KTtcbiAgICAgICAgICAgICAgICBwb2ludGVybWFwLnNldCh0aGlzLlBPSU5URVJfSUQsIGUudGFyZ2V0KTtcbiAgICAgICAgICAgICAgICBkaXNwYXRjaGVyLmRvd24oZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG1vdXNlbW92ZTogZnVuY3Rpb24oaW5FdmVudCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmlzRXZlbnRTaW11bGF0ZWRGcm9tVG91Y2goaW5FdmVudCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0ID0gcG9pbnRlcm1hcC5nZXQodGhpcy5QT0lOVEVSX0lEKTtcbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlID0gdGhpcy5wcmVwYXJlRXZlbnQoaW5FdmVudCk7XG4gICAgICAgICAgICAgICAgICAgIGUudGFyZ2V0ID0gdGFyZ2V0O1xuICAgICAgICAgICAgICAgICAgICAvLyBoYW5kbGUgY2FzZSB3aGVyZSB3ZSBtaXNzZWQgYSBtb3VzZXVwXG4gICAgICAgICAgICAgICAgICAgIGlmICgoSEFTX0JVVFRPTlMgPyBlLmJ1dHRvbnMgOiBlLndoaWNoKSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFIQVNfQlVUVE9OUykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRCdXR0b25zID0gZS5idXR0b25zID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoZXIuY2FuY2VsKGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jbGVhbnVwTW91c2UoZS5idXR0b25zKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoZXIubW92ZShlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgbW91c2V1cDogZnVuY3Rpb24oaW5FdmVudCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmlzRXZlbnRTaW11bGF0ZWRGcm9tVG91Y2goaW5FdmVudCkpIHtcbiAgICAgICAgICAgICAgICB2YXIgZSA9IHRoaXMucHJlcGFyZUV2ZW50KGluRXZlbnQpO1xuICAgICAgICAgICAgICAgIGUucmVsYXRlZFRhcmdldCA9IHNjb3BlLmZpbmRUYXJnZXQoaW5FdmVudCk7XG4gICAgICAgICAgICAgICAgZS50YXJnZXQgPSBwb2ludGVybWFwLmdldCh0aGlzLlBPSU5URVJfSUQpO1xuICAgICAgICAgICAgICAgIGRpc3BhdGNoZXIudXAoZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5jbGVhbnVwTW91c2UoZS5idXR0b25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgY2xlYW51cE1vdXNlOiBmdW5jdGlvbihidXR0b25zKSB7XG4gICAgICAgICAgICBpZiAoYnV0dG9ucyA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHBvaW50ZXJtYXAuZGVsZXRlKHRoaXMuUE9JTlRFUl9JRCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgc2NvcGUubW91c2VFdmVudHMgPSBtb3VzZUV2ZW50cztcbn0pKGV4cG9ydHMpO1xuXG4oZnVuY3Rpb24oc2NvcGUpIHtcbiAgICB2YXIgZGlzcGF0Y2hlciA9IHNjb3BlLmRpc3BhdGNoZXI7XG4gICAgdmFyIGFsbFNoYWRvd3MgPSBzY29wZS50YXJnZXRGaW5kaW5nLmFsbFNoYWRvd3MuYmluZChzY29wZS50YXJnZXRGaW5kaW5nKTtcbiAgICB2YXIgcG9pbnRlcm1hcCA9IGRpc3BhdGNoZXIucG9pbnRlcm1hcDtcbiAgICB2YXIgdG91Y2hNYXAgPSBBcnJheS5wcm90b3R5cGUubWFwLmNhbGwuYmluZChBcnJheS5wcm90b3R5cGUubWFwKTtcbiAgICAvLyBUaGlzIHNob3VsZCBiZSBsb25nIGVub3VnaCB0byBpZ25vcmUgY29tcGF0IG1vdXNlIGV2ZW50cyBtYWRlIGJ5IHRvdWNoXG4gICAgdmFyIERFRFVQX1RJTUVPVVQgPSAyNTAwO1xuICAgIHZhciBERURVUF9ESVNUID0gMjU7XG4gICAgdmFyIENMSUNLX0NPVU5UX1RJTUVPVVQgPSAyMDA7XG4gICAgdmFyIEhZU1RFUkVTSVMgPSAyMDtcbiAgICB2YXIgQVRUUklCID0gJ3RvdWNoLWFjdGlvbic7XG4gICAgLy8gVE9ETyhkZnJlZWRtKTogZGlzYWJsZSB1bnRpbCBodHRwOi8vY3JidWcuY29tLzM5OTc2NSBpcyByZXNvbHZlZFxuICAgIC8vIHZhciBIQVNfVE9VQ0hfQUNUSU9OID0gQVRUUklCIGluIGRvY3VtZW50LmhlYWQuc3R5bGU7XG4gICAgdmFyIEhBU19UT1VDSF9BQ1RJT04gPSBmYWxzZTtcblxuICAgIC8vIGhhbmRsZXIgYmxvY2sgZm9yIG5hdGl2ZSB0b3VjaCBldmVudHNcbiAgICB2YXIgdG91Y2hFdmVudHMgPSB7XG4gICAgICAgIElTX0lPUzogZmFsc2UsXG4gICAgICAgIGV2ZW50czogW1xuICAgICAgICAgICAgJ3RvdWNoc3RhcnQnLFxuICAgICAgICAgICAgJ3RvdWNobW92ZScsXG4gICAgICAgICAgICAndG91Y2hlbmQnLFxuICAgICAgICAgICAgJ3RvdWNoY2FuY2VsJ1xuICAgICAgICBdLFxuICAgICAgICBleHBvc2VzOiBbXG4gICAgICAgICAgICAnZG93bicsXG4gICAgICAgICAgICAndXAnLFxuICAgICAgICAgICAgJ21vdmUnXG4gICAgICAgIF0sXG4gICAgICAgIHJlZ2lzdGVyOiBmdW5jdGlvbih0YXJnZXQsIGluaXRpYWwpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLklTX0lPUyA/IGluaXRpYWwgOiAhaW5pdGlhbCkge1xuICAgICAgICAgICAgICAgIGRpc3BhdGNoZXIubGlzdGVuKHRhcmdldCwgdGhpcy5ldmVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB1bnJlZ2lzdGVyOiBmdW5jdGlvbih0YXJnZXQpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5JU19JT1MpIHtcbiAgICAgICAgICAgICAgICBkaXNwYXRjaGVyLnVubGlzdGVuKHRhcmdldCwgdGhpcy5ldmVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBzY3JvbGxUeXBlczoge1xuICAgICAgICAgICAgRU1JVFRFUjogJ25vbmUnLFxuICAgICAgICAgICAgWFNDUk9MTEVSOiAncGFuLXgnLFxuICAgICAgICAgICAgWVNDUk9MTEVSOiAncGFuLXknLFxuICAgICAgICB9LFxuICAgICAgICB0b3VjaEFjdGlvblRvU2Nyb2xsVHlwZTogZnVuY3Rpb24odG91Y2hBY3Rpb24pIHtcbiAgICAgICAgICAgIHZhciB0ID0gdG91Y2hBY3Rpb247XG4gICAgICAgICAgICB2YXIgc3QgPSB0aGlzLnNjcm9sbFR5cGVzO1xuICAgICAgICAgICAgaWYgKHQgPT09IHN0LkVNSVRURVIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ25vbmUnO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0ID09PSBzdC5YU0NST0xMRVIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ1gnO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0ID09PSBzdC5ZU0NST0xMRVIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ1knO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ1hZJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgUE9JTlRFUl9UWVBFOiAndG91Y2gnLFxuICAgICAgICBmaXJzdFRvdWNoOiBudWxsLFxuICAgICAgICBpc1ByaW1hcnlUb3VjaDogZnVuY3Rpb24oaW5Ub3VjaCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmlyc3RUb3VjaCA9PT0gaW5Ub3VjaC5pZGVudGlmaWVyO1xuICAgICAgICB9LFxuICAgICAgICBzZXRQcmltYXJ5VG91Y2g6IGZ1bmN0aW9uKGluVG91Y2gpIHtcbiAgICAgICAgICAgIC8vIHNldCBwcmltYXJ5IHRvdWNoIGlmIHRoZXJlIG5vIHBvaW50ZXJzLCBvciB0aGUgb25seSBwb2ludGVyIGlzIHRoZSBtb3VzZVxuICAgICAgICAgICAgaWYgKHBvaW50ZXJtYXAucG9pbnRlcnMoKSA9PT0gMCB8fCAocG9pbnRlcm1hcC5wb2ludGVycygpID09PSAxICYmIHBvaW50ZXJtYXAuaGFzKDEpKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZmlyc3RUb3VjaCA9IGluVG91Y2guaWRlbnRpZmllcjtcbiAgICAgICAgICAgICAgICB0aGlzLmZpcnN0WFkgPSB7XG4gICAgICAgICAgICAgICAgICAgIFg6IGluVG91Y2guY2xpZW50WCxcbiAgICAgICAgICAgICAgICAgICAgWTogaW5Ub3VjaC5jbGllbnRZXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0aGlzLmZpcnN0VGFyZ2V0ID0gaW5Ub3VjaC50YXJnZXQ7XG4gICAgICAgICAgICAgICAgdGhpcy5zY3JvbGxpbmcgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMuY2FuY2VsUmVzZXRDbGlja0NvdW50KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHJlbW92ZVByaW1hcnlQb2ludGVyOiBmdW5jdGlvbihpblBvaW50ZXIpIHtcbiAgICAgICAgICAgIGlmIChpblBvaW50ZXIuaXNQcmltYXJ5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5maXJzdFRvdWNoID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0aGlzLmZpcnN0WFkgPSBudWxsO1xuICAgICAgICAgICAgICAgIHRoaXMucmVzZXRDbGlja0NvdW50KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGNsaWNrQ291bnQ6IDAsXG4gICAgICAgIHJlc2V0SWQ6IG51bGwsXG4gICAgICAgIHJlc2V0Q2xpY2tDb3VudDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgZm4gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNsaWNrQ291bnQgPSAwO1xuICAgICAgICAgICAgICAgIHRoaXMucmVzZXRJZCA9IG51bGw7XG4gICAgICAgICAgICB9LmJpbmQodGhpcyk7XG4gICAgICAgICAgICB0aGlzLnJlc2V0SWQgPSBzZXRUaW1lb3V0KGZuLCBDTElDS19DT1VOVF9USU1FT1VUKTtcbiAgICAgICAgfSxcbiAgICAgICAgY2FuY2VsUmVzZXRDbGlja0NvdW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlc2V0SWQpIHtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5yZXNldElkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgdHlwZVRvQnV0dG9uczogZnVuY3Rpb24odHlwZSkge1xuICAgICAgICAgICAgdmFyIHJldCA9IDA7XG4gICAgICAgICAgICBpZiAodHlwZSA9PT0gJ3RvdWNoc3RhcnQnIHx8IHR5cGUgPT09ICd0b3VjaG1vdmUnKSB7XG4gICAgICAgICAgICAgICAgcmV0ID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH0sXG4gICAgICAgIGZpbmRUYXJnZXQ6IGZ1bmN0aW9uKHRvdWNoLCBpZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudFRvdWNoRXZlbnQudHlwZSA9PT0gJ3RvdWNoc3RhcnQnKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuaXNQcmltYXJ5VG91Y2godG91Y2gpKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBmYXN0UGF0aCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsaWVudFg6IHRvdWNoLmNsaWVudFgsXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGllbnRZOiB0b3VjaC5jbGllbnRZLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aDogdGhpcy5jdXJyZW50VG91Y2hFdmVudC5wYXRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiB0aGlzLmN1cnJlbnRUb3VjaEV2ZW50LnRhcmdldFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2NvcGUuZmluZFRhcmdldChmYXN0UGF0aCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNjb3BlLmZpbmRUYXJnZXQodG91Y2gpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHJldXNlIHRhcmdldCB3ZSBmb3VuZCBpbiB0b3VjaHN0YXJ0XG4gICAgICAgICAgICByZXR1cm4gcG9pbnRlcm1hcC5nZXQoaWQpO1xuICAgICAgICB9LFxuICAgICAgICB0b3VjaFRvUG9pbnRlcjogZnVuY3Rpb24oaW5Ub3VjaCkge1xuICAgICAgICAgICAgdmFyIGN0ZSA9IHRoaXMuY3VycmVudFRvdWNoRXZlbnQ7XG4gICAgICAgICAgICB2YXIgZSA9IGRpc3BhdGNoZXIuY2xvbmVFdmVudChpblRvdWNoKTtcbiAgICAgICAgICAgIC8vIFNwZWMgc3BlY2lmaWVzIHRoYXQgcG9pbnRlcklkIDEgaXMgcmVzZXJ2ZWQgZm9yIE1vdXNlLlxuICAgICAgICAgICAgLy8gVG91Y2ggaWRlbnRpZmllcnMgY2FuIHN0YXJ0IGF0IDAuXG4gICAgICAgICAgICAvLyBBZGQgMiB0byB0aGUgdG91Y2ggaWRlbnRpZmllciBmb3IgY29tcGF0aWJpbGl0eS5cbiAgICAgICAgICAgIHZhciBpZCA9IGUucG9pbnRlcklkID0gaW5Ub3VjaC5pZGVudGlmaWVyICsgMjtcbiAgICAgICAgICAgIGUudGFyZ2V0ID0gdGhpcy5maW5kVGFyZ2V0KGluVG91Y2gsIGlkKTtcbiAgICAgICAgICAgIGUuYnViYmxlcyA9IHRydWU7XG4gICAgICAgICAgICBlLmNhbmNlbGFibGUgPSB0cnVlO1xuICAgICAgICAgICAgZS5kZXRhaWwgPSB0aGlzLmNsaWNrQ291bnQ7XG4gICAgICAgICAgICBlLmJ1dHRvbnMgPSB0aGlzLnR5cGVUb0J1dHRvbnMoY3RlLnR5cGUpO1xuICAgICAgICAgICAgZS53aWR0aCA9IGluVG91Y2gud2Via2l0UmFkaXVzWCB8fCBpblRvdWNoLnJhZGl1c1ggfHwgMDtcbiAgICAgICAgICAgIGUuaGVpZ2h0ID0gaW5Ub3VjaC53ZWJraXRSYWRpdXNZIHx8IGluVG91Y2gucmFkaXVzWSB8fCAwO1xuICAgICAgICAgICAgZS5wcmVzc3VyZSA9IGluVG91Y2gud2Via2l0Rm9yY2UgfHwgaW5Ub3VjaC5mb3JjZSB8fCAwLjU7XG4gICAgICAgICAgICBlLmlzUHJpbWFyeSA9IHRoaXMuaXNQcmltYXJ5VG91Y2goaW5Ub3VjaCk7XG4gICAgICAgICAgICBlLnBvaW50ZXJUeXBlID0gdGhpcy5QT0lOVEVSX1RZUEU7XG4gICAgICAgICAgICBlLl9zb3VyY2UgPSAndG91Y2gnO1xuICAgICAgICAgICAgLy8gZm9yd2FyZCB0b3VjaCBwcmV2ZW50RGVmYXVsdHNcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBzZWxmLnNjcm9sbGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHNlbGYuZmlyc3RYWSA9IG51bGw7XG4gICAgICAgICAgICAgICAgY3RlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIGU7XG4gICAgICAgIH0sXG4gICAgICAgIHByb2Nlc3NUb3VjaGVzOiBmdW5jdGlvbihpbkV2ZW50LCBpbkZ1bmN0aW9uKSB7XG4gICAgICAgICAgICB2YXIgdGwgPSBpbkV2ZW50LmNoYW5nZWRUb3VjaGVzO1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50VG91Y2hFdmVudCA9IGluRXZlbnQ7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgdCwgcDsgaSA8IHRsLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdCA9IHRsW2ldO1xuICAgICAgICAgICAgICAgIHAgPSB0aGlzLnRvdWNoVG9Qb2ludGVyKHQpO1xuICAgICAgICAgICAgICAgIGlmIChpbkV2ZW50LnR5cGUgPT09ICd0b3VjaHN0YXJ0Jykge1xuICAgICAgICAgICAgICAgICAgICBwb2ludGVybWFwLnNldChwLnBvaW50ZXJJZCwgcC50YXJnZXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocG9pbnRlcm1hcC5oYXMocC5wb2ludGVySWQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGluRnVuY3Rpb24uY2FsbCh0aGlzLCBwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGluRXZlbnQudHlwZSA9PT0gJ3RvdWNoZW5kJyB8fCBpbkV2ZW50Ll9jYW5jZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbGVhblVwUG9pbnRlcihwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC8vIEZvciBzaW5nbGUgYXhpcyBzY3JvbGxlcnMsIGRldGVybWluZXMgd2hldGhlciB0aGUgZWxlbWVudCBzaG91bGQgZW1pdFxuICAgICAgICAvLyBwb2ludGVyIGV2ZW50cyBvciBiZWhhdmUgYXMgYSBzY3JvbGxlclxuICAgICAgICBzaG91bGRTY3JvbGw6IGZ1bmN0aW9uKGluRXZlbnQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmZpcnN0WFkpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmV0O1xuICAgICAgICAgICAgICAgIHZhciB0b3VjaEFjdGlvbiA9IHNjb3BlLnRhcmdldEZpbmRpbmcuZmluZFRvdWNoQWN0aW9uKGluRXZlbnQpO1xuICAgICAgICAgICAgICAgIHZhciBzY3JvbGxBeGlzID0gdGhpcy50b3VjaEFjdGlvblRvU2Nyb2xsVHlwZSh0b3VjaEFjdGlvbik7XG4gICAgICAgICAgICAgICAgaWYgKHNjcm9sbEF4aXMgPT09ICdub25lJykge1xuICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIGVsZW1lbnQgaXMgYSB0b3VjaC1hY3Rpb246IG5vbmUsIHNob3VsZCBuZXZlciBzY3JvbGxcbiAgICAgICAgICAgICAgICAgICAgcmV0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzY3JvbGxBeGlzID09PSAnWFknKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgZWxlbWVudCBzaG91bGQgYWx3YXlzIHNjcm9sbFxuICAgICAgICAgICAgICAgICAgICByZXQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0ID0gaW5FdmVudC5jaGFuZ2VkVG91Y2hlc1swXTtcbiAgICAgICAgICAgICAgICAgICAgLy8gY2hlY2sgdGhlIGludGVuZGVkIHNjcm9sbCBheGlzLCBhbmQgb3RoZXIgYXhpc1xuICAgICAgICAgICAgICAgICAgICB2YXIgYSA9IHNjcm9sbEF4aXM7XG4gICAgICAgICAgICAgICAgICAgIHZhciBvYSA9IHNjcm9sbEF4aXMgPT09ICdZJyA/ICdYJyA6ICdZJztcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRhID0gTWF0aC5hYnModFsnY2xpZW50JyArIGFdIC0gdGhpcy5maXJzdFhZW2FdKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRvYSA9IE1hdGguYWJzKHRbJ2NsaWVudCcgKyBvYV0gLSB0aGlzLmZpcnN0WFlbb2FdKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgZGVsdGEgaW4gdGhlIHNjcm9sbCBheGlzID4gZGVsdGEgb3RoZXIgYXhpcywgc2Nyb2xsIGluc3RlYWQgb2ZcbiAgICAgICAgICAgICAgICAgICAgLy8gbWFraW5nIGV2ZW50c1xuICAgICAgICAgICAgICAgICAgICByZXQgPSBkYSA+PSBkb2E7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGZpbmRUb3VjaDogZnVuY3Rpb24oaW5UTCwgaW5JZCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBpblRMLmxlbmd0aCwgdDsgaSA8IGwgJiYgKHQgPSBpblRMW2ldKTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHQuaWRlbnRpZmllciA9PT0gaW5JZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC8vIEluIHNvbWUgaW5zdGFuY2VzLCBhIHRvdWNoc3RhcnQgY2FuIGhhcHBlbiB3aXRob3V0IGEgdG91Y2hlbmQuIFRoaXNcbiAgICAgICAgLy8gbGVhdmVzIHRoZSBwb2ludGVybWFwIGluIGEgYnJva2VuIHN0YXRlLlxuICAgICAgICAvLyBUaGVyZWZvcmUsIG9uIGV2ZXJ5IHRvdWNoc3RhcnQsIHdlIHJlbW92ZSB0aGUgdG91Y2hlcyB0aGF0IGRpZCBub3QgZmlyZSBhXG4gICAgICAgIC8vIHRvdWNoZW5kIGV2ZW50LlxuICAgICAgICAvLyBUbyBrZWVwIHN0YXRlIGdsb2JhbGx5IGNvbnNpc3RlbnQsIHdlIGZpcmUgYVxuICAgICAgICAvLyBwb2ludGVyY2FuY2VsIGZvciB0aGlzIFwiYWJhbmRvbmVkXCIgdG91Y2hcbiAgICAgICAgdmFjdXVtVG91Y2hlczogZnVuY3Rpb24oaW5FdmVudCkge1xuICAgICAgICAgICAgdmFyIHRsID0gaW5FdmVudC50b3VjaGVzO1xuICAgICAgICAgICAgLy8gcG9pbnRlcm1hcC5wb2ludGVycygpIHNob3VsZCBiZSA8IHRsLmxlbmd0aCBoZXJlLCBhcyB0aGUgdG91Y2hzdGFydCBoYXMgbm90XG4gICAgICAgICAgICAvLyBiZWVuIHByb2Nlc3NlZCB5ZXQuXG4gICAgICAgICAgICBpZiAocG9pbnRlcm1hcC5wb2ludGVycygpID49IHRsLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHZhciBkID0gW107XG4gICAgICAgICAgICAgICAgcG9pbnRlcm1hcC5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTmV2ZXIgcmVtb3ZlIHBvaW50ZXJJZCA9PSAxLCB3aGljaCBpcyBtb3VzZS5cbiAgICAgICAgICAgICAgICAgICAgLy8gVG91Y2ggaWRlbnRpZmllcnMgYXJlIDIgc21hbGxlciB0aGFuIHRoZWlyIHBvaW50ZXJJZCwgd2hpY2ggaXMgdGhlXG4gICAgICAgICAgICAgICAgICAgIC8vIGluZGV4IGluIHBvaW50ZXJtYXAuXG4gICAgICAgICAgICAgICAgICAgIGlmIChrZXkgIT09IDEgJiYgIXRoaXMuZmluZFRvdWNoKHRsLCBrZXkgLSAyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHAgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGQucHVzaChwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICAgICAgICAgIGQuZm9yRWFjaChmdW5jdGlvbihwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FuY2VsKHApO1xuICAgICAgICAgICAgICAgICAgICBwb2ludGVybWFwLmRlbGV0ZShwLnBvaW50ZXJJZCk7XG4gICAgICAgICAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHRvdWNoc3RhcnQ6IGZ1bmN0aW9uKGluRXZlbnQpIHtcbiAgICAgICAgICAgIHRoaXMudmFjdXVtVG91Y2hlcyhpbkV2ZW50KTtcbiAgICAgICAgICAgIHRoaXMuc2V0UHJpbWFyeVRvdWNoKGluRXZlbnQuY2hhbmdlZFRvdWNoZXNbMF0pO1xuICAgICAgICAgICAgdGhpcy5kZWR1cFN5bnRoTW91c2UoaW5FdmVudCk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuc2Nyb2xsaW5nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jbGlja0NvdW50Kys7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzVG91Y2hlcyhpbkV2ZW50LCB0aGlzLmRvd24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBkb3duOiBmdW5jdGlvbihpblBvaW50ZXIpIHtcbiAgICAgICAgICAgIGRpc3BhdGNoZXIuZG93bihpblBvaW50ZXIpO1xuICAgICAgICB9LFxuICAgICAgICB0b3VjaG1vdmU6IGZ1bmN0aW9uKGluRXZlbnQpIHtcbiAgICAgICAgICAgIGlmIChIQVNfVE9VQ0hfQUNUSU9OKSB7XG4gICAgICAgICAgICAgICAgLy8gdG91Y2hldmVudC5jYW5jZWxhYmxlID09IGZhbHNlIGlzIHNlbnQgd2hlbiB0aGUgcGFnZSBpcyBzY3JvbGxpbmcgdW5kZXIgbmF0aXZlIFRvdWNoIEFjdGlvbiBpbiBDaHJvbWUgMzZcbiAgICAgICAgICAgICAgICAvLyBodHRwczovL2dyb3Vwcy5nb29nbGUuY29tL2EvY2hyb21pdW0ub3JnL2QvbXNnL2lucHV0LWRldi93SG55dWtjWUJjQS9iOWttdHdNMWpKUUpcbiAgICAgICAgICAgICAgICBpZiAoaW5FdmVudC5jYW5jZWxhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJvY2Vzc1RvdWNoZXMoaW5FdmVudCwgdGhpcy5tb3ZlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5zY3JvbGxpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuc2Nyb2xsaW5nID09PSBudWxsICYmIHRoaXMuc2hvdWxkU2Nyb2xsKGluRXZlbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNjcm9sbGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5FdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wcm9jZXNzVG91Y2hlcyhpbkV2ZW50LCB0aGlzLm1vdmUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLmZpcnN0WFkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBpbkV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZHggPSB0LmNsaWVudFggLSB0aGlzLmZpcnN0WFkuWDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGR5ID0gdC5jbGllbnRZIC0gdGhpcy5maXJzdFhZLlk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkZCA9IE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkZCA+PSBIWVNURVJFU0lTKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnRvdWNoY2FuY2VsKGluRXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zY3JvbGxpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5maXJzdFhZID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgbW92ZTogZnVuY3Rpb24oaW5Qb2ludGVyKSB7XG4gICAgICAgICAgICBkaXNwYXRjaGVyLm1vdmUoaW5Qb2ludGVyKTtcbiAgICAgICAgfSxcbiAgICAgICAgdG91Y2hlbmQ6IGZ1bmN0aW9uKGluRXZlbnQpIHtcbiAgICAgICAgICAgIHRoaXMuZGVkdXBTeW50aE1vdXNlKGluRXZlbnQpO1xuICAgICAgICAgICAgdGhpcy5wcm9jZXNzVG91Y2hlcyhpbkV2ZW50LCB0aGlzLnVwKTtcbiAgICAgICAgfSxcbiAgICAgICAgdXA6IGZ1bmN0aW9uKGluUG9pbnRlcikge1xuICAgICAgICAgICAgaW5Qb2ludGVyLnJlbGF0ZWRUYXJnZXQgPSBzY29wZS5maW5kVGFyZ2V0KGluUG9pbnRlcik7XG4gICAgICAgICAgICBkaXNwYXRjaGVyLnVwKGluUG9pbnRlcik7XG4gICAgICAgIH0sXG4gICAgICAgIGNhbmNlbDogZnVuY3Rpb24oaW5Qb2ludGVyKSB7XG4gICAgICAgICAgICBkaXNwYXRjaGVyLmNhbmNlbChpblBvaW50ZXIpO1xuICAgICAgICB9LFxuICAgICAgICB0b3VjaGNhbmNlbDogZnVuY3Rpb24oaW5FdmVudCkge1xuICAgICAgICAgICAgaW5FdmVudC5fY2FuY2VsID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMucHJvY2Vzc1RvdWNoZXMoaW5FdmVudCwgdGhpcy5jYW5jZWwpO1xuICAgICAgICB9LFxuICAgICAgICBjbGVhblVwUG9pbnRlcjogZnVuY3Rpb24oaW5Qb2ludGVyKSB7XG4gICAgICAgICAgICBwb2ludGVybWFwWydkZWxldGUnXShpblBvaW50ZXIucG9pbnRlcklkKTtcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlUHJpbWFyeVBvaW50ZXIoaW5Qb2ludGVyKTtcbiAgICAgICAgfSxcbiAgICAgICAgLy8gcHJldmVudCBzeW50aCBtb3VzZSBldmVudHMgZnJvbSBjcmVhdGluZyBwb2ludGVyIGV2ZW50c1xuICAgICAgICBkZWR1cFN5bnRoTW91c2U6IGZ1bmN0aW9uKGluRXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBsdHMgPSBzY29wZS5tb3VzZUV2ZW50cy5sYXN0VG91Y2hlcztcbiAgICAgICAgICAgIHZhciB0ID0gaW5FdmVudC5jaGFuZ2VkVG91Y2hlc1swXTtcbiAgICAgICAgICAgIC8vIG9ubHkgdGhlIHByaW1hcnkgZmluZ2VyIHdpbGwgc3ludGggbW91c2UgZXZlbnRzXG4gICAgICAgICAgICBpZiAodGhpcy5pc1ByaW1hcnlUb3VjaCh0KSkge1xuICAgICAgICAgICAgICAgIC8vIHJlbWVtYmVyIHgveSBvZiBsYXN0IHRvdWNoXG4gICAgICAgICAgICAgICAgdmFyIGx0ID0ge1xuICAgICAgICAgICAgICAgICAgICB4OiB0LmNsaWVudFgsXG4gICAgICAgICAgICAgICAgICAgIHk6IHQuY2xpZW50WVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgbHRzLnB1c2gobHQpO1xuICAgICAgICAgICAgICAgIHZhciBmbiA9IChmdW5jdGlvbihsdHMsIGx0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpID0gbHRzLmluZGV4T2YobHQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsdHMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSkuYmluZChudWxsLCBsdHMsIGx0KTtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZuLCBERURVUF9USU1FT1VUKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBwcmV2ZW50IFwiZ2hvc3QgY2xpY2tzXCIgdGhhdCBjb21lIGZyb20gZWxlbWVudHMgdGhhdCB3ZXJlIHJlbW92ZWQgaW4gYSB0b3VjaCBoYW5kbGVyXG4gICAgdmFyIFNUT1BfUFJPUF9GTiA9IEV2ZW50LnByb3RvdHlwZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24gfHwgRXZlbnQucHJvdG90eXBlLnN0b3BQcm9wYWdhdGlvbjtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uKGV2KSB7XG4gICAgICAgIHZhciB4ID0gZXYuY2xpZW50WCxcbiAgICAgICAgICAgIHkgPSBldi5jbGllbnRZO1xuICAgICAgICAvLyBjaGVjayBpZiBhIGNsaWNrIGlzIHdpdGhpbiBERURVUF9ESVNUIHB4IHJhZGl1cyBvZiB0aGUgdG91Y2hzdGFydFxuICAgICAgICB2YXIgY2xvc2VUbyA9IGZ1bmN0aW9uKHRvdWNoKSB7XG4gICAgICAgICAgICB2YXIgZHggPSBNYXRoLmFicyh4IC0gdG91Y2gueCksXG4gICAgICAgICAgICAgICAgZHkgPSBNYXRoLmFicyh5IC0gdG91Y2gueSk7XG4gICAgICAgICAgICByZXR1cm4gKGR4IDw9IERFRFVQX0RJU1QgJiYgZHkgPD0gREVEVVBfRElTVCk7XG4gICAgICAgIH07XG4gICAgICAgIC8vIGlmIGNsaWNrIGNvb3JkaW5hdGVzIGFyZSBjbG9zZSB0byB0b3VjaCBjb29yZGluYXRlcywgYXNzdW1lIHRoZSBjbGljayBjYW1lIGZyb20gYSB0b3VjaFxuICAgICAgICB2YXIgd2FzVG91Y2hlZCA9IHNjb3BlLm1vdXNlRXZlbnRzLmxhc3RUb3VjaGVzLnNvbWUoY2xvc2VUbyk7XG4gICAgICAgIC8vIGlmIHRoZSBjbGljayBjYW1lIGZyb20gdG91Y2gsIGFuZCB0aGUgdG91Y2hzdGFydCB0YXJnZXQgaXMgbm90IGluIHRoZSBwYXRoIG9mIHRoZSBjbGljayBldmVudCxcbiAgICAgICAgLy8gdGhlbiB0aGUgdG91Y2hzdGFydCB0YXJnZXQgd2FzIHByb2JhYmx5IHJlbW92ZWQsIGFuZCB0aGUgY2xpY2sgc2hvdWxkIGJlIFwiYnVzdGVkXCJcbiAgICAgICAgdmFyIHBhdGggPSBzY29wZS50YXJnZXRGaW5kaW5nLnBhdGgoZXYpO1xuICAgICAgICBpZiAod2FzVG91Y2hlZCkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhdGhbaV0gPT09IHRvdWNoRXZlbnRzLmZpcnN0VGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgU1RPUF9QUk9QX0ZOLmNhbGwoZXYpO1xuICAgICAgICB9XG4gICAgfSwgdHJ1ZSk7XG5cbiAgICBzY29wZS50b3VjaEV2ZW50cyA9IHRvdWNoRXZlbnRzO1xufSkoZXhwb3J0cyk7XG5cbihmdW5jdGlvbihzY29wZSkge1xuICAgIHZhciBkaXNwYXRjaGVyID0gc2NvcGUuZGlzcGF0Y2hlcjtcbiAgICB2YXIgcG9pbnRlcm1hcCA9IGRpc3BhdGNoZXIucG9pbnRlcm1hcDtcbiAgICB2YXIgSEFTX0JJVE1BUF9UWVBFID0gd2luZG93Lk1TUG9pbnRlckV2ZW50ICYmIHR5cGVvZiB3aW5kb3cuTVNQb2ludGVyRXZlbnQuTVNQT0lOVEVSX1RZUEVfTU9VU0UgPT09ICdudW1iZXInO1xuICAgIHZhciBtc0V2ZW50cyA9IHtcbiAgICAgICAgZXZlbnRzOiBbXG4gICAgICAgICAgICAnTVNQb2ludGVyRG93bicsXG4gICAgICAgICAgICAnTVNQb2ludGVyTW92ZScsXG4gICAgICAgICAgICAnTVNQb2ludGVyVXAnLFxuICAgICAgICAgICAgJ01TUG9pbnRlckNhbmNlbCcsXG4gICAgICAgIF0sXG4gICAgICAgIHJlZ2lzdGVyOiBmdW5jdGlvbih0YXJnZXQpIHtcbiAgICAgICAgICAgIGRpc3BhdGNoZXIubGlzdGVuKHRhcmdldCwgdGhpcy5ldmVudHMpO1xuICAgICAgICB9LFxuICAgICAgICB1bnJlZ2lzdGVyOiBmdW5jdGlvbih0YXJnZXQpIHtcbiAgICAgICAgICAgIGlmICh0YXJnZXQubm9kZVR5cGUgPT09IE5vZGUuRE9DVU1FTlRfTk9ERSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRpc3BhdGNoZXIudW5saXN0ZW4odGFyZ2V0LCB0aGlzLmV2ZW50cyk7XG4gICAgICAgIH0sXG4gICAgICAgIFBPSU5URVJfVFlQRVM6IFtcbiAgICAgICAgICAgICcnLFxuICAgICAgICAgICAgJ3VuYXZhaWxhYmxlJyxcbiAgICAgICAgICAgICd0b3VjaCcsXG4gICAgICAgICAgICAncGVuJyxcbiAgICAgICAgICAgICdtb3VzZSdcbiAgICAgICAgXSxcbiAgICAgICAgcHJlcGFyZUV2ZW50OiBmdW5jdGlvbihpbkV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgZSA9IGluRXZlbnQ7XG4gICAgICAgICAgICBlID0gZGlzcGF0Y2hlci5jbG9uZUV2ZW50KGluRXZlbnQpO1xuICAgICAgICAgICAgaWYgKEhBU19CSVRNQVBfVFlQRSkge1xuICAgICAgICAgICAgICAgIGUucG9pbnRlclR5cGUgPSB0aGlzLlBPSU5URVJfVFlQRVNbaW5FdmVudC5wb2ludGVyVHlwZV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlLl9zb3VyY2UgPSAnbXMnO1xuICAgICAgICAgICAgcmV0dXJuIGU7XG4gICAgICAgIH0sXG4gICAgICAgIGNsZWFudXA6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICBwb2ludGVybWFwWydkZWxldGUnXShpZCk7XG4gICAgICAgIH0sXG4gICAgICAgIE1TUG9pbnRlckRvd246IGZ1bmN0aW9uKGluRXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBlID0gdGhpcy5wcmVwYXJlRXZlbnQoaW5FdmVudCk7XG4gICAgICAgICAgICBlLnRhcmdldCA9IHNjb3BlLmZpbmRUYXJnZXQoaW5FdmVudCk7XG4gICAgICAgICAgICBwb2ludGVybWFwLnNldChpbkV2ZW50LnBvaW50ZXJJZCwgZS50YXJnZXQpO1xuICAgICAgICAgICAgZGlzcGF0Y2hlci5kb3duKGUpO1xuICAgICAgICB9LFxuICAgICAgICBNU1BvaW50ZXJNb3ZlOiBmdW5jdGlvbihpbkV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgdGFyZ2V0ID0gcG9pbnRlcm1hcC5nZXQoaW5FdmVudC5wb2ludGVySWQpO1xuICAgICAgICAgICAgaWYgKHRhcmdldCkge1xuICAgICAgICAgICAgICAgIHZhciBlID0gdGhpcy5wcmVwYXJlRXZlbnQoaW5FdmVudCk7XG4gICAgICAgICAgICAgICAgZS50YXJnZXQgPSB0YXJnZXQ7XG4gICAgICAgICAgICAgICAgZGlzcGF0Y2hlci5tb3ZlKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBNU1BvaW50ZXJVcDogZnVuY3Rpb24oaW5FdmVudCkge1xuICAgICAgICAgICAgdmFyIGUgPSB0aGlzLnByZXBhcmVFdmVudChpbkV2ZW50KTtcbiAgICAgICAgICAgIGUucmVsYXRlZFRhcmdldCA9IHNjb3BlLmZpbmRUYXJnZXQoaW5FdmVudCk7XG4gICAgICAgICAgICBlLnRhcmdldCA9IHBvaW50ZXJtYXAuZ2V0KGUucG9pbnRlcklkKTtcbiAgICAgICAgICAgIGRpc3BhdGNoZXIudXAoZSk7XG4gICAgICAgICAgICB0aGlzLmNsZWFudXAoaW5FdmVudC5wb2ludGVySWQpO1xuICAgICAgICB9LFxuICAgICAgICBNU1BvaW50ZXJDYW5jZWw6IGZ1bmN0aW9uKGluRXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBlID0gdGhpcy5wcmVwYXJlRXZlbnQoaW5FdmVudCk7XG4gICAgICAgICAgICBlLnJlbGF0ZWRUYXJnZXQgPSBzY29wZS5maW5kVGFyZ2V0KGluRXZlbnQpO1xuICAgICAgICAgICAgZS50YXJnZXQgPSBwb2ludGVybWFwLmdldChlLnBvaW50ZXJJZCk7XG4gICAgICAgICAgICBkaXNwYXRjaGVyLmNhbmNlbChlKTtcbiAgICAgICAgICAgIHRoaXMuY2xlYW51cChpbkV2ZW50LnBvaW50ZXJJZCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgc2NvcGUubXNFdmVudHMgPSBtc0V2ZW50cztcbn0pKGV4cG9ydHMpO1xuXG4oZnVuY3Rpb24oc2NvcGUpIHtcbiAgICB2YXIgZGlzcGF0Y2hlciA9IHNjb3BlLmRpc3BhdGNoZXI7XG4gICAgdmFyIHBvaW50ZXJtYXAgPSBkaXNwYXRjaGVyLnBvaW50ZXJtYXA7XG4gICAgdmFyIHBvaW50ZXJFdmVudHMgPSB7XG4gICAgICAgIGV2ZW50czogW1xuICAgICAgICAgICAgJ3BvaW50ZXJkb3duJyxcbiAgICAgICAgICAgICdwb2ludGVybW92ZScsXG4gICAgICAgICAgICAncG9pbnRlcnVwJyxcbiAgICAgICAgICAgICdwb2ludGVyY2FuY2VsJ1xuICAgICAgICBdLFxuICAgICAgICBwcmVwYXJlRXZlbnQ6IGZ1bmN0aW9uKGluRXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBlID0gZGlzcGF0Y2hlci5jbG9uZUV2ZW50KGluRXZlbnQpO1xuICAgICAgICAgICAgZS5fc291cmNlID0gJ3BvaW50ZXInO1xuICAgICAgICAgICAgcmV0dXJuIGU7XG4gICAgICAgIH0sXG4gICAgICAgIHJlZ2lzdGVyOiBmdW5jdGlvbih0YXJnZXQpIHtcbiAgICAgICAgICAgIGRpc3BhdGNoZXIubGlzdGVuKHRhcmdldCwgdGhpcy5ldmVudHMpO1xuICAgICAgICB9LFxuICAgICAgICB1bnJlZ2lzdGVyOiBmdW5jdGlvbih0YXJnZXQpIHtcbiAgICAgICAgICAgIGlmICh0YXJnZXQubm9kZVR5cGUgPT09IE5vZGUuRE9DVU1FTlRfTk9ERSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRpc3BhdGNoZXIudW5saXN0ZW4odGFyZ2V0LCB0aGlzLmV2ZW50cyk7XG4gICAgICAgIH0sXG4gICAgICAgIGNsZWFudXA6IGZ1bmN0aW9uKGlkKSB7XG4gICAgICAgICAgICBwb2ludGVybWFwWydkZWxldGUnXShpZCk7XG4gICAgICAgIH0sXG4gICAgICAgIHBvaW50ZXJkb3duOiBmdW5jdGlvbihpbkV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgZSA9IHRoaXMucHJlcGFyZUV2ZW50KGluRXZlbnQpO1xuICAgICAgICAgICAgZS50YXJnZXQgPSBzY29wZS5maW5kVGFyZ2V0KGluRXZlbnQpO1xuICAgICAgICAgICAgcG9pbnRlcm1hcC5zZXQoZS5wb2ludGVySWQsIGUudGFyZ2V0KTtcbiAgICAgICAgICAgIGRpc3BhdGNoZXIuZG93bihlKTtcbiAgICAgICAgfSxcbiAgICAgICAgcG9pbnRlcm1vdmU6IGZ1bmN0aW9uKGluRXZlbnQpIHtcbiAgICAgICAgICAgIHZhciB0YXJnZXQgPSBwb2ludGVybWFwLmdldChpbkV2ZW50LnBvaW50ZXJJZCk7XG4gICAgICAgICAgICBpZiAodGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgdmFyIGUgPSB0aGlzLnByZXBhcmVFdmVudChpbkV2ZW50KTtcbiAgICAgICAgICAgICAgICBlLnRhcmdldCA9IHRhcmdldDtcbiAgICAgICAgICAgICAgICBkaXNwYXRjaGVyLm1vdmUoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHBvaW50ZXJ1cDogZnVuY3Rpb24oaW5FdmVudCkge1xuICAgICAgICAgICAgdmFyIGUgPSB0aGlzLnByZXBhcmVFdmVudChpbkV2ZW50KTtcbiAgICAgICAgICAgIGUucmVsYXRlZFRhcmdldCA9IHNjb3BlLmZpbmRUYXJnZXQoaW5FdmVudCk7XG4gICAgICAgICAgICBlLnRhcmdldCA9IHBvaW50ZXJtYXAuZ2V0KGUucG9pbnRlcklkKTtcbiAgICAgICAgICAgIGRpc3BhdGNoZXIudXAoZSk7XG4gICAgICAgICAgICB0aGlzLmNsZWFudXAoaW5FdmVudC5wb2ludGVySWQpO1xuICAgICAgICB9LFxuICAgICAgICBwb2ludGVyY2FuY2VsOiBmdW5jdGlvbihpbkV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgZSA9IHRoaXMucHJlcGFyZUV2ZW50KGluRXZlbnQpO1xuICAgICAgICAgICAgZS5yZWxhdGVkVGFyZ2V0ID0gc2NvcGUuZmluZFRhcmdldChpbkV2ZW50KTtcbiAgICAgICAgICAgIGUudGFyZ2V0ID0gcG9pbnRlcm1hcC5nZXQoZS5wb2ludGVySWQpO1xuICAgICAgICAgICAgZGlzcGF0Y2hlci5jYW5jZWwoZSk7XG4gICAgICAgICAgICB0aGlzLmNsZWFudXAoaW5FdmVudC5wb2ludGVySWQpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHNjb3BlLnBvaW50ZXJFdmVudHMgPSBwb2ludGVyRXZlbnRzO1xufSkoZXhwb3J0cyk7XG5cbi8qKlxuICogVGhpcyBtb2R1bGUgY29udGFpbnMgdGhlIGhhbmRsZXJzIGZvciBuYXRpdmUgcGxhdGZvcm0gZXZlbnRzLlxuICogRnJvbSBoZXJlLCB0aGUgZGlzcGF0Y2hlciBpcyBjYWxsZWQgdG8gY3JlYXRlIHVuaWZpZWQgcG9pbnRlciBldmVudHMuXG4gKiBJbmNsdWRlZCBhcmUgdG91Y2ggZXZlbnRzICh2MSksIG1vdXNlIGV2ZW50cywgYW5kIE1TUG9pbnRlckV2ZW50cy5cbiAqL1xuKGZ1bmN0aW9uKHNjb3BlKSB7XG5cbiAgICB2YXIgZGlzcGF0Y2hlciA9IHNjb3BlLmRpc3BhdGNoZXI7XG4gICAgdmFyIG5hdiA9IHdpbmRvdy5uYXZpZ2F0b3I7XG5cbiAgICBpZiAod2luZG93LlBvaW50ZXJFdmVudCkge1xuICAgICAgICBkaXNwYXRjaGVyLnJlZ2lzdGVyU291cmNlKCdwb2ludGVyJywgc2NvcGUucG9pbnRlckV2ZW50cyk7XG4gICAgfSBlbHNlIGlmIChuYXYubXNQb2ludGVyRW5hYmxlZCkge1xuICAgICAgICBkaXNwYXRjaGVyLnJlZ2lzdGVyU291cmNlKCdtcycsIHNjb3BlLm1zRXZlbnRzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBkaXNwYXRjaGVyLnJlZ2lzdGVyU291cmNlKCdtb3VzZScsIHNjb3BlLm1vdXNlRXZlbnRzKTtcbiAgICAgICAgaWYgKHdpbmRvdy5vbnRvdWNoc3RhcnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgZGlzcGF0Y2hlci5yZWdpc3RlclNvdXJjZSgndG91Y2gnLCBzY29wZS50b3VjaEV2ZW50cyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBXb3JrIGFyb3VuZCBpT1MgYnVncyBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTM1NjI4IGFuZCBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTM2NTA2XG4gICAgdmFyIHVhID0gbmF2aWdhdG9yLnVzZXJBZ2VudDtcbiAgICB2YXIgSVNfSU9TID0gdWEubWF0Y2goL2lQYWR8aVBob25lfGlQb2QvKSAmJiAnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3c7XG5cbiAgICBkaXNwYXRjaGVyLklTX0lPUyA9IElTX0lPUztcbiAgICBzY29wZS50b3VjaEV2ZW50cy5JU19JT1MgPSBJU19JT1M7XG5cbiAgICBkaXNwYXRjaGVyLnJlZ2lzdGVyKGRvY3VtZW50LCB0cnVlKTtcbn0pKGV4cG9ydHMpO1xuXG4vKipcbiAqIFRoaXMgZXZlbnQgZGVub3RlcyB0aGUgYmVnaW5uaW5nIG9mIGEgc2VyaWVzIG9mIHRyYWNraW5nIGV2ZW50cy5cbiAqXG4gKiBAbW9kdWxlIFBvaW50ZXJHZXN0dXJlc1xuICogQHN1Ym1vZHVsZSBFdmVudHNcbiAqIEBjbGFzcyB0cmFja3N0YXJ0XG4gKi9cbi8qKlxuICogUGl4ZWxzIG1vdmVkIGluIHRoZSB4IGRpcmVjdGlvbiBzaW5jZSB0cmFja3N0YXJ0LlxuICogQHR5cGUgTnVtYmVyXG4gKiBAcHJvcGVydHkgZHhcbiAqL1xuLyoqXG4gKiBQaXhlcyBtb3ZlZCBpbiB0aGUgeSBkaXJlY3Rpb24gc2luY2UgdHJhY2tzdGFydC5cbiAqIEB0eXBlIE51bWJlclxuICogQHByb3BlcnR5IGR5XG4gKi9cbi8qKlxuICogUGl4ZWxzIG1vdmVkIGluIHRoZSB4IGRpcmVjdGlvbiBzaW5jZSB0aGUgbGFzdCB0cmFjay5cbiAqIEB0eXBlIE51bWJlclxuICogQHByb3BlcnR5IGRkeFxuICovXG4vKipcbiAqIFBpeGxlcyBtb3ZlZCBpbiB0aGUgeSBkaXJlY3Rpb24gc2luY2UgdGhlIGxhc3QgdHJhY2suXG4gKiBAdHlwZSBOdW1iZXJcbiAqIEBwcm9wZXJ0eSBkZHlcbiAqL1xuLyoqXG4gKiBUaGUgY2xpZW50WCBwb3NpdGlvbiBvZiB0aGUgdHJhY2sgZ2VzdHVyZS5cbiAqIEB0eXBlIE51bWJlclxuICogQHByb3BlcnR5IGNsaWVudFhcbiAqL1xuLyoqXG4gKiBUaGUgY2xpZW50WSBwb3NpdGlvbiBvZiB0aGUgdHJhY2sgZ2VzdHVyZS5cbiAqIEB0eXBlIE51bWJlclxuICogQHByb3BlcnR5IGNsaWVudFlcbiAqL1xuLyoqXG4gKiBUaGUgcGFnZVggcG9zaXRpb24gb2YgdGhlIHRyYWNrIGdlc3R1cmUuXG4gKiBAdHlwZSBOdW1iZXJcbiAqIEBwcm9wZXJ0eSBwYWdlWFxuICovXG4vKipcbiAqIFRoZSBwYWdlWSBwb3NpdGlvbiBvZiB0aGUgdHJhY2sgZ2VzdHVyZS5cbiAqIEB0eXBlIE51bWJlclxuICogQHByb3BlcnR5IHBhZ2VZXG4gKi9cbi8qKlxuICogVGhlIHNjcmVlblggcG9zaXRpb24gb2YgdGhlIHRyYWNrIGdlc3R1cmUuXG4gKiBAdHlwZSBOdW1iZXJcbiAqIEBwcm9wZXJ0eSBzY3JlZW5YXG4gKi9cbi8qKlxuICogVGhlIHNjcmVlblkgcG9zaXRpb24gb2YgdGhlIHRyYWNrIGdlc3R1cmUuXG4gKiBAdHlwZSBOdW1iZXJcbiAqIEBwcm9wZXJ0eSBzY3JlZW5ZXG4gKi9cbi8qKlxuICogVGhlIGxhc3QgeCBheGlzIGRpcmVjdGlvbiBvZiB0aGUgcG9pbnRlci5cbiAqIEB0eXBlIE51bWJlclxuICogQHByb3BlcnR5IHhEaXJlY3Rpb25cbiAqL1xuLyoqXG4gKiBUaGUgbGFzdCB5IGF4aXMgZGlyZWN0aW9uIG9mIHRoZSBwb2ludGVyLlxuICogQHR5cGUgTnVtYmVyXG4gKiBAcHJvcGVydHkgeURpcmVjdGlvblxuICovXG4vKipcbiAqIEEgc2hhcmVkIG9iamVjdCBiZXR3ZWVuIGFsbCB0cmFja2luZyBldmVudHMuXG4gKiBAdHlwZSBPYmplY3RcbiAqIEBwcm9wZXJ0eSB0cmFja0luZm9cbiAqL1xuLyoqXG4gKiBUaGUgZWxlbWVudCBjdXJyZW50bHkgdW5kZXIgdGhlIHBvaW50ZXIuXG4gKiBAdHlwZSBFbGVtZW50XG4gKiBAcHJvcGVydHkgcmVsYXRlZFRhcmdldFxuICovXG4vKipcbiAqIFRoZSB0eXBlIG9mIHBvaW50ZXIgdGhhdCBtYWtlIHRoZSB0cmFjayBnZXN0dXJlLlxuICogQHR5cGUgU3RyaW5nXG4gKiBAcHJvcGVydHkgcG9pbnRlclR5cGVcbiAqL1xuLyoqXG4gKlxuICogVGhpcyBldmVudCBmaXJlcyBmb3IgYWxsIHBvaW50ZXIgbW92ZW1lbnQgYmVpbmcgdHJhY2tlZC5cbiAqXG4gKiBAY2xhc3MgdHJhY2tcbiAqIEBleHRlbmRzIHRyYWNrc3RhcnRcbiAqL1xuLyoqXG4gKiBUaGlzIGV2ZW50IGZpcmVzIHdoZW4gdGhlIHBvaW50ZXIgaXMgbm8gbG9uZ2VyIGJlaW5nIHRyYWNrZWQuXG4gKlxuICogQGNsYXNzIHRyYWNrZW5kXG4gKiBAZXh0ZW5kcyB0cmFja3N0YXJ0XG4gKi9cblxuKGZ1bmN0aW9uKHNjb3BlKSB7XG4gICAgdmFyIGRpc3BhdGNoZXIgPSBzY29wZS5kaXNwYXRjaGVyO1xuICAgIHZhciBldmVudEZhY3RvcnkgPSBzY29wZS5ldmVudEZhY3Rvcnk7XG4gICAgdmFyIHBvaW50ZXJtYXAgPSBuZXcgc2NvcGUuUG9pbnRlck1hcCgpO1xuICAgIHZhciB0cmFjayA9IHtcbiAgICAgICAgZXZlbnRzOiBbXG4gICAgICAgICAgICAnZG93bicsXG4gICAgICAgICAgICAnbW92ZScsXG4gICAgICAgICAgICAndXAnLFxuICAgICAgICBdLFxuICAgICAgICBleHBvc2VzOiBbXG4gICAgICAgICAgICAndHJhY2tzdGFydCcsXG4gICAgICAgICAgICAndHJhY2snLFxuICAgICAgICAgICAgJ3RyYWNreCcsXG4gICAgICAgICAgICAndHJhY2t5JyxcbiAgICAgICAgICAgICd0cmFja2VuZCdcbiAgICAgICAgXSxcbiAgICAgICAgZGVmYXVsdEFjdGlvbnM6IHtcbiAgICAgICAgICAgICd0cmFjayc6ICdub25lJyxcbiAgICAgICAgICAgICd0cmFja3gnOiAncGFuLXknLFxuICAgICAgICAgICAgJ3RyYWNreSc6ICdwYW4teCdcbiAgICAgICAgfSxcbiAgICAgICAgV0lHR0xFX1RIUkVTSE9MRDogNCxcbiAgICAgICAgY2xhbXBEaXI6IGZ1bmN0aW9uKGluRGVsdGEpIHtcbiAgICAgICAgICAgIHJldHVybiBpbkRlbHRhID4gMCA/IDEgOiAtMTtcbiAgICAgICAgfSxcbiAgICAgICAgY2FsY1Bvc2l0aW9uRGVsdGE6IGZ1bmN0aW9uKGluQSwgaW5CKSB7XG4gICAgICAgICAgICB2YXIgeCA9IDAsXG4gICAgICAgICAgICAgICAgeSA9IDA7XG4gICAgICAgICAgICBpZiAoaW5BICYmIGluQikge1xuICAgICAgICAgICAgICAgIHggPSBpbkIucGFnZVggLSBpbkEucGFnZVg7XG4gICAgICAgICAgICAgICAgeSA9IGluQi5wYWdlWSAtIGluQS5wYWdlWTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgICAgICB5OiB5XG4gICAgICAgICAgICB9O1xuICAgICAgICB9LFxuICAgICAgICBmaXJlVHJhY2s6IGZ1bmN0aW9uKGluVHlwZSwgaW5FdmVudCwgaW5UcmFja2luZ0RhdGEpIHtcbiAgICAgICAgICAgIHZhciB0ID0gaW5UcmFja2luZ0RhdGE7XG4gICAgICAgICAgICB2YXIgZCA9IHRoaXMuY2FsY1Bvc2l0aW9uRGVsdGEodC5kb3duRXZlbnQsIGluRXZlbnQpO1xuICAgICAgICAgICAgdmFyIGRkID0gdGhpcy5jYWxjUG9zaXRpb25EZWx0YSh0Lmxhc3RNb3ZlRXZlbnQsIGluRXZlbnQpO1xuICAgICAgICAgICAgaWYgKGRkLngpIHtcbiAgICAgICAgICAgICAgICB0LnhEaXJlY3Rpb24gPSB0aGlzLmNsYW1wRGlyKGRkLngpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpblR5cGUgPT09ICd0cmFja3gnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRkLnkpIHtcbiAgICAgICAgICAgICAgICB0LnlEaXJlY3Rpb24gPSB0aGlzLmNsYW1wRGlyKGRkLnkpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpblR5cGUgPT09ICd0cmFja3knKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGdlc3R1cmVQcm90byA9IHtcbiAgICAgICAgICAgICAgICBidWJibGVzOiB0cnVlLFxuICAgICAgICAgICAgICAgIGNhbmNlbGFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgdHJhY2tJbmZvOiB0LnRyYWNrSW5mbyxcbiAgICAgICAgICAgICAgICByZWxhdGVkVGFyZ2V0OiBpbkV2ZW50LnJlbGF0ZWRUYXJnZXQsXG4gICAgICAgICAgICAgICAgcG9pbnRlclR5cGU6IGluRXZlbnQucG9pbnRlclR5cGUsXG4gICAgICAgICAgICAgICAgcG9pbnRlcklkOiBpbkV2ZW50LnBvaW50ZXJJZCxcbiAgICAgICAgICAgICAgICBfc291cmNlOiAndHJhY2snXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKGluVHlwZSAhPT0gJ3RyYWNreScpIHtcbiAgICAgICAgICAgICAgICBnZXN0dXJlUHJvdG8ueCA9IGluRXZlbnQueDtcbiAgICAgICAgICAgICAgICBnZXN0dXJlUHJvdG8uZHggPSBkLng7XG4gICAgICAgICAgICAgICAgZ2VzdHVyZVByb3RvLmRkeCA9IGRkLng7XG4gICAgICAgICAgICAgICAgZ2VzdHVyZVByb3RvLmNsaWVudFggPSBpbkV2ZW50LmNsaWVudFg7XG4gICAgICAgICAgICAgICAgZ2VzdHVyZVByb3RvLnBhZ2VYID0gaW5FdmVudC5wYWdlWDtcbiAgICAgICAgICAgICAgICBnZXN0dXJlUHJvdG8uc2NyZWVuWCA9IGluRXZlbnQuc2NyZWVuWDtcbiAgICAgICAgICAgICAgICBnZXN0dXJlUHJvdG8ueERpcmVjdGlvbiA9IHQueERpcmVjdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpblR5cGUgIT09ICd0cmFja3gnKSB7XG4gICAgICAgICAgICAgICAgZ2VzdHVyZVByb3RvLmR5ID0gZC55O1xuICAgICAgICAgICAgICAgIGdlc3R1cmVQcm90by5kZHkgPSBkZC55O1xuICAgICAgICAgICAgICAgIGdlc3R1cmVQcm90by55ID0gaW5FdmVudC55O1xuICAgICAgICAgICAgICAgIGdlc3R1cmVQcm90by5jbGllbnRZID0gaW5FdmVudC5jbGllbnRZO1xuICAgICAgICAgICAgICAgIGdlc3R1cmVQcm90by5wYWdlWSA9IGluRXZlbnQucGFnZVk7XG4gICAgICAgICAgICAgICAgZ2VzdHVyZVByb3RvLnNjcmVlblkgPSBpbkV2ZW50LnNjcmVlblk7XG4gICAgICAgICAgICAgICAgZ2VzdHVyZVByb3RvLnlEaXJlY3Rpb24gPSB0LnlEaXJlY3Rpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgZSA9IGV2ZW50RmFjdG9yeS5tYWtlR2VzdHVyZUV2ZW50KGluVHlwZSwgZ2VzdHVyZVByb3RvKTtcbiAgICAgICAgICAgIHQuZG93blRhcmdldC5kaXNwYXRjaEV2ZW50KGUpO1xuICAgICAgICB9LFxuICAgICAgICBkb3duOiBmdW5jdGlvbihpbkV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoaW5FdmVudC5pc1ByaW1hcnkgJiYgKGluRXZlbnQucG9pbnRlclR5cGUgPT09ICdtb3VzZScgPyBpbkV2ZW50LmJ1dHRvbnMgPT09IDEgOiB0cnVlKSkge1xuICAgICAgICAgICAgICAgIHZhciBwID0ge1xuICAgICAgICAgICAgICAgICAgICBkb3duRXZlbnQ6IGluRXZlbnQsXG4gICAgICAgICAgICAgICAgICAgIGRvd25UYXJnZXQ6IGluRXZlbnQudGFyZ2V0LFxuICAgICAgICAgICAgICAgICAgICB0cmFja0luZm86IHt9LFxuICAgICAgICAgICAgICAgICAgICBsYXN0TW92ZUV2ZW50OiBudWxsLFxuICAgICAgICAgICAgICAgICAgICB4RGlyZWN0aW9uOiAwLFxuICAgICAgICAgICAgICAgICAgICB5RGlyZWN0aW9uOiAwLFxuICAgICAgICAgICAgICAgICAgICB0cmFja2luZzogZmFsc2VcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHBvaW50ZXJtYXAuc2V0KGluRXZlbnQucG9pbnRlcklkLCBwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgbW92ZTogZnVuY3Rpb24oaW5FdmVudCkge1xuICAgICAgICAgICAgdmFyIHAgPSBwb2ludGVybWFwLmdldChpbkV2ZW50LnBvaW50ZXJJZCk7XG4gICAgICAgICAgICBpZiAocCkge1xuICAgICAgICAgICAgICAgIGlmICghcC50cmFja2luZykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgZCA9IHRoaXMuY2FsY1Bvc2l0aW9uRGVsdGEocC5kb3duRXZlbnQsIGluRXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbW92ZSA9IGQueCAqIGQueCArIGQueSAqIGQueTtcbiAgICAgICAgICAgICAgICAgICAgLy8gc3RhcnQgdHJhY2tpbmcgb25seSBpZiBmaW5nZXIgbW92ZXMgbW9yZSB0aGFuIFdJR0dMRV9USFJFU0hPTERcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1vdmUgPiB0aGlzLldJR0dMRV9USFJFU0hPTEQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHAudHJhY2tpbmcgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgcC5sYXN0TW92ZUV2ZW50ID0gcC5kb3duRXZlbnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmZpcmVUcmFjaygndHJhY2tzdGFydCcsIGluRXZlbnQsIHApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwLnRyYWNraW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmlyZVRyYWNrKCd0cmFjaycsIGluRXZlbnQsIHApO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpcmVUcmFjaygndHJhY2t4JywgaW5FdmVudCwgcCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmlyZVRyYWNrKCd0cmFja3knLCBpbkV2ZW50LCBwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcC5sYXN0TW92ZUV2ZW50ID0gaW5FdmVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgdXA6IGZ1bmN0aW9uKGluRXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBwID0gcG9pbnRlcm1hcC5nZXQoaW5FdmVudC5wb2ludGVySWQpO1xuICAgICAgICAgICAgaWYgKHApIHtcbiAgICAgICAgICAgICAgICBpZiAocC50cmFja2luZykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpcmVUcmFjaygndHJhY2tlbmQnLCBpbkV2ZW50LCBwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcG9pbnRlcm1hcC5kZWxldGUoaW5FdmVudC5wb2ludGVySWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBkaXNwYXRjaGVyLnJlZ2lzdGVyR2VzdHVyZSgndHJhY2snLCB0cmFjayk7XG59KShleHBvcnRzKTtcblxuLyoqXG4gKiBUaGlzIGV2ZW50IGlzIGZpcmVkIHdoZW4gYSBwb2ludGVyIGlzIGhlbGQgZG93biBmb3IgMjAwbXMuXG4gKlxuICogQG1vZHVsZSBQb2ludGVyR2VzdHVyZXNcbiAqIEBzdWJtb2R1bGUgRXZlbnRzXG4gKiBAY2xhc3MgaG9sZFxuICovXG4vKipcbiAqIFR5cGUgb2YgcG9pbnRlciB0aGF0IG1hZGUgdGhlIGhvbGRpbmcgZXZlbnQuXG4gKiBAdHlwZSBTdHJpbmdcbiAqIEBwcm9wZXJ0eSBwb2ludGVyVHlwZVxuICovXG4vKipcbiAqIFNjcmVlbiBYIGF4aXMgcG9zaXRpb24gb2YgdGhlIGhlbGQgcG9pbnRlclxuICogQHR5cGUgTnVtYmVyXG4gKiBAcHJvcGVydHkgY2xpZW50WFxuICovXG4vKipcbiAqIFNjcmVlbiBZIGF4aXMgcG9zaXRpb24gb2YgdGhlIGhlbGQgcG9pbnRlclxuICogQHR5cGUgTnVtYmVyXG4gKiBAcHJvcGVydHkgY2xpZW50WVxuICovXG4vKipcbiAqIFR5cGUgb2YgcG9pbnRlciB0aGF0IG1hZGUgdGhlIGhvbGRpbmcgZXZlbnQuXG4gKiBAdHlwZSBTdHJpbmdcbiAqIEBwcm9wZXJ0eSBwb2ludGVyVHlwZVxuICovXG4vKipcbiAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgZXZlcnkgMjAwbXMgd2hpbGUgYSBwb2ludGVyIGlzIGhlbGQgZG93bi5cbiAqXG4gKiBAY2xhc3MgaG9sZHB1bHNlXG4gKiBAZXh0ZW5kcyBob2xkXG4gKi9cbi8qKlxuICogTWlsbGlzZWNvbmRzIHBvaW50ZXIgaGFzIGJlZW4gaGVsZCBkb3duLlxuICogQHR5cGUgTnVtYmVyXG4gKiBAcHJvcGVydHkgaG9sZFRpbWVcbiAqL1xuLyoqXG4gKiBUaGlzIGV2ZW50IGlzIGZpcmVkIHdoZW4gYSBoZWxkIHBvaW50ZXIgaXMgcmVsZWFzZWQgb3IgbW92ZWQuXG4gKlxuICogQGNsYXNzIHJlbGVhc2VcbiAqL1xuXG4oZnVuY3Rpb24oc2NvcGUpIHtcbiAgICB2YXIgZGlzcGF0Y2hlciA9IHNjb3BlLmRpc3BhdGNoZXI7XG4gICAgdmFyIGV2ZW50RmFjdG9yeSA9IHNjb3BlLmV2ZW50RmFjdG9yeTtcbiAgICB2YXIgaG9sZCA9IHtcbiAgICAgICAgLy8gd2FpdCBhdCBsZWFzdCBIT0xEX0RFTEFZIG1zIGJldHdlZW4gaG9sZCBhbmQgcHVsc2UgZXZlbnRzXG4gICAgICAgIEhPTERfREVMQVk6IDIwMCxcbiAgICAgICAgLy8gcG9pbnRlciBjYW4gbW92ZSBXSUdHTEVfVEhSRVNIT0xEIHBpeGVscyBiZWZvcmUgbm90IGNvdW50aW5nIGFzIGEgaG9sZFxuICAgICAgICBXSUdHTEVfVEhSRVNIT0xEOiAxNixcbiAgICAgICAgZXZlbnRzOiBbXG4gICAgICAgICAgICAnZG93bicsXG4gICAgICAgICAgICAnbW92ZScsXG4gICAgICAgICAgICAndXAnLFxuICAgICAgICBdLFxuICAgICAgICBleHBvc2VzOiBbXG4gICAgICAgICAgICAnaG9sZCcsXG4gICAgICAgICAgICAnaG9sZHB1bHNlJyxcbiAgICAgICAgICAgICdyZWxlYXNlJ1xuICAgICAgICBdLFxuICAgICAgICBoZWxkUG9pbnRlcjogbnVsbCxcbiAgICAgICAgaG9sZEpvYjogbnVsbCxcbiAgICAgICAgcHVsc2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIGhvbGQgPSBEYXRlLm5vdygpIC0gdGhpcy5oZWxkUG9pbnRlci50aW1lU3RhbXA7XG4gICAgICAgICAgICB2YXIgdHlwZSA9IHRoaXMuaGVsZCA/ICdob2xkcHVsc2UnIDogJ2hvbGQnO1xuICAgICAgICAgICAgdGhpcy5maXJlSG9sZCh0eXBlLCBob2xkKTtcbiAgICAgICAgICAgIHRoaXMuaGVsZCA9IHRydWU7XG4gICAgICAgIH0sXG4gICAgICAgIGNhbmNlbDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKHRoaXMuaG9sZEpvYik7XG4gICAgICAgICAgICBpZiAodGhpcy5oZWxkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5maXJlSG9sZCgncmVsZWFzZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5oZWxkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmhlbGRQb2ludGVyID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMudGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuaG9sZEpvYiA9IG51bGw7XG4gICAgICAgIH0sXG4gICAgICAgIGRvd246IGZ1bmN0aW9uKGluRXZlbnQpIHtcbiAgICAgICAgICAgIGlmIChpbkV2ZW50LmlzUHJpbWFyeSAmJiAhdGhpcy5oZWxkUG9pbnRlcikge1xuICAgICAgICAgICAgICAgIHRoaXMuaGVsZFBvaW50ZXIgPSBpbkV2ZW50O1xuICAgICAgICAgICAgICAgIHRoaXMudGFyZ2V0ID0gaW5FdmVudC50YXJnZXQ7XG4gICAgICAgICAgICAgICAgdGhpcy5ob2xkSm9iID0gc2V0SW50ZXJ2YWwodGhpcy5wdWxzZS5iaW5kKHRoaXMpLCB0aGlzLkhPTERfREVMQVkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB1cDogZnVuY3Rpb24oaW5FdmVudCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaGVsZFBvaW50ZXIgJiYgdGhpcy5oZWxkUG9pbnRlci5wb2ludGVySWQgPT09IGluRXZlbnQucG9pbnRlcklkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jYW5jZWwoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgbW92ZTogZnVuY3Rpb24oaW5FdmVudCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaGVsZFBvaW50ZXIgJiYgdGhpcy5oZWxkUG9pbnRlci5wb2ludGVySWQgPT09IGluRXZlbnQucG9pbnRlcklkKSB7XG4gICAgICAgICAgICAgICAgdmFyIHggPSBpbkV2ZW50LmNsaWVudFggLSB0aGlzLmhlbGRQb2ludGVyLmNsaWVudFg7XG4gICAgICAgICAgICAgICAgdmFyIHkgPSBpbkV2ZW50LmNsaWVudFkgLSB0aGlzLmhlbGRQb2ludGVyLmNsaWVudFk7XG4gICAgICAgICAgICAgICAgaWYgKCh4ICogeCArIHkgKiB5KSA+IHRoaXMuV0lHR0xFX1RIUkVTSE9MRCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbmNlbCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZmlyZUhvbGQ6IGZ1bmN0aW9uKGluVHlwZSwgaW5Ib2xkVGltZSkge1xuICAgICAgICAgICAgdmFyIHAgPSB7XG4gICAgICAgICAgICAgICAgYnViYmxlczogdHJ1ZSxcbiAgICAgICAgICAgICAgICBjYW5jZWxhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIHBvaW50ZXJUeXBlOiB0aGlzLmhlbGRQb2ludGVyLnBvaW50ZXJUeXBlLFxuICAgICAgICAgICAgICAgIHBvaW50ZXJJZDogdGhpcy5oZWxkUG9pbnRlci5wb2ludGVySWQsXG4gICAgICAgICAgICAgICAgeDogdGhpcy5oZWxkUG9pbnRlci5jbGllbnRYLFxuICAgICAgICAgICAgICAgIHk6IHRoaXMuaGVsZFBvaW50ZXIuY2xpZW50WSxcbiAgICAgICAgICAgICAgICBfc291cmNlOiAnaG9sZCdcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoaW5Ib2xkVGltZSkge1xuICAgICAgICAgICAgICAgIHAuaG9sZFRpbWUgPSBpbkhvbGRUaW1lO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGUgPSBldmVudEZhY3RvcnkubWFrZUdlc3R1cmVFdmVudChpblR5cGUsIHApO1xuICAgICAgICAgICAgdGhpcy50YXJnZXQuZGlzcGF0Y2hFdmVudChlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgZGlzcGF0Y2hlci5yZWdpc3Rlckdlc3R1cmUoJ2hvbGQnLCBob2xkKTtcbn0pKGV4cG9ydHMpO1xuXG4vKipcbiAqIFRoaXMgZXZlbnQgaXMgZmlyZWQgd2hlbiBhIHBvaW50ZXIgcXVpY2tseSBnb2VzIGRvd24gYW5kIHVwLCBhbmQgaXMgdXNlZCB0b1xuICogZGVub3RlIGFjdGl2YXRpb24uXG4gKlxuICogQW55IGdlc3R1cmUgZXZlbnQgY2FuIHByZXZlbnQgdGhlIHRhcCBldmVudCBmcm9tIGJlaW5nIGNyZWF0ZWQgYnkgY2FsbGluZ1xuICogYGV2ZW50LnByZXZlbnRUYXBgLlxuICpcbiAqIEFueSBwb2ludGVyIGV2ZW50IGNhbiBwcmV2ZW50IHRoZSB0YXAgYnkgc2V0dGluZyB0aGUgYHRhcFByZXZlbnRlZGAgcHJvcGVydHlcbiAqIG9uIGl0c2VsZi5cbiAqXG4gKiBAbW9kdWxlIFBvaW50ZXJHZXN0dXJlc1xuICogQHN1Ym1vZHVsZSBFdmVudHNcbiAqIEBjbGFzcyB0YXBcbiAqL1xuLyoqXG4gKiBYIGF4aXMgcG9zaXRpb24gb2YgdGhlIHRhcC5cbiAqIEBwcm9wZXJ0eSB4XG4gKiBAdHlwZSBOdW1iZXJcbiAqL1xuLyoqXG4gKiBZIGF4aXMgcG9zaXRpb24gb2YgdGhlIHRhcC5cbiAqIEBwcm9wZXJ0eSB5XG4gKiBAdHlwZSBOdW1iZXJcbiAqL1xuLyoqXG4gKiBUeXBlIG9mIHRoZSBwb2ludGVyIHRoYXQgbWFkZSB0aGUgdGFwLlxuICogQHByb3BlcnR5IHBvaW50ZXJUeXBlXG4gKiBAdHlwZSBTdHJpbmdcbiAqL1xuKGZ1bmN0aW9uKHNjb3BlKSB7XG4gICAgdmFyIGRpc3BhdGNoZXIgPSBzY29wZS5kaXNwYXRjaGVyO1xuICAgIHZhciBldmVudEZhY3RvcnkgPSBzY29wZS5ldmVudEZhY3Rvcnk7XG4gICAgdmFyIHBvaW50ZXJtYXAgPSBuZXcgc2NvcGUuUG9pbnRlck1hcCgpO1xuICAgIHZhciB0YXAgPSB7XG4gICAgICAgIGV2ZW50czogW1xuICAgICAgICAgICAgJ2Rvd24nLFxuICAgICAgICAgICAgJ3VwJ1xuICAgICAgICBdLFxuICAgICAgICBleHBvc2VzOiBbXG4gICAgICAgICAgICAndGFwJ1xuICAgICAgICBdLFxuICAgICAgICBkb3duOiBmdW5jdGlvbihpbkV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoaW5FdmVudC5pc1ByaW1hcnkgJiYgIWluRXZlbnQudGFwUHJldmVudGVkKSB7XG4gICAgICAgICAgICAgICAgcG9pbnRlcm1hcC5zZXQoaW5FdmVudC5wb2ludGVySWQsIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiBpbkV2ZW50LnRhcmdldCxcbiAgICAgICAgICAgICAgICAgICAgYnV0dG9uczogaW5FdmVudC5idXR0b25zLFxuICAgICAgICAgICAgICAgICAgICB4OiBpbkV2ZW50LmNsaWVudFgsXG4gICAgICAgICAgICAgICAgICAgIHk6IGluRXZlbnQuY2xpZW50WVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBzaG91bGRUYXA6IGZ1bmN0aW9uKGUsIGRvd25TdGF0ZSkge1xuICAgICAgICAgICAgdmFyIHRhcCA9IHRydWU7XG4gICAgICAgICAgICBpZiAoZS5wb2ludGVyVHlwZSA9PT0gJ21vdXNlJykge1xuICAgICAgICAgICAgICAgIC8vIG9ubHkgYWxsb3cgbGVmdCBjbGljayB0byB0YXAgZm9yIG1vdXNlXG4gICAgICAgICAgICAgICAgdGFwID0gKGUuYnV0dG9ucyBeIDEpICYmIChkb3duU3RhdGUuYnV0dG9ucyAmIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRhcCAmJiAhZS50YXBQcmV2ZW50ZWQ7XG4gICAgICAgIH0sXG4gICAgICAgIHVwOiBmdW5jdGlvbihpbkV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgc3RhcnQgPSBwb2ludGVybWFwLmdldChpbkV2ZW50LnBvaW50ZXJJZCk7XG4gICAgICAgICAgICBpZiAoc3RhcnQgJiYgdGhpcy5zaG91bGRUYXAoaW5FdmVudCwgc3RhcnQpKSB7XG4gICAgICAgICAgICAgICAgLy8gdXAucmVsYXRlZFRhcmdldCBpcyB0YXJnZXQgY3VycmVudGx5IHVuZGVyIGZpbmdlclxuICAgICAgICAgICAgICAgIHZhciB0ID0gc2NvcGUudGFyZ2V0RmluZGluZy5MQ0Eoc3RhcnQudGFyZ2V0LCBpbkV2ZW50LnJlbGF0ZWRUYXJnZXQpO1xuICAgICAgICAgICAgICAgIGlmICh0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlID0gZXZlbnRGYWN0b3J5Lm1ha2VHZXN0dXJlRXZlbnQoJ3RhcCcsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBjYW5jZWxhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgeDogaW5FdmVudC5jbGllbnRYLFxuICAgICAgICAgICAgICAgICAgICAgICAgeTogaW5FdmVudC5jbGllbnRZLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGV0YWlsOiBpbkV2ZW50LmRldGFpbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvaW50ZXJUeXBlOiBpbkV2ZW50LnBvaW50ZXJUeXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9pbnRlcklkOiBpbkV2ZW50LnBvaW50ZXJJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsdEtleTogaW5FdmVudC5hbHRLZXksXG4gICAgICAgICAgICAgICAgICAgICAgICBjdHJsS2V5OiBpbkV2ZW50LmN0cmxLZXksXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRhS2V5OiBpbkV2ZW50Lm1ldGFLZXksXG4gICAgICAgICAgICAgICAgICAgICAgICBzaGlmdEtleTogaW5FdmVudC5zaGlmdEtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF9zb3VyY2U6ICd0YXAnXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB0LmRpc3BhdGNoRXZlbnQoZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9pbnRlcm1hcC5kZWxldGUoaW5FdmVudC5wb2ludGVySWQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBwYXRjaCBldmVudEZhY3RvcnkgdG8gcmVtb3ZlIGlkIGZyb20gdGFwJ3MgcG9pbnRlcm1hcCBmb3IgcHJldmVudFRhcCBjYWxsc1xuICAgIGV2ZW50RmFjdG9yeS5wcmV2ZW50VGFwID0gZnVuY3Rpb24oZSkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBlLnRhcFByZXZlbnRlZCA9IHRydWU7XG4gICAgICAgICAgICBwb2ludGVybWFwLmRlbGV0ZShlLnBvaW50ZXJJZCk7XG4gICAgICAgIH07XG4gICAgfTtcbiAgICBkaXNwYXRjaGVyLnJlZ2lzdGVyR2VzdHVyZSgndGFwJywgdGFwKTtcbn0pKGV4cG9ydHMpO1xuXG4vKlxuICogQmFzaWMgc3RyYXRlZ3k6IGZpbmQgdGhlIGZhcnRoZXN0IGFwYXJ0IHBvaW50cywgdXNlIGFzIGRpYW1ldGVyIG9mIGNpcmNsZVxuICogcmVhY3QgdG8gc2l6ZSBjaGFuZ2UgYW5kIHJvdGF0aW9uIG9mIHRoZSBjaG9yZFxuICovXG5cbi8qKlxuICogQG1vZHVsZSBwb2ludGVyLWdlc3R1cmVzXG4gKiBAc3VibW9kdWxlIEV2ZW50c1xuICogQGNsYXNzIHBpbmNoXG4gKi9cbi8qKlxuICogU2NhbGUgb2YgdGhlIHBpbmNoIHpvb20gZ2VzdHVyZVxuICogQHByb3BlcnR5IHNjYWxlXG4gKiBAdHlwZSBOdW1iZXJcbiAqL1xuLyoqXG4gKiBDZW50ZXIgWCBwb3NpdGlvbiBvZiBwb2ludGVycyBjYXVzaW5nIHBpbmNoXG4gKiBAcHJvcGVydHkgY2VudGVyWFxuICogQHR5cGUgTnVtYmVyXG4gKi9cbi8qKlxuICogQ2VudGVyIFkgcG9zaXRpb24gb2YgcG9pbnRlcnMgY2F1c2luZyBwaW5jaFxuICogQHByb3BlcnR5IGNlbnRlcllcbiAqIEB0eXBlIE51bWJlclxuICovXG5cbi8qKlxuICogQG1vZHVsZSBwb2ludGVyLWdlc3R1cmVzXG4gKiBAc3VibW9kdWxlIEV2ZW50c1xuICogQGNsYXNzIHJvdGF0ZVxuICovXG4vKipcbiAqIEFuZ2xlIChpbiBkZWdyZWVzKSBvZiByb3RhdGlvbi4gTWVhc3VyZWQgZnJvbSBzdGFydGluZyBwb3NpdGlvbnMgb2YgcG9pbnRlcnMuXG4gKiBAcHJvcGVydHkgYW5nbGVcbiAqIEB0eXBlIE51bWJlclxuICovXG4vKipcbiAqIENlbnRlciBYIHBvc2l0aW9uIG9mIHBvaW50ZXJzIGNhdXNpbmcgcm90YXRpb25cbiAqIEBwcm9wZXJ0eSBjZW50ZXJYXG4gKiBAdHlwZSBOdW1iZXJcbiAqL1xuLyoqXG4gKiBDZW50ZXIgWSBwb3NpdGlvbiBvZiBwb2ludGVycyBjYXVzaW5nIHJvdGF0aW9uXG4gKiBAcHJvcGVydHkgY2VudGVyWVxuICogQHR5cGUgTnVtYmVyXG4gKi9cbihmdW5jdGlvbihzY29wZSkge1xuICAgIHZhciBkaXNwYXRjaGVyID0gc2NvcGUuZGlzcGF0Y2hlcjtcbiAgICB2YXIgZXZlbnRGYWN0b3J5ID0gc2NvcGUuZXZlbnRGYWN0b3J5O1xuICAgIHZhciBwb2ludGVybWFwID0gbmV3IHNjb3BlLlBvaW50ZXJNYXAoKTtcbiAgICB2YXIgUkFEX1RPX0RFRyA9IDE4MCAvIE1hdGguUEk7XG4gICAgdmFyIHBpbmNoID0ge1xuICAgICAgICBldmVudHM6IFtcbiAgICAgICAgICAgICdkb3duJyxcbiAgICAgICAgICAgICd1cCcsXG4gICAgICAgICAgICAnbW92ZScsXG4gICAgICAgICAgICAnY2FuY2VsJ1xuICAgICAgICBdLFxuICAgICAgICBleHBvc2VzOiBbXG4gICAgICAgICAgICAncGluY2hzdGFydCcsXG4gICAgICAgICAgICAncGluY2gnLFxuICAgICAgICAgICAgJ3BpbmNoZW5kJyxcbiAgICAgICAgICAgICdyb3RhdGUnXG4gICAgICAgIF0sXG4gICAgICAgIGRlZmF1bHRBY3Rpb25zOiB7XG4gICAgICAgICAgICAncGluY2gnOiAnbm9uZScsXG4gICAgICAgICAgICAncm90YXRlJzogJ25vbmUnXG4gICAgICAgIH0sXG4gICAgICAgIHJlZmVyZW5jZToge30sXG4gICAgICAgIGRvd246IGZ1bmN0aW9uKGluRXZlbnQpIHtcbiAgICAgICAgICAgIHBvaW50ZXJtYXAuc2V0KGluRXZlbnQucG9pbnRlcklkLCBpbkV2ZW50KTtcbiAgICAgICAgICAgIGlmIChwb2ludGVybWFwLnBvaW50ZXJzKCkgPT0gMikge1xuICAgICAgICAgICAgICAgIHZhciBwb2ludHMgPSB0aGlzLmNhbGNDaG9yZCgpO1xuICAgICAgICAgICAgICAgIHZhciBhbmdsZSA9IHRoaXMuY2FsY0FuZ2xlKHBvaW50cyk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWZlcmVuY2UgPSB7XG4gICAgICAgICAgICAgICAgICAgIGFuZ2xlOiBhbmdsZSxcbiAgICAgICAgICAgICAgICAgICAgZGlhbWV0ZXI6IHBvaW50cy5kaWFtZXRlcixcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiBzY29wZS50YXJnZXRGaW5kaW5nLkxDQShwb2ludHMuYS50YXJnZXQsIHBvaW50cy5iLnRhcmdldClcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgdGhpcy5maXJlUGluY2goJ3BpbmNoc3RhcnQnLCBwb2ludHMuZGlhbWV0ZXIsIHBvaW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHVwOiBmdW5jdGlvbihpbkV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgcCA9IHBvaW50ZXJtYXAuZ2V0KGluRXZlbnQucG9pbnRlcklkKTtcbiAgICAgICAgICAgIHZhciBudW0gPSBwb2ludGVybWFwLnBvaW50ZXJzKCk7XG4gICAgICAgICAgICBpZiAocCkge1xuICAgICAgICAgICAgICAgIGlmIChudW0gPT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZmlyZSAncGluY2hlbmQnIGJlZm9yZSBkZWxldGluZyBwb2ludGVyXG4gICAgICAgICAgICAgICAgICAgIHZhciBwb2ludHMgPSB0aGlzLmNhbGNDaG9yZCgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpcmVQaW5jaCgncGluY2hlbmQnLCBwb2ludHMuZGlhbWV0ZXIsIHBvaW50cyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBvaW50ZXJtYXAuZGVsZXRlKGluRXZlbnQucG9pbnRlcklkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgbW92ZTogZnVuY3Rpb24oaW5FdmVudCkge1xuICAgICAgICAgICAgaWYgKHBvaW50ZXJtYXAuaGFzKGluRXZlbnQucG9pbnRlcklkKSkge1xuICAgICAgICAgICAgICAgIHBvaW50ZXJtYXAuc2V0KGluRXZlbnQucG9pbnRlcklkLCBpbkV2ZW50KTtcbiAgICAgICAgICAgICAgICBpZiAocG9pbnRlcm1hcC5wb2ludGVycygpID4gMSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNhbGNQaW5jaFJvdGF0ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgY2FuY2VsOiBmdW5jdGlvbihpbkV2ZW50KSB7XG4gICAgICAgICAgICB0aGlzLnVwKGluRXZlbnQpO1xuICAgICAgICB9LFxuICAgICAgICBmaXJlUGluY2g6IGZ1bmN0aW9uKHR5cGUsIGRpYW1ldGVyLCBwb2ludHMpIHtcbiAgICAgICAgICAgIHZhciB6b29tID0gZGlhbWV0ZXIgLyB0aGlzLnJlZmVyZW5jZS5kaWFtZXRlcjtcbiAgICAgICAgICAgIHZhciBlID0gZXZlbnRGYWN0b3J5Lm1ha2VHZXN0dXJlRXZlbnQodHlwZSwge1xuICAgICAgICAgICAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICAgICAgICAgICAgY2FuY2VsYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBzY2FsZTogem9vbSxcbiAgICAgICAgICAgICAgICBjZW50ZXJYOiBwb2ludHMuY2VudGVyLngsXG4gICAgICAgICAgICAgICAgY2VudGVyWTogcG9pbnRzLmNlbnRlci55LFxuICAgICAgICAgICAgICAgIF9zb3VyY2U6ICdwaW5jaCdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5yZWZlcmVuY2UudGFyZ2V0LmRpc3BhdGNoRXZlbnQoZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGZpcmVSb3RhdGU6IGZ1bmN0aW9uKGFuZ2xlLCBwb2ludHMpIHtcbiAgICAgICAgICAgIHZhciBkaWZmID0gTWF0aC5yb3VuZCgoYW5nbGUgLSB0aGlzLnJlZmVyZW5jZS5hbmdsZSkgJSAzNjApO1xuICAgICAgICAgICAgdmFyIGUgPSBldmVudEZhY3RvcnkubWFrZUdlc3R1cmVFdmVudCgncm90YXRlJywge1xuICAgICAgICAgICAgICAgIGJ1YmJsZXM6IHRydWUsXG4gICAgICAgICAgICAgICAgY2FuY2VsYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBhbmdsZTogZGlmZixcbiAgICAgICAgICAgICAgICBjZW50ZXJYOiBwb2ludHMuY2VudGVyLngsXG4gICAgICAgICAgICAgICAgY2VudGVyWTogcG9pbnRzLmNlbnRlci55LFxuICAgICAgICAgICAgICAgIF9zb3VyY2U6ICdwaW5jaCdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5yZWZlcmVuY2UudGFyZ2V0LmRpc3BhdGNoRXZlbnQoZSk7XG4gICAgICAgIH0sXG4gICAgICAgIGNhbGNQaW5jaFJvdGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgcG9pbnRzID0gdGhpcy5jYWxjQ2hvcmQoKTtcbiAgICAgICAgICAgIHZhciBkaWFtZXRlciA9IHBvaW50cy5kaWFtZXRlcjtcbiAgICAgICAgICAgIHZhciBhbmdsZSA9IHRoaXMuY2FsY0FuZ2xlKHBvaW50cyk7XG4gICAgICAgICAgICBpZiAoZGlhbWV0ZXIgIT0gdGhpcy5yZWZlcmVuY2UuZGlhbWV0ZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmZpcmVQaW5jaCgncGluY2gnLCBkaWFtZXRlciwgcG9pbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhbmdsZSAhPSB0aGlzLnJlZmVyZW5jZS5hbmdsZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZmlyZVJvdGF0ZShhbmdsZSwgcG9pbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgY2FsY0Nob3JkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBwb2ludGVycyA9IFtdO1xuICAgICAgICAgICAgcG9pbnRlcm1hcC5mb3JFYWNoKGZ1bmN0aW9uKHApIHtcbiAgICAgICAgICAgICAgICBwb2ludGVycy5wdXNoKHApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB2YXIgZGlzdCA9IDA7XG4gICAgICAgICAgICAvLyBzdGFydCB3aXRoIGF0IGxlYXN0IHR3byBwb2ludGVyc1xuICAgICAgICAgICAgdmFyIHBvaW50cyA9IHtcbiAgICAgICAgICAgICAgICBhOiBwb2ludGVyc1swXSxcbiAgICAgICAgICAgICAgICBiOiBwb2ludGVyc1sxXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHZhciB4LCB5LCBkO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBhID0gcG9pbnRlcnNbaV07XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IGkgKyAxOyBqIDwgcG9pbnRlcnMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGIgPSBwb2ludGVyc1tqXTtcbiAgICAgICAgICAgICAgICAgICAgeCA9IE1hdGguYWJzKGEuY2xpZW50WCAtIGIuY2xpZW50WCk7XG4gICAgICAgICAgICAgICAgICAgIHkgPSBNYXRoLmFicyhhLmNsaWVudFkgLSBiLmNsaWVudFkpO1xuICAgICAgICAgICAgICAgICAgICBkID0geCArIHk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkID4gZGlzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlzdCA9IGQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb2ludHMgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYTogYSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBiOiBiXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgeCA9IE1hdGguYWJzKHBvaW50cy5hLmNsaWVudFggKyBwb2ludHMuYi5jbGllbnRYKSAvIDI7XG4gICAgICAgICAgICB5ID0gTWF0aC5hYnMocG9pbnRzLmEuY2xpZW50WSArIHBvaW50cy5iLmNsaWVudFkpIC8gMjtcbiAgICAgICAgICAgIHBvaW50cy5jZW50ZXIgPSB7XG4gICAgICAgICAgICAgICAgeDogeCxcbiAgICAgICAgICAgICAgICB5OiB5XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcG9pbnRzLmRpYW1ldGVyID0gZGlzdDtcbiAgICAgICAgICAgIHJldHVybiBwb2ludHM7XG4gICAgICAgIH0sXG4gICAgICAgIGNhbGNBbmdsZTogZnVuY3Rpb24ocG9pbnRzKSB7XG4gICAgICAgICAgICB2YXIgeCA9IHBvaW50cy5hLmNsaWVudFggLSBwb2ludHMuYi5jbGllbnRYO1xuICAgICAgICAgICAgdmFyIHkgPSBwb2ludHMuYS5jbGllbnRZIC0gcG9pbnRzLmIuY2xpZW50WTtcbiAgICAgICAgICAgIHJldHVybiAoMzYwICsgTWF0aC5hdGFuMih5LCB4KSAqIFJBRF9UT19ERUcpICUgMzYwO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBkaXNwYXRjaGVyLnJlZ2lzdGVyR2VzdHVyZSgncGluY2gnLCBwaW5jaCk7XG59KShleHBvcnRzKTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciBCYXNlID0gcmVxdWlyZSgnZXh0ZW5kLW1lJykuQmFzZTtcblxudmFyIERhdGFOb2RlQmFzZSA9IEJhc2UuZXh0ZW5kKCdEYXRhTm9kZUJhc2UnLCB7XG5cbiAgICBpc051bGxPYmplY3Q6IGZhbHNlLFxuXG4gICAgSU5ERU5UOiAnICAgJywgLy8gMyBzcGFjZXNcblxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICB0aGlzLmxhYmVsID0ga2V5O1xuICAgICAgICB0aGlzLmRhdGEgPSBbJyddOyAvLyBUT0RPOiBXaHkgaXMgdGhpcyBmaXJzdCBlbGVtZW50IG5lZWRlZD9cbiAgICAgICAgdGhpcy5pbmRleCA9IFtdOyAvLyBUT0RPOiBmb3JtZXJseSByb3dJbmRleFxuICAgICAgICB0aGlzLmhhc0NoaWxkcmVuID0gZmFsc2U7IC8vIFRPRE86IFdoZXJlL2hvdyBpcyB0aGlzIHVzZWQ/XG4gICAgICAgIHRoaXMuZGVwdGggPSAwO1xuICAgICAgICB0aGlzLmhlaWdodCA9IDE7XG4gICAgICAgIHRoaXMuZXhwYW5kZWQgPSBmYWxzZTtcbiAgICB9LFxuXG4gICAgZ2V0VmFsdWU6IGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVt4XTtcbiAgICB9LFxuXG4gICAgcHJ1bmU6IGZ1bmN0aW9uKGRlcHRoKSB7XG4gICAgICAgIHRoaXMuZGVwdGggPSBkZXB0aDtcbiAgICAgICAgdGhpcy5kYXRhWzBdID0gdGhpcy5jb21wdXRlRGVwdGhTdHJpbmcoKTtcbiAgICB9LFxuXG4gICAgY29tcHV0ZURlcHRoU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5KHRoaXMuZGVwdGggKyAxKS5qb2luKHRoaXMuSU5ERU5UKSArICcgICcgKyB0aGlzLmxhYmVsO1xuICAgIH0sXG5cbiAgICBjb21wdXRlSGVpZ2h0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfSxcblxuICAgIGdldEluZGV4OiBmdW5jdGlvbigpIHsgLy8gVE9ETzogZm9ybWVybHkgZ2V0QWxsUm93SW5kZXhlc1xuICAgICAgICByZXR1cm4gdGhpcy5pbmRleDtcbiAgICB9LFxuXG4gICAgY29tcHV0ZUFnZ3JlZ2F0ZXM6IGZ1bmN0aW9uKGFnZ3JlZ2F0b3IpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5nZXRJbmRleCgpO1xuXG4gICAgICAgIGlmIChpbmRleC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBncm91cHNPZmZzZXQgPSBOdW1iZXIoYWdncmVnYXRvci5oYXNHcm91cHMoKSk7XG5cbiAgICAgICAgICAgIC8vIHJlZGltZW5zaW9uIHRoZSBkYXRhXG4gICAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICAgICAgICAgIGRhdGEubGVuZ3RoID0gZ3JvdXBzT2Zmc2V0ICsgYWdncmVnYXRvci5hZ2dyZWdhdGVzLmxlbmd0aDtcblxuICAgICAgICAgICAgdmFyIHNvcnRlciA9IGFnZ3JlZ2F0b3Iuc29ydGVySW5zdGFuY2U7XG4gICAgICAgICAgICBzb3J0ZXIuaW5kZXggPSBpbmRleDtcblxuICAgICAgICAgICAgYWdncmVnYXRvci5hZ2dyZWdhdGVzLmZvckVhY2goZnVuY3Rpb24oYWdncmVnYXRlLCBpKSB7XG4gICAgICAgICAgICAgICAgZGF0YVtncm91cHNPZmZzZXQgKyBpXSA9IGFnZ3JlZ2F0ZShzb3J0ZXIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgYnVpbGRWaWV3OiBmdW5jdGlvbihhZ2dyZWdhdG9yKSB7XG4gICAgICAgIGFnZ3JlZ2F0b3IuYWRkVmlldyh0aGlzKTtcbiAgICB9LFxuXG4gICAgdG9nZ2xlRXhwYW5zaW9uU3RhdGU6IGZ1bmN0aW9uKCkgeyAvKiBhZ2dyZWdhdG9yICovXG4gICAgICAgIC8vZG8gbm90aGluZyBieSBkZWZhdWx0XG4gICAgfVxuXG59KTtcblxuLy9EYXRhTm9kZUJhc2UucHJvdG90eXBlLmFwcGx5QWdncmVnYXRlcyA9IERhdGFOb2RlQmFzZS5wcm90b3R5cGUuY29tcHV0ZUFnZ3JlZ2F0ZXM7XG5cbm1vZHVsZS5leHBvcnRzID0gRGF0YU5vZGVCYXNlOyIsIid1c2Ugc3RyaWN0JztcblxudmFyIE1hcCA9IHJlcXVpcmUoJy4vdXRpbC9NYXBweScpO1xudmFyIERhdGFOb2RlQmFzZSA9IHJlcXVpcmUoJy4vRGF0YU5vZGVCYXNlJyk7XG5cbnZhciBleHBhbmRlZE1hcCA9IHtcbiAgICB0cnVlOiAnXFx1MjViZScsIC8vICfilr4nXG4gICAgZmFsc2U6ICdcXHUyNWI4JyAvLyAn4pa4J1xufTtcblxudmFyIERhdGFOb2RlR3JvdXAgPSBEYXRhTm9kZUJhc2UuZXh0ZW5kKCdEYXRhTm9kZUdyb3VwJywge1xuXG4gICAgZXh0ZW5kYWJsZTogdHJ1ZSxcblxuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gbmV3IE1hcCgpO1xuICAgIH0sXG5cbiAgICBwcnVuZTogZnVuY3Rpb24oZGVwdGgpIHtcbiAgICAgICAgdGhpcy5kZXB0aCA9IGRlcHRoO1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbi52YWx1ZXM7IC8vIFRPRE86IHdoeT9cbiAgICAgICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICAgICAgICBjaGlsZC5wcnVuZShkZXB0aCArIDEpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5kYXRhWzBdID0gdGhpcy5jb21wdXRlRGVwdGhTdHJpbmcoKTtcbiAgICB9LFxuXG4gICAgY29tcHV0ZURlcHRoU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5KHRoaXMuZGVwdGggKyAxKS5qb2luKHRoaXMuSU5ERU5UKSArXG4gICAgICAgICAgICBleHBhbmRlZE1hcFt0aGlzLmV4cGFuZGVkXSArICcgJyArXG4gICAgICAgICAgICB0aGlzLmxhYmVsO1xuICAgIH0sXG5cbiAgICBnZXRJbmRleDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLmluZGV4Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5pbmRleCA9IHRoaXMuY29tcHV0ZUluZGV4KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuaW5kZXg7XG4gICAgfSxcblxuICAgIGNvbXB1dGVJbmRleDogZnVuY3Rpb24oKSB7IC8vIFRPRE86IGZvcm1lcmx5IGNvbXB1dGVyQWxsUm93SW5kZXhlc1xuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgIHJlc3VsdC5hcHBlbmQgPSBhcHBlbmQ7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbihjaGlsZCkge1xuICAgICAgICAgICAgcmVzdWx0LmFwcGVuZChjaGlsZC5nZXRJbmRleCgpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIHRvZ2dsZUV4cGFuc2lvblN0YXRlOiBmdW5jdGlvbihhZ2dyZWdhdG9yKSB7IC8qIGFnZ3JlZ2F0b3IgKi9cbiAgICAgICAgdGhpcy5leHBhbmRlZCA9ICF0aGlzLmV4cGFuZGVkO1xuICAgICAgICB0aGlzLmRhdGFbMF0gPSB0aGlzLmNvbXB1dGVEZXB0aFN0cmluZygpO1xuICAgICAgICBpZiAodGhpcy5leHBhbmRlZCkge1xuICAgICAgICAgICAgdGhpcy5jb21wdXRlQWdncmVnYXRlcyhhZ2dyZWdhdG9yKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBjb21wdXRlQWdncmVnYXRlczogZnVuY3Rpb24oYWdncmVnYXRvcikge1xuICAgICAgICBEYXRhTm9kZUJhc2UucHJvdG90eXBlLmNvbXB1dGVBZ2dyZWdhdGVzLmNhbGwodGhpcywgYWdncmVnYXRvcik7IC8vIGNhbGwgYmFzZSBjbGFzcydzIHZlcnNpb25cbiAgICAgICAgaWYgKHRoaXMuZXhwYW5kZWQpIHtcbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbihjaGlsZCkge1xuICAgICAgICAgICAgICAgIGNoaWxkLmNvbXB1dGVBZ2dyZWdhdGVzKGFnZ3JlZ2F0b3IpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgYnVpbGRWaWV3OiBmdW5jdGlvbihhZ2dyZWdhdG9yKSB7XG4gICAgICAgIGFnZ3JlZ2F0b3Iudmlldy5wdXNoKHRoaXMpO1xuICAgICAgICBpZiAodGhpcy5leHBhbmRlZCkge1xuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgY2hpbGQuYnVpbGRWaWV3KGFnZ3JlZ2F0b3IpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgY29tcHV0ZUhlaWdodDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBoZWlnaHQgPSAxO1xuXG4gICAgICAgIGlmICh0aGlzLmV4cGFuZGVkKSB7XG4gICAgICAgICAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgICAgICAgICAgICBoZWlnaHQgPSBoZWlnaHQgKyBjaGlsZC5jb21wdXRlSGVpZ2h0KCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAodGhpcy5oZWlnaHQgPSBoZWlnaHQpO1xuICAgIH1cblxufSk7XG5cbi8qKlxuICogQHN1bW1hcnkgQXJyYXkgbWl4aW4gdG8gYXBwZW5kIGFub3RoZXIgYXJyYXkgdG8gZW5kIG9mIGB0aGlzYCBvbmUuXG4gKiBAZGVzYyBBcHBlbmRzIGluIHBsYWNlLCB1bmxpa2UgYHRoaXMuY29uY2F0KClgIHdoaWNoIGNyZWF0ZXMgYSBuZXcgYXJyYXkuXG4gKiBVc2VzIGxlc3MgbWVtb3J5IHRoYW4gY29uY2F0LCBpbXBvcnRhbnQgd2hlbiBgYXBwZW5kaXhgIGlzIGh1Z2UuXG4gKiA+IENBVVRJT046IE11dGF0ZXMgYHRoaXNgIGFycmF5IVxuICogQHBhcmFtIHtBcnJheX0gYXBwZW5kaXhcbiAqIEByZXR1cm5zIHtBcnJheX0gUmVmZXJlbmNlIHRvIGB0aGlzYCAoZm9yIGNvbnZlbmllbmNlKVxuICovXG5mdW5jdGlvbiBhcHBlbmQoYXBwZW5kaXgpIHtcbiAgICB0aGlzLnNwbGljZS5iaW5kKHRoaXMsIHRoaXMubGVuZ3RoLCAwKS5hcHBseSh0aGlzLCBhcHBlbmRpeCk7XG4gICAgcmV0dXJuIHRoaXM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gRGF0YU5vZGVHcm91cDsiLCIndXNlIHN0cmljdCc7XG5cbnZhciBEYXRhTm9kZUJhc2UgPSByZXF1aXJlKCcuL0RhdGFOb2RlQmFzZScpO1xuXG52YXIgRGF0YU5vZGVMZWFmID0gRGF0YU5vZGVCYXNlLmV4dGVuZCgnRGF0YU5vZGVMZWFmJywge1xuXG4gICAgcHJ1bmU6IGZ1bmN0aW9uKGRlcHRoKSB7XG4gICAgICAgIHRoaXMuZGVwdGggPSBkZXB0aDtcbiAgICAgICAgdGhpcy5kYXRhWzBdID0gdGhpcy5jb21wdXRlRGVwdGhTdHJpbmcoKTtcbiAgICB9LFxuXG4gICAgZ2V0SW5kZXg6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbmRleDtcbiAgICB9LFxuXG4gICAgYnVpbGRWaWV3OiBmdW5jdGlvbihhZ2dyZWdhdG9yKSB7XG4gICAgICAgIGFnZ3JlZ2F0b3IuYWRkVmlldyh0aGlzKTtcbiAgICB9LFxuXG4gICAgY29tcHV0ZUhlaWdodDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gRGF0YU5vZGVMZWFmOyIsIid1c2Ugc3RyaWN0JztcblxudmFyIERhdGFOb2RlR3JvdXAgPSByZXF1aXJlKCcuL0RhdGFOb2RlR3JvdXAnKTtcblxudmFyIERhdGFOb2RlVHJlZSA9IERhdGFOb2RlR3JvdXAuZXh0ZW5kKCdEYXRhTm9kZVRyZWUnLCB7XG5cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSAwO1xuICAgICAgICB0aGlzLmV4cGFuZGVkID0gdHJ1ZTtcbiAgICB9LFxuXG4gICAgcHJ1bmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbi52YWx1ZXM7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbihjaGlsZCkge1xuICAgICAgICAgICAgY2hpbGQucHJ1bmUoMCk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBidWlsZFZpZXc6IGZ1bmN0aW9uKGFnZ3JlZ2F0b3IpIHtcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICAgICAgICBjaGlsZC5idWlsZFZpZXcoYWdncmVnYXRvcik7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBjb21wdXRlSGVpZ2h0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGhlaWdodCA9IDE7XG5cbiAgICAgICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uKGNoaWxkKSB7XG4gICAgICAgICAgICBoZWlnaHQgPSBoZWlnaHQgKyBjaGlsZC5jb21wdXRlSGVpZ2h0KCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiAodGhpcy5oZWlnaHQgPSBoZWlnaHQpO1xuICAgIH1cblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gRGF0YU5vZGVUcmVlOyIsIid1c2Ugc3RyaWN0JztcblxudmFyIGhlYWRlcmlmeSA9IHJlcXVpcmUoJy4vdXRpbC9oZWFkZXJpZnknKTtcblxuZnVuY3Rpb24gRGF0YVNvdXJjZShkYXRhLCBmaWVsZHMpIHtcbiAgICB0aGlzLmZpZWxkcyA9IGZpZWxkcyB8fCBjb21wdXRlRmllbGROYW1lcyhkYXRhWzBdKTtcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xufVxuXG5EYXRhU291cmNlLnByb3RvdHlwZSA9IHtcbiAgICBjb25zdHJ1Y3RvcjogRGF0YVNvdXJjZS5wcm90b3R5cGUuY29uc3RydWN0b3IsIC8vIHByZXNlcnZlIGNvbnN0cnVjdG9yXG5cbiAgICBpc051bGxPYmplY3Q6IGZhbHNlLFxuXG4gICAgZ2V0Um93OiBmdW5jdGlvbih5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFbeV07XG4gICAgfSxcblxuICAgIGdldFZhbHVlOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgIHZhciByb3cgPSB0aGlzLmdldFJvdyh5KTtcbiAgICAgICAgaWYgKCFyb3cpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByb3dbdGhpcy5maWVsZHNbeF1dO1xuICAgIH0sXG5cbiAgICBzZXRWYWx1ZTogZnVuY3Rpb24oeCwgeSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5nZXRSb3coeSlbdGhpcy5maWVsZHNbeF1dID0gdmFsdWU7XG4gICAgfSxcblxuICAgIGdldFJvd0NvdW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YS5sZW5ndGg7XG4gICAgfSxcblxuICAgIGdldENvbHVtbkNvdW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RmllbGRzKCkubGVuZ3RoO1xuICAgIH0sXG5cbiAgICBnZXRGaWVsZHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5maWVsZHM7XG4gICAgfSxcblxuICAgIGdldEhlYWRlcnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgdGhpcy5oZWFkZXJzID0gdGhpcy5oZWFkZXJzIHx8XG4gICAgICAgICAgICB0aGlzLmdldERlZmF1bHRIZWFkZXJzKCkubWFwKGZ1bmN0aW9uKGVhY2gpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaGVhZGVyaWZ5KGVhY2gpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICB9LFxuXG4gICAgZ2V0RGVmYXVsdEhlYWRlcnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRGaWVsZHMoKTtcbiAgICB9LFxuXG4gICAgc2V0RmllbGRzOiBmdW5jdGlvbihmaWVsZHMpIHtcbiAgICAgICAgdGhpcy5maWVsZHMgPSBmaWVsZHM7XG4gICAgfSxcblxuICAgIHNldEhlYWRlcnM6IGZ1bmN0aW9uKGhlYWRlcnMpIHtcbiAgICAgICAgaWYgKCEoaGVhZGVycyBpbnN0YW5jZW9mIEFycmF5KSkge1xuICAgICAgICAgICAgZXJyb3IoJ3NldEhlYWRlcnMnLCAncGFyYW0gIzEgYGhlYWRlcnNgIG5vdCBhcnJheScpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaGVhZGVycyA9IGhlYWRlcnM7XG4gICAgfSxcblxuICAgIGdldEdyYW5kVG90YWxzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy9ub3RoaW5nIGhlcmVcbiAgICAgICAgcmV0dXJuO1xuICAgIH0sXG5cbiAgICBzZXREYXRhOiBmdW5jdGlvbihhcnJheU9mVW5pZm9ybU9iamVjdHMpIHtcbiAgICAgICAgdGhpcy5kYXRhID0gYXJyYXlPZlVuaWZvcm1PYmplY3RzO1xuICAgIH1cbn07XG5cbmZ1bmN0aW9uIGVycm9yKG1ldGhvZE5hbWUsIG1lc3NhZ2UpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0RhdGFTb3VyY2UuJyArIG1ldGhvZE5hbWUgKyAnOiAnICsgbWVzc2FnZSk7XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVGaWVsZE5hbWVzKG9iamVjdCkge1xuICAgIGlmICghb2JqZWN0KSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgdmFyIGZpZWxkcyA9IFtdLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhvYmplY3QpLmZpbHRlcihmdW5jdGlvbihlKSB7XG4gICAgICAgIHJldHVybiBlLnN1YnN0cigwLCAyKSAhPT0gJ19fJztcbiAgICB9KSk7XG4gICAgcmV0dXJuIGZpZWxkcztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBEYXRhU291cmNlOyIsIid1c2Ugc3RyaWN0JztcblxudmFyIF8gPSByZXF1aXJlKCdvYmplY3QtaXRlcmF0b3JzJyk7XG5cbnZhciBEYXRhU291cmNlU29ydGVyID0gcmVxdWlyZSgnLi9EYXRhU291cmNlU29ydGVyJyk7XG52YXIgRGF0YU5vZGVUcmVlID0gcmVxdWlyZSgnLi9EYXRhTm9kZVRyZWUnKTtcbnZhciBEYXRhTm9kZUdyb3VwID0gcmVxdWlyZSgnLi9EYXRhTm9kZUdyb3VwJyk7XG52YXIgRGF0YU5vZGVMZWFmID0gcmVxdWlyZSgnLi9EYXRhTm9kZUxlYWYnKTtcbnZhciBoZWFkZXJpZnkgPSByZXF1aXJlKCcuL3V0aWwvaGVhZGVyaWZ5Jyk7XG5cbi8vP1t0LGMsYixhXVxuLy8gdCBpcyBhIGRhdGFTb3VyY2UsXG4vLyBhIGlzIGEgZGljdGlvbmFyeSBvZiBhZ2dyZWdhdGVzLCAgY29sdW1uTmFtZTpmdW5jdGlvblxuLy8gYiBpcyBhIGRpY3Rpb25hcnkgb2YgZ3JvdXBieXMsIGNvbHVtbk5hbWU6c291cmNlQ29sdW1uTmFtZVxuLy8gYyBpcyBhIGxpc3Qgb2YgY29uc3RyYWludHMsXG5cbmZ1bmN0aW9uIERhdGFTb3VyY2VBZ2dyZWdhdG9yKGRhdGFTb3VyY2UpIHtcbiAgICB0aGlzLmRhdGFTb3VyY2UgPSBkYXRhU291cmNlO1xuICAgIHRoaXMudHJlZSA9IG5ldyBEYXRhTm9kZVRyZWUoJ1RvdGFscycpO1xuICAgIHRoaXMuaW5kZXggPSBbXTtcbiAgICB0aGlzLmFnZ3JlZ2F0ZXMgPSBbXTtcbiAgICB0aGlzLmhlYWRlcnMgPSBbXTtcbiAgICB0aGlzLmdyb3VwQnlzID0gW107XG4gICAgdGhpcy52aWV3ID0gW107XG4gICAgdGhpcy5zb3J0ZXJJbnN0YW5jZSA9IHt9O1xuICAgIHRoaXMucHJlc29ydEdyb3VwcyA9IHRydWU7XG4gICAgdGhpcy5sYXN0QWdncmVnYXRlID0ge307XG4gICAgdGhpcy5zZXRBZ2dyZWdhdGVzKHt9KTtcbn1cblxuRGF0YVNvdXJjZUFnZ3JlZ2F0b3IucHJvdG90eXBlID0ge1xuICAgIGNvbnN0cnVjdG9yOiBEYXRhU291cmNlQWdncmVnYXRvci5wcm90b3R5cGUuY29uc3RydWN0b3IsIC8vIHByZXNlcnZlIGNvbnN0cnVjdG9yXG5cbiAgICBpc051bGxPYmplY3Q6IGZhbHNlLFxuXG4gICAgc2V0QWdncmVnYXRlczogZnVuY3Rpb24oYWdncmVnYXRpb25zKSB7XG4gICAgICAgIHRoaXMubGFzdEFnZ3JlZ2F0ZSA9IGFnZ3JlZ2F0aW9ucztcbiAgICAgICAgdGhpcy5jbGVhckFnZ3JlZ2F0aW9ucygpO1xuICAgICAgICB0aGlzLmhlYWRlcnMubGVuZ3RoID0gMDtcblxuICAgICAgICBpZiAodGhpcy5oYXNHcm91cHMoKSkge1xuICAgICAgICAgICAgdGhpcy5oZWFkZXJzLnB1c2goJ1RyZWUnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgXyhhZ2dyZWdhdGlvbnMpLmVhY2goZnVuY3Rpb24oYWdncmVnYXRpb24sIGtleSkge1xuICAgICAgICAgICAgc2VsZi5hZGRBZ2dyZWdhdGUoa2V5LCBhZ2dyZWdhdGlvbik7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBhZGRBZ2dyZWdhdGU6IGZ1bmN0aW9uKGxhYmVsLCBmdW5jKSB7XG4gICAgICAgIHRoaXMuaGVhZGVycy5wdXNoKGhlYWRlcmlmeShsYWJlbCkpO1xuICAgICAgICB0aGlzLmFnZ3JlZ2F0ZXMucHVzaChmdW5jKTtcbiAgICB9LFxuXG4gICAgc2V0R3JvdXBCeXM6IGZ1bmN0aW9uKGNvbHVtbkluZGV4QXJyYXkpIHtcbiAgICAgICAgdmFyIGdyb3VwQnlzID0gdGhpcy5ncm91cEJ5cztcbiAgICAgICAgZ3JvdXBCeXMubGVuZ3RoID0gMDtcbiAgICAgICAgY29sdW1uSW5kZXhBcnJheS5mb3JFYWNoKGZ1bmN0aW9uKGNvbHVtbkluZGV4KSB7XG4gICAgICAgICAgICBncm91cEJ5cy5wdXNoKGNvbHVtbkluZGV4KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc2V0QWdncmVnYXRlcyh0aGlzLmxhc3RBZ2dyZWdhdGUpO1xuICAgIH0sXG5cbiAgICBhZGRHcm91cEJ5OiBmdW5jdGlvbihpbmRleCkge1xuICAgICAgICB0aGlzLmdyb3VwQnlzLnB1c2goaW5kZXgpO1xuICAgIH0sXG5cbiAgICBoYXNHcm91cHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gISF0aGlzLmdyb3VwQnlzLmxlbmd0aDtcbiAgICB9LFxuXG4gICAgaGFzQWdncmVnYXRlczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMuYWdncmVnYXRlcy5sZW5ndGg7XG4gICAgfSxcblxuICAgIGFwcGx5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5idWlsZEdyb3VwVHJlZSgpO1xuICAgIH0sXG5cbiAgICBjbGVhckdyb3VwczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuZ3JvdXBCeXMubGVuZ3RoID0gMDtcbiAgICB9LFxuXG4gICAgY2xlYXJBZ2dyZWdhdGlvbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmFnZ3JlZ2F0ZXMubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5oZWFkZXJzLmxlbmd0aCA9IDA7XG4gICAgfSxcblxuICAgIGJ1aWxkR3JvdXBUcmVlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGdyb3VwQnlzID0gdGhpcy5ncm91cEJ5cyxcbiAgICAgICAgICAgIGxlYWZEZXB0aCA9IGdyb3VwQnlzLmxlbmd0aCAtIDEsXG4gICAgICAgICAgICBzb3VyY2UgPSB0aGlzLmRhdGFTb3VyY2UsXG4gICAgICAgICAgICByb3dDb3VudCA9IHNvdXJjZS5nZXRSb3dDb3VudCgpLFxuICAgICAgICAgICAgdHJlZSA9IHRoaXMudHJlZSA9IG5ldyBEYXRhTm9kZVRyZWUoJ1RvdGFscycpO1xuXG4gICAgICAgIC8vIGZpcnN0IHNvcnQgZGF0YVxuICAgICAgICBpZiAodGhpcy5wcmVzb3J0R3JvdXBzKSB7XG4gICAgICAgICAgICBncm91cEJ5cy5yZXZlcnNlKCkuZm9yRWFjaChmdW5jdGlvbihncm91cEJ5KSB7XG4gICAgICAgICAgICAgICAgc291cmNlID0gbmV3IERhdGFTb3VyY2VTb3J0ZXIoc291cmNlKTtcbiAgICAgICAgICAgICAgICBzb3VyY2Uuc29ydE9uKGdyb3VwQnkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciByID0gMDsgciA8IHJvd0NvdW50OyByKyspIHtcbiAgICAgICAgICAgIHZhciBwYXRoID0gdHJlZTtcblxuICAgICAgICAgICAgZ3JvdXBCeXMuZm9yRWFjaChmdW5jdGlvbihnLCBjKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbG9vcC1mdW5jXG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IHNvdXJjZS5nZXRWYWx1ZShnLCByKSxcbiAgICAgICAgICAgICAgICAgICAgdGVybWluYWxOb2RlID0gKGMgPT09IGxlYWZEZXB0aCksXG4gICAgICAgICAgICAgICAgICAgIENvbnN0cnVjdG9yID0gdGVybWluYWxOb2RlID8gRGF0YU5vZGVMZWFmIDogRGF0YU5vZGVHcm91cCxcbiAgICAgICAgICAgICAgICAgICAgaWZBYnNlbnRGdW5jID0gY3JlYXRlTm9kZS5iaW5kKHRoaXMsIENvbnN0cnVjdG9yKTtcbiAgICAgICAgICAgICAgICBwYXRoID0gcGF0aC5jaGlsZHJlbi5nZXRJZkFic2VudChrZXksIGlmQWJzZW50RnVuYyk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcGF0aC5pbmRleC5wdXNoKHIpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zb3J0ZXJJbnN0YW5jZSA9IG5ldyBEYXRhU291cmNlU29ydGVyKHNvdXJjZSk7XG4gICAgICAgIHRyZWUucHJ1bmUoKTtcbiAgICAgICAgdHJlZS5jb21wdXRlQWdncmVnYXRlcyh0aGlzKTtcbiAgICAgICAgdGhpcy5idWlsZFZpZXcoKTtcbiAgICB9LFxuXG4gICAgYWRkVmlldzogZnVuY3Rpb24oZGF0YU5vZGUpIHtcbiAgICAgICAgdGhpcy52aWV3LnB1c2goZGF0YU5vZGUpO1xuICAgIH0sXG5cbiAgICBidWlsZFZpZXc6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnZpZXcubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy50cmVlLmNvbXB1dGVIZWlnaHQoKTtcbiAgICAgICAgdGhpcy50cmVlLmJ1aWxkVmlldyh0aGlzKTtcbiAgICB9LFxuXG4gICAgdmlld01ha2VzU2Vuc2U6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oYXNBZ2dyZWdhdGVzKCk7XG4gICAgfSxcblxuICAgIGdldFZhbHVlOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgIGlmICghdGhpcy52aWV3TWFrZXNTZW5zZSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhU291cmNlLmdldFZhbHVlKHgsIHkpO1xuICAgICAgICB9XG4gICAgICAgIHZhciByb3cgPSB0aGlzLnZpZXdbeV07XG4gICAgICAgIGlmICghcm93KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcm93LmdldFZhbHVlKHgpOyAvLyBUT0RPOiB3aGF0IGtpbmQgb2Ygb2JqZWN0IGlzIHJvdy4uLiA/IHNob3VsZCBpdCBiZSB1bmZpbHRyZWQ/XG4gICAgfSxcblxuICAgIHNldFZhbHVlOiBmdW5jdGlvbih4LCB5LCB2YWx1ZSkge1xuICAgICAgICBpZiAoIXRoaXMudmlld01ha2VzU2Vuc2UoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVNvdXJjZS5zZXRWYWx1ZSh4LCB5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZ2V0Q29sdW1uQ291bnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMudmlld01ha2VzU2Vuc2UoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVNvdXJjZS5nZXRDb2x1bW5Db3VudCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmdldEhlYWRlcnMoKS5sZW5ndGg7XG4gICAgfSxcblxuICAgIGdldFJvd0NvdW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLnZpZXdNYWtlc1NlbnNlKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGFTb3VyY2UuZ2V0Um93Q291bnQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy52aWV3Lmxlbmd0aDsgLy9oZWFkZXIgY29sdW1uXG4gICAgfSxcblxuICAgIGNsaWNrOiBmdW5jdGlvbih5KSB7XG4gICAgICAgIHZhciBncm91cCA9IHRoaXMudmlld1t5XTtcbiAgICAgICAgZ3JvdXAudG9nZ2xlRXhwYW5zaW9uU3RhdGUodGhpcyk7XG4gICAgICAgIHRoaXMuYnVpbGRWaWV3KCk7XG4gICAgfSxcblxuICAgIGdldEhlYWRlcnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMudmlld01ha2VzU2Vuc2UoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVNvdXJjZS5nZXRIZWFkZXJzKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuaGVhZGVyczsgLy8gVE9ETzogVmlld3Mgb3ZlcnJpZGUgZGF0YVNvdXJjZSBoZWFkZXJzIHdpdGggdGhlaXIgb3duIGhlYWRlcnM/XG4gICAgfSxcblxuICAgIHNldEhlYWRlcnM6IGZ1bmN0aW9uKGhlYWRlcnMpIHtcbiAgICAgICAgdGhpcy5kYXRhU291cmNlLnNldEhlYWRlcnMoaGVhZGVycyk7XG4gICAgfSxcblxuICAgIGdldEZpZWxkczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFTb3VyY2UuZ2V0RmllbGRzKCk7XG4gICAgfSxcblxuICAgIHNldEZpZWxkczogZnVuY3Rpb24oZmllbGRzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFTb3VyY2Uuc2V0RmllbGRzKGZpZWxkcyk7XG4gICAgfSxcblxuICAgIGdldEdyYW5kVG90YWxzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHZpZXcgPSB0aGlzLnRyZWU7XG4gICAgICAgIHJldHVybiBbdmlldy5kYXRhXTtcbiAgICB9LFxuXG4gICAgZ2V0Um93OiBmdW5jdGlvbih5KSB7XG4gICAgICAgIGlmICghdGhpcy52aWV3TWFrZXNTZW5zZSgpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhU291cmNlLmdldFJvdyh5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByb2xsdXBzID0gdGhpcy52aWV3W3ldO1xuXG4gICAgICAgIHJldHVybiByb2xsdXBzID8gcm9sbHVwcyA6IHRoaXMudHJlZTtcbiAgICB9LFxuXG4gICAgc2V0RGF0YTogZnVuY3Rpb24oYXJyYXlPZlVuaWZvcm1PYmplY3RzKSB7XG4gICAgICAgIHRoaXMuZGF0YVNvdXJjZS5zZXREYXRhKGFycmF5T2ZVbmlmb3JtT2JqZWN0cyk7XG4gICAgICAgIHRoaXMuYXBwbHkoKTtcbiAgICB9XG59O1xuXG5mdW5jdGlvbiBjcmVhdGVOb2RlKERhdGFOb2RlQ29uc3RydWN0b3IsIGtleSwgbWFwKSB7XG4gICAgdmFyIHZhbHVlID0gbmV3IERhdGFOb2RlQ29uc3RydWN0b3Ioa2V5KTtcbiAgICBtYXAuc2V0KGtleSwgdmFsdWUpO1xuICAgIHJldHVybiB2YWx1ZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBEYXRhU291cmNlQWdncmVnYXRvcjsiLCIndXNlIHN0cmljdCc7XG5cbnZhciBEYXRhU291cmNlSW5kZXhlZCA9IHJlcXVpcmUoJy4vRGF0YVNvdXJjZUluZGV4ZWQnKTtcblxudmFyIERhdGFTb3VyY2VGaWx0ZXIgPSBEYXRhU291cmNlSW5kZXhlZC5leHRlbmQoJ0RhdGFTb3VyY2VGaWx0ZXInLCB7XG5cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5maWx0ZXJzID0gW107XG4gICAgfSxcblxuICAgIGFkZDogZnVuY3Rpb24oY29sdW1uSW5kZXgsIGZpbHRlcikge1xuICAgICAgICBmaWx0ZXIuY29sdW1uSW5kZXggPSBjb2x1bW5JbmRleDtcbiAgICAgICAgdGhpcy5maWx0ZXJzLnB1c2goZmlsdGVyKTtcbiAgICB9LFxuXG4gICAgY2xlYXJBbGw6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmZpbHRlcnMubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5jbGVhckluZGV4KCk7XG4gICAgfSxcblxuICAgIGFwcGx5QWxsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLmZpbHRlcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLmNsZWFySW5kZXgoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuYnVpbGRJbmRleChhcHBseUZpbHRlcnMpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGdldFJvd0NvdW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVycy5sZW5ndGggPyB0aGlzLmluZGV4Lmxlbmd0aCA6IHRoaXMuZGF0YVNvdXJjZS5nZXRSb3dDb3VudCgpO1xuICAgIH0sXG5cbiAgICBhbGlhc2VzOiB7XG4gICAgICAgIHNldDogJ2FkZCdcbiAgICB9XG59KTtcblxuZnVuY3Rpb24gYXBwbHlGaWx0ZXJzKHIsIHJvd09iamVjdCkgeyAvLyBjYWxsZWQgaW4gY29udGV4dCBmcm9tIC5idWlsZEluZGV4KClcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG5cbiAgICBpZiAoQXJyYXkucHJvdG90eXBlLmZpbmQpIHtcbiAgICAgICAgLy8gZG91YmxlIG5lZ2F0aXZlIGhlcmUgbWVhbnMgXCJubyBmaWx0ZXIgZmFpbHNcIiAoaS5lLiwgcm93IHBhc3NlcyBhbGwgZmlsdGVycylcbiAgICAgICAgcmV0dXJuICF0aGlzLmZpbHRlcnMuZmluZChmdW5jdGlvbihmaWx0ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiAhZmlsdGVyKHNlbGYuZGF0YVNvdXJjZS5nZXRWYWx1ZShmaWx0ZXIuY29sdW1uSW5kZXgsIHIpLCByb3dPYmplY3QsIHIpO1xuICAgICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5maWx0ZXJzLnJlZHVjZShmdW5jdGlvbihpc0ZpbHRlcmVkLCBmaWx0ZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBpc0ZpbHRlcmVkICYmIGZpbHRlcihzZWxmLmRhdGFTb3VyY2UuZ2V0VmFsdWUoZmlsdGVyLmNvbHVtbkluZGV4LCByKSwgcm93T2JqZWN0LCByKTtcbiAgICAgICAgfSwgdHJ1ZSk7XG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IERhdGFTb3VyY2VGaWx0ZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBEYXRhU291cmNlSW5kZXhlZCA9IHJlcXVpcmUoJy4vRGF0YVNvdXJjZUluZGV4ZWQnKTtcblxudmFyIERhdGFTb3VyY2VHbG9iYWxGaWx0ZXIgPSBEYXRhU291cmNlSW5kZXhlZC5leHRlbmQoJ0RhdGFTb3VyY2VHbG9iYWxGaWx0ZXInLCB7XG5cbiAgICBzZXQ6IGZ1bmN0aW9uKGZpbHRlcikge1xuICAgICAgICB0aGlzLmZpbHRlciA9IGZpbHRlcjtcbiAgICB9LFxuXG4gICAgY2xlYXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICBkZWxldGUgdGhpcy5maWx0ZXI7XG4gICAgICAgIHRoaXMuY2xlYXJJbmRleCgpO1xuICAgIH0sXG5cbiAgICBhcHBseTogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghdGhpcy5maWx0ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuY2xlYXJJbmRleCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5idWlsZEluZGV4KGFwcGx5RmlsdGVyKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBnZXRSb3dDb3VudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbHRlciA/IHRoaXMuaW5kZXgubGVuZ3RoIDogdGhpcy5kYXRhU291cmNlLmdldFJvd0NvdW50KCk7XG4gICAgfVxufSk7XG5cbmZ1bmN0aW9uIGFwcGx5RmlsdGVyKHIsIHJvd09iamVjdCkgeyAvLyBjYWxsZWQgaW4gY29udGV4dCBmcm9tIC5idWlsZEluZGV4KClcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIHRoaXMuZ2V0RmllbGRzKCkuZmluZChmdW5jdGlvbihjb2x1bW5JbmRleCkge1xuICAgICAgICB2YXIgY2VsbFZhbHVlID0gc2VsZi5kYXRhU291cmNlLmdldFZhbHVlKGNvbHVtbkluZGV4LCByKTtcbiAgICAgICAgcmV0dXJuIHNlbGYuZmlsdGVyKGNlbGxWYWx1ZSwgcm93T2JqZWN0LCByKTtcbiAgICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBEYXRhU291cmNlR2xvYmFsRmlsdGVyOyIsIid1c2Ugc3RyaWN0JztcblxudmFyIEJhc2UgPSByZXF1aXJlKCdleHRlbmQtbWUnKS5CYXNlO1xuXG52YXIgRGF0YVNvdXJjZUluZGV4ZWQgPSBCYXNlLmV4dGVuZCgnRGF0YVNvdXJjZUluZGV4ZWQnLCB7XG5cbiAgICBpc051bGxPYmplY3Q6IGZhbHNlLFxuXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oZGF0YVNvdXJjZSkge1xuICAgICAgICB0aGlzLmRhdGFTb3VyY2UgPSBkYXRhU291cmNlO1xuICAgICAgICB0aGlzLmluZGV4ID0gW107XG4gICAgfSxcblxuICAgIHRyYW5zcG9zZVk6IGZ1bmN0aW9uKHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5kZXgubGVuZ3RoID8gdGhpcy5pbmRleFt5XSA6IHk7XG4gICAgfSxcblxuICAgIGdldFJvdzogZnVuY3Rpb24oeSkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhU291cmNlLmdldFJvdyh0aGlzLnRyYW5zcG9zZVkoeSkpO1xuICAgIH0sXG5cbiAgICBnZXRWYWx1ZTogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhU291cmNlLmdldFZhbHVlKHgsIHRoaXMudHJhbnNwb3NlWSh5KSk7XG4gICAgfSxcblxuICAgIHNldFZhbHVlOiBmdW5jdGlvbih4LCB5LCB2YWx1ZSkge1xuICAgICAgICB0aGlzLmRhdGFTb3VyY2Uuc2V0VmFsdWUoeCwgdGhpcy50cmFuc3Bvc2VZKHkpLCB2YWx1ZSk7XG4gICAgfSxcblxuICAgIGdldFJvd0NvdW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5kZXgubGVuZ3RoIHx8IHRoaXMuZGF0YVNvdXJjZS5nZXRSb3dDb3VudCgpO1xuICAgIH0sXG5cbiAgICBnZXRDb2x1bW5Db3VudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFTb3VyY2UuZ2V0Q29sdW1uQ291bnQoKTtcbiAgICB9LFxuXG4gICAgZ2V0RmllbGRzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVNvdXJjZS5nZXRGaWVsZHMoKTtcbiAgICB9LFxuXG4gICAgc2V0RmllbGRzOiBmdW5jdGlvbihmaWVsZHMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVNvdXJjZS5zZXRGaWVsZHMoZmllbGRzKTtcbiAgICB9LFxuXG4gICAgZ2V0RGVmYXVsdEhlYWRlcnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhU291cmNlLmdldEZpZWxkcygpO1xuICAgIH0sXG5cbiAgICBzZXRIZWFkZXJzOiBmdW5jdGlvbihoZWFkZXJzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFTb3VyY2Uuc2V0SGVhZGVycyhoZWFkZXJzKTtcbiAgICB9LFxuXG4gICAgZ2V0SGVhZGVyczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFTb3VyY2UuZ2V0SGVhZGVycygpO1xuICAgIH0sXG5cbiAgICBnZXRHcmFuZFRvdGFsczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFTb3VyY2UuZ2V0R3JhbmRUb3RhbHMoKTtcbiAgICB9LFxuXG4gICAgc2V0RGF0YTogZnVuY3Rpb24oYXJyYXlPZlVuaWZvcm1PYmplY3RzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFTb3VyY2Uuc2V0RGF0YShhcnJheU9mVW5pZm9ybU9iamVjdHMpO1xuICAgIH0sXG5cbiAgICBjbGVhckluZGV4OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5pbmRleC5sZW5ndGggPSAwO1xuICAgIH0sXG5cbiAgICBidWlsZEluZGV4OiBmdW5jdGlvbihwcmVkaWNhdGUpIHtcbiAgICAgICAgdmFyIHJvd0NvdW50ID0gdGhpcy5kYXRhU291cmNlLmdldFJvd0NvdW50KCksXG4gICAgICAgICAgICBpbmRleCA9IHRoaXMuaW5kZXg7XG5cbiAgICAgICAgaW5kZXgubGVuZ3RoID0gMDtcblxuICAgICAgICBmb3IgKHZhciByID0gMDsgciA8IHJvd0NvdW50OyByKyspIHtcbiAgICAgICAgICAgIGlmICghcHJlZGljYXRlIHx8IHByZWRpY2F0ZS5jYWxsKHRoaXMsIHIsIHRoaXMuZGF0YVNvdXJjZS5nZXRSb3cocikpKSB7XG4gICAgICAgICAgICAgICAgaW5kZXgucHVzaChyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICB9XG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IERhdGFTb3VyY2VJbmRleGVkO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgRGF0YVNvdXJjZUluZGV4ZWQgPSByZXF1aXJlKCcuL0RhdGFTb3VyY2VJbmRleGVkJyk7XG52YXIgc3RhYmxlU29ydCA9IHJlcXVpcmUoJy4vdXRpbC9zdGFibGVTb3J0Jyk7XG5cbnZhciBEYXRhU291cmNlU29ydGVyID0gRGF0YVNvdXJjZUluZGV4ZWQuZXh0ZW5kKCdEYXRhU291cmNlU29ydGVyJywge1xuICAgIGluaXRpYWxpemU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmRlc2NlbmRpbmdTb3J0ID0gZmFsc2U7IC8vIFRPRE86IHRoaXMgZG9lcyBub3Qgc2VlbSB0byBiZSBpbiB1c2VcbiAgICB9LFxuXG4gICAgc29ydE9uOiBmdW5jdGlvbihjb2xJZHgsIGRpcmVjdGlvbikge1xuICAgICAgICBzd2l0Y2ggKGRpcmVjdGlvbikge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHRoaXMuY2xlYXJJbmRleCgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIGNhc2UgLTE6XG4gICAgICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzOyAvLyBmb3IgdXNlIGluIGdldFZhbHVlXG4gICAgICAgICAgICAgICAgc3RhYmxlU29ydC5zb3J0KHRoaXMuYnVpbGRJbmRleCgpLCBnZXRWYWx1ZSwgZGlyZWN0aW9uKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGdldFZhbHVlKHJvd0lkeCkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbE9yRnVuY0NhbGwoc2VsZi5kYXRhU291cmNlLmdldFZhbHVlKGNvbElkeCwgcm93SWR4KSk7XG4gICAgICAgIH1cbiAgICB9XG59KTtcblxuZnVuY3Rpb24gdmFsT3JGdW5jQ2FsbCh2YWxPckZ1bmMpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbE9yRnVuYyA9PT0gJ2Z1bmN0aW9uJyA/IHZhbE9yRnVuYygpIDogdmFsT3JGdW5jO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IERhdGFTb3VyY2VTb3J0ZXI7IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgRGF0YVNvdXJjZUluZGV4ZWQgPSByZXF1aXJlKCcuL0RhdGFTb3VyY2VJbmRleGVkJyk7XG52YXIgRGF0YVNvdXJjZVNvcnRlciA9IHJlcXVpcmUoJy4vRGF0YVNvdXJjZVNvcnRlcicpO1xuXG52YXIgRGF0YVNvdXJjZVNvcnRlckNvbXBvc2l0ZSA9IERhdGFTb3VyY2VJbmRleGVkLmV4dGVuZCgnRGF0YVNvdXJjZVNvcnRlckNvbXBvc2l0ZScsIHtcbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5zb3J0cyA9IFtdO1xuICAgICAgICB0aGlzLmxhc3QgPSB0aGlzLmRhdGFTb3VyY2U7XG4gICAgfSxcblxuICAgIC8vIENhdmVhdHMgcmVnYXJkaW5nIHRoaXMuc29ydHM6XG4gICAgLy8gMS4gQ29sdW1ucyBzaG91bGQgYmUgdW5pcXVlbHkgcmVwcmVzZW50ZWQgKGkuZS4sIG5vIHJlcGVhdHMgd2l0aCBzYW1lIGNvbHVtbkluZGV4KVxuICAgIC8vIDIuIENvbHVtbnMgc2hvdWxkIGJlIGFkZGVkIGxvdy0gdG8gaGlnaC1vcmRlciAoaS5lLiwgbW9zdCBncm91cGVkIGNvbHVtbnMgY29tZSBsYXN0KVxuICAgIHNvcnRPbjogZnVuY3Rpb24oY29sdW1uSW5kZXgsIGRpcmVjdGlvbikge1xuICAgICAgICB0aGlzLnNvcnRzLnB1c2goW2NvbHVtbkluZGV4LCBkaXJlY3Rpb25dKTtcbiAgICB9LFxuXG4gICAgYXBwbHlTb3J0czogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBlYWNoID0gdGhpcy5kYXRhU291cmNlO1xuXG4gICAgICAgIHRoaXMuc29ydHMuZm9yRWFjaChmdW5jdGlvbihzb3J0KSB7XG4gICAgICAgICAgICBlYWNoID0gbmV3IERhdGFTb3VyY2VTb3J0ZXIoZWFjaCk7XG4gICAgICAgICAgICBlYWNoLnNvcnRPbi5hcHBseShlYWNoLCBzb3J0KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5sYXN0ID0gZWFjaDtcbiAgICB9LFxuXG4gICAgY2xlYXJTb3J0czogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuc29ydHMubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5sYXN0ID0gdGhpcy5kYXRhU291cmNlO1xuICAgIH0sXG5cbiAgICBnZXRWYWx1ZTogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICByZXR1cm4gdGhpcy5sYXN0LmdldFZhbHVlKHgsIHkpO1xuICAgIH0sXG5cbiAgICBzZXRWYWx1ZTogZnVuY3Rpb24oeCwgeSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5sYXN0LnNldFZhbHVlKHgsIHksIHZhbHVlKTtcbiAgICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBEYXRhU291cmNlU29ydGVyQ29tcG9zaXRlOyIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgSlNEYXRhU291cmNlOiByZXF1aXJlKCcuL0RhdGFTb3VyY2UnKSxcbiAgICBEYXRhU291cmNlU29ydGVyOiByZXF1aXJlKCcuL0RhdGFTb3VyY2VTb3J0ZXInKSxcbiAgICBEYXRhU291cmNlU29ydGVyQ29tcG9zaXRlOiByZXF1aXJlKCcuL0RhdGFTb3VyY2VTb3J0ZXJDb21wb3NpdGUnKSxcbiAgICBEYXRhU291cmNlRmlsdGVyOiByZXF1aXJlKCcuL0RhdGFTb3VyY2VGaWx0ZXInKSxcbiAgICBEYXRhU291cmNlR2xvYmFsRmlsdGVyOiByZXF1aXJlKCcuL0RhdGFTb3VyY2VHbG9iYWxGaWx0ZXInKSxcbiAgICBEYXRhU291cmNlQWdncmVnYXRvcjogcmVxdWlyZSgnLi9EYXRhU291cmNlQWdncmVnYXRvcicpLFxuICAgIHV0aWw6IHtcbiAgICAgICAgYWdncmVnYXRpb25zOiByZXF1aXJlKCcuL3V0aWwvYWdncmVnYXRpb25zJylcbiAgICB9XG59OyIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gTWFwcHkoKSB7XG4gICAgdGhpcy5rZXlzID0gW107XG4gICAgdGhpcy5kYXRhID0ge307XG4gICAgdGhpcy52YWx1ZXMgPSBbXTtcbn1cblxuTWFwcHkucHJvdG90eXBlID0ge1xuXG4gICAgY29uc3RydWN0b3I6IE1hcHB5LnByb3RvdHlwZS5jb25zdHJ1Y3RvciwgLy8gcHJlc2VydmUgY29uc3RydWN0b3JcblxuICAgIHNldDogZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgICB2YXIgaGFzaENvZGUgPSBoYXNoKGtleSk7XG4gICAgICAgIGlmICghKGhhc2hDb2RlIGluIHRoaXMuZGF0YSkpIHtcbiAgICAgICAgICAgIHRoaXMua2V5cy5wdXNoKGtleSk7XG4gICAgICAgICAgICB0aGlzLnZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRhdGFbaGFzaENvZGVdID0gdmFsdWU7XG4gICAgfSxcblxuICAgIGdldDogZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHZhciBoYXNoQ29kZSA9IGhhc2goa2V5KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVtoYXNoQ29kZV07XG4gICAgfSxcblxuICAgIGdldElmQWJzZW50OiBmdW5jdGlvbihrZXksIGlmQWJzZW50RnVuYykge1xuICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLmdldChrZXkpO1xuICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdmFsdWUgPSBpZkFic2VudEZ1bmMoa2V5LCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSxcblxuICAgIHNpemU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5rZXlzLmxlbmd0aDtcbiAgICB9LFxuXG4gICAgY2xlYXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmtleXMubGVuZ3RoID0gMDtcbiAgICAgICAgLy8gVE9ETzogSXMgdGhlcmUgYSByZWFzb24gd2h5IHRoaXMudmFsdWVzIGlzIG5vdCBiZWluZyB0cnVuY2F0ZWQgaGVyZSBhcyB3ZWxsP1xuICAgICAgICB0aGlzLmRhdGEgPSB7fTtcbiAgICB9LFxuXG4gICAgZGVsZXRlOiBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgdmFyIGhhc2hDb2RlID0gaGFzaChrZXkpO1xuICAgICAgICBpZiAodGhpcy5kYXRhW2hhc2hDb2RlXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2YXIgaW5kZXggPSBiZXR0ZXJJbmRleE9mKHRoaXMua2V5cywga2V5KTtcbiAgICAgICAgICAgIHRoaXMua2V5cy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgdGhpcy52YWx1ZXMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmRhdGFbaGFzaENvZGVdO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGZvckVhY2g6IGZ1bmN0aW9uKGZ1bmMpIHtcbiAgICAgICAgdmFyIGtleXMgPSB0aGlzLmtleXMsXG4gICAgICAgICAgICBzZWxmID0gdGhpcztcbiAgICAgICAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gc2VsZi5nZXQoa2V5KTtcbiAgICAgICAgICAgIGZ1bmModmFsdWUsIGtleSwgc2VsZik7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICBtYXA6IGZ1bmN0aW9uKGZ1bmMpIHtcbiAgICAgICAgdmFyIGtleXMgPSB0aGlzLmtleXMsXG4gICAgICAgICAgICBuZXdNYXAgPSBuZXcgTWFwcHkoKSxcbiAgICAgICAgICAgIHNlbGYgPSB0aGlzO1xuICAgICAgICBrZXlzLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBzZWxmLmdldChrZXkpLFxuICAgICAgICAgICAgICAgIHRyYW5zZm9ybWVkID0gZnVuYyh2YWx1ZSwga2V5LCBzZWxmKTtcbiAgICAgICAgICAgIG5ld01hcC5zZXQoa2V5LCB0cmFuc2Zvcm1lZCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbmV3TWFwO1xuICAgIH0sXG5cbiAgICBjb3B5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGtleXMgPSB0aGlzLmtleXMsXG4gICAgICAgICAgICBuZXdNYXAgPSBuZXcgTWFwcHkoKSxcbiAgICAgICAgICAgIHNlbGYgPSB0aGlzO1xuICAgICAgICBrZXlzLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSBzZWxmLmdldChrZXkpO1xuICAgICAgICAgICAgbmV3TWFwLnNldChrZXksIHZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBuZXdNYXA7XG4gICAgfVxuXG59O1xuXG52YXIgT0lEX1BSRUZJWCA9ICcufi4jJV8nOyAvL3RoaXMgc2hvdWxkIGJlIHNvbWV0aGluZyB3ZSBuZXZlciB3aWxsIHNlZSBhdCB0aGUgYmVnaW5uaW5nIG9mIGEgc3RyaW5nXG52YXIgY291bnRlciA9IDA7XG5cbmZ1bmN0aW9uIGhhc2goa2V5KSB7XG4gICAgdmFyIHR5cGVPZiA9IHR5cGVvZiBrZXk7XG5cbiAgICBzd2l0Y2ggKHR5cGVPZikge1xuICAgICAgICBjYXNlICdudW1iZXInOlxuICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgY2FzZSAnc3ltYm9sJzpcbiAgICAgICAgICAgIHJldHVybiBPSURfUFJFRklYICsgdHlwZU9mICsgJ18nICsga2V5O1xuXG4gICAgICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICAgICAgICByZXR1cm4gT0lEX1BSRUZJWCArICd1bmRlZmluZWQnO1xuXG4gICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICAvLyBUT0RPOiB3aGF0IGFib3V0IGhhbmRsaW5nIG51bGwgKHNwZWNpYWwgY2FzZSBvZiBvYmplY3QpP1xuICAgICAgICBjYXNlICdmdW5jdGlvbic6XG4gICAgICAgICAgICByZXR1cm4gKGtleS5fX19maW5oYXNoID0ga2V5Ll9fX2Zpbmhhc2ggfHwgT0lEX1BSRUZJWCArIGNvdW50ZXIrKyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICB9XG59XG5cbi8vIE9iamVjdC5pcyBwb2x5ZmlsbCwgY291cnRlc3kgb2YgQFdlYlJlZmxlY3Rpb25cbnZhciBpcyA9IE9iamVjdC5pcyB8fCBmdW5jdGlvbihhLCBiKSB7XG4gICAgcmV0dXJuIGEgPT09IGIgPyBhICE9PSAwIHx8IDEgLyBhID09IDEgLyBiIDogYSAhPSBhICYmIGIgIT0gYjsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxufTtcblxuLy8gTW9yZSByZWxpYWJsZSBpbmRleE9mLCBjb3VydGVzeSBvZiBAV2ViUmVmbGVjdGlvblxuZnVuY3Rpb24gYmV0dGVySW5kZXhPZihhcnIsIHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlICE9IHZhbHVlIHx8IHZhbHVlID09PSAwKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgICAgZm9yICh2YXIgaSA9IGFyci5sZW5ndGg7IGktLSAmJiAhaXMoYXJyW2ldLCB2YWx1ZSk7KSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGkgPSBbXS5pbmRleE9mLmNhbGwoYXJyLCB2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiBpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IE1hcHB5OyIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gY291bnQoZ3JvdXApIHtcbiAgICByZXR1cm4gZ3JvdXAuZ2V0Um93Q291bnQoKTtcbn1cblxuZnVuY3Rpb24gc3VtKGNvbHVtbkluZGV4LCBncm91cCkge1xuICAgIHZhciByID0gZ3JvdXAuZ2V0Um93Q291bnQoKSxcbiAgICAgICAgbiA9IDA7XG5cbiAgICB3aGlsZSAoci0tKSB7XG4gICAgICAgIG4gKz0gZ3JvdXAuZ2V0VmFsdWUoY29sdW1uSW5kZXgsIHIpO1xuICAgIH1cblxuICAgIHJldHVybiBuO1xufVxuXG5mdW5jdGlvbiBtaW5tYXgoY29sdW1uSW5kZXgsIG1ldGhvZCwgbiwgZ3JvdXApIHtcbiAgICB2YXIgciA9IGdyb3VwLmdldFJvd0NvdW50KCk7XG5cbiAgICB3aGlsZSAoci0tKSB7XG4gICAgICAgIG4gPSBtZXRob2QobiwgZ3JvdXAuZ2V0VmFsdWUoY29sdW1uSW5kZXgsIHIpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbjtcbn1cblxuZnVuY3Rpb24gYXZnKGNvbHVtbkluZGV4LCBncm91cCkge1xuICAgIHJldHVybiBzdW0oY29sdW1uSW5kZXgsIGdyb3VwKSAvIGdyb3VwLmdldFJvd0NvdW50KCk7XG59XG5cbmZ1bmN0aW9uIGZpcnN0KGNvbHVtbkluZGV4LCBncm91cCkge1xuICAgIHJldHVybiBncm91cC5nZXRWYWx1ZShjb2x1bW5JbmRleCwgMCk7XG59XG5cbmZ1bmN0aW9uIGxhc3QoY29sdW1uSW5kZXgsIGdyb3VwKSB7XG4gICAgcmV0dXJuIGdyb3VwLmdldFZhbHVlKGNvbHVtbkluZGV4LCBncm91cC5nZXRSb3dDb3VudCgpIC0gMSk7XG59XG5cbmZ1bmN0aW9uIHN0ZGRldihjb2x1bW5JbmRleCwgZ3JvdXApIHtcbiAgICB2YXIgcm93cyA9IGdyb3VwLmdldFJvd0NvdW50KCksXG4gICAgICAgIG1lYW4gPSBhdmcoY29sdW1uSW5kZXgsIGdyb3VwKTtcblxuICAgIGZvciAodmFyIGRldiwgciA9IHJvd3MsIHZhcmlhbmNlID0gMDsgci0tOyB2YXJpYW5jZSArPSBkZXYgKiBkZXYpIHtcbiAgICAgICAgZGV2ID0gZ3JvdXAuZ2V0VmFsdWUoY29sdW1uSW5kZXgsIHIpIC0gbWVhbjtcbiAgICB9XG5cbiAgICByZXR1cm4gTWF0aC5zcXJ0KHZhcmlhbmNlIC8gcm93cyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIGNvdW50OiBmdW5jdGlvbihjb2x1bW5JbmRleCkge1xuICAgICAgICByZXR1cm4gY291bnQ7XG4gICAgfSxcbiAgICBzdW06IGZ1bmN0aW9uKGNvbHVtbkluZGV4KSB7XG4gICAgICAgIHJldHVybiBzdW0uYmluZCh0aGlzLCBjb2x1bW5JbmRleCk7XG4gICAgfSxcbiAgICBtaW46IGZ1bmN0aW9uKGNvbHVtbkluZGV4KSB7XG4gICAgICAgIHJldHVybiBtaW5tYXguYmluZCh0aGlzLCBjb2x1bW5JbmRleCwgTWF0aC5taW4sIEluZmluaXR5KTtcbiAgICB9LFxuICAgIG1heDogZnVuY3Rpb24oY29sdW1uSW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIG1pbm1heC5iaW5kKHRoaXMsIGNvbHVtbkluZGV4LCBNYXRoLm1heCwgLUluZmluaXR5KTtcbiAgICB9LFxuICAgIGF2ZzogZnVuY3Rpb24oY29sdW1uSW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGF2Zy5iaW5kKHRoaXMsIGNvbHVtbkluZGV4KTtcbiAgICB9LFxuICAgIGZpcnN0OiBmdW5jdGlvbihjb2x1bW5JbmRleCkge1xuICAgICAgICByZXR1cm4gZmlyc3QuYmluZCh0aGlzLCBjb2x1bW5JbmRleCk7XG4gICAgfSxcbiAgICBsYXN0OiBmdW5jdGlvbihjb2x1bW5JbmRleCkge1xuICAgICAgICByZXR1cm4gbGFzdC5iaW5kKHRoaXMsIGNvbHVtbkluZGV4KTtcbiAgICB9LFxuICAgIHN0ZGRldjogZnVuY3Rpb24oY29sdW1uSW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHN0ZGRldi5iaW5kKHRoaXMsIGNvbHVtbkluZGV4KTtcbiAgICB9XG59OyIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gaGVhZGVyaWZ5KHN0cmluZykge1xuICAgIHJldHVybiAoL1thLXpdLy50ZXN0KHN0cmluZykgPyBzdHJpbmcgOiBzdHJpbmcudG9Mb3dlckNhc2UoKSlcbiAgICAgICAgLnJlcGxhY2UoL1tcXHNcXC1fXSooW15cXHNcXC1fXSkoW15cXHNcXC1fXSspL2csIHJlcGxhY2VyKVxuICAgICAgICAucmVwbGFjZSgvW0EtWl0vZywgJyAkJicpXG4gICAgICAgIC50cmltKCk7XG59XG5cbmZ1bmN0aW9uIHJlcGxhY2VyKGEsIGIsIGMpIHtcbiAgICByZXR1cm4gYi50b1VwcGVyQ2FzZSgpICsgYztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoZWFkZXJpZnk7IiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBzdGFiaWxpemUoY29tcGFyYXRvciwgZGVzY2VuZGluZywgYXJyMSwgYXJyMikgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNoYWRvd1xuICAgIHZhciB4ID0gYXJyMVswXTtcbiAgICB2YXIgeSA9IGFycjJbMF07XG5cbiAgICBpZiAoeCA9PT0geSkge1xuICAgICAgICB4ID0gZGVzY2VuZGluZyA/IGFycjJbMV0gOiBhcnIxWzFdO1xuICAgICAgICB5ID0gZGVzY2VuZGluZyA/IGFycjFbMV0gOiBhcnIyWzFdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh5ID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHggPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbXBhcmF0b3IoeCwgeSk7XG59XG5cbmZ1bmN0aW9uIGFzY2VuZGluZ051bWJlcnMoeCwgeSkge1xuICAgIHJldHVybiB4IC0geTtcbn1cblxuZnVuY3Rpb24gZGVzY2VuZGluZ051bWJlcnMoeCwgeSkge1xuICAgIHJldHVybiB5IC0geDtcbn1cblxuZnVuY3Rpb24gYXNjZW5kaW5nQWxsT3RoZXJzKHgsIHkpIHtcbiAgICByZXR1cm4geCA8IHkgPyAtMSA6IDE7XG59XG5cbmZ1bmN0aW9uIGRlc2NlbmRpbmdBbGxPdGhlcnMoeCwgeSkge1xuICAgIHJldHVybiB5IDwgeCA/IC0xIDogMTtcbn1cblxuZnVuY3Rpb24gYXNjZW5kaW5nKHR5cGVPZkRhdGEpIHtcbiAgICByZXR1cm4gc3RhYmlsaXplLmJpbmQodGhpcywgdHlwZU9mRGF0YSA9PT0gJ251bWJlcicgPyBhc2NlbmRpbmdOdW1iZXJzIDogYXNjZW5kaW5nQWxsT3RoZXJzLCBmYWxzZSk7XG59XG5cbmZ1bmN0aW9uIGRlc2NlbmRpbmcodHlwZU9mRGF0YSkge1xuICAgIHJldHVybiBzdGFiaWxpemUuYmluZCh0aGlzLCB0eXBlT2ZEYXRhID09PSAnbnVtYmVyJyA/IGRlc2NlbmRpbmdOdW1iZXJzIDogZGVzY2VuZGluZ0FsbE90aGVycywgdHJ1ZSk7XG59XG5cbmZ1bmN0aW9uIHNvcnQoaW5kZXgsIGdldFZhbHVlLCBkaXJlY3Rpb24pIHtcblxuICAgIHZhciBjb21wYXJlLCBpO1xuXG4gICAgLy8gYXBwbHkgZGVmYXVsdHNcbiAgICBpZiAoZGlyZWN0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZGlyZWN0aW9uID0gMTtcbiAgICB9XG5cbiAgICBpZiAoaW5kZXgubGVuZ3RoKSB7IC8vIHNvbWV0aGluZyB0byBkb1xuICAgICAgICBzd2l0Y2ggKGRpcmVjdGlvbikge1xuICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgIHJldHVybjsgLy8gYmFpbDogbm90aGluZyB0byBzb3J0XG5cbiAgICAgICAgICAgIGNhc2UgdW5kZWZpbmVkOiAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWZhbGx0aHJvdWdoXG4gICAgICAgICAgICAgICAgZGlyZWN0aW9uID0gMTtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICBjb21wYXJlID0gYXNjZW5kaW5nKHR5cGVvZiBnZXRWYWx1ZSgwKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgLTE6XG4gICAgICAgICAgICAgICAgY29tcGFyZSA9IGRlc2NlbmRpbmcodHlwZW9mIGdldFZhbHVlKDApKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNldCB1cCB0aGUgc29ydC4uLi4uXG4gICAgICAgIHZhciB0bXAgPSBuZXcgQXJyYXkoaW5kZXgubGVuZ3RoKTtcblxuICAgICAgICAvLyBhZGQgdGhlIGluZGV4IGZvciBcInN0YWJpbGl0eVwiXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBpbmRleC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdG1wW2ldID0gW2dldFZhbHVlKGkpLCBpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGRvIHRoZSBhY3R1YWwgc29ydFxuICAgICAgICB0bXAuc29ydChjb21wYXJlKTtcblxuICAgICAgICAvLyBjb3B5IHRoZSBzb3J0ZWQgdmFsdWVzIGludG8gb3VyIGluZGV4IHZlY3RvclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgaW5kZXgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGluZGV4W2ldID0gdG1wW2ldWzFdO1xuICAgICAgICB9XG4gICAgfVxuXG59XG5cbmV4cG9ydHMuc29ydCA9IHNvcnQ7IiwiLy8gbGlzdC1kcmFnb24gbm9kZSBtb2R1bGVcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9vcGVuZmluL2xpc3QtZHJhZ29uXG5cbid1c2Ugc3RyaWN0JztcblxuLyogZXNsaW50LWVudiBub2RlLCBicm93c2VyICovXG5cbihmdW5jdGlvbiAobW9kdWxlKSB7ICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC1leHByZXNzaW9uc1xuXG4gICAgLy8gVGhpcyBjbG9zdXJlIHN1cHBvcnRzIE5vZGVKUy1sZXNzIGNsaWVudCBzaWRlIGluY2x1ZGVzIHdpdGggPHNjcmlwdD4gdGFncy4gU2VlIG5vdGVzIGF0IGJvdHRvbSBvZiB0aGlzIGZpbGUuXG5cbiAgICB2YXIgZm9ybWF0ID0gd2luZG93LnRlbXBsZXggfHwgcmVxdWlyZSgndGVtcGxleCcpO1xuXG4gICAgdmFyIFJFVkVSVF9UT19TVFlMRVNIRUVUX1ZBTFVFID0gbnVsbDsgIC8vIG51bGwgcmVtb3ZlcyB0aGUgc3R5bGVcblxuICAgIHZhciBib2R5LCB0cmFuc2Zvcm0sIHRpbWVyLCBzY3JvbGxWZWxvY2l0eTtcblxuICAgIC8qIGluamVjdDpjc3MgKi9cbiAgICAoZnVuY3Rpb24oKXt2YXIgYT1cImRpdi5kcmFnb24tbGlzdHtwb3NpdGlvbjpyZWxhdGl2ZTtiYWNrZ3JvdW5kLWNvbG9yOiNmZmZ9ZGl2LmRyYWdvbi1saXN0PmRpdixkaXYuZHJhZ29uLWxpc3Q+dWx7cG9zaXRpb246YWJzb2x1dGU7bGVmdDowO3JpZ2h0OjB9ZGl2LmRyYWdvbi1saXN0PmRpdnt0ZXh0LWFsaWduOmNlbnRlcjtiYWNrZ3JvdW5kLWNvbG9yOiMwMDc5NmI7Y29sb3I6I2ZmZjtib3gtc2hhZG93OjAgM3B4IDZweCByZ2JhKDAsMCwwLC4xNiksMCAzcHggNnB4IHJnYmEoMCwwLDAsLjIzKTtvdmVyZmxvdzpoaWRkZW47d2hpdGUtc3BhY2U6bm93cmFwfWRpdi5kcmFnb24tbGlzdD51bHtvdmVyZmxvdy15OmF1dG87Ym90dG9tOjA7bWFyZ2luOjA7cGFkZGluZzowO2JveC1zaGFkb3c6MCAxcHggM3B4IHJnYmEoMCwwLDAsLjEyKSwwIDFweCAycHggcmdiYSgwLDAsMCwuMjQpfWRpdi5kcmFnb24tbGlzdD51bD5saSxsaS5kcmFnb24tcG9we3doaXRlLXNwYWNlOm5vd3JhcDtsaXN0LXN0eWxlLXR5cGU6bm9uZTtib3JkZXI6MCBzb2xpZCAjZjRmNGY0O2JvcmRlci1ib3R0b206MXB4IHNvbGlkICNlMGUwZTA7Y3Vyc29yOm1vdmU7dHJhbnNpdGlvbjpib3JkZXItdG9wLXdpZHRoIC4yc31kaXYuZHJhZ29uLWxpc3Q+dWw+bGk6bGFzdC1jaGlsZHtoZWlnaHQ6MDtib3JkZXItYm90dG9tOm5vbmV9bGkuZHJhZ29uLXBvcHtwb3NpdGlvbjpmaXhlZDtiYWNrZ3JvdW5kLWNvbG9yOiNmZmY7Ym9yZGVyOjFweCBzb2xpZCAjZTBlMGUwO2xlZnQ6MDt0b3A6MDtvdmVyZmxvdy14OmhpZGRlbjtib3gtc2hhZG93OnJnYmEoMCwwLDAsLjE4ODIzNSkgMCAxMHB4IDIwcHgscmdiYSgwLDAsMCwuMjI3NDUxKSAwIDZweCA2cHh9XCIsYj1kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIiksaGVhZD1kb2N1bWVudC5oZWFkfHxkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcImhlYWRcIilbMF07Yi50eXBlPVwidGV4dC9jc3NcIjtpZihiLnN0eWxlU2hlZXQpYi5zdHlsZVNoZWV0LmNzc1RleHQ9YTtlbHNlIGIuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoYSkpO2hlYWQuaW5zZXJ0QmVmb3JlKGIsaGVhZC5maXJzdENoaWxkKX0pKCk7XG4gICAgLyogZW5kaW5qZWN0ICovXG5cbiAgICAvKipcbiAgICAgKiBAY29uc3RydWN0b3IgTGlzdERyYWdvblxuICAgICAqXG4gICAgICogQGRlc2MgVGhpcyBvYmplY3Qgc2VydmljZXMgYSBzZXQgb2YgaXRlbSBsaXN0cyB0aGF0IGFsbG93IGRyYWdnaW5nIGFuZCBkcm9wcGluZyBpdGVtcyB3aXRoaW4gYW5kIGJldHdlZW4gbGlzdHMgaW4gYSBzZXQuXG4gICAgICpcbiAgICAgKiBUd28gc3RyYXRlZ2llcyBhcmUgc3VwcG9ydGVkOlxuICAgICAqXG4gICAgICogMS4gU3VwcGx5IHlvdXIgb3duIEhUTUwgbWFya3VwIGFuZCBsZXQgdGhlIEFQSSBidWlsZCB0aGUgaXRlbSBtb2RlbHMgZm9yIHlvdS5cbiAgICAgKiAgICBUbyB1c2UgdGhpcyBzdHJhdGVneSwgc2NyaXB0IHlvdXIgSFRNTCBhbmQgcHJvdmlkZSBvbmUgb2YgdGhlc2U6XG4gICAgICogICAgKiBhbiBhcnJheSBvZiBhbGwgdGhlIGxpc3QgaXRlbSAoYDxsaT5gKSB0YWdzXG4gICAgICogICAgKiBhIENTUyBzZWxlY3RvciB0aGF0IHBvaW50cyB0byBhbGwgdGhlIGxpc3QgaXRlbSB0YWdzXG4gICAgICogMi4gU3VwcGx5IHlvdXIgb3duIGl0ZW0gbW9kZWxzIGFuZCBsZXQgdGhlIEFQSSBidWlsZCB0aGUgSFRNTCBtYXJrdXAgZm9yIHlvdS5cbiAgICAgKiAgICBUbyB1c2UgdGhpcyBzdHJhdGVneSwgcHJvdmlkZSBhbiBhcnJheSBvZiBtb2RlbCBsaXN0cy5cbiAgICAgKlxuICAgICAqIFRoZSBuZXcgTGlzdERyYWdvbiBvYmplY3QncyBgbW9kZWxMaXN0c2AgcHJvcGVydHkgcmVmZXJlbmNlcyB0aGUgYXJyYXkgb2YgbW9kZWwgbGlzdHMgdGhlIEFQSSBjb25zdHJ1Y3RlZCBmb3IgeW91IGluIHN0cmF0ZWd5ICMxIG9yIHRoZSBhcnJheSBvZiBtb2RlbCBsaXN0cyB5b3Ugc3VwcGxpZWQgZm9yIHN0cmF0ZWd5ICMyLlxuICAgICAqXG4gICAgICogQWZ0ZXIgdGhlIHVzZXIgcGVyZm9ybXMgYSBzdWNjZXNzZnVsIGRyYWctYW5kLWRyb3Agb3BlcmF0aW9uLCB0aGUgcG9zaXRpb24gb2YgdGhlIG1vZGVsIHJlZmVyZW5jZXMgd2l0aGluIHRoZSBgbW9kZWxMaXN0c2AgYXJyYXkgaXMgcmVhcnJhbmdlZC4gKFRoZSBtb2RlbHMgdGhlbXNlbHZlcyBhcmUgdGhlIG9yaWdpbmFsIG9iamVjdHMgYXMgc3VwcGxpZWQgaW4gdGhlIG1vZGVsIGxpc3RzOyB0aGV5IGFyZSBub3QgcmVidWlsdCBvciBhbHRlcmVkIGluIGFueSB3YXkuIEp1c3QgdGhlIHJlZmVyZW5jZXMgdG8gdGhlbSBhcmUgbW92ZWQgYXJvdW5kLilcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfEVsZW1lbnRbXXxtb2RlbExpc3RUeXBlW119IHNlbGVjdG9yT3JNb2RlbExpc3RzIC0gWW91IG11c3Qgc3VwcGx5IG9uZSBvZiB0aGUgaXRlbXMgaW4gKipib2xkKiogYmVsb3c6XG4gICAgICpcbiAgICAgKiAxLiBfRm9yIHN0cmF0ZWd5ICMxIGFib3ZlIChBUEkgY3JlYXRlcyBtb2RlbHMgZnJvbSBzdXBwbGllZCBlbGVtZW50cyk6XyBBbGwgdGhlIGxpc3QgaXRlbSAoYDxsaT5gKSBET00gZWxlbWVudHMgb2YgYWxsIHRoZSBsaXN0cyB5b3Ugd2FudCB0aGUgbmV3IG9iamVjdCB0byBtYW5hZ2UsIGFzIGVpdGhlcjpcbiAgICAgKiAgICAxLiAqKkEgQ1NTIHNlbGVjdG9yOyoqIF9vcl9cbiAgICAgKiAgICAyLiAqKkFuIGFycmF5IG9mIERPTSBlbGVtZW50cyoqXG4gICAgICogMi4gX0ZvciBzdHJhdGVneSAjMiBhYm92ZSAoQVBJIGNyZWF0ZXMgZWxlbWVudHMgZnJvbSBzdXBwbGllZCBtb2RlbHMpOl8gKipBbiBhcnJheSBvZiBtb2RlbCBsaXN0cywqKiBlYWNoIG9mIHdoaWNoIGlzIGluIG9uZSBvZiB0aGUgZm9sbG93aW5nIGZvcm1zOlxuICAgICAqICAgIDEuIEFuIGFycmF5IG9mIGl0ZW0gbW9kZWxzICh3aXRoIHZhcmlvdXMgb3B0aW9uIHByb3BlcnRpZXMgaGFuZ2luZyBvZmYgb2YgaXQpOyBfYW5kL29yX1xuICAgICAqICAgIDIuIEEge0BsaW5rIG1vZGVsTGlzdFR5cGV9IG9iamVjdCB3aXRoIHRob3NlIHNhbWUgdmFyaW91cyBvcHRpb24gcHJvcGVydGllcyBpbmNsdWRpbmcgdGhlIHJlcXVpcmVkIGBtb2RlbHNgIHByb3BlcnR5IGNvbnRhaW5pbmcgdGhhdCBzYW1lIGFycmF5IG9mIGl0ZW0gbW9kZWxzLlxuICAgICAqXG4gICAgICogSW4gZWl0aGVyIGNhc2UgKDIuMSBvciAyLjIpLCBlYWNoIGVsZW1lbnQgb2Ygc3VjaCBhcnJheXMgb2YgaXRlbSBtb2RlbHMgbWF5IHRha2UgdGhlIGZvcm0gb2Y6XG4gICAgICogKiBBIHN0cmluZyBwcmltaXRpdmU7IF9vcl9cbiAgICAgKiAqIEEge0BsaW5rIGl0ZW1Nb2RlbFR5cGV9IG9iamVjdCB3aXRoIGEgdmFyaW91cyBvcHRpb24gcHJvcGVydGllcyBpbmNsdWRpbmcgdGhlIHJlcXVpcmVkIGBsYWJlbGAgcHJvcGVydHkgY29udGFpbmluZyBhIHN0cmluZyBwcmltaXRpdmUuXG4gICAgICpcbiAgICAgKiBSZWdhcmRpbmcgdGhlc2Ugc3RyaW5nIHByaW1pdGl2ZXMsIGVhY2ggaXMgZWl0aGVyOlxuICAgICAqICogQSBzdHJpbmcgdG8gYmUgZGlzcGxheWVkIGluIHRoZSBsaXN0IGl0ZW07IF9vcl9cbiAgICAgKiAqIEEgZm9ybWF0IHN0cmluZyB3aXRoIG90aGVyIHByb3BlcnR5IHZhbHVlcyBtZXJnZWQgaW4sIHRoZSByZXN1bHQgb2Ygd2hpY2ggaXMgdG8gYmUgZGlzcGxheWVkIGluIHRoZSBsaXN0IGl0ZW0uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnM9e31dIC0gVGhlcmUgYXJlIG5vIGZvcm1hbCBvcHRpb25zLCBidXQgeW91IGNhbiBzdXBwbHkgXCJnbG9iYWxcIiB0ZW1wbGF0ZSB2YXJpYWJsZXMgaGVyZSwgcmVwcmVzZW50aW5nIHRoZSBcIm91dGVyIHNjb3BlLFwiIGFmdGVyIGZpcnN0IHNlYXJjaGluZyBlYWNoIG1vZGVsIGFuZCB0aGVuIGVhY2ggbW9kZWwgbGlzdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBMaXN0RHJhZ29uKHNlbGVjdG9yT3JNb2RlbExpc3RzLCBvcHRpb25zKSB7XG5cbiAgICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIExpc3REcmFnb24pKSB7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcignTm90IGNhbGxlZCB3aXRoIFwibmV3XCIga2V5d29yZC4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzZWxmID0gdGhpcywgbW9kZWxMaXN0cywgaXRlbXM7XG5cbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgICAgaWYgKHR5cGVvZiBzZWxlY3Rvck9yTW9kZWxMaXN0cyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGl0ZW1zID0gdG9BcnJheShkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yT3JNb2RlbExpc3RzKSk7XG4gICAgICAgICAgICBtb2RlbExpc3RzID0gY3JlYXRlTW9kZWxMaXN0c0Zyb21MaXN0RWxlbWVudHMoaXRlbXMpO1xuICAgICAgICB9IGVsc2UgaWYgKHNlbGVjdG9yT3JNb2RlbExpc3RzWzBdIGluc3RhbmNlb2YgRWxlbWVudCkge1xuICAgICAgICAgICAgaXRlbXMgPSB0b0FycmF5KHNlbGVjdG9yT3JNb2RlbExpc3RzKTtcbiAgICAgICAgICAgIG1vZGVsTGlzdHMgPSBjcmVhdGVNb2RlbExpc3RzRnJvbUxpc3RFbGVtZW50cyhpdGVtcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBwYXJhbSBpcyBhcnJheSBvZiBtb2RlbCBsaXN0c1xuICAgICAgICAgICAgLy8gYnVpbGQgbmV3IDx1bD4gZWxlbWVudChzKSBmb3IgZWFjaCBsaXN0IGFuZCBwdXQgaW4gYC5tb2RlbExpc3RzYDtcbiAgICAgICAgICAgIC8vIGZpbGwgYC5pdGVtc2AgYXJyYXkgd2l0aCA8bGk+IGVsZW1lbnRzIGZyb20gdGhlc2UgbmV3IDx1bD4gZWxlbWVudHNcbiAgICAgICAgICAgIGl0ZW1zID0gW107XG4gICAgICAgICAgICBtb2RlbExpc3RzID0gY3JlYXRlTGlzdEVsZW1lbnRzRnJvbU1vZGVsTGlzdHMoc2VsZWN0b3JPck1vZGVsTGlzdHMsIG9wdGlvbnMpO1xuICAgICAgICAgICAgbW9kZWxMaXN0cy5mb3JFYWNoKGZ1bmN0aW9uIChsaXN0KSB7XG4gICAgICAgICAgICAgICAgaXRlbXMgPSBpdGVtcy5jb25jYXQodG9BcnJheShsaXN0LmVsZW1lbnQucXVlcnlTZWxlY3RvckFsbCgnbGknKSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpdGVtcy5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtRWxlbWVudCwgaW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBpdGVtID0gKGl0ZW1FbGVtZW50ICE9PSBpdGVtRWxlbWVudC5wYXJlbnRFbGVtZW50Lmxhc3RFbGVtZW50Q2hpbGQpXG4gICAgICAgICAgICAgICAgPyBzZWxmLmFkZEV2dChpdGVtRWxlbWVudCwgJ21vdXNlZG93bicsIGl0ZW1FbGVtZW50LCB0cnVlKVxuICAgICAgICAgICAgICAgIDogeyBlbGVtZW50OiBpdGVtRWxlbWVudCB9O1xuXG4gICAgICAgICAgICAvKiBgaXRlbS5tb2RlbGAgbm90IGN1cnJlbnRseSBuZWVkZWQgc28gY29tbWVudGVkIG91dCBoZXJlLlxuICAgICAgICAgICAgICogKE9yaWdpbmFsbHkgdXNlZCBmb3IgcmVidWlsZGluZyBtb2RlbExpc3RzIGZvciBmaW5hbFxuICAgICAgICAgICAgICogcmVwb3J0aW5nLCBtb2RlbExpc3RzIGFyZSBub3cgc3BsaWNlZCBvbiBldmVyeSBzdWNjZXNzZnVsXG4gICAgICAgICAgICAgKiBkcmFnLWFuZC1kcm9wIG9wZXJhdGlvbiBzbyB0aGV5J3JlIGFsd2F5cyB1cCB0byBkYXRlLilcblxuICAgICAgICAgICAgIHZhciBvcmlnaW4gPSB0aGlzLml0ZW1Db29yZGluYXRlcyhpdGVtRWxlbWVudCk7XG4gICAgICAgICAgICAgaXRlbS5tb2RlbCA9IHRoaXMubW9kZWxMaXN0c1tvcmlnaW4ubGlzdF0ubW9kZWxzW29yaWdpbi5pdGVtXTtcblxuICAgICAgICAgICAgICovXG5cbiAgICAgICAgICAgIGl0ZW1zW2luZGV4XSA9IGl0ZW07XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGJvZHkgPSBib2R5IHx8IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdib2R5JylbMF07XG5cbiAgICAgICAgdHJhbnNmb3JtID0gJ3RyYW5zZm9ybScgaW4gaXRlbXNbMF0uZWxlbWVudC5zdHlsZVxuICAgICAgICAgICAgPyAndHJhbnNmb3JtJyAvLyBDaHJvbWUgNDUgYW5kIEZpcmVmb3ggNDBcbiAgICAgICAgICAgIDogJy13ZWJraXQtdHJhbnNmb3JtJzsgLy8gU2FmYXJpIDhcblxuICAgICAgICAvLyBzZXQgdXAgdGhlIG5ldyBvYmplY3RcbiAgICAgICAgdGhpcy5tb2RlbExpc3RzID0gbW9kZWxMaXN0cztcbiAgICAgICAgdGhpcy5pdGVtcyA9IGl0ZW1zO1xuICAgICAgICB0aGlzLmJpbmRpbmdzID0ge307XG4gICAgICAgIHRoaXMuY2FsbGJhY2sgPSB7fTtcblxuICAgIH1cblxuICAgIExpc3REcmFnb24ucHJvdG90eXBlID0ge1xuXG4gICAgICAgIGFkZEV2dDogZnVuY3Rpb24gKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIsIGRvTm90QmluZCkge1xuICAgICAgICAgICAgdmFyIGJpbmRpbmcgPSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlcjogaGFuZGxlcnNbdHlwZV0uYmluZCh0YXJnZXQsIHRoaXMpLFxuICAgICAgICAgICAgICAgIGVsZW1lbnQ6IGxpc3RlbmVyIHx8IHdpbmRvd1xuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgaWYgKCFkb05vdEJpbmQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmJpbmRpbmdzW3R5cGVdID0gYmluZGluZztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYmluZGluZy5lbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgYmluZGluZy5oYW5kbGVyKTtcblxuICAgICAgICAgICAgcmV0dXJuIGJpbmRpbmc7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVtb3ZlRXZ0OiBmdW5jdGlvbiAodHlwZSkge1xuICAgICAgICAgICAgdmFyIGJpbmRpbmcgPSB0aGlzLmJpbmRpbmdzW3R5cGVdO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuYmluZGluZ3NbdHlwZV07XG4gICAgICAgICAgICBiaW5kaW5nLmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBiaW5kaW5nLmhhbmRsZXIpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHJlbW92ZUFsbEV2ZW50TGlzdGVuZXJzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyByZW1vdmUgZHJhZyAmIGRyb3AgZXZlbnRzIChtb3VzZW1vdmUsIG1vdXNldXAsIGFuZCB0cmFuc2l0aW9uZW5kKVxuICAgICAgICAgICAgZm9yICh2YXIgdHlwZSBpbiB0aGlzLmJpbmRpbmdzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGJpbmRpbmcgPSB0aGlzLmJpbmRpbmdzW3R5cGVdO1xuICAgICAgICAgICAgICAgIGJpbmRpbmcuZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGJpbmRpbmcuaGFuZGxlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyByZW1vdmUgdGhlIG1vdXNlZG93biBldmVudHMgZnJvbSBhbGwgbGlzdCBpdGVtc1xuICAgICAgICAgICAgdGhpcy5pdGVtcy5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZW0uaGFuZGxlcikge1xuICAgICAgICAgICAgICAgICAgICBpdGVtLmVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgaXRlbS5oYW5kbGVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcblxuICAgICAgICBwb2ludEluTGlzdFJlY3RzOiBmdW5jdGlvbiAocG9pbnQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm1vZGVsTGlzdHMuZmluZChmdW5jdGlvbiAobW9kZWxMaXN0KSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlY3QgPSBtb2RlbExpc3QuZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgICAgICAgICAgICAgIHJlY3QgPSB7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQ6ICAgd2luZG93LnNjcm9sbFggKyByZWN0LmxlZnQsXG4gICAgICAgICAgICAgICAgICAgIHRvcDogICAgd2luZG93LnNjcm9sbFkgKyByZWN0LnRvcCxcbiAgICAgICAgICAgICAgICAgICAgcmlnaHQ6ICB3aW5kb3cuc2Nyb2xsWCArIHJlY3QucmlnaHQsXG4gICAgICAgICAgICAgICAgICAgIGJvdHRvbTogd2luZG93LnNjcm9sbFkgKyByZWN0LmJvdHRvbSxcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6ICByZWN0LndpZHRoLFxuICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IHJlY3QuaGVpZ2h0XG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIG1vZGVsTGlzdC5yZWN0ID0gcmVjdDtcblxuICAgICAgICAgICAgICAgIGlmIChwb2ludEluUmVjdChwb2ludCwgcmVjdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbW9kZWxMaXN0LnJlY3QgPSByZWN0O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTsgLy8gZm91bmRcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcG9pbnRJbkl0ZW1SZWN0czogZnVuY3Rpb24gKHBvaW50LCBleGNlcHQxLCBleGNlcHQyKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5pdGVtcy5maW5kKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVsZW1lbnQgPSBpdGVtLmVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudCAhPT0gZXhjZXB0MSAmJlxuICAgICAgICAgICAgICAgICAgICBlbGVtZW50ICE9PSBleGNlcHQyICYmXG4gICAgICAgICAgICAgICAgICAgIHBvaW50SW5SZWN0KHBvaW50LCBpdGVtLnJlY3QpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8vIGdldCBwb3NpdGlvbnMgb2YgYWxsIGxpc3QgaXRlbXMgaW4gcGFnZSBjb29yZHMgKG5vcm1hbGl6ZWQgZm9yIHdpbmRvdyBhbmQgbGlzdCBzY3JvbGxpbmcpXG4gICAgICAgIGdldEFsbEl0ZW1Cb3VuZGluZ1JlY3RzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbW9kZWxMaXN0cyA9IHRoaXMubW9kZWxMaXN0cywgaGVpZ2h0O1xuICAgICAgICAgICAgdGhpcy5pdGVtcy5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgdmFyIGl0ZW1FbGVtZW50ID0gaXRlbS5lbGVtZW50LFxuICAgICAgICAgICAgICAgICAgICBsaXN0RWxlbWVudCA9IGl0ZW1FbGVtZW50LnBhcmVudEVsZW1lbnQsXG4gICAgICAgICAgICAgICAgICAgIGxpc3QgPSBtb2RlbExpc3RzLmZpbmQoZnVuY3Rpb24gKGxpc3QpIHsgcmV0dXJuIGxpc3QuZWxlbWVudCA9PT0gbGlzdEVsZW1lbnQ7IH0pO1xuXG4gICAgICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgICAgICAvLyBvbWl0dGVkOiBkZWZhdWx0IHRvIHRydWVcbiAgICAgICAgICAgICAgICAgICAgbGlzdC5pc0Ryb3BUYXJnZXQgPT09IHVuZGVmaW5lZCB8fFxuXG4gICAgICAgICAgICAgICAgICAgIC8vIGZ1bmN0aW9uOiB1c2UgcmV0dXJuIHZhbHVlXG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiBsaXN0LmlzRHJvcFRhcmdldCA9PT0gJ2Z1bmN0aW9uJyAmJiBsaXN0LmlzRHJvcFRhcmdldCgpIHx8XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gb3RoZXJ3aXNlOiB1c2UgdHJ1dGhpbmVzcyBvZiBnaXZlbiB2YWx1ZVxuICAgICAgICAgICAgICAgICAgICBsaXN0LmlzRHJvcFRhcmdldFxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVjdCA9IGl0ZW1FbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgYm90dG9tID0gcmVjdC5ib3R0b207XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW1FbGVtZW50ID09PSBsaXN0RWxlbWVudC5sYXN0RWxlbWVudENoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBib3R0b20gPSBsaXN0RWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5ib3R0b207XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYm90dG9tIDwgcmVjdC50b3ApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3R0b20gPSByZWN0LnRvcCArIChoZWlnaHQgfHwgNTApO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGVpZ2h0ID0gcmVjdC5oZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZWN0ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGVmdDogICB3aW5kb3cuc2Nyb2xsWCArIHJlY3QubGVmdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpZ2h0OiAgd2luZG93LnNjcm9sbFggKyByZWN0LnJpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9wOiAgICB3aW5kb3cuc2Nyb2xsWSArIHJlY3QudG9wICAgICsgbGlzdEVsZW1lbnQuc2Nyb2xsVG9wLFxuICAgICAgICAgICAgICAgICAgICAgICAgYm90dG9tOiB3aW5kb3cuc2Nyb2xsWSArIGJvdHRvbSArIGxpc3RFbGVtZW50LnNjcm9sbFRvcFxuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIGl0ZW0ucmVjdCA9IHJlY3Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgcmVpbnNlcnQ6IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgICAgICAgICAgIHZhciBzdHlsZSA9IHRhcmdldC5zdHlsZTtcbiAgICAgICAgICAgIHN0eWxlLndpZHRoID0gc3R5bGVbdHJhbnNmb3JtXSA9IHN0eWxlLnRyYW5zaXRpb24gPSBSRVZFUlRfVE9fU1RZTEVTSEVFVF9WQUxVRTtcblxuICAgICAgICAgICAgdGFyZ2V0LmNsYXNzTGlzdC5yZW1vdmUoJ2RyYWdvbi1wb3AnKTtcblxuICAgICAgICAgICAgdGhpcy5kcm9wLnN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbiA9ICcwcyc7XG4gICAgICAgICAgICB0aGlzLmRyb3Auc3R5bGUuYm9yZGVyVG9wV2lkdGggPSBSRVZFUlRfVE9fU1RZTEVTSEVFVF9WQUxVRTtcbiAgICAgICAgICAgIHRoaXMuZHJvcC5wYXJlbnRFbGVtZW50Lmluc2VydEJlZm9yZSh0YXJnZXQsIHRoaXMuZHJvcCk7XG5cbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmRyb3A7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gcmV0dXJuIGFuIG9iamVjdCB7IGl0ZW06IDxpdGVtIGluZGV4IHdpdGhpbiBsaXN0PiwgbGlzdDogPGxpc3QgaW5kZXggd2l0aGluIGxpc3Qgb2YgbGlzdHM+IH1cbiAgICAgICAgaXRlbUNvb3JkaW5hdGVzOiBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgdmFyIGxpc3RFbGVtZW50ID0gaXRlbS5wYXJlbnRFbGVtZW50LFxuICAgICAgICAgICAgICAgIGNvb3JkcyA9IHsgaXRlbTogMCB9O1xuXG4gICAgICAgICAgICB3aGlsZSAoKGl0ZW0gPSBpdGVtLnByZXZpb3VzRWxlbWVudFNpYmxpbmcpKSB7XG4gICAgICAgICAgICAgICAgKytjb29yZHMuaXRlbTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5tb2RlbExpc3RzLmZpbmQoZnVuY3Rpb24gKGxpc3QsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgY29vcmRzLmxpc3QgPSBpbmRleDtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGlzdC5lbGVtZW50ID09PSBsaXN0RWxlbWVudDsgLy8gc3RvcCB3aGVuIHdlIGZpbmQgdGhlIG9uZSB3ZSBiZWxvbmcgdG9cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICByZXR1cm4gY29vcmRzO1xuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgdmFyIGhhbmRsZXJzID0ge1xuICAgICAgICBtb3VzZWRvd246IGZ1bmN0aW9uIChkcmFnb24sIGV2dCkge1xuXG4gICAgICAgICAgICBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTsgIC8vcHJldmVudHMgdXNlciBzZWxlY3Rpb24gb2YgcmVuZGVyZWQgbm9kZXMgZHVyaW5nIGRyYWdcblxuICAgICAgICAgICAgaWYgKGRyYWdvbi5kcm9wKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgcmVjdCA9IHRoaXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICAgICAgICAgIGRyYWdvbi5yZWN0ID0gcmVjdCA9IHtcbiAgICAgICAgICAgICAgICBsZWZ0OiAgIE1hdGgucm91bmQocmVjdC5sZWZ0IC0gMSksXG4gICAgICAgICAgICAgICAgdG9wOiAgICBNYXRoLnJvdW5kKHJlY3QudG9wIC0gMSksXG4gICAgICAgICAgICAgICAgcmlnaHQ6ICBNYXRoLnJvdW5kKHJlY3QucmlnaHQpLFxuICAgICAgICAgICAgICAgIGJvdHRvbTogTWF0aC5yb3VuZChyZWN0LmJvdHRvbSksXG4gICAgICAgICAgICAgICAgd2lkdGg6ICBNYXRoLnJvdW5kKHJlY3Qud2lkdGgpLFxuICAgICAgICAgICAgICAgIGhlaWdodDogTWF0aC5yb3VuZChyZWN0LmhlaWdodClcbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGRyYWdvbi5waW4gPSB7XG4gICAgICAgICAgICAgICAgeDogd2luZG93LnNjcm9sbFggKyBldnQuY2xpZW50WCxcbiAgICAgICAgICAgICAgICB5OiB3aW5kb3cuc2Nyb2xsWSArIGV2dC5jbGllbnRZXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBkcmFnb24ub3JpZ2luID0gZHJhZ29uLml0ZW1Db29yZGluYXRlcyh0aGlzKTtcblxuICAgICAgICAgICAgaWYgKGRyYWdvbi5jYWxsYmFjay5ncmFiYmVkKSB7XG4gICAgICAgICAgICAgICAgZHJhZ29uLmNhbGxiYWNrLmdyYWJiZWQuY2FsbCh0aGlzLCBkcmFnb24pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkcmFnb24uZ2V0QWxsSXRlbUJvdW5kaW5nUmVjdHMoKTtcblxuICAgICAgICAgICAgZHJhZ29uLmRyb3AgPSB0aGlzLm5leHRFbGVtZW50U2libGluZztcbiAgICAgICAgICAgIGRyYWdvbi5kcm9wLnN0eWxlLnRyYW5zaXRpb25EdXJhdGlvbiA9ICcwcyc7XG4gICAgICAgICAgICBkcmFnb24uZHJvcC5zdHlsZS5ib3JkZXJUb3BXaWR0aCA9IHJlY3QuaGVpZ2h0ICsgJ3B4JztcblxuICAgICAgICAgICAgdGhpcy5zdHlsZS53aWR0aCA9IHJlY3Qud2lkdGggKyAncHgnO1xuICAgICAgICAgICAgdGhpcy5zdHlsZS50cmFuc2l0aW9uRHVyYXRpb24gPSAnMHMnO1xuICAgICAgICAgICAgdGhpcy5zdHlsZVt0cmFuc2Zvcm1dID0gdHJhbnNsYXRlKFxuICAgICAgICAgICAgICAgIHJlY3QubGVmdCAtIHdpbmRvdy5zY3JvbGxYLFxuICAgICAgICAgICAgICAgIHJlY3QudG9wICAtIHdpbmRvdy5zY3JvbGxZXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgdGhpcy5jbGFzc0xpc3QuYWRkKCdkcmFnb24tcG9wJyk7XG4gICAgICAgICAgICB0aGlzLnN0eWxlLnpJbmRleCA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGRyYWdvbi5tb2RlbExpc3RzWzBdLmNvbnRhaW5lci5wYXJlbnRFbGVtZW50KS56SW5kZXg7XG5cbiAgICAgICAgICAgIGJvZHkuYXBwZW5kQ2hpbGQodGhpcyk7XG5cbiAgICAgICAgICAgIHJlY3QubGVmdCAgICs9IHdpbmRvdy5zY3JvbGxYO1xuICAgICAgICAgICAgcmVjdC50b3AgICAgKz0gd2luZG93LnNjcm9sbFk7XG4gICAgICAgICAgICByZWN0LnJpZ2h0ICArPSB3aW5kb3cuc2Nyb2xsWDtcbiAgICAgICAgICAgIHJlY3QuYm90dG9tICs9IHdpbmRvdy5zY3JvbGxZO1xuXG4gICAgICAgICAgICBkcmFnb24uYWRkRXZ0KHRoaXMsICdtb3VzZW1vdmUnKTtcbiAgICAgICAgICAgIGRyYWdvbi5hZGRFdnQodGhpcywgJ21vdXNldXAnKTtcbiAgICAgICAgfSxcblxuICAgICAgICBtb3VzZW1vdmU6IGZ1bmN0aW9uIChkcmFnb24sIGV2dCkge1xuICAgICAgICAgICAgZHJhZ29uLmRyb3Auc3R5bGUudHJhbnNpdGlvbiA9IFJFVkVSVF9UT19TVFlMRVNIRUVUX1ZBTFVFO1xuXG4gICAgICAgICAgICB2YXIgaG92ZXJMaXN0ID0gZHJhZ29uLnBvaW50SW5MaXN0UmVjdHMoeyB4OiBldnQuY2xpZW50WCwgeTogZXZ0LmNsaWVudFkgfSkgfHwgZHJhZ29uLm1vc3RSZWNlbnRIb3Zlckxpc3Q7XG5cbiAgICAgICAgICAgIGlmIChob3Zlckxpc3QpIHtcbiAgICAgICAgICAgICAgICB2YXIgZHggPSBldnQuY2xpZW50WCAtIGRyYWdvbi5waW4ueCxcbiAgICAgICAgICAgICAgICAgICAgZHkgPSBldnQuY2xpZW50WSAtIGRyYWdvbi5waW4ueTtcblxuICAgICAgICAgICAgICAgIGRyYWdvbi5tb3N0UmVjZW50SG92ZXJMaXN0ID0gaG92ZXJMaXN0O1xuXG4gICAgICAgICAgICAgICAgdmFyIG1heFNjcm9sbFkgPSBob3Zlckxpc3QuZWxlbWVudC5zY3JvbGxIZWlnaHQgLSBob3Zlckxpc3QucmVjdC5oZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgIHkgPSBldnQuY2xpZW50WSArIHdpbmRvdy5zY3JvbGxZLFxuICAgICAgICAgICAgICAgICAgICBtYWduaXR1ZGU7XG5cbiAgICAgICAgICAgICAgICBpZiAobWF4U2Nyb2xsWSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbGlzdCBpcyBzY3JvbGxhYmxlIChpcyB0YWxsZXIgdGhhbiByZWN0KVxuICAgICAgICAgICAgICAgICAgICBpZiAoaG92ZXJMaXN0LmVsZW1lbnQuc2Nyb2xsVG9wID4gMCAmJiAobWFnbml0dWRlID0geSAtIChob3Zlckxpc3QucmVjdC50b3AgKyA1KSkgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBtb3VzZSBuZWFyIG9yIGFib3ZlIHRvcCBhbmQgbGlzdCBpcyBub3Qgc2Nyb2xsZWQgdG8gdG9wIHlldFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzZXRBdXRvU2Nyb2xsVGltZXIobWFnbml0dWRlLCAwLCBob3Zlckxpc3QuZWxlbWVudCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaG92ZXJMaXN0LmVsZW1lbnQuc2Nyb2xsVG9wIDwgbWF4U2Nyb2xsWSAmJiAobWFnbml0dWRlID0geSAtIChob3Zlckxpc3QucmVjdC5ib3R0b20gLSAxIC0gNSkpID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbW91c2UgbmVhciBvciBiZWxvdyBib3R0b20gYW5kIGxpc3Qgbm90IHNjcm9sbGVkIHRvIGJvdHRvbSB5ZXRcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc2V0QXV0b1Njcm9sbFRpbWVyKG1hZ25pdHVkZSwgbWF4U2Nyb2xsWSwgaG92ZXJMaXN0LmVsZW1lbnQpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbW91c2UgaW5zaWRlXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNldEF1dG9TY3JvbGxUaW1lcigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIG90aGVyID0gZHJhZ29uLnBvaW50SW5JdGVtUmVjdHMoe1xuICAgICAgICAgICAgICAgICAgICB4OiBldnQuY2xpZW50WCxcbiAgICAgICAgICAgICAgICAgICAgeTogZHJhZ29uLnJlY3QuYm90dG9tICsgd2luZG93LnNjcm9sbFkgKyBkeSArIGhvdmVyTGlzdC5lbGVtZW50LnNjcm9sbFRvcFxuICAgICAgICAgICAgICAgIH0sIHRoaXMsIGRyYWdvbi5kcm9wKTtcblxuICAgICAgICAgICAgICAgIHRoaXMuc3R5bGVbdHJhbnNmb3JtXSA9IHRyYW5zbGF0ZShcbiAgICAgICAgICAgICAgICAgICAgZHJhZ29uLnJlY3QubGVmdCAtIHdpbmRvdy5zY3JvbGxYICsgZHgsXG4gICAgICAgICAgICAgICAgICAgIGRyYWdvbi5yZWN0LnRvcCAtIHdpbmRvdy5zY3JvbGxZICsgZHlcbiAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgaWYgKG90aGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBlbGVtZW50ID0gb3RoZXIuZWxlbWVudDtcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudC5zdHlsZS50cmFuc2l0aW9uID0gUkVWRVJUX1RPX1NUWUxFU0hFRVRfVkFMVUU7XG4gICAgICAgICAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUuYm9yZGVyVG9wV2lkdGggPSBkcmFnb24uZHJvcC5zdHlsZS5ib3JkZXJUb3BXaWR0aDtcbiAgICAgICAgICAgICAgICAgICAgZHJhZ29uLmRyb3Auc3R5bGUuYm9yZGVyVG9wV2lkdGggPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBkcmFnb24uZHJvcCA9IGVsZW1lbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIG1vdXNldXA6IGZ1bmN0aW9uIChkcmFnb24sIGV2dCkge1xuICAgICAgICAgICAgcmVzZXRBdXRvU2Nyb2xsVGltZXIoKTtcbiAgICAgICAgICAgIGRyYWdvbi5yZW1vdmVFdnQoJ21vdXNlbW92ZScpO1xuICAgICAgICAgICAgZHJhZ29uLnJlbW92ZUV2dCgnbW91c2V1cCcpO1xuXG4gICAgICAgICAgICBldnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICAgICAgICAgIHZhciBuZXdSZWN0ID0gdGhpcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgICAgICAgICAgaWYgKFxuICAgICAgICAgICAgICAgIHdpbmRvdy5zY3JvbGxYICsgbmV3UmVjdC5sZWZ0ID09PSBkcmFnb24ucmVjdC5sZWZ0ICYmXG4gICAgICAgICAgICAgICAgd2luZG93LnNjcm9sbFkgKyBuZXdSZWN0LnRvcCA9PT0gZHJhZ29uLnJlY3QudG9wXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBkcmFnb24ucmVpbnNlcnQodGhpcyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBkcm9wUmVjdCA9IGRyYWdvbi5kcm9wLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgICAgICAgICAgICAgZHJhZ29uLmFkZEV2dCh0aGlzLCAndHJhbnNpdGlvbmVuZCcsIHRoaXMpO1xuICAgICAgICAgICAgICAgIHRoaXMuc3R5bGUudHJhbnNpdGlvbkR1cmF0aW9uID0gUkVWRVJUX1RPX1NUWUxFU0hFRVRfVkFMVUU7IC8vcmV2ZXJ0cyB0byAyMDBtc1xuICAgICAgICAgICAgICAgIHRoaXMuc3R5bGUudHJhbnNpdGlvblByb3BlcnR5ID0gdHJhbnNmb3JtO1xuICAgICAgICAgICAgICAgIHRoaXMuc3R5bGVbdHJhbnNmb3JtXSA9IHRyYW5zbGF0ZShcbiAgICAgICAgICAgICAgICAgICAgZHJvcFJlY3QubGVmdCAtIHdpbmRvdy5zY3JvbGxYLFxuICAgICAgICAgICAgICAgICAgICBkcm9wUmVjdC50b3AgLSB3aW5kb3cuc2Nyb2xsWVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgdHJhbnNpdGlvbmVuZDogZnVuY3Rpb24gKGRyYWdvbiwgZXZ0KSB7XG4gICAgICAgICAgICBpZiAoZXZ0LnByb3BlcnR5TmFtZSA9PT0gdHJhbnNmb3JtKSB7XG4gICAgICAgICAgICAgICAgZHJhZ29uLnJlbW92ZUV2dCgndHJhbnNpdGlvbmVuZCcpO1xuICAgICAgICAgICAgICAgIGRyYWdvbi5yZWluc2VydCh0aGlzKTtcblxuICAgICAgICAgICAgICAgIHRoaXMuc3R5bGUudHJhbnNpdGlvblByb3BlcnR5ID0gUkVWRVJUX1RPX1NUWUxFU0hFRVRfVkFMVUU7IC8vcmV2ZXJ0cyB0byBib3JkZXItdG9wLXdpZHRoXG5cbiAgICAgICAgICAgICAgICB2YXIgbW9kZWwgPSBkcmFnb24ubW9kZWxMaXN0c1tkcmFnb24ub3JpZ2luLmxpc3RdLnNwbGljZShkcmFnb24ub3JpZ2luLml0ZW0sIDEpWzBdO1xuICAgICAgICAgICAgICAgIHZhciBkZXN0aW5hdGlvbiA9IGRyYWdvbi5pdGVtQ29vcmRpbmF0ZXModGhpcyk7XG4gICAgICAgICAgICAgICAgZHJhZ29uLm1vZGVsTGlzdHNbZGVzdGluYXRpb24ubGlzdF0uc3BsaWNlKGRlc3RpbmF0aW9uLml0ZW0sIDAsIG1vZGVsKTtcblxuICAgICAgICAgICAgICAgIGlmIChkcmFnb24uY2FsbGJhY2suZHJvcHBlZCkge1xuICAgICAgICAgICAgICAgICAgICBkcmFnb24uY2FsbGJhY2suZHJvcHBlZC5jYWxsKHRoaXMsIGRyYWdvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIHJlc2V0QXV0b1Njcm9sbFRpbWVyKG1hZ25pdHVkZSwgbGltaXQsIGVsZW1lbnQpIHtcbiAgICAgICAgaWYgKCFtYWduaXR1ZGUpIHtcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGltZXIpO1xuICAgICAgICAgICAgc2Nyb2xsVmVsb2NpdHkgPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGNoYW5nZURpcmVjdGlvbiA9XG4gICAgICAgICAgICAgICAgc2Nyb2xsVmVsb2NpdHkgIDwgIDAgJiYgbWFnbml0dWRlICA+PSAwIHx8XG4gICAgICAgICAgICAgICAgc2Nyb2xsVmVsb2NpdHkgPT09IDAgJiYgbWFnbml0dWRlICE9PSAwIHx8XG4gICAgICAgICAgICAgICAgc2Nyb2xsVmVsb2NpdHkgID4gIDAgJiYgbWFnbml0dWRlICA8PSAwO1xuICAgICAgICAgICAgc2Nyb2xsVmVsb2NpdHkgPSBtYWduaXR1ZGUgPiAwID8gTWF0aC5taW4oNTAsIG1hZ25pdHVkZSkgOiBNYXRoLm1heCgtNTAsIG1hZ25pdHVkZSk7XG4gICAgICAgICAgICBpZiAoY2hhbmdlRGlyZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aW1lcik7XG4gICAgICAgICAgICAgICAgdGltZXIgPSBzZXRJbnRlcnZhbChmdW5jdGlvbiAobGltaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNjcm9sbFRvcCA9IGVsZW1lbnQuc2Nyb2xsVG9wICsgc2Nyb2xsVmVsb2NpdHk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzY3JvbGxWZWxvY2l0eSA8IDAgJiYgc2Nyb2xsVG9wIDwgbGltaXQgfHwgc2Nyb2xsVmVsb2NpdHkgPiAwICYmIHNjcm9sbFRvcCA+IGxpbWl0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50LnNjcm9sbFRvcCA9IGxpbWl0O1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aW1lcik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtZW50LnNjcm9sbFRvcCA9IHNjcm9sbFRvcDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIDEyNSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiB0b0FycmF5KGFycmF5TGlrZU9iamVjdCkge1xuICAgICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJyYXlMaWtlT2JqZWN0KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBwb2ludEluUmVjdChwb2ludCwgcmVjdCkge1xuICAgICAgICByZXR1cm4gcmVjdC50b3AgPD0gcG9pbnQueSAmJiBwb2ludC55IDw9IHJlY3QuYm90dG9tXG4gICAgICAgICAgICAmJiByZWN0LmxlZnQgPD0gcG9pbnQueCAmJiBwb2ludC54IDw9IHJlY3QucmlnaHQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdHJhbnNsYXRlKGxlZnQsIHRvcCkge1xuICAgICAgICByZXR1cm4gJ3RyYW5zbGF0ZSgnXG4gICAgICAgICAgICArIE1hdGguZmxvb3IobGVmdCArIHdpbmRvdy5zY3JvbGxYKSArICdweCwnXG4gICAgICAgICAgICArIE1hdGguZmxvb3IodG9wICsgd2luZG93LnNjcm9sbFkpICsgJ3B4KSc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaHRtbEVuY29kZShzdHJpbmcpIHtcbiAgICAgICAgdmFyIHRleHROb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoc3RyaW5nKTtcblxuICAgICAgICByZXR1cm4gZG9jdW1lbnRcbiAgICAgICAgICAgIC5jcmVhdGVFbGVtZW50KCdhJylcbiAgICAgICAgICAgIC5hcHBlbmRDaGlsZCh0ZXh0Tm9kZSlcbiAgICAgICAgICAgIC5wYXJlbnROb2RlXG4gICAgICAgICAgICAuaW5uZXJIVE1MO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYDx1bD4uLi48L3VsPmAgZWxlbWVudHMgYW5kIGluc2VydHMgdGhlbSBpbnRvIGFuIGBlbGVtZW50YCBwcm9wZXJ0eSBvbiBlYWNoIG1vZGVsLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBtb2RlbExpc3RzXG4gICAgICogQHJldHVybnMgYG1vZGVsTGlzdHNgXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlTGlzdEVsZW1lbnRzRnJvbU1vZGVsTGlzdHMobW9kZWxMaXN0cywgb3B0aW9ucykge1xuICAgICAgICB2YXIgdGVtcGxhdGVMYWJlbCA9IG9wdGlvbnMubGFiZWwgfHwgJ3tsYWJlbH0nO1xuXG4gICAgICAgIG1vZGVsTGlzdHMuZm9yRWFjaChmdW5jdGlvbiAobW9kZWxMaXN0LCBsaXN0SW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBsaXN0TGFiZWwgPSBtb2RlbExpc3QubGFiZWwgfHwgdGVtcGxhdGVMYWJlbCxcbiAgICAgICAgICAgICAgICBsaXN0SHRtbEVuY29kZSA9IG1vZGVsTGlzdC5odG1sRW5jb2RlICE9PSB1bmRlZmluZWQgJiYgbW9kZWxMaXN0Lmh0bWxFbmNvZGUgfHwgb3B0aW9ucy5odG1sRW5jb2RlLFxuICAgICAgICAgICAgICAgIGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLFxuICAgICAgICAgICAgICAgIGxpc3RFbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndWwnKTtcblxuICAgICAgICAgICAgaWYgKG1vZGVsTGlzdC5tb2RlbHMpIHtcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhtb2RlbExpc3QpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5ICE9PSAnbW9kZWxzJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbW9kZWxMaXN0Lm1vZGVsc1trZXldID0gbW9kZWxMaXN0W2tleV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBtb2RlbExpc3RzW2xpc3RJbmRleF0gPSBtb2RlbExpc3QgPSBtb2RlbExpc3QubW9kZWxzO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChtb2RlbExpc3QgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgICAgICAgICAgICAgIG1vZGVsTGlzdC5tb2RlbHMgPSBtb2RlbExpc3Q7IC8vIHBvaW50IHRvIHNlbGZcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3IoJ0xpc3QgW3sxfV0gbm90IGFuIGFycmF5IG9mIG1vZGVscyAod2l0aCBvciB3aXRob3V0IGFkZGl0aW9uYWwgcHJvcGVydGllcykgT1IgJyArXG4gICAgICAgICAgICAgICAgICAgICdhbiBvYmplY3QgKHdpdGggYSBgbW9kZWxzYCBwcm9wZXJ0eSBjb250YWluaW5nIGFuIGFycmF5IG9mIG1vZGVscykuJywgbGlzdEluZGV4KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbW9kZWxMaXN0LmZvckVhY2goZnVuY3Rpb24gKG1vZGVsKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1vZGVsTGFiZWwgPSBtb2RlbC5sYWJlbCB8fCBsaXN0TGFiZWwsXG4gICAgICAgICAgICAgICAgICAgIG1vZGVsSHRtbEVuY29kZSA9IG1vZGVsLmh0bWxFbmNvZGUgIT09IHVuZGVmaW5lZCAmJiBtb2RlbC5odG1sRW5jb2RlIHx8IGxpc3RIdG1sRW5jb2RlLFxuICAgICAgICAgICAgICAgICAgICBtb2RlbE9iamVjdCA9IHR5cGVvZiBtb2RlbCA9PT0gJ29iamVjdCcgPyBtb2RlbCA6IHsgbGFiZWw6IG1vZGVsfSxcbiAgICAgICAgICAgICAgICAgICAgbGFiZWwgPSBmb3JtYXQuY2FsbChbbW9kZWxPYmplY3QsIG1vZGVsTGlzdCwgb3B0aW9uc10sIG1vZGVsTGFiZWwpLFxuICAgICAgICAgICAgICAgICAgICBpdGVtRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2xpJyk7XG5cbiAgICAgICAgICAgICAgICBpdGVtRWxlbWVudC5pbm5lckhUTUwgPSBtb2RlbEh0bWxFbmNvZGUgPyBodG1sRW5jb2RlKGxhYmVsKSA6IGxhYmVsO1xuXG4gICAgICAgICAgICAgICAgbGlzdEVsZW1lbnQuYXBwZW5kQ2hpbGQoaXRlbUVsZW1lbnQpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIGFwcGVuZCB0aGUgZmluYWwgXCJmZW5jZXBvc3RcIiBpdGVtIC0tIGRyb3AgdGFyZ2V0IGF0IGJvdHRvbSBvZiBsaXN0IGFmdGVyIGFsbCBpdGVtc1xuICAgICAgICAgICAgdmFyIGl0ZW1FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGknKTtcbiAgICAgICAgICAgIGl0ZW1FbGVtZW50LmlubmVySFRNTCA9ICcmbmJzcDsnO1xuICAgICAgICAgICAgbGlzdEVsZW1lbnQuYXBwZW5kQ2hpbGQoaXRlbUVsZW1lbnQpO1xuXG4gICAgICAgICAgICAvLyBhcHBlbmQgaGVhZGVyIHRvIGNvbnRhaW5lclxuICAgICAgICAgICAgaWYgKG1vZGVsTGlzdC50aXRsZSkge1xuICAgICAgICAgICAgICAgIHZhciBoZWFkZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgICAgICBoZWFkZXIuaW5uZXJIVE1MID0gbGlzdEh0bWxFbmNvZGUgPyBodG1sRW5jb2RlKG1vZGVsTGlzdC50aXRsZSkgOiBtb2RlbExpc3QudGl0bGU7XG4gICAgICAgICAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGhlYWRlcik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChsaXN0RWxlbWVudCk7XG4gICAgICAgICAgICBjb250YWluZXIuY2xhc3NOYW1lID0gbW9kZWxMaXN0LmNzc0NsYXNzTmFtZXMgfHwgb3B0aW9ucy5jc3NDbGFzc05hbWVzIHx8ICdkcmFnb24tbGlzdCc7XG4gICAgICAgICAgICBtb2RlbExpc3QuZWxlbWVudCA9IGxpc3RFbGVtZW50O1xuICAgICAgICAgICAgbW9kZWxMaXN0LmNvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIG1vZGVsTGlzdHM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgYC5tb2RlbExpc3RzYCBhcnJheSB3aXRoIHRoZXNlIDxsaT4gZWxlbWVudHMnIHBhcmVudCA8dWw+IGVsZW1lbnRzXG4gICAgICogQHBhcmFtIHtFbGVtZW50W119IGxpc3RJdGVtRWxlbWVudHNcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlTW9kZWxMaXN0c0Zyb21MaXN0RWxlbWVudHMobGlzdEl0ZW1FbGVtZW50cykge1xuICAgICAgICB2YXIgbW9kZWxMaXN0cyA9IFtdO1xuXG4gICAgICAgIGxpc3RJdGVtRWxlbWVudHMuZm9yRWFjaChmdW5jdGlvbiAoaXRlbUVsZW1lbnQpIHtcbiAgICAgICAgICAgIHZhciBsaXN0RWxlbWVudCA9IGl0ZW1FbGVtZW50LnBhcmVudEVsZW1lbnQsXG4gICAgICAgICAgICAgICAgY29udGFpbmVyID0gbGlzdEVsZW1lbnQucGFyZW50RWxlbWVudCxcbiAgICAgICAgICAgICAgICBtb2RlbHMgPSBbXTtcbiAgICAgICAgICAgIGlmICghbW9kZWxMaXN0cy5maW5kKGZ1bmN0aW9uIChsaXN0KSB7IHJldHVybiBsaXN0LmVsZW1lbnQgPT09IGxpc3RFbGVtZW50OyB9KSkge1xuICAgICAgICAgICAgICAgIHRvQXJyYXkobGlzdEVsZW1lbnQucXVlcnlTZWxlY3RvckFsbCgnbGknKSkuZm9yRWFjaChmdW5jdGlvbiAoaXRlbUVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW1FbGVtZW50ICE9PSBsaXN0RWxlbWVudC5sYXN0RWxlbWVudENoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RlbHMucHVzaChpdGVtRWxlbWVudC5pbm5lckhUTUwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgbW9kZWxzLmVsZW1lbnQgPSBsaXN0RWxlbWVudDtcbiAgICAgICAgICAgICAgICBtb2RlbHMuY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgICAgICAgICAgICAgIG1vZGVsTGlzdHMucHVzaChtb2RlbHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gbW9kZWxMaXN0cztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBlcnJvcigpIHtcbiAgICAgICAgcmV0dXJuICdsaXN0LWRyYWdvbjogJyArIGZvcm1hdC5hcHBseSh0aGlzLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpKTtcbiAgICB9XG5cbiAgICAvLyB0aGlzIGludGVyZmFjZSBjb25zaXN0cyBzb2xlbHkgb2YgdGhlIHByb3RvdHlwYWwgb2JqZWN0IGNvbnN0cnVjdG9yXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBMaXN0RHJhZ29uO1xuXG59KShcbiAgICB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiBtb2R1bGUgfHwgKHdpbmRvdy5MaXN0RHJhZ29uID0ge30pLFxuICAgIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzIHx8ICh3aW5kb3cuTGlzdERyYWdvbi5leHBvcnRzID0ge30pXG4pIHx8IChcbiAgICB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyB8fCAod2luZG93Lkxpc3REcmFnb24gPSB3aW5kb3cuTGlzdERyYWdvbi5leHBvcnRzKVxuKTtcblxuLyogQWJvdXQgdGhlIGFib3ZlIElJRkU6XG4gKiBUaGlzIGZpbGUgaXMgYSBcIm1vZGlmaWVkIG5vZGUgbW9kdWxlLlwiIEl0IGZ1bmN0aW9ucyBhcyB1c3VhbCBpbiBOb2RlLmpzICphbmQqIGlzIGFsc28gdXNhYmxlIGRpcmVjdGx5IGluIHRoZSBicm93c2VyLlxuICogMS4gTm9kZS5qczogVGhlIElJRkUgaXMgc3VwZXJmbHVvdXMgYnV0IGlubm9jdW91cy5cbiAqIDIuIEluIHRoZSBicm93c2VyOiBUaGUgSUlGRSBjbG9zdXJlIHNlcnZlcyB0byBrZWVwIGludGVybmFsIGRlY2xhcmF0aW9ucyBwcml2YXRlLlxuICogMi5hLiBJbiB0aGUgYnJvd3NlciBhcyBhIGdsb2JhbDogVGhlIGxvZ2ljIGluIHRoZSBhY3R1YWwgcGFyYW1ldGVyIGV4cHJlc3Npb25zICsgdGhlIHBvc3QtaW52b2NhdGlvbiBleHByZXNzaW9uXG4gKiB3aWxsIHB1dCB5b3VyIEFQSSBpbiBgd2luZG93Lkxpc3REcmFnb25gLlxuICogMi5iLiBJbiB0aGUgYnJvd3NlciBhcyBhIG1vZHVsZTogSWYgeW91IHByZWRlZmluZSBhIGB3aW5kb3cubW9kdWxlYCBvYmplY3QsIHRoZSByZXN1bHRzIHdpbGwgYmUgaW4gYG1vZHVsZS5leHBvcnRzYC5cbiAqIFRoZSBib3dlciBjb21wb25lbnQgYG1ubWAgbWFrZXMgdGhpcyBlYXN5IGFuZCBhbHNvIHByb3ZpZGVzIGEgZ2xvYmFsIGByZXF1aXJlKClgIGZ1bmN0aW9uIGZvciByZWZlcmVuY2luZyB5b3VyIG1vZHVsZVxuICogZnJvbSBvdGhlciBjbG9zdXJlcy4gSW4gZWl0aGVyIGNhc2UsIHRoaXMgd29ya3Mgd2l0aCBib3RoIE5vZGVKcy1zdHlsZSBleHBvcnQgbWVjaGFuaXNtcyAtLSBhIHNpbmdsZSBBUEkgYXNzaWdubWVudCxcbiAqIGBtb2R1bGUuZXhwb3J0cyA9IHlvdXJBUElgICpvciogYSBzZXJpZXMgb2YgaW5kaXZpZHVhbCBwcm9wZXJ0eSBhc3NpZ25tZW50cywgYG1vZHVsZS5leHBvcnRzLnByb3BlcnR5ID0gcHJvcGVydHlgLlxuICpcbiAqIEJlZm9yZSB0aGUgSUlGRSBydW5zLCB0aGUgYWN0dWFsIHBhcmFtZXRlciBleHByZXNzaW9ucyBhcmUgZXhlY3V0ZWQ6XG4gKiAxLiBJZiBgd2luZG93YCBvYmplY3QgdW5kZWZpbmVkLCB3ZSdyZSBpbiBOb2RlSnMgc28gYXNzdW1lIHRoZXJlIGlzIGEgYG1vZHVsZWAgb2JqZWN0IHdpdGggYW4gYGV4cG9ydHNgIHByb3BlcnR5XG4gKiAyLiBJZiBgd2luZG93YCBvYmplY3QgZGVmaW5lZCwgd2UncmUgaW4gYnJvd3NlclxuICogMi5hLiBJZiBgbW9kdWxlYCBvYmplY3QgcHJlZGVmaW5lZCwgdXNlIGl0XG4gKiAyLmIuIElmIGBtb2R1bGVgIG9iamVjdCB1bmRlZmluZWQsIGNyZWF0ZSBhIGBMaXN0RHJhZ29uYCBvYmplY3RcbiAqXG4gKiBBZnRlciB0aGUgSUlGRSByZXR1cm5zOlxuICogQmVjYXVzZSBpdCBhbHdheXMgcmV0dXJucyB1bmRlZmluZWQsIHRoZSBleHByZXNzaW9uIGFmdGVyIHRoZSB8fCB3aWxsIGV4ZWN1dGU6XG4gKiAxLiBJZiBgd2luZG93YCBvYmplY3QgdW5kZWZpbmVkLCB0aGVuIHdlJ3JlIGluIE5vZGVKcyBzbyB3ZSdyZSBkb25lXG4gKiAyLiBJZiBgd2luZG93YCBvYmplY3QgZGVmaW5lZCwgdGhlbiB3ZSdyZSBpbiBicm93c2VyXG4gKiAyLmEuIElmIGBtb2R1bGVgIG9iamVjdCBwcmVkZWZpbmVkLCB3ZSdyZSBkb25lOyByZXN1bHRzIGFyZSBpbiBgbW91ZHVsZS5leHBvcnRzYFxuICogMi5iLiBJZiBgbW9kdWxlYCBvYmplY3QgdW5kZWZpbmVkLCByZWRlZmluZWBMaXN0RHJhZ29uYCB0byBiZSB0aGUgYExpc3REcmFnb24uZXhwb3J0c2Agb2JqZWN0XG4gKi9cbiIsIjsoZnVuY3Rpb24gKCkgeyAvLyBjbG9zdXJlIGZvciB3ZWIgYnJvd3NlcnNcblxuaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gTFJVQ2FjaGVcbn0gZWxzZSB7XG4gIC8vIGp1c3Qgc2V0IHRoZSBnbG9iYWwgZm9yIG5vbi1ub2RlIHBsYXRmb3Jtcy5cbiAgdGhpcy5MUlVDYWNoZSA9IExSVUNhY2hlXG59XG5cbmZ1bmN0aW9uIGhPUCAob2JqLCBrZXkpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSlcbn1cblxuZnVuY3Rpb24gbmFpdmVMZW5ndGggKCkgeyByZXR1cm4gMSB9XG5cbnZhciBkaWRUeXBlV2FybmluZyA9IGZhbHNlXG5mdW5jdGlvbiB0eXBlQ2hlY2tLZXkoa2V5KSB7XG4gIGlmICghZGlkVHlwZVdhcm5pbmcgJiYgdHlwZW9mIGtleSAhPT0gJ3N0cmluZycgJiYgdHlwZW9mIGtleSAhPT0gJ251bWJlcicpIHtcbiAgICBkaWRUeXBlV2FybmluZyA9IHRydWVcbiAgICBjb25zb2xlLmVycm9yKG5ldyBUeXBlRXJyb3IoXCJMUlU6IGtleSBtdXN0IGJlIGEgc3RyaW5nIG9yIG51bWJlci4gQWxtb3N0IGNlcnRhaW5seSBhIGJ1ZyEgXCIgKyB0eXBlb2Yga2V5KS5zdGFjaylcbiAgfVxufVxuXG5mdW5jdGlvbiBMUlVDYWNoZSAob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgTFJVQ2FjaGUpKVxuICAgIHJldHVybiBuZXcgTFJVQ2FjaGUob3B0aW9ucylcblxuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdudW1iZXInKVxuICAgIG9wdGlvbnMgPSB7IG1heDogb3B0aW9ucyB9XG5cbiAgaWYgKCFvcHRpb25zKVxuICAgIG9wdGlvbnMgPSB7fVxuXG4gIHRoaXMuX21heCA9IG9wdGlvbnMubWF4XG4gIC8vIEtpbmQgb2Ygd2VpcmQgdG8gaGF2ZSBhIGRlZmF1bHQgbWF4IG9mIEluZmluaXR5LCBidXQgb2ggd2VsbC5cbiAgaWYgKCF0aGlzLl9tYXggfHwgISh0eXBlb2YgdGhpcy5fbWF4ID09PSBcIm51bWJlclwiKSB8fCB0aGlzLl9tYXggPD0gMCApXG4gICAgdGhpcy5fbWF4ID0gSW5maW5pdHlcblxuICB0aGlzLl9sZW5ndGhDYWxjdWxhdG9yID0gb3B0aW9ucy5sZW5ndGggfHwgbmFpdmVMZW5ndGhcbiAgaWYgKHR5cGVvZiB0aGlzLl9sZW5ndGhDYWxjdWxhdG9yICE9PSBcImZ1bmN0aW9uXCIpXG4gICAgdGhpcy5fbGVuZ3RoQ2FsY3VsYXRvciA9IG5haXZlTGVuZ3RoXG5cbiAgdGhpcy5fYWxsb3dTdGFsZSA9IG9wdGlvbnMuc3RhbGUgfHwgZmFsc2VcbiAgdGhpcy5fbWF4QWdlID0gb3B0aW9ucy5tYXhBZ2UgfHwgbnVsbFxuICB0aGlzLl9kaXNwb3NlID0gb3B0aW9ucy5kaXNwb3NlXG4gIHRoaXMucmVzZXQoKVxufVxuXG4vLyByZXNpemUgdGhlIGNhY2hlIHdoZW4gdGhlIG1heCBjaGFuZ2VzLlxuT2JqZWN0LmRlZmluZVByb3BlcnR5KExSVUNhY2hlLnByb3RvdHlwZSwgXCJtYXhcIixcbiAgeyBzZXQgOiBmdW5jdGlvbiAobUwpIHtcbiAgICAgIGlmICghbUwgfHwgISh0eXBlb2YgbUwgPT09IFwibnVtYmVyXCIpIHx8IG1MIDw9IDAgKSBtTCA9IEluZmluaXR5XG4gICAgICB0aGlzLl9tYXggPSBtTFxuICAgICAgaWYgKHRoaXMuX2xlbmd0aCA+IHRoaXMuX21heCkgdHJpbSh0aGlzKVxuICAgIH1cbiAgLCBnZXQgOiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9tYXggfVxuICAsIGVudW1lcmFibGUgOiB0cnVlXG4gIH0pXG5cbi8vIHJlc2l6ZSB0aGUgY2FjaGUgd2hlbiB0aGUgbGVuZ3RoQ2FsY3VsYXRvciBjaGFuZ2VzLlxuT2JqZWN0LmRlZmluZVByb3BlcnR5KExSVUNhY2hlLnByb3RvdHlwZSwgXCJsZW5ndGhDYWxjdWxhdG9yXCIsXG4gIHsgc2V0IDogZnVuY3Rpb24gKGxDKSB7XG4gICAgICBpZiAodHlwZW9mIGxDICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhpcy5fbGVuZ3RoQ2FsY3VsYXRvciA9IG5haXZlTGVuZ3RoXG4gICAgICAgIHRoaXMuX2xlbmd0aCA9IHRoaXMuX2l0ZW1Db3VudFxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gdGhpcy5fY2FjaGUpIHtcbiAgICAgICAgICB0aGlzLl9jYWNoZVtrZXldLmxlbmd0aCA9IDFcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fbGVuZ3RoQ2FsY3VsYXRvciA9IGxDXG4gICAgICAgIHRoaXMuX2xlbmd0aCA9IDBcbiAgICAgICAgZm9yICh2YXIga2V5IGluIHRoaXMuX2NhY2hlKSB7XG4gICAgICAgICAgdGhpcy5fY2FjaGVba2V5XS5sZW5ndGggPSB0aGlzLl9sZW5ndGhDYWxjdWxhdG9yKHRoaXMuX2NhY2hlW2tleV0udmFsdWUpXG4gICAgICAgICAgdGhpcy5fbGVuZ3RoICs9IHRoaXMuX2NhY2hlW2tleV0ubGVuZ3RoXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX2xlbmd0aCA+IHRoaXMuX21heCkgdHJpbSh0aGlzKVxuICAgIH1cbiAgLCBnZXQgOiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLl9sZW5ndGhDYWxjdWxhdG9yIH1cbiAgLCBlbnVtZXJhYmxlIDogdHJ1ZVxuICB9KVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoTFJVQ2FjaGUucHJvdG90eXBlLCBcImxlbmd0aFwiLFxuICB7IGdldCA6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2xlbmd0aCB9XG4gICwgZW51bWVyYWJsZSA6IHRydWVcbiAgfSlcblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoTFJVQ2FjaGUucHJvdG90eXBlLCBcIml0ZW1Db3VudFwiLFxuICB7IGdldCA6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXMuX2l0ZW1Db3VudCB9XG4gICwgZW51bWVyYWJsZSA6IHRydWVcbiAgfSlcblxuTFJVQ2FjaGUucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiAoZm4sIHRoaXNwKSB7XG4gIHRoaXNwID0gdGhpc3AgfHwgdGhpc1xuICB2YXIgaSA9IDBcbiAgdmFyIGl0ZW1Db3VudCA9IHRoaXMuX2l0ZW1Db3VudFxuXG4gIGZvciAodmFyIGsgPSB0aGlzLl9tcnUgLSAxOyBrID49IDAgJiYgaSA8IGl0ZW1Db3VudDsgay0tKSBpZiAodGhpcy5fbHJ1TGlzdFtrXSkge1xuICAgIGkrK1xuICAgIHZhciBoaXQgPSB0aGlzLl9scnVMaXN0W2tdXG4gICAgaWYgKGlzU3RhbGUodGhpcywgaGl0KSkge1xuICAgICAgZGVsKHRoaXMsIGhpdClcbiAgICAgIGlmICghdGhpcy5fYWxsb3dTdGFsZSkgaGl0ID0gdW5kZWZpbmVkXG4gICAgfVxuICAgIGlmIChoaXQpIHtcbiAgICAgIGZuLmNhbGwodGhpc3AsIGhpdC52YWx1ZSwgaGl0LmtleSwgdGhpcylcbiAgICB9XG4gIH1cbn1cblxuTFJVQ2FjaGUucHJvdG90eXBlLmtleXMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBrZXlzID0gbmV3IEFycmF5KHRoaXMuX2l0ZW1Db3VudClcbiAgdmFyIGkgPSAwXG4gIGZvciAodmFyIGsgPSB0aGlzLl9tcnUgLSAxOyBrID49IDAgJiYgaSA8IHRoaXMuX2l0ZW1Db3VudDsgay0tKSBpZiAodGhpcy5fbHJ1TGlzdFtrXSkge1xuICAgIHZhciBoaXQgPSB0aGlzLl9scnVMaXN0W2tdXG4gICAga2V5c1tpKytdID0gaGl0LmtleVxuICB9XG4gIHJldHVybiBrZXlzXG59XG5cbkxSVUNhY2hlLnByb3RvdHlwZS52YWx1ZXMgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciB2YWx1ZXMgPSBuZXcgQXJyYXkodGhpcy5faXRlbUNvdW50KVxuICB2YXIgaSA9IDBcbiAgZm9yICh2YXIgayA9IHRoaXMuX21ydSAtIDE7IGsgPj0gMCAmJiBpIDwgdGhpcy5faXRlbUNvdW50OyBrLS0pIGlmICh0aGlzLl9scnVMaXN0W2tdKSB7XG4gICAgdmFyIGhpdCA9IHRoaXMuX2xydUxpc3Rba11cbiAgICB2YWx1ZXNbaSsrXSA9IGhpdC52YWx1ZVxuICB9XG4gIHJldHVybiB2YWx1ZXNcbn1cblxuTFJVQ2FjaGUucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICBpZiAodGhpcy5fZGlzcG9zZSAmJiB0aGlzLl9jYWNoZSkge1xuICAgIGZvciAodmFyIGsgaW4gdGhpcy5fY2FjaGUpIHtcbiAgICAgIHRoaXMuX2Rpc3Bvc2UoaywgdGhpcy5fY2FjaGVba10udmFsdWUpXG4gICAgfVxuICB9XG5cbiAgdGhpcy5fY2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpIC8vIGhhc2ggb2YgaXRlbXMgYnkga2V5XG4gIHRoaXMuX2xydUxpc3QgPSBPYmplY3QuY3JlYXRlKG51bGwpIC8vIGxpc3Qgb2YgaXRlbXMgaW4gb3JkZXIgb2YgdXNlIHJlY2VuY3lcbiAgdGhpcy5fbXJ1ID0gMCAvLyBtb3N0IHJlY2VudGx5IHVzZWRcbiAgdGhpcy5fbHJ1ID0gMCAvLyBsZWFzdCByZWNlbnRseSB1c2VkXG4gIHRoaXMuX2xlbmd0aCA9IDAgLy8gbnVtYmVyIG9mIGl0ZW1zIGluIHRoZSBsaXN0XG4gIHRoaXMuX2l0ZW1Db3VudCA9IDBcbn1cblxuTFJVQ2FjaGUucHJvdG90eXBlLmR1bXAgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBhcnIgPSBbXVxuICB2YXIgaSA9IDBcblxuICBmb3IgKHZhciBrID0gdGhpcy5fbXJ1IC0gMTsgayA+PSAwICYmIGkgPCB0aGlzLl9pdGVtQ291bnQ7IGstLSkgaWYgKHRoaXMuX2xydUxpc3Rba10pIHtcbiAgICB2YXIgaGl0ID0gdGhpcy5fbHJ1TGlzdFtrXVxuICAgIGlmICghaXNTdGFsZSh0aGlzLCBoaXQpKSB7XG4gICAgICAvL0RvIG5vdCBzdG9yZSBzdGFsZWQgaGl0c1xuICAgICAgKytpXG4gICAgICBhcnIucHVzaCh7XG4gICAgICAgIGs6IGhpdC5rZXksXG4gICAgICAgIHY6IGhpdC52YWx1ZSxcbiAgICAgICAgZTogaGl0Lm5vdyArIChoaXQubWF4QWdlIHx8IDApXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgLy9hcnIgaGFzIHRoZSBtb3N0IHJlYWQgZmlyc3RcbiAgcmV0dXJuIGFyclxufVxuXG5MUlVDYWNoZS5wcm90b3R5cGUuZHVtcExydSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX2xydUxpc3Rcbn1cblxuTFJVQ2FjaGUucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChrZXksIHZhbHVlLCBtYXhBZ2UpIHtcbiAgbWF4QWdlID0gbWF4QWdlIHx8IHRoaXMuX21heEFnZVxuICB0eXBlQ2hlY2tLZXkoa2V5KVxuXG4gIHZhciBub3cgPSBtYXhBZ2UgPyBEYXRlLm5vdygpIDogMFxuICB2YXIgbGVuID0gdGhpcy5fbGVuZ3RoQ2FsY3VsYXRvcih2YWx1ZSlcblxuICBpZiAoaE9QKHRoaXMuX2NhY2hlLCBrZXkpKSB7XG4gICAgaWYgKGxlbiA+IHRoaXMuX21heCkge1xuICAgICAgZGVsKHRoaXMsIHRoaXMuX2NhY2hlW2tleV0pXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgLy8gZGlzcG9zZSBvZiB0aGUgb2xkIG9uZSBiZWZvcmUgb3ZlcndyaXRpbmdcbiAgICBpZiAodGhpcy5fZGlzcG9zZSlcbiAgICAgIHRoaXMuX2Rpc3Bvc2Uoa2V5LCB0aGlzLl9jYWNoZVtrZXldLnZhbHVlKVxuXG4gICAgdGhpcy5fY2FjaGVba2V5XS5ub3cgPSBub3dcbiAgICB0aGlzLl9jYWNoZVtrZXldLm1heEFnZSA9IG1heEFnZVxuICAgIHRoaXMuX2NhY2hlW2tleV0udmFsdWUgPSB2YWx1ZVxuICAgIHRoaXMuX2xlbmd0aCArPSAobGVuIC0gdGhpcy5fY2FjaGVba2V5XS5sZW5ndGgpXG4gICAgdGhpcy5fY2FjaGVba2V5XS5sZW5ndGggPSBsZW5cbiAgICB0aGlzLmdldChrZXkpXG5cbiAgICBpZiAodGhpcy5fbGVuZ3RoID4gdGhpcy5fbWF4KVxuICAgICAgdHJpbSh0aGlzKVxuXG4gICAgcmV0dXJuIHRydWVcbiAgfVxuXG4gIHZhciBoaXQgPSBuZXcgRW50cnkoa2V5LCB2YWx1ZSwgdGhpcy5fbXJ1KyssIGxlbiwgbm93LCBtYXhBZ2UpXG5cbiAgLy8gb3ZlcnNpemVkIG9iamVjdHMgZmFsbCBvdXQgb2YgY2FjaGUgYXV0b21hdGljYWxseS5cbiAgaWYgKGhpdC5sZW5ndGggPiB0aGlzLl9tYXgpIHtcbiAgICBpZiAodGhpcy5fZGlzcG9zZSkgdGhpcy5fZGlzcG9zZShrZXksIHZhbHVlKVxuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgdGhpcy5fbGVuZ3RoICs9IGhpdC5sZW5ndGhcbiAgdGhpcy5fbHJ1TGlzdFtoaXQubHVdID0gdGhpcy5fY2FjaGVba2V5XSA9IGhpdFxuICB0aGlzLl9pdGVtQ291bnQgKytcblxuICBpZiAodGhpcy5fbGVuZ3RoID4gdGhpcy5fbWF4KVxuICAgIHRyaW0odGhpcylcblxuICByZXR1cm4gdHJ1ZVxufVxuXG5MUlVDYWNoZS5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24gKGtleSkge1xuICB0eXBlQ2hlY2tLZXkoa2V5KVxuICBpZiAoIWhPUCh0aGlzLl9jYWNoZSwga2V5KSkgcmV0dXJuIGZhbHNlXG4gIHZhciBoaXQgPSB0aGlzLl9jYWNoZVtrZXldXG4gIGlmIChpc1N0YWxlKHRoaXMsIGhpdCkpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICByZXR1cm4gdHJ1ZVxufVxuXG5MUlVDYWNoZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGtleSkge1xuICB0eXBlQ2hlY2tLZXkoa2V5KVxuICByZXR1cm4gZ2V0KHRoaXMsIGtleSwgdHJ1ZSlcbn1cblxuTFJVQ2FjaGUucHJvdG90eXBlLnBlZWsgPSBmdW5jdGlvbiAoa2V5KSB7XG4gIHR5cGVDaGVja0tleShrZXkpXG4gIHJldHVybiBnZXQodGhpcywga2V5LCBmYWxzZSlcbn1cblxuTFJVQ2FjaGUucHJvdG90eXBlLnBvcCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGhpdCA9IHRoaXMuX2xydUxpc3RbdGhpcy5fbHJ1XVxuICBkZWwodGhpcywgaGl0KVxuICByZXR1cm4gaGl0IHx8IG51bGxcbn1cblxuTFJVQ2FjaGUucHJvdG90eXBlLmRlbCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgdHlwZUNoZWNrS2V5KGtleSlcbiAgZGVsKHRoaXMsIHRoaXMuX2NhY2hlW2tleV0pXG59XG5cbkxSVUNhY2hlLnByb3RvdHlwZS5sb2FkID0gZnVuY3Rpb24gKGFycikge1xuICAvL3Jlc2V0IHRoZSBjYWNoZVxuICB0aGlzLnJlc2V0KCk7XG5cbiAgdmFyIG5vdyA9IERhdGUubm93KClcbiAgLy9BIHByZXZpb3VzIHNlcmlhbGl6ZWQgY2FjaGUgaGFzIHRoZSBtb3N0IHJlY2VudCBpdGVtcyBmaXJzdFxuICBmb3IgKHZhciBsID0gYXJyLmxlbmd0aCAtIDE7IGwgPj0gMDsgbC0tICkge1xuICAgIHZhciBoaXQgPSBhcnJbbF1cbiAgICB0eXBlQ2hlY2tLZXkoaGl0LmspXG4gICAgdmFyIGV4cGlyZXNBdCA9IGhpdC5lIHx8IDBcbiAgICBpZiAoZXhwaXJlc0F0ID09PSAwKSB7XG4gICAgICAvL3RoZSBpdGVtIHdhcyBjcmVhdGVkIHdpdGhvdXQgZXhwaXJhdGlvbiBpbiBhIG5vbiBhZ2VkIGNhY2hlXG4gICAgICB0aGlzLnNldChoaXQuaywgaGl0LnYpXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBtYXhBZ2UgPSBleHBpcmVzQXQgLSBub3dcbiAgICAgIC8vZG9udCBhZGQgYWxyZWFkeSBleHBpcmVkIGl0ZW1zXG4gICAgICBpZiAobWF4QWdlID4gMCkgdGhpcy5zZXQoaGl0LmssIGhpdC52LCBtYXhBZ2UpXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldCAoc2VsZiwga2V5LCBkb1VzZSkge1xuICB0eXBlQ2hlY2tLZXkoa2V5KVxuICB2YXIgaGl0ID0gc2VsZi5fY2FjaGVba2V5XVxuICBpZiAoaGl0KSB7XG4gICAgaWYgKGlzU3RhbGUoc2VsZiwgaGl0KSkge1xuICAgICAgZGVsKHNlbGYsIGhpdClcbiAgICAgIGlmICghc2VsZi5fYWxsb3dTdGFsZSkgaGl0ID0gdW5kZWZpbmVkXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChkb1VzZSkgdXNlKHNlbGYsIGhpdClcbiAgICB9XG4gICAgaWYgKGhpdCkgaGl0ID0gaGl0LnZhbHVlXG4gIH1cbiAgcmV0dXJuIGhpdFxufVxuXG5mdW5jdGlvbiBpc1N0YWxlKHNlbGYsIGhpdCkge1xuICBpZiAoIWhpdCB8fCAoIWhpdC5tYXhBZ2UgJiYgIXNlbGYuX21heEFnZSkpIHJldHVybiBmYWxzZVxuICB2YXIgc3RhbGUgPSBmYWxzZTtcbiAgdmFyIGRpZmYgPSBEYXRlLm5vdygpIC0gaGl0Lm5vd1xuICBpZiAoaGl0Lm1heEFnZSkge1xuICAgIHN0YWxlID0gZGlmZiA+IGhpdC5tYXhBZ2VcbiAgfSBlbHNlIHtcbiAgICBzdGFsZSA9IHNlbGYuX21heEFnZSAmJiAoZGlmZiA+IHNlbGYuX21heEFnZSlcbiAgfVxuICByZXR1cm4gc3RhbGU7XG59XG5cbmZ1bmN0aW9uIHVzZSAoc2VsZiwgaGl0KSB7XG4gIHNoaWZ0TFUoc2VsZiwgaGl0KVxuICBoaXQubHUgPSBzZWxmLl9tcnUgKytcbiAgc2VsZi5fbHJ1TGlzdFtoaXQubHVdID0gaGl0XG59XG5cbmZ1bmN0aW9uIHRyaW0gKHNlbGYpIHtcbiAgd2hpbGUgKHNlbGYuX2xydSA8IHNlbGYuX21ydSAmJiBzZWxmLl9sZW5ndGggPiBzZWxmLl9tYXgpXG4gICAgZGVsKHNlbGYsIHNlbGYuX2xydUxpc3Rbc2VsZi5fbHJ1XSlcbn1cblxuZnVuY3Rpb24gc2hpZnRMVSAoc2VsZiwgaGl0KSB7XG4gIGRlbGV0ZSBzZWxmLl9scnVMaXN0WyBoaXQubHUgXVxuICB3aGlsZSAoc2VsZi5fbHJ1IDwgc2VsZi5fbXJ1ICYmICFzZWxmLl9scnVMaXN0W3NlbGYuX2xydV0pIHNlbGYuX2xydSArK1xufVxuXG5mdW5jdGlvbiBkZWwgKHNlbGYsIGhpdCkge1xuICBpZiAoaGl0KSB7XG4gICAgaWYgKHNlbGYuX2Rpc3Bvc2UpIHNlbGYuX2Rpc3Bvc2UoaGl0LmtleSwgaGl0LnZhbHVlKVxuICAgIHNlbGYuX2xlbmd0aCAtPSBoaXQubGVuZ3RoXG4gICAgc2VsZi5faXRlbUNvdW50IC0tXG4gICAgZGVsZXRlIHNlbGYuX2NhY2hlWyBoaXQua2V5IF1cbiAgICBzaGlmdExVKHNlbGYsIGhpdClcbiAgfVxufVxuXG4vLyBjbGFzc3ksIHNpbmNlIFY4IHByZWZlcnMgcHJlZGljdGFibGUgb2JqZWN0cy5cbmZ1bmN0aW9uIEVudHJ5IChrZXksIHZhbHVlLCBsdSwgbGVuZ3RoLCBub3csIG1heEFnZSkge1xuICB0aGlzLmtleSA9IGtleVxuICB0aGlzLnZhbHVlID0gdmFsdWVcbiAgdGhpcy5sdSA9IGx1XG4gIHRoaXMubGVuZ3RoID0gbGVuZ3RoXG4gIHRoaXMubm93ID0gbm93XG4gIGlmIChtYXhBZ2UpIHRoaXMubWF4QWdlID0gbWF4QWdlXG59XG5cbn0pKClcbiIsIi8qIVxuICogbXVzdGFjaGUuanMgLSBMb2dpYy1sZXNzIHt7bXVzdGFjaGV9fSB0ZW1wbGF0ZXMgd2l0aCBKYXZhU2NyaXB0XG4gKiBodHRwOi8vZ2l0aHViLmNvbS9qYW5sL211c3RhY2hlLmpzXG4gKi9cblxuLypnbG9iYWwgZGVmaW5lOiBmYWxzZSBNdXN0YWNoZTogdHJ1ZSovXG5cbihmdW5jdGlvbiBkZWZpbmVNdXN0YWNoZSAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gIGlmICh0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiB0eXBlb2YgZXhwb3J0cy5ub2RlTmFtZSAhPT0gJ3N0cmluZycpIHtcbiAgICBmYWN0b3J5KGV4cG9ydHMpOyAvLyBDb21tb25KU1xuICB9IGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgIGRlZmluZShbJ2V4cG9ydHMnXSwgZmFjdG9yeSk7IC8vIEFNRFxuICB9IGVsc2Uge1xuICAgIGdsb2JhbC5NdXN0YWNoZSA9IHt9O1xuICAgIGZhY3RvcnkoTXVzdGFjaGUpOyAvLyBzY3JpcHQsIHdzaCwgYXNwXG4gIH1cbn0odGhpcywgZnVuY3Rpb24gbXVzdGFjaGVGYWN0b3J5IChtdXN0YWNoZSkge1xuXG4gIHZhciBvYmplY3RUb1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG4gIHZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiBpc0FycmF5UG9seWZpbGwgKG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3RUb1N0cmluZy5jYWxsKG9iamVjdCkgPT09ICdbb2JqZWN0IEFycmF5XSc7XG4gIH07XG5cbiAgZnVuY3Rpb24gaXNGdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdmdW5jdGlvbic7XG4gIH1cblxuICAvKipcbiAgICogTW9yZSBjb3JyZWN0IHR5cGVvZiBzdHJpbmcgaGFuZGxpbmcgYXJyYXlcbiAgICogd2hpY2ggbm9ybWFsbHkgcmV0dXJucyB0eXBlb2YgJ29iamVjdCdcbiAgICovXG4gIGZ1bmN0aW9uIHR5cGVTdHIgKG9iaikge1xuICAgIHJldHVybiBpc0FycmF5KG9iaikgPyAnYXJyYXknIDogdHlwZW9mIG9iajtcbiAgfVxuXG4gIGZ1bmN0aW9uIGVzY2FwZVJlZ0V4cCAoc3RyaW5nKSB7XG4gICAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKC9bXFwtXFxbXFxde30oKSorPy4sXFxcXFxcXiR8I1xcc10vZywgJ1xcXFwkJicpO1xuICB9XG5cbiAgLyoqXG4gICAqIE51bGwgc2FmZSB3YXkgb2YgY2hlY2tpbmcgd2hldGhlciBvciBub3QgYW4gb2JqZWN0LFxuICAgKiBpbmNsdWRpbmcgaXRzIHByb3RvdHlwZSwgaGFzIGEgZ2l2ZW4gcHJvcGVydHlcbiAgICovXG4gIGZ1bmN0aW9uIGhhc1Byb3BlcnR5IChvYmosIHByb3BOYW1lKSB7XG4gICAgcmV0dXJuIG9iaiAhPSBudWxsICYmIHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmIChwcm9wTmFtZSBpbiBvYmopO1xuICB9XG5cbiAgLy8gV29ya2Fyb3VuZCBmb3IgaHR0cHM6Ly9pc3N1ZXMuYXBhY2hlLm9yZy9qaXJhL2Jyb3dzZS9DT1VDSERCLTU3N1xuICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2phbmwvbXVzdGFjaGUuanMvaXNzdWVzLzE4OVxuICB2YXIgcmVnRXhwVGVzdCA9IFJlZ0V4cC5wcm90b3R5cGUudGVzdDtcbiAgZnVuY3Rpb24gdGVzdFJlZ0V4cCAocmUsIHN0cmluZykge1xuICAgIHJldHVybiByZWdFeHBUZXN0LmNhbGwocmUsIHN0cmluZyk7XG4gIH1cblxuICB2YXIgbm9uU3BhY2VSZSA9IC9cXFMvO1xuICBmdW5jdGlvbiBpc1doaXRlc3BhY2UgKHN0cmluZykge1xuICAgIHJldHVybiAhdGVzdFJlZ0V4cChub25TcGFjZVJlLCBzdHJpbmcpO1xuICB9XG5cbiAgdmFyIGVudGl0eU1hcCA9IHtcbiAgICAnJic6ICcmYW1wOycsXG4gICAgJzwnOiAnJmx0OycsXG4gICAgJz4nOiAnJmd0OycsXG4gICAgJ1wiJzogJyZxdW90OycsXG4gICAgXCInXCI6ICcmIzM5OycsXG4gICAgJy8nOiAnJiN4MkY7J1xuICB9O1xuXG4gIGZ1bmN0aW9uIGVzY2FwZUh0bWwgKHN0cmluZykge1xuICAgIHJldHVybiBTdHJpbmcoc3RyaW5nKS5yZXBsYWNlKC9bJjw+XCInXFwvXS9nLCBmdW5jdGlvbiBmcm9tRW50aXR5TWFwIChzKSB7XG4gICAgICByZXR1cm4gZW50aXR5TWFwW3NdO1xuICAgIH0pO1xuICB9XG5cbiAgdmFyIHdoaXRlUmUgPSAvXFxzKi87XG4gIHZhciBzcGFjZVJlID0gL1xccysvO1xuICB2YXIgZXF1YWxzUmUgPSAvXFxzKj0vO1xuICB2YXIgY3VybHlSZSA9IC9cXHMqXFx9LztcbiAgdmFyIHRhZ1JlID0gLyN8XFxefFxcL3w+fFxce3wmfD18IS87XG5cbiAgLyoqXG4gICAqIEJyZWFrcyB1cCB0aGUgZ2l2ZW4gYHRlbXBsYXRlYCBzdHJpbmcgaW50byBhIHRyZWUgb2YgdG9rZW5zLiBJZiB0aGUgYHRhZ3NgXG4gICAqIGFyZ3VtZW50IGlzIGdpdmVuIGhlcmUgaXQgbXVzdCBiZSBhbiBhcnJheSB3aXRoIHR3byBzdHJpbmcgdmFsdWVzOiB0aGVcbiAgICogb3BlbmluZyBhbmQgY2xvc2luZyB0YWdzIHVzZWQgaW4gdGhlIHRlbXBsYXRlIChlLmcuIFsgXCI8JVwiLCBcIiU+XCIgXSkuIE9mXG4gICAqIGNvdXJzZSwgdGhlIGRlZmF1bHQgaXMgdG8gdXNlIG11c3RhY2hlcyAoaS5lLiBtdXN0YWNoZS50YWdzKS5cbiAgICpcbiAgICogQSB0b2tlbiBpcyBhbiBhcnJheSB3aXRoIGF0IGxlYXN0IDQgZWxlbWVudHMuIFRoZSBmaXJzdCBlbGVtZW50IGlzIHRoZVxuICAgKiBtdXN0YWNoZSBzeW1ib2wgdGhhdCB3YXMgdXNlZCBpbnNpZGUgdGhlIHRhZywgZS5nLiBcIiNcIiBvciBcIiZcIi4gSWYgdGhlIHRhZ1xuICAgKiBkaWQgbm90IGNvbnRhaW4gYSBzeW1ib2wgKGkuZS4ge3tteVZhbHVlfX0pIHRoaXMgZWxlbWVudCBpcyBcIm5hbWVcIi4gRm9yXG4gICAqIGFsbCB0ZXh0IHRoYXQgYXBwZWFycyBvdXRzaWRlIGEgc3ltYm9sIHRoaXMgZWxlbWVudCBpcyBcInRleHRcIi5cbiAgICpcbiAgICogVGhlIHNlY29uZCBlbGVtZW50IG9mIGEgdG9rZW4gaXMgaXRzIFwidmFsdWVcIi4gRm9yIG11c3RhY2hlIHRhZ3MgdGhpcyBpc1xuICAgKiB3aGF0ZXZlciBlbHNlIHdhcyBpbnNpZGUgdGhlIHRhZyBiZXNpZGVzIHRoZSBvcGVuaW5nIHN5bWJvbC4gRm9yIHRleHQgdG9rZW5zXG4gICAqIHRoaXMgaXMgdGhlIHRleHQgaXRzZWxmLlxuICAgKlxuICAgKiBUaGUgdGhpcmQgYW5kIGZvdXJ0aCBlbGVtZW50cyBvZiB0aGUgdG9rZW4gYXJlIHRoZSBzdGFydCBhbmQgZW5kIGluZGljZXMsXG4gICAqIHJlc3BlY3RpdmVseSwgb2YgdGhlIHRva2VuIGluIHRoZSBvcmlnaW5hbCB0ZW1wbGF0ZS5cbiAgICpcbiAgICogVG9rZW5zIHRoYXQgYXJlIHRoZSByb290IG5vZGUgb2YgYSBzdWJ0cmVlIGNvbnRhaW4gdHdvIG1vcmUgZWxlbWVudHM6IDEpIGFuXG4gICAqIGFycmF5IG9mIHRva2VucyBpbiB0aGUgc3VidHJlZSBhbmQgMikgdGhlIGluZGV4IGluIHRoZSBvcmlnaW5hbCB0ZW1wbGF0ZSBhdFxuICAgKiB3aGljaCB0aGUgY2xvc2luZyB0YWcgZm9yIHRoYXQgc2VjdGlvbiBiZWdpbnMuXG4gICAqL1xuICBmdW5jdGlvbiBwYXJzZVRlbXBsYXRlICh0ZW1wbGF0ZSwgdGFncykge1xuICAgIGlmICghdGVtcGxhdGUpXG4gICAgICByZXR1cm4gW107XG5cbiAgICB2YXIgc2VjdGlvbnMgPSBbXTsgICAgIC8vIFN0YWNrIHRvIGhvbGQgc2VjdGlvbiB0b2tlbnNcbiAgICB2YXIgdG9rZW5zID0gW107ICAgICAgIC8vIEJ1ZmZlciB0byBob2xkIHRoZSB0b2tlbnNcbiAgICB2YXIgc3BhY2VzID0gW107ICAgICAgIC8vIEluZGljZXMgb2Ygd2hpdGVzcGFjZSB0b2tlbnMgb24gdGhlIGN1cnJlbnQgbGluZVxuICAgIHZhciBoYXNUYWcgPSBmYWxzZTsgICAgLy8gSXMgdGhlcmUgYSB7e3RhZ319IG9uIHRoZSBjdXJyZW50IGxpbmU/XG4gICAgdmFyIG5vblNwYWNlID0gZmFsc2U7ICAvLyBJcyB0aGVyZSBhIG5vbi1zcGFjZSBjaGFyIG9uIHRoZSBjdXJyZW50IGxpbmU/XG5cbiAgICAvLyBTdHJpcHMgYWxsIHdoaXRlc3BhY2UgdG9rZW5zIGFycmF5IGZvciB0aGUgY3VycmVudCBsaW5lXG4gICAgLy8gaWYgdGhlcmUgd2FzIGEge3sjdGFnfX0gb24gaXQgYW5kIG90aGVyd2lzZSBvbmx5IHNwYWNlLlxuICAgIGZ1bmN0aW9uIHN0cmlwU3BhY2UgKCkge1xuICAgICAgaWYgKGhhc1RhZyAmJiAhbm9uU3BhY2UpIHtcbiAgICAgICAgd2hpbGUgKHNwYWNlcy5sZW5ndGgpXG4gICAgICAgICAgZGVsZXRlIHRva2Vuc1tzcGFjZXMucG9wKCldO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3BhY2VzID0gW107XG4gICAgICB9XG5cbiAgICAgIGhhc1RhZyA9IGZhbHNlO1xuICAgICAgbm9uU3BhY2UgPSBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgb3BlbmluZ1RhZ1JlLCBjbG9zaW5nVGFnUmUsIGNsb3NpbmdDdXJseVJlO1xuICAgIGZ1bmN0aW9uIGNvbXBpbGVUYWdzICh0YWdzVG9Db21waWxlKSB7XG4gICAgICBpZiAodHlwZW9mIHRhZ3NUb0NvbXBpbGUgPT09ICdzdHJpbmcnKVxuICAgICAgICB0YWdzVG9Db21waWxlID0gdGFnc1RvQ29tcGlsZS5zcGxpdChzcGFjZVJlLCAyKTtcblxuICAgICAgaWYgKCFpc0FycmF5KHRhZ3NUb0NvbXBpbGUpIHx8IHRhZ3NUb0NvbXBpbGUubGVuZ3RoICE9PSAyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdGFnczogJyArIHRhZ3NUb0NvbXBpbGUpO1xuXG4gICAgICBvcGVuaW5nVGFnUmUgPSBuZXcgUmVnRXhwKGVzY2FwZVJlZ0V4cCh0YWdzVG9Db21waWxlWzBdKSArICdcXFxccyonKTtcbiAgICAgIGNsb3NpbmdUYWdSZSA9IG5ldyBSZWdFeHAoJ1xcXFxzKicgKyBlc2NhcGVSZWdFeHAodGFnc1RvQ29tcGlsZVsxXSkpO1xuICAgICAgY2xvc2luZ0N1cmx5UmUgPSBuZXcgUmVnRXhwKCdcXFxccyonICsgZXNjYXBlUmVnRXhwKCd9JyArIHRhZ3NUb0NvbXBpbGVbMV0pKTtcbiAgICB9XG5cbiAgICBjb21waWxlVGFncyh0YWdzIHx8IG11c3RhY2hlLnRhZ3MpO1xuXG4gICAgdmFyIHNjYW5uZXIgPSBuZXcgU2Nhbm5lcih0ZW1wbGF0ZSk7XG5cbiAgICB2YXIgc3RhcnQsIHR5cGUsIHZhbHVlLCBjaHIsIHRva2VuLCBvcGVuU2VjdGlvbjtcbiAgICB3aGlsZSAoIXNjYW5uZXIuZW9zKCkpIHtcbiAgICAgIHN0YXJ0ID0gc2Nhbm5lci5wb3M7XG5cbiAgICAgIC8vIE1hdGNoIGFueSB0ZXh0IGJldHdlZW4gdGFncy5cbiAgICAgIHZhbHVlID0gc2Nhbm5lci5zY2FuVW50aWwob3BlbmluZ1RhZ1JlKTtcblxuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwLCB2YWx1ZUxlbmd0aCA9IHZhbHVlLmxlbmd0aDsgaSA8IHZhbHVlTGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBjaHIgPSB2YWx1ZS5jaGFyQXQoaSk7XG5cbiAgICAgICAgICBpZiAoaXNXaGl0ZXNwYWNlKGNocikpIHtcbiAgICAgICAgICAgIHNwYWNlcy5wdXNoKHRva2Vucy5sZW5ndGgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBub25TcGFjZSA9IHRydWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdG9rZW5zLnB1c2goWyAndGV4dCcsIGNociwgc3RhcnQsIHN0YXJ0ICsgMSBdKTtcbiAgICAgICAgICBzdGFydCArPSAxO1xuXG4gICAgICAgICAgLy8gQ2hlY2sgZm9yIHdoaXRlc3BhY2Ugb24gdGhlIGN1cnJlbnQgbGluZS5cbiAgICAgICAgICBpZiAoY2hyID09PSAnXFxuJylcbiAgICAgICAgICAgIHN0cmlwU3BhY2UoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBNYXRjaCB0aGUgb3BlbmluZyB0YWcuXG4gICAgICBpZiAoIXNjYW5uZXIuc2NhbihvcGVuaW5nVGFnUmUpKVxuICAgICAgICBicmVhaztcblxuICAgICAgaGFzVGFnID0gdHJ1ZTtcblxuICAgICAgLy8gR2V0IHRoZSB0YWcgdHlwZS5cbiAgICAgIHR5cGUgPSBzY2FubmVyLnNjYW4odGFnUmUpIHx8ICduYW1lJztcbiAgICAgIHNjYW5uZXIuc2Nhbih3aGl0ZVJlKTtcblxuICAgICAgLy8gR2V0IHRoZSB0YWcgdmFsdWUuXG4gICAgICBpZiAodHlwZSA9PT0gJz0nKSB7XG4gICAgICAgIHZhbHVlID0gc2Nhbm5lci5zY2FuVW50aWwoZXF1YWxzUmUpO1xuICAgICAgICBzY2FubmVyLnNjYW4oZXF1YWxzUmUpO1xuICAgICAgICBzY2FubmVyLnNjYW5VbnRpbChjbG9zaW5nVGFnUmUpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAneycpIHtcbiAgICAgICAgdmFsdWUgPSBzY2FubmVyLnNjYW5VbnRpbChjbG9zaW5nQ3VybHlSZSk7XG4gICAgICAgIHNjYW5uZXIuc2NhbihjdXJseVJlKTtcbiAgICAgICAgc2Nhbm5lci5zY2FuVW50aWwoY2xvc2luZ1RhZ1JlKTtcbiAgICAgICAgdHlwZSA9ICcmJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbHVlID0gc2Nhbm5lci5zY2FuVW50aWwoY2xvc2luZ1RhZ1JlKTtcbiAgICAgIH1cblxuICAgICAgLy8gTWF0Y2ggdGhlIGNsb3NpbmcgdGFnLlxuICAgICAgaWYgKCFzY2FubmVyLnNjYW4oY2xvc2luZ1RhZ1JlKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmNsb3NlZCB0YWcgYXQgJyArIHNjYW5uZXIucG9zKTtcblxuICAgICAgdG9rZW4gPSBbIHR5cGUsIHZhbHVlLCBzdGFydCwgc2Nhbm5lci5wb3MgXTtcbiAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcblxuICAgICAgaWYgKHR5cGUgPT09ICcjJyB8fCB0eXBlID09PSAnXicpIHtcbiAgICAgICAgc2VjdGlvbnMucHVzaCh0b2tlbik7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICcvJykge1xuICAgICAgICAvLyBDaGVjayBzZWN0aW9uIG5lc3RpbmcuXG4gICAgICAgIG9wZW5TZWN0aW9uID0gc2VjdGlvbnMucG9wKCk7XG5cbiAgICAgICAgaWYgKCFvcGVuU2VjdGlvbilcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vub3BlbmVkIHNlY3Rpb24gXCInICsgdmFsdWUgKyAnXCIgYXQgJyArIHN0YXJ0KTtcblxuICAgICAgICBpZiAob3BlblNlY3Rpb25bMV0gIT09IHZhbHVlKVxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5jbG9zZWQgc2VjdGlvbiBcIicgKyBvcGVuU2VjdGlvblsxXSArICdcIiBhdCAnICsgc3RhcnQpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnbmFtZScgfHwgdHlwZSA9PT0gJ3snIHx8IHR5cGUgPT09ICcmJykge1xuICAgICAgICBub25TcGFjZSA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICc9Jykge1xuICAgICAgICAvLyBTZXQgdGhlIHRhZ3MgZm9yIHRoZSBuZXh0IHRpbWUgYXJvdW5kLlxuICAgICAgICBjb21waWxlVGFncyh2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gTWFrZSBzdXJlIHRoZXJlIGFyZSBubyBvcGVuIHNlY3Rpb25zIHdoZW4gd2UncmUgZG9uZS5cbiAgICBvcGVuU2VjdGlvbiA9IHNlY3Rpb25zLnBvcCgpO1xuXG4gICAgaWYgKG9wZW5TZWN0aW9uKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmNsb3NlZCBzZWN0aW9uIFwiJyArIG9wZW5TZWN0aW9uWzFdICsgJ1wiIGF0ICcgKyBzY2FubmVyLnBvcyk7XG5cbiAgICByZXR1cm4gbmVzdFRva2VucyhzcXVhc2hUb2tlbnModG9rZW5zKSk7XG4gIH1cblxuICAvKipcbiAgICogQ29tYmluZXMgdGhlIHZhbHVlcyBvZiBjb25zZWN1dGl2ZSB0ZXh0IHRva2VucyBpbiB0aGUgZ2l2ZW4gYHRva2Vuc2AgYXJyYXlcbiAgICogdG8gYSBzaW5nbGUgdG9rZW4uXG4gICAqL1xuICBmdW5jdGlvbiBzcXVhc2hUb2tlbnMgKHRva2Vucykge1xuICAgIHZhciBzcXVhc2hlZFRva2VucyA9IFtdO1xuXG4gICAgdmFyIHRva2VuLCBsYXN0VG9rZW47XG4gICAgZm9yICh2YXIgaSA9IDAsIG51bVRva2VucyA9IHRva2Vucy5sZW5ndGg7IGkgPCBudW1Ub2tlbnM7ICsraSkge1xuICAgICAgdG9rZW4gPSB0b2tlbnNbaV07XG5cbiAgICAgIGlmICh0b2tlbikge1xuICAgICAgICBpZiAodG9rZW5bMF0gPT09ICd0ZXh0JyAmJiBsYXN0VG9rZW4gJiYgbGFzdFRva2VuWzBdID09PSAndGV4dCcpIHtcbiAgICAgICAgICBsYXN0VG9rZW5bMV0gKz0gdG9rZW5bMV07XG4gICAgICAgICAgbGFzdFRva2VuWzNdID0gdG9rZW5bM107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3F1YXNoZWRUb2tlbnMucHVzaCh0b2tlbik7XG4gICAgICAgICAgbGFzdFRva2VuID0gdG9rZW47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc3F1YXNoZWRUb2tlbnM7XG4gIH1cblxuICAvKipcbiAgICogRm9ybXMgdGhlIGdpdmVuIGFycmF5IG9mIGB0b2tlbnNgIGludG8gYSBuZXN0ZWQgdHJlZSBzdHJ1Y3R1cmUgd2hlcmVcbiAgICogdG9rZW5zIHRoYXQgcmVwcmVzZW50IGEgc2VjdGlvbiBoYXZlIHR3byBhZGRpdGlvbmFsIGl0ZW1zOiAxKSBhbiBhcnJheSBvZlxuICAgKiBhbGwgdG9rZW5zIHRoYXQgYXBwZWFyIGluIHRoYXQgc2VjdGlvbiBhbmQgMikgdGhlIGluZGV4IGluIHRoZSBvcmlnaW5hbFxuICAgKiB0ZW1wbGF0ZSB0aGF0IHJlcHJlc2VudHMgdGhlIGVuZCBvZiB0aGF0IHNlY3Rpb24uXG4gICAqL1xuICBmdW5jdGlvbiBuZXN0VG9rZW5zICh0b2tlbnMpIHtcbiAgICB2YXIgbmVzdGVkVG9rZW5zID0gW107XG4gICAgdmFyIGNvbGxlY3RvciA9IG5lc3RlZFRva2VucztcbiAgICB2YXIgc2VjdGlvbnMgPSBbXTtcblxuICAgIHZhciB0b2tlbiwgc2VjdGlvbjtcbiAgICBmb3IgKHZhciBpID0gMCwgbnVtVG9rZW5zID0gdG9rZW5zLmxlbmd0aDsgaSA8IG51bVRva2VuczsgKytpKSB7XG4gICAgICB0b2tlbiA9IHRva2Vuc1tpXTtcblxuICAgICAgc3dpdGNoICh0b2tlblswXSkge1xuICAgICAgY2FzZSAnIyc6XG4gICAgICBjYXNlICdeJzpcbiAgICAgICAgY29sbGVjdG9yLnB1c2godG9rZW4pO1xuICAgICAgICBzZWN0aW9ucy5wdXNoKHRva2VuKTtcbiAgICAgICAgY29sbGVjdG9yID0gdG9rZW5bNF0gPSBbXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICcvJzpcbiAgICAgICAgc2VjdGlvbiA9IHNlY3Rpb25zLnBvcCgpO1xuICAgICAgICBzZWN0aW9uWzVdID0gdG9rZW5bMl07XG4gICAgICAgIGNvbGxlY3RvciA9IHNlY3Rpb25zLmxlbmd0aCA+IDAgPyBzZWN0aW9uc1tzZWN0aW9ucy5sZW5ndGggLSAxXVs0XSA6IG5lc3RlZFRva2VucztcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBjb2xsZWN0b3IucHVzaCh0b2tlbik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5lc3RlZFRva2VucztcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHNpbXBsZSBzdHJpbmcgc2Nhbm5lciB0aGF0IGlzIHVzZWQgYnkgdGhlIHRlbXBsYXRlIHBhcnNlciB0byBmaW5kXG4gICAqIHRva2VucyBpbiB0ZW1wbGF0ZSBzdHJpbmdzLlxuICAgKi9cbiAgZnVuY3Rpb24gU2Nhbm5lciAoc3RyaW5nKSB7XG4gICAgdGhpcy5zdHJpbmcgPSBzdHJpbmc7XG4gICAgdGhpcy50YWlsID0gc3RyaW5nO1xuICAgIHRoaXMucG9zID0gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdGFpbCBpcyBlbXB0eSAoZW5kIG9mIHN0cmluZykuXG4gICAqL1xuICBTY2FubmVyLnByb3RvdHlwZS5lb3MgPSBmdW5jdGlvbiBlb3MgKCkge1xuICAgIHJldHVybiB0aGlzLnRhaWwgPT09ICcnO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUcmllcyB0byBtYXRjaCB0aGUgZ2l2ZW4gcmVndWxhciBleHByZXNzaW9uIGF0IHRoZSBjdXJyZW50IHBvc2l0aW9uLlxuICAgKiBSZXR1cm5zIHRoZSBtYXRjaGVkIHRleHQgaWYgaXQgY2FuIG1hdGNoLCB0aGUgZW1wdHkgc3RyaW5nIG90aGVyd2lzZS5cbiAgICovXG4gIFNjYW5uZXIucHJvdG90eXBlLnNjYW4gPSBmdW5jdGlvbiBzY2FuIChyZSkge1xuICAgIHZhciBtYXRjaCA9IHRoaXMudGFpbC5tYXRjaChyZSk7XG5cbiAgICBpZiAoIW1hdGNoIHx8IG1hdGNoLmluZGV4ICE9PSAwKVxuICAgICAgcmV0dXJuICcnO1xuXG4gICAgdmFyIHN0cmluZyA9IG1hdGNoWzBdO1xuXG4gICAgdGhpcy50YWlsID0gdGhpcy50YWlsLnN1YnN0cmluZyhzdHJpbmcubGVuZ3RoKTtcbiAgICB0aGlzLnBvcyArPSBzdHJpbmcubGVuZ3RoO1xuXG4gICAgcmV0dXJuIHN0cmluZztcbiAgfTtcblxuICAvKipcbiAgICogU2tpcHMgYWxsIHRleHQgdW50aWwgdGhlIGdpdmVuIHJlZ3VsYXIgZXhwcmVzc2lvbiBjYW4gYmUgbWF0Y2hlZC4gUmV0dXJuc1xuICAgKiB0aGUgc2tpcHBlZCBzdHJpbmcsIHdoaWNoIGlzIHRoZSBlbnRpcmUgdGFpbCBpZiBubyBtYXRjaCBjYW4gYmUgbWFkZS5cbiAgICovXG4gIFNjYW5uZXIucHJvdG90eXBlLnNjYW5VbnRpbCA9IGZ1bmN0aW9uIHNjYW5VbnRpbCAocmUpIHtcbiAgICB2YXIgaW5kZXggPSB0aGlzLnRhaWwuc2VhcmNoKHJlKSwgbWF0Y2g7XG5cbiAgICBzd2l0Y2ggKGluZGV4KSB7XG4gICAgY2FzZSAtMTpcbiAgICAgIG1hdGNoID0gdGhpcy50YWlsO1xuICAgICAgdGhpcy50YWlsID0gJyc7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDA6XG4gICAgICBtYXRjaCA9ICcnO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIG1hdGNoID0gdGhpcy50YWlsLnN1YnN0cmluZygwLCBpbmRleCk7XG4gICAgICB0aGlzLnRhaWwgPSB0aGlzLnRhaWwuc3Vic3RyaW5nKGluZGV4KTtcbiAgICB9XG5cbiAgICB0aGlzLnBvcyArPSBtYXRjaC5sZW5ndGg7XG5cbiAgICByZXR1cm4gbWF0Y2g7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJlcHJlc2VudHMgYSByZW5kZXJpbmcgY29udGV4dCBieSB3cmFwcGluZyBhIHZpZXcgb2JqZWN0IGFuZFxuICAgKiBtYWludGFpbmluZyBhIHJlZmVyZW5jZSB0byB0aGUgcGFyZW50IGNvbnRleHQuXG4gICAqL1xuICBmdW5jdGlvbiBDb250ZXh0ICh2aWV3LCBwYXJlbnRDb250ZXh0KSB7XG4gICAgdGhpcy52aWV3ID0gdmlldztcbiAgICB0aGlzLmNhY2hlID0geyAnLic6IHRoaXMudmlldyB9O1xuICAgIHRoaXMucGFyZW50ID0gcGFyZW50Q29udGV4dDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IGNvbnRleHQgdXNpbmcgdGhlIGdpdmVuIHZpZXcgd2l0aCB0aGlzIGNvbnRleHRcbiAgICogYXMgdGhlIHBhcmVudC5cbiAgICovXG4gIENvbnRleHQucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiBwdXNoICh2aWV3KSB7XG4gICAgcmV0dXJuIG5ldyBDb250ZXh0KHZpZXcsIHRoaXMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGUgZ2l2ZW4gbmFtZSBpbiB0aGlzIGNvbnRleHQsIHRyYXZlcnNpbmdcbiAgICogdXAgdGhlIGNvbnRleHQgaGllcmFyY2h5IGlmIHRoZSB2YWx1ZSBpcyBhYnNlbnQgaW4gdGhpcyBjb250ZXh0J3Mgdmlldy5cbiAgICovXG4gIENvbnRleHQucHJvdG90eXBlLmxvb2t1cCA9IGZ1bmN0aW9uIGxvb2t1cCAobmFtZSkge1xuICAgIHZhciBjYWNoZSA9IHRoaXMuY2FjaGU7XG5cbiAgICB2YXIgdmFsdWU7XG4gICAgaWYgKGNhY2hlLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICB2YWx1ZSA9IGNhY2hlW25hbWVdO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgY29udGV4dCA9IHRoaXMsIG5hbWVzLCBpbmRleCwgbG9va3VwSGl0ID0gZmFsc2U7XG5cbiAgICAgIHdoaWxlIChjb250ZXh0KSB7XG4gICAgICAgIGlmIChuYW1lLmluZGV4T2YoJy4nKSA+IDApIHtcbiAgICAgICAgICB2YWx1ZSA9IGNvbnRleHQudmlldztcbiAgICAgICAgICBuYW1lcyA9IG5hbWUuc3BsaXQoJy4nKTtcbiAgICAgICAgICBpbmRleCA9IDA7XG5cbiAgICAgICAgICAvKipcbiAgICAgICAgICAgKiBVc2luZyB0aGUgZG90IG5vdGlvbiBwYXRoIGluIGBuYW1lYCwgd2UgZGVzY2VuZCB0aHJvdWdoIHRoZVxuICAgICAgICAgICAqIG5lc3RlZCBvYmplY3RzLlxuICAgICAgICAgICAqXG4gICAgICAgICAgICogVG8gYmUgY2VydGFpbiB0aGF0IHRoZSBsb29rdXAgaGFzIGJlZW4gc3VjY2Vzc2Z1bCwgd2UgaGF2ZSB0b1xuICAgICAgICAgICAqIGNoZWNrIGlmIHRoZSBsYXN0IG9iamVjdCBpbiB0aGUgcGF0aCBhY3R1YWxseSBoYXMgdGhlIHByb3BlcnR5XG4gICAgICAgICAgICogd2UgYXJlIGxvb2tpbmcgZm9yLiBXZSBzdG9yZSB0aGUgcmVzdWx0IGluIGBsb29rdXBIaXRgLlxuICAgICAgICAgICAqXG4gICAgICAgICAgICogVGhpcyBpcyBzcGVjaWFsbHkgbmVjZXNzYXJ5IGZvciB3aGVuIHRoZSB2YWx1ZSBoYXMgYmVlbiBzZXQgdG9cbiAgICAgICAgICAgKiBgdW5kZWZpbmVkYCBhbmQgd2Ugd2FudCB0byBhdm9pZCBsb29raW5nIHVwIHBhcmVudCBjb250ZXh0cy5cbiAgICAgICAgICAgKiovXG4gICAgICAgICAgd2hpbGUgKHZhbHVlICE9IG51bGwgJiYgaW5kZXggPCBuYW1lcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGlmIChpbmRleCA9PT0gbmFtZXMubGVuZ3RoIC0gMSlcbiAgICAgICAgICAgICAgbG9va3VwSGl0ID0gaGFzUHJvcGVydHkodmFsdWUsIG5hbWVzW2luZGV4XSk7XG5cbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWVbbmFtZXNbaW5kZXgrK11dO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZSA9IGNvbnRleHQudmlld1tuYW1lXTtcbiAgICAgICAgICBsb29rdXBIaXQgPSBoYXNQcm9wZXJ0eShjb250ZXh0LnZpZXcsIG5hbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxvb2t1cEhpdClcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjb250ZXh0ID0gY29udGV4dC5wYXJlbnQ7XG4gICAgICB9XG5cbiAgICAgIGNhY2hlW25hbWVdID0gdmFsdWU7XG4gICAgfVxuXG4gICAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKVxuICAgICAgdmFsdWUgPSB2YWx1ZS5jYWxsKHRoaXMudmlldyk7XG5cbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG5cbiAgLyoqXG4gICAqIEEgV3JpdGVyIGtub3dzIGhvdyB0byB0YWtlIGEgc3RyZWFtIG9mIHRva2VucyBhbmQgcmVuZGVyIHRoZW0gdG8gYVxuICAgKiBzdHJpbmcsIGdpdmVuIGEgY29udGV4dC4gSXQgYWxzbyBtYWludGFpbnMgYSBjYWNoZSBvZiB0ZW1wbGF0ZXMgdG9cbiAgICogYXZvaWQgdGhlIG5lZWQgdG8gcGFyc2UgdGhlIHNhbWUgdGVtcGxhdGUgdHdpY2UuXG4gICAqL1xuICBmdW5jdGlvbiBXcml0ZXIgKCkge1xuICAgIHRoaXMuY2FjaGUgPSB7fTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbGVhcnMgYWxsIGNhY2hlZCB0ZW1wbGF0ZXMgaW4gdGhpcyB3cml0ZXIuXG4gICAqL1xuICBXcml0ZXIucHJvdG90eXBlLmNsZWFyQ2FjaGUgPSBmdW5jdGlvbiBjbGVhckNhY2hlICgpIHtcbiAgICB0aGlzLmNhY2hlID0ge307XG4gIH07XG5cbiAgLyoqXG4gICAqIFBhcnNlcyBhbmQgY2FjaGVzIHRoZSBnaXZlbiBgdGVtcGxhdGVgIGFuZCByZXR1cm5zIHRoZSBhcnJheSBvZiB0b2tlbnNcbiAgICogdGhhdCBpcyBnZW5lcmF0ZWQgZnJvbSB0aGUgcGFyc2UuXG4gICAqL1xuICBXcml0ZXIucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24gcGFyc2UgKHRlbXBsYXRlLCB0YWdzKSB7XG4gICAgdmFyIGNhY2hlID0gdGhpcy5jYWNoZTtcbiAgICB2YXIgdG9rZW5zID0gY2FjaGVbdGVtcGxhdGVdO1xuXG4gICAgaWYgKHRva2VucyA9PSBudWxsKVxuICAgICAgdG9rZW5zID0gY2FjaGVbdGVtcGxhdGVdID0gcGFyc2VUZW1wbGF0ZSh0ZW1wbGF0ZSwgdGFncyk7XG5cbiAgICByZXR1cm4gdG9rZW5zO1xuICB9O1xuXG4gIC8qKlxuICAgKiBIaWdoLWxldmVsIG1ldGhvZCB0aGF0IGlzIHVzZWQgdG8gcmVuZGVyIHRoZSBnaXZlbiBgdGVtcGxhdGVgIHdpdGhcbiAgICogdGhlIGdpdmVuIGB2aWV3YC5cbiAgICpcbiAgICogVGhlIG9wdGlvbmFsIGBwYXJ0aWFsc2AgYXJndW1lbnQgbWF5IGJlIGFuIG9iamVjdCB0aGF0IGNvbnRhaW5zIHRoZVxuICAgKiBuYW1lcyBhbmQgdGVtcGxhdGVzIG9mIHBhcnRpYWxzIHRoYXQgYXJlIHVzZWQgaW4gdGhlIHRlbXBsYXRlLiBJdCBtYXlcbiAgICogYWxzbyBiZSBhIGZ1bmN0aW9uIHRoYXQgaXMgdXNlZCB0byBsb2FkIHBhcnRpYWwgdGVtcGxhdGVzIG9uIHRoZSBmbHlcbiAgICogdGhhdCB0YWtlcyBhIHNpbmdsZSBhcmd1bWVudDogdGhlIG5hbWUgb2YgdGhlIHBhcnRpYWwuXG4gICAqL1xuICBXcml0ZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uIHJlbmRlciAodGVtcGxhdGUsIHZpZXcsIHBhcnRpYWxzKSB7XG4gICAgdmFyIHRva2VucyA9IHRoaXMucGFyc2UodGVtcGxhdGUpO1xuICAgIHZhciBjb250ZXh0ID0gKHZpZXcgaW5zdGFuY2VvZiBDb250ZXh0KSA/IHZpZXcgOiBuZXcgQ29udGV4dCh2aWV3KTtcbiAgICByZXR1cm4gdGhpcy5yZW5kZXJUb2tlbnModG9rZW5zLCBjb250ZXh0LCBwYXJ0aWFscywgdGVtcGxhdGUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBMb3ctbGV2ZWwgbWV0aG9kIHRoYXQgcmVuZGVycyB0aGUgZ2l2ZW4gYXJyYXkgb2YgYHRva2Vuc2AgdXNpbmdcbiAgICogdGhlIGdpdmVuIGBjb250ZXh0YCBhbmQgYHBhcnRpYWxzYC5cbiAgICpcbiAgICogTm90ZTogVGhlIGBvcmlnaW5hbFRlbXBsYXRlYCBpcyBvbmx5IGV2ZXIgdXNlZCB0byBleHRyYWN0IHRoZSBwb3J0aW9uXG4gICAqIG9mIHRoZSBvcmlnaW5hbCB0ZW1wbGF0ZSB0aGF0IHdhcyBjb250YWluZWQgaW4gYSBoaWdoZXItb3JkZXIgc2VjdGlvbi5cbiAgICogSWYgdGhlIHRlbXBsYXRlIGRvZXNuJ3QgdXNlIGhpZ2hlci1vcmRlciBzZWN0aW9ucywgdGhpcyBhcmd1bWVudCBtYXlcbiAgICogYmUgb21pdHRlZC5cbiAgICovXG4gIFdyaXRlci5wcm90b3R5cGUucmVuZGVyVG9rZW5zID0gZnVuY3Rpb24gcmVuZGVyVG9rZW5zICh0b2tlbnMsIGNvbnRleHQsIHBhcnRpYWxzLCBvcmlnaW5hbFRlbXBsYXRlKSB7XG4gICAgdmFyIGJ1ZmZlciA9ICcnO1xuXG4gICAgdmFyIHRva2VuLCBzeW1ib2wsIHZhbHVlO1xuICAgIGZvciAodmFyIGkgPSAwLCBudW1Ub2tlbnMgPSB0b2tlbnMubGVuZ3RoOyBpIDwgbnVtVG9rZW5zOyArK2kpIHtcbiAgICAgIHZhbHVlID0gdW5kZWZpbmVkO1xuICAgICAgdG9rZW4gPSB0b2tlbnNbaV07XG4gICAgICBzeW1ib2wgPSB0b2tlblswXTtcblxuICAgICAgaWYgKHN5bWJvbCA9PT0gJyMnKSB2YWx1ZSA9IHRoaXMucmVuZGVyU2VjdGlvbih0b2tlbiwgY29udGV4dCwgcGFydGlhbHMsIG9yaWdpbmFsVGVtcGxhdGUpO1xuICAgICAgZWxzZSBpZiAoc3ltYm9sID09PSAnXicpIHZhbHVlID0gdGhpcy5yZW5kZXJJbnZlcnRlZCh0b2tlbiwgY29udGV4dCwgcGFydGlhbHMsIG9yaWdpbmFsVGVtcGxhdGUpO1xuICAgICAgZWxzZSBpZiAoc3ltYm9sID09PSAnPicpIHZhbHVlID0gdGhpcy5yZW5kZXJQYXJ0aWFsKHRva2VuLCBjb250ZXh0LCBwYXJ0aWFscywgb3JpZ2luYWxUZW1wbGF0ZSk7XG4gICAgICBlbHNlIGlmIChzeW1ib2wgPT09ICcmJykgdmFsdWUgPSB0aGlzLnVuZXNjYXBlZFZhbHVlKHRva2VuLCBjb250ZXh0KTtcbiAgICAgIGVsc2UgaWYgKHN5bWJvbCA9PT0gJ25hbWUnKSB2YWx1ZSA9IHRoaXMuZXNjYXBlZFZhbHVlKHRva2VuLCBjb250ZXh0KTtcbiAgICAgIGVsc2UgaWYgKHN5bWJvbCA9PT0gJ3RleHQnKSB2YWx1ZSA9IHRoaXMucmF3VmFsdWUodG9rZW4pO1xuXG4gICAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgYnVmZmVyICs9IHZhbHVlO1xuICAgIH1cblxuICAgIHJldHVybiBidWZmZXI7XG4gIH07XG5cbiAgV3JpdGVyLnByb3RvdHlwZS5yZW5kZXJTZWN0aW9uID0gZnVuY3Rpb24gcmVuZGVyU2VjdGlvbiAodG9rZW4sIGNvbnRleHQsIHBhcnRpYWxzLCBvcmlnaW5hbFRlbXBsYXRlKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBidWZmZXIgPSAnJztcbiAgICB2YXIgdmFsdWUgPSBjb250ZXh0Lmxvb2t1cCh0b2tlblsxXSk7XG5cbiAgICAvLyBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgdG8gcmVuZGVyIGFuIGFyYml0cmFyeSB0ZW1wbGF0ZVxuICAgIC8vIGluIHRoZSBjdXJyZW50IGNvbnRleHQgYnkgaGlnaGVyLW9yZGVyIHNlY3Rpb25zLlxuICAgIGZ1bmN0aW9uIHN1YlJlbmRlciAodGVtcGxhdGUpIHtcbiAgICAgIHJldHVybiBzZWxmLnJlbmRlcih0ZW1wbGF0ZSwgY29udGV4dCwgcGFydGlhbHMpO1xuICAgIH1cblxuICAgIGlmICghdmFsdWUpIHJldHVybjtcblxuICAgIGlmIChpc0FycmF5KHZhbHVlKSkge1xuICAgICAgZm9yICh2YXIgaiA9IDAsIHZhbHVlTGVuZ3RoID0gdmFsdWUubGVuZ3RoOyBqIDwgdmFsdWVMZW5ndGg7ICsraikge1xuICAgICAgICBidWZmZXIgKz0gdGhpcy5yZW5kZXJUb2tlbnModG9rZW5bNF0sIGNvbnRleHQucHVzaCh2YWx1ZVtqXSksIHBhcnRpYWxzLCBvcmlnaW5hbFRlbXBsYXRlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICBidWZmZXIgKz0gdGhpcy5yZW5kZXJUb2tlbnModG9rZW5bNF0sIGNvbnRleHQucHVzaCh2YWx1ZSksIHBhcnRpYWxzLCBvcmlnaW5hbFRlbXBsYXRlKTtcbiAgICB9IGVsc2UgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICBpZiAodHlwZW9mIG9yaWdpbmFsVGVtcGxhdGUgIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCB1c2UgaGlnaGVyLW9yZGVyIHNlY3Rpb25zIHdpdGhvdXQgdGhlIG9yaWdpbmFsIHRlbXBsYXRlJyk7XG5cbiAgICAgIC8vIEV4dHJhY3QgdGhlIHBvcnRpb24gb2YgdGhlIG9yaWdpbmFsIHRlbXBsYXRlIHRoYXQgdGhlIHNlY3Rpb24gY29udGFpbnMuXG4gICAgICB2YWx1ZSA9IHZhbHVlLmNhbGwoY29udGV4dC52aWV3LCBvcmlnaW5hbFRlbXBsYXRlLnNsaWNlKHRva2VuWzNdLCB0b2tlbls1XSksIHN1YlJlbmRlcik7XG5cbiAgICAgIGlmICh2YWx1ZSAhPSBudWxsKVxuICAgICAgICBidWZmZXIgKz0gdmFsdWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJ1ZmZlciArPSB0aGlzLnJlbmRlclRva2Vucyh0b2tlbls0XSwgY29udGV4dCwgcGFydGlhbHMsIG9yaWdpbmFsVGVtcGxhdGUpO1xuICAgIH1cbiAgICByZXR1cm4gYnVmZmVyO1xuICB9O1xuXG4gIFdyaXRlci5wcm90b3R5cGUucmVuZGVySW52ZXJ0ZWQgPSBmdW5jdGlvbiByZW5kZXJJbnZlcnRlZCAodG9rZW4sIGNvbnRleHQsIHBhcnRpYWxzLCBvcmlnaW5hbFRlbXBsYXRlKSB7XG4gICAgdmFyIHZhbHVlID0gY29udGV4dC5sb29rdXAodG9rZW5bMV0pO1xuXG4gICAgLy8gVXNlIEphdmFTY3JpcHQncyBkZWZpbml0aW9uIG9mIGZhbHN5LiBJbmNsdWRlIGVtcHR5IGFycmF5cy5cbiAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2phbmwvbXVzdGFjaGUuanMvaXNzdWVzLzE4NlxuICAgIGlmICghdmFsdWUgfHwgKGlzQXJyYXkodmFsdWUpICYmIHZhbHVlLmxlbmd0aCA9PT0gMCkpXG4gICAgICByZXR1cm4gdGhpcy5yZW5kZXJUb2tlbnModG9rZW5bNF0sIGNvbnRleHQsIHBhcnRpYWxzLCBvcmlnaW5hbFRlbXBsYXRlKTtcbiAgfTtcblxuICBXcml0ZXIucHJvdG90eXBlLnJlbmRlclBhcnRpYWwgPSBmdW5jdGlvbiByZW5kZXJQYXJ0aWFsICh0b2tlbiwgY29udGV4dCwgcGFydGlhbHMpIHtcbiAgICBpZiAoIXBhcnRpYWxzKSByZXR1cm47XG5cbiAgICB2YXIgdmFsdWUgPSBpc0Z1bmN0aW9uKHBhcnRpYWxzKSA/IHBhcnRpYWxzKHRva2VuWzFdKSA6IHBhcnRpYWxzW3Rva2VuWzFdXTtcbiAgICBpZiAodmFsdWUgIT0gbnVsbClcbiAgICAgIHJldHVybiB0aGlzLnJlbmRlclRva2Vucyh0aGlzLnBhcnNlKHZhbHVlKSwgY29udGV4dCwgcGFydGlhbHMsIHZhbHVlKTtcbiAgfTtcblxuICBXcml0ZXIucHJvdG90eXBlLnVuZXNjYXBlZFZhbHVlID0gZnVuY3Rpb24gdW5lc2NhcGVkVmFsdWUgKHRva2VuLCBjb250ZXh0KSB7XG4gICAgdmFyIHZhbHVlID0gY29udGV4dC5sb29rdXAodG9rZW5bMV0pO1xuICAgIGlmICh2YWx1ZSAhPSBudWxsKVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICB9O1xuXG4gIFdyaXRlci5wcm90b3R5cGUuZXNjYXBlZFZhbHVlID0gZnVuY3Rpb24gZXNjYXBlZFZhbHVlICh0b2tlbiwgY29udGV4dCkge1xuICAgIHZhciB2YWx1ZSA9IGNvbnRleHQubG9va3VwKHRva2VuWzFdKTtcbiAgICBpZiAodmFsdWUgIT0gbnVsbClcbiAgICAgIHJldHVybiBtdXN0YWNoZS5lc2NhcGUodmFsdWUpO1xuICB9O1xuXG4gIFdyaXRlci5wcm90b3R5cGUucmF3VmFsdWUgPSBmdW5jdGlvbiByYXdWYWx1ZSAodG9rZW4pIHtcbiAgICByZXR1cm4gdG9rZW5bMV07XG4gIH07XG5cbiAgbXVzdGFjaGUubmFtZSA9ICdtdXN0YWNoZS5qcyc7XG4gIG11c3RhY2hlLnZlcnNpb24gPSAnMi4yLjAnO1xuICBtdXN0YWNoZS50YWdzID0gWyAne3snLCAnfX0nIF07XG5cbiAgLy8gQWxsIGhpZ2gtbGV2ZWwgbXVzdGFjaGUuKiBmdW5jdGlvbnMgdXNlIHRoaXMgd3JpdGVyLlxuICB2YXIgZGVmYXVsdFdyaXRlciA9IG5ldyBXcml0ZXIoKTtcblxuICAvKipcbiAgICogQ2xlYXJzIGFsbCBjYWNoZWQgdGVtcGxhdGVzIGluIHRoZSBkZWZhdWx0IHdyaXRlci5cbiAgICovXG4gIG11c3RhY2hlLmNsZWFyQ2FjaGUgPSBmdW5jdGlvbiBjbGVhckNhY2hlICgpIHtcbiAgICByZXR1cm4gZGVmYXVsdFdyaXRlci5jbGVhckNhY2hlKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFBhcnNlcyBhbmQgY2FjaGVzIHRoZSBnaXZlbiB0ZW1wbGF0ZSBpbiB0aGUgZGVmYXVsdCB3cml0ZXIgYW5kIHJldHVybnMgdGhlXG4gICAqIGFycmF5IG9mIHRva2VucyBpdCBjb250YWlucy4gRG9pbmcgdGhpcyBhaGVhZCBvZiB0aW1lIGF2b2lkcyB0aGUgbmVlZCB0b1xuICAgKiBwYXJzZSB0ZW1wbGF0ZXMgb24gdGhlIGZseSBhcyB0aGV5IGFyZSByZW5kZXJlZC5cbiAgICovXG4gIG11c3RhY2hlLnBhcnNlID0gZnVuY3Rpb24gcGFyc2UgKHRlbXBsYXRlLCB0YWdzKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRXcml0ZXIucGFyc2UodGVtcGxhdGUsIHRhZ3MpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZW5kZXJzIHRoZSBgdGVtcGxhdGVgIHdpdGggdGhlIGdpdmVuIGB2aWV3YCBhbmQgYHBhcnRpYWxzYCB1c2luZyB0aGVcbiAgICogZGVmYXVsdCB3cml0ZXIuXG4gICAqL1xuICBtdXN0YWNoZS5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXIgKHRlbXBsYXRlLCB2aWV3LCBwYXJ0aWFscykge1xuICAgIGlmICh0eXBlb2YgdGVtcGxhdGUgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIHRlbXBsYXRlISBUZW1wbGF0ZSBzaG91bGQgYmUgYSBcInN0cmluZ1wiICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAnYnV0IFwiJyArIHR5cGVTdHIodGVtcGxhdGUpICsgJ1wiIHdhcyBnaXZlbiBhcyB0aGUgZmlyc3QgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICdhcmd1bWVudCBmb3IgbXVzdGFjaGUjcmVuZGVyKHRlbXBsYXRlLCB2aWV3LCBwYXJ0aWFscyknKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGVmYXVsdFdyaXRlci5yZW5kZXIodGVtcGxhdGUsIHZpZXcsIHBhcnRpYWxzKTtcbiAgfTtcblxuICAvLyBUaGlzIGlzIGhlcmUgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHdpdGggMC40LnguLFxuICAvKmVzbGludC1kaXNhYmxlICovIC8vIGVzbGludCB3YW50cyBjYW1lbCBjYXNlZCBmdW5jdGlvbiBuYW1lXG4gIG11c3RhY2hlLnRvX2h0bWwgPSBmdW5jdGlvbiB0b19odG1sICh0ZW1wbGF0ZSwgdmlldywgcGFydGlhbHMsIHNlbmQpIHtcbiAgICAvKmVzbGludC1lbmFibGUqL1xuXG4gICAgdmFyIHJlc3VsdCA9IG11c3RhY2hlLnJlbmRlcih0ZW1wbGF0ZSwgdmlldywgcGFydGlhbHMpO1xuXG4gICAgaWYgKGlzRnVuY3Rpb24oc2VuZCkpIHtcbiAgICAgIHNlbmQocmVzdWx0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIH07XG5cbiAgLy8gRXhwb3J0IHRoZSBlc2NhcGluZyBmdW5jdGlvbiBzbyB0aGF0IHRoZSB1c2VyIG1heSBvdmVycmlkZSBpdC5cbiAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9qYW5sL211c3RhY2hlLmpzL2lzc3Vlcy8yNDRcbiAgbXVzdGFjaGUuZXNjYXBlID0gZXNjYXBlSHRtbDtcblxuICAvLyBFeHBvcnQgdGhlc2UgbWFpbmx5IGZvciB0ZXN0aW5nLCBidXQgYWxzbyBmb3IgYWR2YW5jZWQgdXNhZ2UuXG4gIG11c3RhY2hlLlNjYW5uZXIgPSBTY2FubmVyO1xuICBtdXN0YWNoZS5Db250ZXh0ID0gQ29udGV4dDtcbiAgbXVzdGFjaGUuV3JpdGVyID0gV3JpdGVyO1xuXG59KSk7XG4iLCIvKiBvYmplY3QtaXRlcmF0b3JzLmpzIC0gTWluaSBVbmRlcnNjb3JlIGxpYnJhcnlcbiAqIGJ5IEpvbmF0aGFuIEVpdGVuXG4gKlxuICogVGhlIG1ldGhvZHMgYmVsb3cgb3BlcmF0ZSBvbiBvYmplY3RzIChidXQgbm90IGFycmF5cykgc2ltaWxhcmx5XG4gKiB0byBVbmRlcnNjb3JlIChodHRwOi8vdW5kZXJzY29yZWpzLm9yZy8jY29sbGVjdGlvbnMpLlxuICpcbiAqIFJlY29tbWVuZGVkIHVzYWdlOlxuICpcbiAqICAgIHZhciBfID0gcmVxdWlyZSgnb2JqZWN0LWl0ZXJhdG9ycycpO1xuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBzdW1tYXJ5IFdyYXAgYW4gb2JqZWN0IGZvciBvbmUgbWV0aG9kLlxuICogQERlc2MgTm90ZSB0aGF0IHRoZSBgbmV3YCBrZXl3b3JkIGlzIG5vdCBuZWNlc3NhcnkuXG4gKiBAcGFyYW0ge29iamVjdHxudWxsfHVuZGVmaW5lZH0gb2JqZWN0IC0gYG51bGxgIG9yIGB1bmRlZmluZWRgIGlzIHRyZWF0ZWQgYXMgYW4gZW1wdHkgcGxhaW4gb2JqZWN0LlxuICogQHJldHVybiB7V3JhcHBlcn0gVGhlIHdyYXBwZWQgb2JqZWN0LlxuICovXG5mdW5jdGlvbiBXcmFwcGVyKG9iamVjdCkge1xuICAgIGlmIChvYmplY3QgaW5zdGFuY2VvZiBXcmFwcGVyKSB7XG4gICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBXcmFwcGVyKSkge1xuICAgICAgICByZXR1cm4gbmV3IFdyYXBwZXIob2JqZWN0KTtcbiAgICB9XG4gICAgdGhpcy5vcmlnaW5hbFZhbHVlID0gb2JqZWN0O1xuICAgIHRoaXMubyA9IG9iamVjdCB8fCB7fTtcbn1cblxuLyoqXG4gKiBAbmFtZSBXcmFwcGVyLmNoYWluXG4gKiBAc3VtbWFyeSBXcmFwIGFuIG9iamVjdCBmb3IgYSBjaGFpbiBvZiBtZXRob2RzLlxuICogQERlc2MgQ2FsbHMgdGhlIGNvbnN0cnVjdG9yIGBXcmFwcGVyKClgIGFuZCBtb2RpZmllcyB0aGUgd3JhcHBlciBmb3IgY2hhaW5pbmcuXG4gKiBAcGFyYW0ge29iamVjdH0gb2JqZWN0XG4gKiBAcmV0dXJuIHtXcmFwcGVyfSBUaGUgd3JhcHBlZCBvYmplY3QuXG4gKi9cbldyYXBwZXIuY2hhaW4gPSBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgdmFyIHdyYXBwZWQgPSBXcmFwcGVyKG9iamVjdCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbmV3LWNhcFxuICAgIHdyYXBwZWQuY2hhaW5pbmcgPSB0cnVlO1xuICAgIHJldHVybiB3cmFwcGVkO1xufTtcblxuV3JhcHBlci5wcm90b3R5cGUgPSB7XG4gICAgLyoqXG4gICAgICogVW53cmFwIGFuIG9iamVjdCB3cmFwcGVkIHdpdGgge0BsaW5rIFdyYXBwZXIuY2hhaW58V3JhcHBlci5jaGFpbigpfS5cbiAgICAgKiBAcmV0dXJuIHtvYmplY3R8bnVsbHx1bmRlZmluZWR9IFRoZSB2YWx1ZSBvcmlnaW5hbGx5IHdyYXBwZWQgYnkgdGhlIGNvbnN0cnVjdG9yLlxuICAgICAqIEBtZW1iZXJPZiBXcmFwcGVyLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHZhbHVlOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9yaWdpbmFsVmFsdWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBkZXNjIE1pbWljcyBVbmRlcnNjb3JlJ3MgW2VhY2hdKGh0dHA6Ly91bmRlcnNjb3JlanMub3JnLyNlYWNoKSBtZXRob2Q6IEl0ZXJhdGUgb3ZlciB0aGUgbWVtYmVycyBvZiB0aGUgd3JhcHBlZCBvYmplY3QsIGNhbGxpbmcgYGl0ZXJhdGVlKClgIHdpdGggZWFjaC5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBpdGVyYXRlZSAtIEZvciBlYWNoIG1lbWJlciBvZiB0aGUgd3JhcHBlZCBvYmplY3QsIHRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIHdpdGggdGhyZWUgYXJndW1lbnRzOiBgKHZhbHVlLCBrZXksIG9iamVjdClgLiBUaGUgcmV0dXJuIHZhbHVlIG9mIHRoaXMgZnVuY3Rpb24gaXMgdW5kZWZpbmVkOyBhbiBgLmVhY2hgIGxvb3AgY2Fubm90IGJlIGJyb2tlbiBvdXQgb2YgKHVzZSB7QGxpbmsgV3JhcHBlciNmaW5kfC5maW5kfSBpbnN0ZWFkKS5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW2NvbnRleHRdIC0gSWYgZ2l2ZW4sIGBpdGVyYXRlZWAgaXMgYm91bmQgdG8gdGhpcyBvYmplY3QuIEluIG90aGVyIHdvcmRzLCB0aGlzIG9iamVjdCBiZWNvbWVzIHRoZSBgdGhpc2AgdmFsdWUgaW4gdGhlIGNhbGxzIHRvIGBpdGVyYXRlZWAuIChPdGhlcndpc2UsIHRoZSBgdGhpc2AgdmFsdWUgd2lsbCBiZSB0aGUgdW53cmFwcGVkIG9iamVjdC4pXG4gICAgICogQHJldHVybiB7V3JhcHBlcn0gVGhlIHdyYXBwZWQgb2JqZWN0IGZvciBjaGFpbmluZy5cbiAgICAgKiBAbWVtYmVyT2YgV3JhcHBlci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBlYWNoOiBmdW5jdGlvbiAoaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIG8gPSB0aGlzLm87XG4gICAgICAgIGNvbnRleHQgPSBjb250ZXh0IHx8IG87XG4gICAgICAgIE9iamVjdC5rZXlzKG8pLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgaXRlcmF0ZWUuY2FsbChjb250ZXh0LCBvW2tleV0sIGtleSwgbyk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQGRlc2MgTWltaWNzIFVuZGVyc2NvcmUncyBbZmluZF0oaHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvI2ZpbmQpIG1ldGhvZDogTG9vayB0aHJvdWdoIGVhY2ggbWVtYmVyIG9mIHRoZSB3cmFwcGVkIG9iamVjdCwgcmV0dXJuaW5nIHRoZSBmaXJzdCBvbmUgdGhhdCBwYXNzZXMgYSB0cnV0aCB0ZXN0IChwcmVkaWNhdGUpLCBvciBgdW5kZWZpbmVkYCBpZiBubyB2YWx1ZSBwYXNzZXMgdGhlIHRlc3QuIFRoZSBmdW5jdGlvbiByZXR1cm5zIHRoZSB2YWx1ZSBvZiB0aGUgZmlyc3QgYWNjZXB0YWJsZSBtZW1iZXIsIGFuZCBkb2Vzbid0IG5lY2Vzc2FyaWx5IHRyYXZlcnNlIHRoZSBlbnRpcmUgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IHByZWRpY2F0ZSAtIEZvciBlYWNoIG1lbWJlciBvZiB0aGUgd3JhcHBlZCBvYmplY3QsIHRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIHdpdGggdGhyZWUgYXJndW1lbnRzOiBgKHZhbHVlLCBrZXksIG9iamVjdClgLiBUaGUgcmV0dXJuIHZhbHVlIG9mIHRoaXMgZnVuY3Rpb24gc2hvdWxkIGJlIHRydXRoeSBpZiB0aGUgbWVtYmVyIHBhc3NlcyB0aGUgdGVzdCBhbmQgZmFsc3kgb3RoZXJ3aXNlLlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBbY29udGV4dF0gLSBJZiBnaXZlbiwgYHByZWRpY2F0ZWAgaXMgYm91bmQgdG8gdGhpcyBvYmplY3QuIEluIG90aGVyIHdvcmRzLCB0aGlzIG9iamVjdCBiZWNvbWVzIHRoZSBgdGhpc2AgdmFsdWUgaW4gdGhlIGNhbGxzIHRvIGBwcmVkaWNhdGVgLiAoT3RoZXJ3aXNlLCB0aGUgYHRoaXNgIHZhbHVlIHdpbGwgYmUgdGhlIHVud3JhcHBlZCBvYmplY3QuKVxuICAgICAqIEByZXR1cm4geyp9IFRoZSBmb3VuZCBwcm9wZXJ0eSdzIHZhbHVlLlxuICAgICAqIEBtZW1iZXJPZiBXcmFwcGVyLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGZpbmQ6IGZ1bmN0aW9uIChwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICAgICAgdmFyIG8gPSB0aGlzLm87XG4gICAgICAgIGNvbnRleHQgPSBjb250ZXh0IHx8IG87XG4gICAgICAgIHZhciByZXN1bHQgPSBPYmplY3Qua2V5cyhvKS5maW5kKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBwcmVkaWNhdGUuY2FsbChjb250ZXh0LCBvW2tleV0sIGtleSwgbyk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0ID09PSB1bmRlZmluZWQgPyB1bmRlZmluZWQgOiBvW3Jlc3VsdF07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBkZXNjIE1pbWljcyBVbmRlcnNjb3JlJ3MgW3JlZHVjZV0oaHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvI3JlZHVjZSkgbWV0aG9kOiBCb2lsIGRvd24gdGhlIHZhbHVlcyBvZiBhbGwgdGhlIG1lbWJlcnMgb2YgdGhlIHdyYXBwZWQgb2JqZWN0IGludG8gYSBzaW5nbGUgdmFsdWUuIGBtZW1vYCBpcyB0aGUgaW5pdGlhbCBzdGF0ZSBvZiB0aGUgcmVkdWN0aW9uLCBhbmQgZWFjaCBzdWNjZXNzaXZlIHN0ZXAgb2YgaXQgc2hvdWxkIGJlIHJldHVybmVkIGJ5IGBpdGVyYXRlZSgpYC5cbiAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBpdGVyYXRlZSAtIEZvciBlYWNoIG1lbWJlciBvZiB0aGUgd3JhcHBlZCBvYmplY3QsIHRoaXMgZnVuY3Rpb24gaXMgY2FsbGVkIHdpdGggZm91ciBhcmd1bWVudHM6IGAobWVtbywgdmFsdWUsIGtleSwgb2JqZWN0KWAuIFRoZSByZXR1cm4gdmFsdWUgb2YgdGhpcyBmdW5jdGlvbiBiZWNvbWVzIHRoZSBuZXcgdmFsdWUgb2YgYG1lbW9gIGZvciB0aGUgbmV4dCBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbbWVtb10gLSBJZiBubyBtZW1vIGlzIHBhc3NlZCB0byB0aGUgaW5pdGlhbCBpbnZvY2F0aW9uIG9mIHJlZHVjZSwgdGhlIGl0ZXJhdGVlIGlzIG5vdCBpbnZva2VkIG9uIHRoZSBmaXJzdCBlbGVtZW50IG9mIHRoZSBsaXN0LiBUaGUgZmlyc3QgZWxlbWVudCBpcyBpbnN0ZWFkIHBhc3NlZCBhcyB0aGUgbWVtbyBpbiB0aGUgaW52b2NhdGlvbiBvZiB0aGUgaXRlcmF0ZWUgb24gdGhlIG5leHQgZWxlbWVudCBpbiB0aGUgbGlzdC5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gW2NvbnRleHRdIC0gSWYgZ2l2ZW4sIGBpdGVyYXRlZWAgaXMgYm91bmQgdG8gdGhpcyBvYmplY3QuIEluIG90aGVyIHdvcmRzLCB0aGlzIG9iamVjdCBiZWNvbWVzIHRoZSBgdGhpc2AgdmFsdWUgaW4gdGhlIGNhbGxzIHRvIGBpdGVyYXRlZWAuIChPdGhlcndpc2UsIHRoZSBgdGhpc2AgdmFsdWUgd2lsbCBiZSB0aGUgdW53cmFwcGVkIG9iamVjdC4pXG4gICAgICogQHJldHVybiB7Kn0gVGhlIHZhbHVlIG9mIGBtZW1vYCBcInJlZHVjZWRcIiBhcyBwZXIgYGl0ZXJhdGVlYC5cbiAgICAgKiBAbWVtYmVyT2YgV3JhcHBlci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICByZWR1Y2U6IGZ1bmN0aW9uIChpdGVyYXRlZSwgbWVtbywgY29udGV4dCkge1xuICAgICAgICB2YXIgbyA9IHRoaXMubztcbiAgICAgICAgY29udGV4dCA9IGNvbnRleHQgfHwgbztcbiAgICAgICAgT2JqZWN0LmtleXMobykuZm9yRWFjaChmdW5jdGlvbiAoa2V5LCBpZHgpIHtcbiAgICAgICAgICAgIG1lbW8gPSAoIWlkeCAmJiBtZW1vID09PSB1bmRlZmluZWQpID8gb1trZXldIDogaXRlcmF0ZWUuY2FsbChjb250ZXh0LCBtZW1vLCBvW2tleV0sIGtleSwgbyk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbWVtbztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQGRlc2MgTWltaWNzIFVuZGVyc2NvcmUncyBbZXh0ZW5kXShodHRwOi8vdW5kZXJzY29yZWpzLm9yZy8jZXh0ZW5kKSBtZXRob2Q6IENvcHkgYWxsIG9mIHRoZSBwcm9wZXJ0aWVzIGluIGVhY2ggb2YgdGhlIGBzb3VyY2VgIG9iamVjdCBwYXJhbWV0ZXIocykgb3ZlciB0byB0aGUgKHdyYXBwZWQpIGRlc3RpbmF0aW9uIG9iamVjdCAodGh1cyBtdXRhdGluZyBpdCkuIEl0J3MgaW4tb3JkZXIsIHNvIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBsYXN0IGBzb3VyY2VgIG9iamVjdCB3aWxsIG92ZXJyaWRlIHByb3BlcnRpZXMgd2l0aCB0aGUgc2FtZSBuYW1lIGluIHByZXZpb3VzIGFyZ3VtZW50cyBvciBpbiB0aGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqID4gVGhpcyBtZXRob2QgY29waWVzIG93biBtZW1iZXJzIGFzIHdlbGwgYXMgbWVtYmVycyBpbmhlcml0ZWQgZnJvbSBwcm90b3R5cGUgY2hhaW4uXG4gICAgICogQHBhcmFtIHsuLi5vYmplY3R8bnVsbHx1bmRlZmluZWR9IHNvdXJjZSAtIFZhbHVlcyBvZiBgbnVsbGAgb3IgYHVuZGVmaW5lZGAgYXJlIHRyZWF0ZWQgYXMgZW1wdHkgcGxhaW4gb2JqZWN0cy5cbiAgICAgKiBAcmV0dXJuIHtXcmFwcGVyfG9iamVjdH0gVGhlIHdyYXBwZWQgZGVzdGluYXRpb24gb2JqZWN0IGlmIGNoYWluaW5nIGlzIGluIGVmZmVjdDsgb3RoZXJ3aXNlIHRoZSB1bndyYXBwZWQgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBtZW1iZXJPZiBXcmFwcGVyLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGV4dGVuZDogZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgICAgICB2YXIgbyA9IHRoaXMubztcbiAgICAgICAgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKS5mb3JFYWNoKGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICAgICAgICAgIGlmIChvYmplY3QpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIG9ba2V5XSA9IG9iamVjdFtrZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLmNoYWluaW5nID8gdGhpcyA6IG87XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBkZXNjIE1pbWljcyBVbmRlcnNjb3JlJ3MgW2V4dGVuZE93bl0oaHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvI2V4dGVuZE93bikgbWV0aG9kOiBMaWtlIHtAbGluayBXcmFwcGVyI2V4dGVuZHxleHRlbmR9LCBidXQgb25seSBjb3BpZXMgaXRzIFwib3duXCIgcHJvcGVydGllcyBvdmVyIHRvIHRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHsuLi5vYmplY3R8bnVsbHx1bmRlZmluZWR9IHNvdXJjZSAtIFZhbHVlcyBvZiBgbnVsbGAgb3IgYHVuZGVmaW5lZGAgYXJlIHRyZWF0ZWQgYXMgZW1wdHkgcGxhaW4gb2JqZWN0cy5cbiAgICAgKiBAcmV0dXJuIHtXcmFwcGVyfG9iamVjdH0gVGhlIHdyYXBwZWQgZGVzdGluYXRpb24gb2JqZWN0IGlmIGNoYWluaW5nIGlzIGluIGVmZmVjdDsgb3RoZXJ3aXNlIHRoZSB1bndyYXBwZWQgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBtZW1iZXJPZiBXcmFwcGVyLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGV4dGVuZE93bjogZnVuY3Rpb24gKHNvdXJjZSkge1xuICAgICAgICB2YXIgbyA9IHRoaXMubztcbiAgICAgICAgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKS5mb3JFYWNoKGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICAgICAgICAgIFdyYXBwZXIob2JqZWN0KS5lYWNoKGZ1bmN0aW9uICh2YWwsIGtleSkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5ldy1jYXBcbiAgICAgICAgICAgICAgICBvW2tleV0gPSB2YWw7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLmNoYWluaW5nID8gdGhpcyA6IG87XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBXcmFwcGVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKiBlc2xpbnQtZW52IG5vZGUsIGJyb3dzZXIgKi9cblxuLyogW09OQ0UgQ0FMTElORyBDT0RFIElTIFVQREFURUQgQU5EIFRFU1RFRCwgUkVNT1ZFIFRISVMgQ09NTUVOVCArIEFMTCBMSU5FUyBDT05UQUlOSU5HIFwiRm9ybWVybHkuLi5cIl1cbiAqIFRoaXMgbW9kdWxlIHJlY3Rhbmd1bGFyLmpzIGRpZmZlcnMgZnJvbSBwcmVkZWNlc3NvciBmaW4tcmVjdGFuZ2xlLmpzIGFzIGZvbGxvd3M6XG4gKiAxLiBJbnN0ZWFkIG9mIGNyZWF0aW5nIFBvbHltZXIgY29tcG9uZW50IGBmaW4tcmVjdGFuZ2xlc2AsIG5vdyBkb2VzIG9uZSBvZiBmb2xsb3dpbmc6XG4gKiAgYS4gSWYgb2JqZWN0IGBleHBvcnRzYCBleGlzdHM6IEFkZHMgb2JqZWN0IGFzIG5ldyBwcm9wZXJ0eSBgZXhwb3J0cy5yZWN0YW5ndWxhcmBcbiAqICAgICB0aHVzIHN1cHBvcnRpbmcgTm9kZSBhcyB3ZWxsIGFzIGZpbGUgYnVuZGxpbmcgYnkgQnJvd3NlcmlmeS5cbiAqICBiLiBJZiBvYmplY3QgYGV4cG9ydHNgIGRvZXMgbm90IGV4aXN0OiBBZGRzIG9iamVjdCBhcyBuZXcgcHJvcGVydHlcbiAqICAgICBgd2luZG93LmZpbi5yZWN0YW5ndWxhcmAgKGZpcnN0IGNyZWF0aW5nIG9iamVjdCBgd2luZG93LmZpbmAgaWYgbmVjZXNzYXJ5KVxuICogICAgIHRodXMgc3VwcG9ydGluZyBjbGllbnQtc2lkZSBpbmNsdXNpb24gdmlhIDxzY3JpcHQ+IHRhZy5cbiAqIDIuIEZpbGUgd2FzIHJlb3JnYW5pemVkIHRvIHVzZSBwcm90b3R5cGFsIGluaGVyaXRhbmNlIHNvOlxuICogIGEuIGNoYW5nZSAncmVjdGFuZ2xlcy5wb2ludC5jcmVhdGUoJyB0byAnbmV3IHJlY3Rhbmd1bGFyLlBvaW50KCdcbiAqICBiLiBjaGFuZ2UgJ3JlY3RhbmdsZXMucmVjdGFuZ2xlLmNyZWF0ZSgnIHRvICduZXcgcmVjdGFuZ3VsYXIuUmVjdGFuZ2xlKCdcbiAqIDMuIENoYW5nZSBhbGwgaW5zdGFuY2VzIG9mICdUaGFuRXF1YWxUbycgdG8gJ1RoYW5PckVxdWFsVG8nXG4gKiA0LiBDaGFuZ2UgYWxsIGludm9jYXRpb25zIG9mIFJlY3RhbmdsZS50b3AsIC5sZWZ0LCAuYm90dG9tLCAucmlnaHQsIC53aWR0aCxcbiAqICAgIC5oZWlnaHQsIGFuZCAuYXJlYSB0byBnZXR0ZXIgcmVmZXJlbmNlcyBieSByZW1vdmluZyB0aGUgaW52b2NhdGlvbiBvcGVyYXRvclxuICogICAgKGkuZS4sIHRoZSBwYXJlbnRoZXNlcykuXG4gKi9cblxuKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykgeyAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtZXhwcmVzc2lvbnNcblxuICAgIC8vIFRoaXMgY2xvc3VyZSBzdXBwb3J0cyBOb2RlSlMtbGVzcyBjbGllbnQgc2lkZSBpbmNsdWRlcyB3aXRoIDxzY3JpcHQ+IHRhZ3MuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vam9uZWl0L21ubS5cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgcmVhZC1vbmx5IHByb3BlcnR5IGFuZCBhdHRhY2hlcyBpdCB0byB0aGUgcHJvdmlkZWQgY29udGV4dC5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gTmFtZSBmb3IgbmV3IHByb3BlcnR5LlxuICAgICAqIEBwYXJhbSB7Kn0gW3ZhbHVlXSAtIFZhbHVlIG9mIG5ldyBwcm9wZXJ0eS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhZGRSZWFkT25seVByb3BlcnR5KG5hbWUsIHZhbHVlKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBuYW1lLCB7XG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAY29uc3RydWN0b3IgUG9pbnRcbiAgICAgKlxuICAgICAqIEBkZXNjIFRoaXMgb2JqZWN0IHJlcHJlc2VudHMgYSBzaW5nbGUgcG9pbnQgaW4gYW4gYWJzdHJhY3QgMi1kaW1lbnNpb25hbCBtYXRyaXguXG4gICAgICpcbiAgICAgKiBUaGUgdW5pdCBvZiBtZWFzdXJlIGlzIHR5cGljYWxseSBwaXhlbHMuXG4gICAgICogKElmIHVzZWQgdG8gbW9kZWwgY29tcHV0ZXIgZ3JhcGhpY3MsIHZlcnRpY2FsIGNvb3JkaW5hdGVzIGFyZSB0eXBpY2FsbHkgbWVhc3VyZWQgZG93bndhcmRzXG4gICAgICogZnJvbSB0aGUgdG9wIG9mIHRoZSB3aW5kb3cuIFRoaXMgY29udmVudGlvbiBob3dldmVyIGlzIG5vdCBpbmhlcmVudCBpbiB0aGlzIG9iamVjdC4pXG4gICAgICpcbiAgICAgKiBOb3RlOiBUaGlzIG9iamVjdCBzaG91bGQgYmUgaW5zdGFudGlhdGVkIHdpdGggdGhlIGBuZXdgIGtleXdvcmQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCAtIHRoZSBuZXcgcG9pbnQncyBgeGAgcHJvcGVydHlcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSAtIHRoZSBuZXcgcG9pbnQncyBgeWAgcHJvcGVydHlcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBQb2ludCh4LCB5KSB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBuYW1lIHhcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICogQHN1bW1hcnkgVGhpcyBwb2ludCdzIGhvcml6b250YWwgY29vcmRpbmF0ZS5cbiAgICAgICAgICogQGRlc2MgQ3JlYXRlZCB1cG9uIGluc3RhbnRpYXRpb24gYnkgdGhlIHtAbGluayBQb2ludHxjb25zdHJ1Y3Rvcn0uXG4gICAgICAgICAqIEBtZW1iZXJPZiBQb2ludC5wcm90b3R5cGVcbiAgICAgICAgICogQGFic3RyYWN0XG4gICAgICAgICAqL1xuICAgICAgICBhZGRSZWFkT25seVByb3BlcnR5LmNhbGwodGhpcywgJ3gnLCBOdW1iZXIoeCkgfHwgMCk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBuYW1lIHlcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICogQHN1bW1hcnkgVGhpcyBwb2ludCdzIHZlcnRpY2FsIGNvb3JkaW5hdGUuXG4gICAgICAgICAqIEBkZXNjIENyZWF0ZWQgdXBvbiBpbnN0YW50aWF0aW9uIGJ5IHRoZSB7QGxpbmsgUG9pbnR8Y29uc3RydWN0b3J9LlxuICAgICAgICAgKiBAbWVtYmVyT2YgUG9pbnQucHJvdG90eXBlXG4gICAgICAgICAqIEBhYnN0cmFjdFxuICAgICAgICAgKi9cbiAgICAgICAgYWRkUmVhZE9ubHlQcm9wZXJ0eS5jYWxsKHRoaXMsICd5JywgTnVtYmVyKHkpIHx8IDApO1xuXG4gICAgfVxuXG4gICAgUG9pbnQucHJvdG90eXBlID0ge1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJucyB7UG9pbnR9IEEgbmV3IHBvaW50IHdoaWNoIGlzIHRoaXMgcG9pbnQncyBwb3NpdGlvbiBpbmNyZWFzZWQgYnkgY29vcmRpbmF0ZXMgb2YgZ2l2ZW4gYHBvaW50YC5cbiAgICAgICAgICogQHBhcmFtIHtQb2ludH0gT2Zmc2V0IC0gSG9yaXpvbnRhbCBhbmQgdmVydGljYWwgdmFsdWVzIHRvIGFkZCB0byB0aGlzIHBvaW50J3MgY29vcmRpbmF0ZXMuXG4gICAgICAgICAqIEBtZW1iZXJPZiBQb2ludC5wcm90b3R5cGVcbiAgICAgICAgICovXG4gICAgICAgIHBsdXM6IGZ1bmN0aW9uKG9mZnNldCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQb2ludChcbiAgICAgICAgICAgICAgICB0aGlzLnggKyBvZmZzZXQueCxcbiAgICAgICAgICAgICAgICB0aGlzLnkgKyBvZmZzZXQueVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybnMge1BvaW50fSBBIG5ldyBwb2ludCB3aGljaCBpcyB0aGlzIHBvaW50J3MgcG9zaXRpb24gaW5jcmVhc2VkIGJ5IGdpdmVuIG9mZnNldHMuXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb2Zmc2V0WD0wXSAtIFZhbHVlIHRvIGFkZCB0byB0aGlzIHBvaW50J3MgaG9yaXpvbnRhbCBjb29yZGluYXRlLlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW29mZnNldFk9MF0gLSBWYWx1ZSB0byBhZGQgdG8gdGhpcyBwb2ludCdzIGhvcml6b250YWwgY29vcmRpbmF0ZS5cbiAgICAgICAgICogQG1lbWJlck9mIFBvaW50LnByb3RvdHlwZVxuICAgICAgICAgKi9cbiAgICAgICAgcGx1c1hZOiBmdW5jdGlvbihvZmZzZXRYLCBvZmZzZXRZKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KFxuICAgICAgICAgICAgICAgIHRoaXMueCArIChvZmZzZXRYIHx8IDApLFxuICAgICAgICAgICAgICAgIHRoaXMueSArIChvZmZzZXRZIHx8IDApXG4gICAgICAgICAgICApO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJucyB7UG9pbnR9IEEgbmV3IHBvaW50IHdoaWNoIGlzIHRoaXMgcG9pbnQncyBwb3NpdGlvbiBkZWNyZWFzZWQgYnkgY29vcmRpbmF0ZXMgb2YgZ2l2ZW4gYHBvaW50YC5cbiAgICAgICAgICogQHBhcmFtIHtQb2ludH0gb2Zmc2V0IC0gSG9yaXpvbnRhbCBhbmQgdmVydGljYWwgdmFsdWVzIHRvIHN1YnRyYWN0IGZyb20gdGhpcyBwb2ludCdzIGNvb3JkaW5hdGVzLlxuICAgICAgICAgKiBAbWVtYmVyT2YgUG9pbnQucHJvdG90eXBlXG4gICAgICAgICAqL1xuICAgICAgICBtaW51czogZnVuY3Rpb24ob2Zmc2V0KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFBvaW50KFxuICAgICAgICAgICAgICAgIHRoaXMueCAtIG9mZnNldC54LFxuICAgICAgICAgICAgICAgIHRoaXMueSAtIG9mZnNldC55XG4gICAgICAgICAgICApO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJucyB7UG9pbnR9IEEgbmV3IGBQb2ludGAgcG9zaXRpb25lZCB0byBsZWFzdCB4IGFuZCBsZWFzdCB5IG9mIHRoaXMgcG9pbnQgYW5kIGdpdmVuIGBwb2ludGAuXG4gICAgICAgICAqIEBwYXJhbSB7UG9pbnR9IHBvaW50IC0gQSBwb2ludCB0byBjb21wYXJlIHRvIHRoaXMgcG9pbnQuXG4gICAgICAgICAqIEBtZW1iZXJPZiBQb2ludC5wcm90b3R5cGVcbiAgICAgICAgICovXG4gICAgICAgIG1pbjogZnVuY3Rpb24ocG9pbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQoXG4gICAgICAgICAgICAgICAgTWF0aC5taW4odGhpcy54LCBwb2ludC54KSxcbiAgICAgICAgICAgICAgICBNYXRoLm1pbih0aGlzLnksIHBvaW50LnkpXG4gICAgICAgICAgICApO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJucyB7UG9pbnR9IEEgbmV3IGBQb2ludGAgcG9zaXRpb25lZCB0byBncmVhdGVzdCB4IGFuZCBncmVhdGVzdCB5IG9mIHRoaXMgcG9pbnQgYW5kIGdpdmVuIGBwb2ludGAuXG4gICAgICAgICAqIEBwYXJhbSB7UG9pbnR9IHBvaW50IC0gQSBwb2ludCB0byBjb21wYXJlIHRvIHRoaXMgcG9pbnQuXG4gICAgICAgICAqIEBtZW1iZXJPZiBQb2ludC5wcm90b3R5cGVcbiAgICAgICAgICovXG4gICAgICAgIG1heDogZnVuY3Rpb24ocG9pbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUG9pbnQoXG4gICAgICAgICAgICAgICAgTWF0aC5tYXgodGhpcy54LCBwb2ludC54KSxcbiAgICAgICAgICAgICAgICBNYXRoLm1heCh0aGlzLnksIHBvaW50LnkpXG4gICAgICAgICAgICApO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBEaXN0YW5jZSBiZXR3ZWVuIGdpdmVuIGBwb2ludGAgYW5kIHRoaXMgcG9pbnQgdXNpbmcgUHl0aGFnb3JlYW4gVGhlb3JlbSBmb3JtdWxhLlxuICAgICAgICAgKiBAcGFyYW0ge1BvaW50fSBwb2ludCAtIEEgcG9pbnQgZnJvbSB3aGljaCB0byBjb21wdXRlIHRoZSBkaXN0YW5jZSB0byB0aGlzIHBvaW50LlxuICAgICAgICAgKiBAbWVtYmVyT2YgUG9pbnQucHJvdG90eXBlXG4gICAgICAgICAqL1xuICAgICAgICBkaXN0YW5jZTogZnVuY3Rpb24ocG9pbnQpIHtcbiAgICAgICAgICAgIHZhciBkZWx0YVggPSBwb2ludC54IC0gdGhpcy54LFxuICAgICAgICAgICAgICAgIGRlbHRhWSA9IHBvaW50LnkgLSB0aGlzLnk7XG5cbiAgICAgICAgICAgIHJldHVybiBNYXRoLnNxcnQoXG4gICAgICAgICAgICAgICAgZGVsdGFYICogZGVsdGFYICtcbiAgICAgICAgICAgICAgICBkZWx0YVkgKiBkZWx0YVlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIF8oRm9ybWVybHk6IGBlcXVhbGAuKV9cbiAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZmYgX2JvdGhfIGNvb3JkaW5hdGVzIG9mIHRoaXMgcG9pbnQgYXJlIGV4YWN0bHkgZXF1YWwgdG8gdGhvc2Ugb2YgZ2l2ZW4gYHBvaW50YC5cbiAgICAgICAgICogQHBhcmFtIHtQb2ludH0gcG9pbnQgLSBBIHBvaW50IHRvIGNvbXBhcmUgdG8gdGhpcyBwb2ludC5cbiAgICAgICAgICogQG1lbWJlck9mIFBvaW50LnByb3RvdHlwZVxuICAgICAgICAgKi9cbiAgICAgICAgZXF1YWxzOiBmdW5jdGlvbihwb2ludCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGZhbHNlO1xuXG4gICAgICAgICAgICBpZiAocG9pbnQpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnggPT09IHBvaW50LnggJiZcbiAgICAgICAgICAgICAgICAgICAgdGhpcy55ID09PSBwb2ludC55O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmZiBfYm90aF8gY29vcmRpbmF0ZXMgb2YgdGhpcyBwb2ludCBhcmUgZ3JlYXRlciB0aGFuIHRob3NlIG9mIGdpdmVuIGBwb2ludGAuXG4gICAgICAgICAqIEBwYXJhbSB7UG9pbnR9IHBvaW50IC0gQSBwb2ludCB0byBjb21wYXJlIHRvIHRoaXMgcG9pbnRcbiAgICAgICAgICogQG1lbWJlck9mIFBvaW50LnByb3RvdHlwZVxuICAgICAgICAgKi9cbiAgICAgICAgZ3JlYXRlclRoYW46IGZ1bmN0aW9uKHBvaW50KSB7XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIHRoaXMueCA+IHBvaW50LnggJiZcbiAgICAgICAgICAgICAgICB0aGlzLnkgPiBwb2ludC55XG4gICAgICAgICAgICApO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmZiBfYm90aF8gY29vcmRpbmF0ZXMgb2YgdGhpcyBwb2ludCBhcmUgbGVzcyB0aGFuIHRob3NlIG9mIGdpdmVuIGBwb2ludGAuXG4gICAgICAgICAqIEBwYXJhbSB7UG9pbnR9IHBvaW50IC0gQSBwb2ludCB0byBjb21wYXJlIHRvIHRoaXMgcG9pbnRcbiAgICAgICAgICogQG1lbWJlck9mIFBvaW50LnByb3RvdHlwZVxuICAgICAgICAgKi9cbiAgICAgICAgbGVzc1RoYW46IGZ1bmN0aW9uKHBvaW50KSB7XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIHRoaXMueCA8IHBvaW50LnggJiZcbiAgICAgICAgICAgICAgICB0aGlzLnkgPCBwb2ludC55XG4gICAgICAgICAgICApO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBfKEZvcm1lcmx5IGBncmVhdGVyVGhhbkVxdWFsVG9gLilfXG4gICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWZmIF9ib3RoXyBjb29yZGluYXRlcyBvZiB0aGlzIHBvaW50IGFyZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gdGhvc2Ugb2YgZ2l2ZW4gYHBvaW50YC5cbiAgICAgICAgICogQHBhcmFtIHtQb2ludH0gcG9pbnQgLSBBIHBvaW50IHRvIGNvbXBhcmUgdG8gdGhpcyBwb2ludFxuICAgICAgICAgKiBAbWVtYmVyT2YgUG9pbnQucHJvdG90eXBlXG4gICAgICAgICAqL1xuICAgICAgICBncmVhdGVyVGhhbk9yRXF1YWxUbzogZnVuY3Rpb24ocG9pbnQpIHtcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgdGhpcy54ID49IHBvaW50LnggJiZcbiAgICAgICAgICAgICAgICB0aGlzLnkgPj0gcG9pbnQueVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogXyhGb3JtZXJseSBgbGVzc1RoYW5FcXVhbFRvYC4pX1xuICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmZiBfYm90aF8gY29vcmRpbmF0ZXMgb2YgdGhpcyBwb2ludCBhcmUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRob3NlIG9mIGdpdmVuIGBwb2ludGAuXG4gICAgICAgICAqIEBwYXJhbSB7UG9pbnR9IHBvaW50IC0gQSBwb2ludCB0byBjb21wYXJlIHRvIHRoaXMgcG9pbnQuXG4gICAgICAgICAqIEBtZW1iZXJPZiBQb2ludC5wcm90b3R5cGVcbiAgICAgICAgICovXG4gICAgICAgIGxlc3NUaGFuT3JFcXVhbFRvOiBmdW5jdGlvbihwb2ludCkge1xuICAgICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgICAgICB0aGlzLnggPD0gcG9pbnQueCAmJlxuICAgICAgICAgICAgICAgIHRoaXMueSA8PSBwb2ludC55XG4gICAgICAgICAgICApO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBfKEZvcm1lcmx5IGBpc0NvbnRhaW5lZFdpdGhpblJlY3RhbmdsZWAuKV9cbiAgICAgICAgICogQHBhcmFtIHJlY3Qge1JlY3RhbmdsZX0gLSBSZWN0YW5nbGUgdG8gdGVzdCB0aGlzIHBvaW50IGFnYWluc3QuXG4gICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWZmIHRoaXMgcG9pbnQgaXMgd2l0aGluIGdpdmVuIGByZWN0YC5cbiAgICAgICAgICogQG1lbWJlck9mIFBvaW50LnByb3RvdHlwZVxuICAgICAgICAgKi9cbiAgICAgICAgd2l0aGluOiBmdW5jdGlvbihyZWN0KSB7XG4gICAgICAgICAgICB2YXIgbWluWCA9IHJlY3Qub3JpZ2luLngsXG4gICAgICAgICAgICAgICAgbWF4WCA9IG1pblggKyByZWN0LmV4dGVudC54O1xuICAgICAgICAgICAgdmFyIG1pblkgPSByZWN0Lm9yaWdpbi55LFxuICAgICAgICAgICAgICAgIG1heFkgPSBtaW5ZICsgcmVjdC5leHRlbnQueTtcblxuICAgICAgICAgICAgaWYgKHJlY3QuZXh0ZW50LnggPCAwKSB7XG4gICAgICAgICAgICAgICAgbWluWCA9IG1heFg7XG4gICAgICAgICAgICAgICAgbWF4WCA9IHJlY3Qub3JpZ2luLng7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChyZWN0LmV4dGVudC55IDwgMCkge1xuICAgICAgICAgICAgICAgIG1pblkgPSBtYXhZO1xuICAgICAgICAgICAgICAgIG1heFkgPSByZWN0Lm9yaWdpbi55O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIG1pblggPD0gdGhpcy54ICYmIHRoaXMueCA8IG1heFggJiZcbiAgICAgICAgICAgICAgICBtaW5ZIDw9IHRoaXMueSAmJiB0aGlzLnkgPCBtYXhZXG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIFBvaW50LnByb3RvdHlwZS5FUSA9IFBvaW50LnByb3RvdHlwZS5lcXVhbHM7XG4gICAgUG9pbnQucHJvdG90eXBlLkdUID0gUG9pbnQucHJvdG90eXBlLmdyZWF0ZXJUaGFuO1xuICAgIFBvaW50LnByb3RvdHlwZS5MVCA9IFBvaW50LnByb3RvdHlwZS5sZXNzVGhhbjtcbiAgICBQb2ludC5wcm90b3R5cGUuR0UgPSBQb2ludC5wcm90b3R5cGUuZ3JlYXRlclRoYW5PckVxdWFsVG87XG4gICAgUG9pbnQucHJvdG90eXBlLkxFID0gUG9pbnQucHJvdG90eXBlLmxlc3NUaGFuT3JFcXVhbFRvO1xuXG5cbiAgICAvKipcbiAgICAgKiBAY29uc3RydWN0b3IgUmVjdGFuZ2xlXG4gICAgICpcbiAgICAgKiBAZGVzYyBUaGlzIG9iamVjdCByZXByZXNlbnRzIGEgcmVjdGFuZ3VsYXIgYXJlYSB3aXRoaW4gYW4gYWJzdHJhY3QgMi1kaW1lbnNpb25hbCBtYXRyaXguXG4gICAgICpcbiAgICAgKiBUaGUgdW5pdCBvZiBtZWFzdXJlIGlzIHR5cGljYWxseSBwaXhlbHMuXG4gICAgICogKElmIHVzZWQgdG8gbW9kZWwgY29tcHV0ZXIgZ3JhcGhpY3MsIHZlcnRpY2FsIGNvb3JkaW5hdGVzIGFyZSB0eXBpY2FsbHkgbWVhc3VyZWQgZG93bndhcmRzXG4gICAgICogZnJvbSB0aGUgdG9wIG9mIHRoZSB3aW5kb3cuIFRoaXMgY29udmVudGlvbiBob3dldmVyIGlzIG5vdCBpbmhlcmVudCBpbiB0aGlzIG9iamVjdC4pXG4gICAgICpcbiAgICAgKiBOb3JtYWxseSwgdGhlIGB4YCBhbmQgYHlgIHBhcmFtZXRlcnMgdG8gdGhlIGNvbnN0cnVjdG9yIGRlc2NyaWJlIHRoZSB1cHBlciBsZWZ0IGNvcm5lciBvZiB0aGUgcmVjdC5cbiAgICAgKiBIb3dldmVyLCBuZWdhdGl2ZSB2YWx1ZXMgb2YgYHdpZHRoYCBhbmQgYGhlaWdodGAgd2lsbCBiZSBhZGRlZCB0byB0aGUgZ2l2ZW4gYHhgIGFuZCBgeWAuIFRoYXQgaXMsXG4gICAgICogYSBuZWdhdGl2ZSB2YWx1ZSBvZiB0aGUgYHdpZHRoYCBwYXJhbWV0ZXIgd2lsbCBleHRlbmQgdGhlIHJlY3QgdG8gdGhlIGxlZnQgb2YgdGhlIGdpdmVuIGB4YCBhbmRcbiAgICAgKiBhIG5lZ2F0aXZlIHZhbHVlIG9mIHRoZSBgaGVpZ2h0YCBwYXJhbWV0ZXIgd2lsbCBleHRlbmQgdGhlIHJlY3QgYWJvdmUgdGhlIGdpdmVuIGB5YC5cbiAgICAgKiBJbiBhbnkgY2FzZSwgYWZ0ZXIgaW5zdGFudGlhdGlvbiB0aGUgZm9sbG93aW5nIGFyZSBndWFyYW50ZWVkIHRvIGFsd2F5cyBiZSB0cnVlOlxuICAgICAqICogVGhlIGBleHRlbnRgLCBgd2lkdGhgLCBhbmQgYGhlaWdodGAgcHJvcGVydGllcyBfYWx3YXlzXyBnaXZlIHBvc2l0aXZlIHZhbHVlcy5cbiAgICAgKiAqIFRoZSBgb3JpZ2luYCwgYHRvcGAsIGFuZCBgbGVmdGAgcHJvcGVydGllcyBfYWx3YXlzXyByZWZsZWN0IHRoZSB1cHBlciBsZWZ0IGNvcm5lci5cbiAgICAgKiAqIFRoZSBgY29ybmVyYCwgYGJvdHRvbWAsIGFuZCBgcmlnaHRgIHByb3BlcnRpZXMgX2Fsd2F5c18gcmVmbGVjdCB0aGUgbG93ZXIgcmlnaHQgY29ybmVyLlxuICAgICAqXG4gICAgICogTm90ZTogVGhpcyBvYmplY3Qgc2hvdWxkIGJlIGluc3RhbnRpYXRlZCB3aXRoIHRoZSBgbmV3YCBrZXl3b3JkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt4PTBdIC0gSG9yaXpvbnRhbCBjb29yZGluYXRlIG9mIHNvbWUgY29ybmVyIG9mIHRoZSByZWN0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbeT0wXSAtIFZlcnRpY2FsIGNvb3JkaW5hdGUgb2Ygc29tZSBjb3JuZXIgb2YgdGhlIHJlY3QuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt3aWR0aD0wXSAtIFdpZHRoIG9mIHRoZSBuZXcgcmVjdC4gTWF5IGJlIG5lZ2F0aXZlIChzZWUgYWJvdmUpLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbaGVpZ2h0PTBdIC0gSGVpZ2h0IG9mIHRoZSBuZXcgcmVjdC4gTWF5IGJlIG5lZ2F0aXZlIChzZWUgYWJvdmUpLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIFJlY3RhbmdsZSh4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG5cbiAgICAgICAgeCA9IE51bWJlcih4KSB8fCAwO1xuICAgICAgICB5ID0gTnVtYmVyKHkpIHx8IDA7XG4gICAgICAgIHdpZHRoID0gTnVtYmVyKHdpZHRoKSB8fCAwO1xuICAgICAgICBoZWlnaHQgPSBOdW1iZXIoaGVpZ2h0KSB8fCAwO1xuXG4gICAgICAgIGlmICh3aWR0aCA8IDApIHtcbiAgICAgICAgICAgIHggKz0gd2lkdGg7XG4gICAgICAgICAgICB3aWR0aCA9IC13aWR0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoZWlnaHQgPCAwKSB7XG4gICAgICAgICAgICB5ICs9IGhlaWdodDtcbiAgICAgICAgICAgIGhlaWdodCA9IC1oZWlnaHQ7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogQG5hbWUgb3JpZ2luXG4gICAgICAgICAqIEB0eXBlIHtQb2ludH1cbiAgICAgICAgICogQHN1bW1hcnkgVXBwZXIgbGVmdCBjb3JuZXIgb2YgdGhpcyByZWN0LlxuICAgICAgICAgKiBAZGVzYyBDcmVhdGVkIHVwb24gaW5zdGFudGlhdGlvbiBieSB0aGUge0BsaW5rcGxhaW4gUmVjdGFuZ2xlfGNvbnN0cnVjdG9yfS5cbiAgICAgICAgICogQG1lbWJlck9mIFJlY3RhbmdsZS5wcm90b3R5cGVcbiAgICAgICAgICogQGFic3RyYWN0XG4gICAgICAgICAqL1xuICAgICAgICBhZGRSZWFkT25seVByb3BlcnR5LmNhbGwodGhpcywgJ29yaWdpbicsIG5ldyBQb2ludCh4LCB5KSk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBuYW1lIGV4dGVudFxuICAgICAgICAgKiBAdHlwZSB7UG9pbnR9XG4gICAgICAgICAqIEBzdW1tYXJ5IHRoaXMgcmVjdCdzIHdpZHRoIGFuZCBoZWlnaHQuXG4gICAgICAgICAqIEBkZXNjIFVubGlrZSB0aGUgb3RoZXIgYFBvaW50YCBwcm9wZXJ0aWVzLCBgZXh0ZW50YCBpcyBub3QgYSBnbG9iYWwgY29vcmRpbmF0ZSBwYWlyOyByYXRoZXIgaXQgY29uc2lzdHMgb2YgYSBfd2lkdGhfIChgeGAsIGFsd2F5cyBwb3NpdGl2ZSkgYW5kIGEgX2hlaWdodF8gKGB5YCwgYWx3YXlzIHBvc2l0aXZlKS5cbiAgICAgICAgICpcbiAgICAgICAgICogVGhpcyBvYmplY3QgbWlnaHQgYmUgbW9yZSBsZWdpdGltYXRlbHkgdHlwZWQgYXMgc29tZXRoaW5nIGxpa2UgYEFyZWFgIHdpdGggcHJvcGVydGllcyBgd2lkdGhgIGFuZCBgaGVpZ2h0YDsgaG93ZXZlciB3ZSB3YW50ZWQgaXQgdG8gYmUgYWJsZSB0byB1c2UgaXQgZWZmaWNpZW50bHkgd2l0aCBhIHBvaW50J3MgYHBsdXNgIGFuZCBgbWludXNgIG1ldGhvZHMgKHRoYXQgaXMsIHdpdGhvdXQgdGhvc2UgbWV0aG9kcyBoYXZpbmcgdG8gY2hlY2sgYW5kIGJyYW5jaCBvbiB0aGUgdHlwZSBvZiBpdHMgcGFyYW1ldGVyKS5cbiAgICAgICAgICpcbiAgICAgICAgICogQ3JlYXRlZCB1cG9uIGluc3RhbnRpYXRpb24gYnkgdGhlIHtAbGlua3BsYWluIFJlY3RhbmdsZXxjb25zdHJ1Y3Rvcn0uXG4gICAgICAgICAqIEBzZWUgVGhlIHtAbGluayBSZWN0YW5nbGUjY29ybmVyfGNvcm5lcn0gbWV0aG9kLlxuICAgICAgICAgKiBAbWVtYmVyT2YgUmVjdGFuZ2xlLnByb3RvdHlwZVxuICAgICAgICAgKiBAYWJzdHJhY3RcbiAgICAgICAgICovXG4gICAgICAgIGFkZFJlYWRPbmx5UHJvcGVydHkuY2FsbCh0aGlzLCAnZXh0ZW50JywgbmV3IFBvaW50KHdpZHRoLCBoZWlnaHQpKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQG5hbWUgY29ybmVyXG4gICAgICAgICAqIEB0eXBlIHtQb2ludH1cbiAgICAgICAgICogQHN1bW1hcnkgTG93ZXIgcmlnaHQgY29ybmVyIG9mIHRoaXMgcmVjdC5cbiAgICAgICAgICogQGRlc2MgVGhpcyBpcyBhIGNhbGN1bGF0ZWQgdmFsdWUgY3JlYXRlZCB1cG9uIGluc3RhbnRpYXRpb24gYnkgdGhlIHtAbGlua3BsYWluIFJlY3RhbmdsZXxjb25zdHJ1Y3Rvcn0uIEl0IGlzIGBvcmlnaW5gIG9mZnNldCBieSBgZXh0ZW50YC5cbiAgICAgICAgICpcbiAgICAgICAgICogKipOb3RlOioqIFRoZXNlIGNvb3JkaW5hdGVzIGFjdHVhbGx5IHBvaW50IHRvIHRoZSBwaXhlbCBvbmUgYmVsb3cgYW5kIG9uZSB0byB0aGUgcmlnaHQgb2YgdGhlIHJlY3QncyBhY3R1YWwgbG93ZXIgcmlnaHQgcGl4ZWwuXG4gICAgICAgICAqIEBtZW1iZXJPZiBSZWN0YW5nbGUucHJvdG90eXBlXG4gICAgICAgICAqIEBhYnN0cmFjdFxuICAgICAgICAgKi9cbiAgICAgICAgYWRkUmVhZE9ubHlQcm9wZXJ0eS5jYWxsKHRoaXMsICdjb3JuZXInLCBuZXcgUG9pbnQoeCArIHdpZHRoLCB5ICsgaGVpZ2h0KSk7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBuYW1lIGNlbnRlclxuICAgICAgICAgKiBAdHlwZSB7UG9pbnR9XG4gICAgICAgICAqIEBzdW1tYXJ5IENlbnRlciBvZiB0aGlzIHJlY3QuXG4gICAgICAgICAqIEBkZXNjIENyZWF0ZWQgdXBvbiBpbnN0YW50aWF0aW9uIGJ5IHRoZSB7QGxpbmtwbGFpbiBSZWN0YW5nbGV8Y29uc3RydWN0b3J9LlxuICAgICAgICAgKiBAbWVtYmVyT2YgUmVjdGFuZ2xlLnByb3RvdHlwZVxuICAgICAgICAgKiBAYWJzdHJhY3RcbiAgICAgICAgICovXG4gICAgICAgIGFkZFJlYWRPbmx5UHJvcGVydHkuY2FsbCh0aGlzLCAnY2VudGVyJywgbmV3IFBvaW50KHggKyAod2lkdGggLyAyKSwgeSArIChoZWlnaHQgLyAyKSkpO1xuXG4gICAgfVxuXG4gICAgUmVjdGFuZ2xlLnByb3RvdHlwZSA9IHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICogQGRlc2MgXyhGb3JtZXJseSBhIGZ1bmN0aW9uOyBub3cgYSBnZXR0ZXIuKV9cbiAgICAgICAgICogQHN1bW1hcnkgTWluaW11bSB2ZXJ0aWNhbCBjb29yZGluYXRlIG9mIHRoaXMgcmVjdC5cbiAgICAgICAgICogQG1lbWJlck9mIFJlY3RhbmdsZS5wcm90b3R5cGVcbiAgICAgICAgICovXG4gICAgICAgIGdldCB0b3AoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vcmlnaW4ueTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICogQGRlc2MgXyhGb3JtZXJseSBhIGZ1bmN0aW9uOyBub3cgYSBnZXR0ZXIuKV9cbiAgICAgICAgICogQHN1bW1hcnkgTWluaW11bSBob3Jpem9udGFsIGNvb3JkaW5hdGUgb2YgdGhpcyByZWN0LlxuICAgICAgICAgKiBAbWVtYmVyT2YgUmVjdGFuZ2xlLnByb3RvdHlwZVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0IGxlZnQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vcmlnaW4ueDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICogQGRlc2MgXyhGb3JtZXJseSBhIGZ1bmN0aW9uOyBub3cgYSBnZXR0ZXIuKV9cbiAgICAgICAgICogQHN1bW1hcnkgTWF4aW11bSB2ZXJ0aWNhbCBjb29yZGluYXRlIG9mIHRoaXMgcmVjdCArIDEuXG4gICAgICAgICAqIEBtZW1iZXJPZiBSZWN0YW5nbGUucHJvdG90eXBlXG4gICAgICAgICAqL1xuICAgICAgICBnZXQgYm90dG9tKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29ybmVyLnk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqIEBkZXNjIF8oRm9ybWVybHkgYSBmdW5jdGlvbjsgbm93IGEgZ2V0dGVyLilfXG4gICAgICAgICAqIEBzdW1tYXJ5IE1heGltdW0gaG9yaXpvbnRhbCBjb29yZGluYXRlIG9mIHRoaXMgcmVjdCArIDEuXG4gICAgICAgICAqIEBtZW1iZXJPZiBSZWN0YW5nbGUucHJvdG90eXBlXG4gICAgICAgICAqL1xuICAgICAgICBnZXQgcmlnaHQoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb3JuZXIueDtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHR5cGUge251bWJlcn1cbiAgICAgICAgICogQGRlc2MgXyhGb3JtZXJseSBhIGZ1bmN0aW9uOyBub3cgYSBnZXR0ZXIuKV9cbiAgICAgICAgICogQHN1bW1hcnkgV2lkdGggb2YgdGhpcyByZWN0IChhbHdheXMgcG9zaXRpdmUpLlxuICAgICAgICAgKiBAbWVtYmVyT2YgUmVjdGFuZ2xlLnByb3RvdHlwZVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0IHdpZHRoKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXh0ZW50Lng7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqIEBkZXNjIF8oRm9ybWVybHkgYSBmdW5jdGlvbjsgbm93IGEgZ2V0dGVyLilfXG4gICAgICAgICAqIEBzdW1tYXJ5IEhlaWdodCBvZiB0aGlzIHJlY3QgKGFsd2F5cyBwb3NpdGl2ZSkuXG4gICAgICAgICAqIEBtZW1iZXJPZiBSZWN0YW5nbGUucHJvdG90eXBlXG4gICAgICAgICAqL1xuICAgICAgICBnZXQgaGVpZ2h0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXh0ZW50Lnk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICAgICAqIEBkZXNjIF8oRm9ybWVybHkgYSBmdW5jdGlvbjsgbm93IGEgZ2V0dGVyLilfXG4gICAgICAgICAqIEBzdW1tYXJ5IEFyZWEgb2YgdGhpcyByZWN0LlxuICAgICAgICAgKiBAbWVtYmVyT2YgUmVjdGFuZ2xlLnByb3RvdHlwZVxuICAgICAgICAgKi9cbiAgICAgICAgZ2V0IGFyZWEoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy53aWR0aCAqIHRoaXMuaGVpZ2h0O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJucyB7UmVjdGFuZ2xlfSBBIGNvcHkgb2YgdGhpcyByZWN0IGJ1dCB3aXRoIGhvcml6b250YWwgcG9zaXRpb24gcmVzZXQgdG8gZ2l2ZW4gYHhgIGFuZCBubyB3aWR0aC5cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHggLSBIb3Jpem9udGFsIGNvb3JkaW5hdGUgb2YgdGhlIG5ldyByZWN0LlxuICAgICAgICAgKiBAbWVtYmVyT2YgUmVjdGFuZ2xlLnByb3RvdHlwZVxuICAgICAgICAgKi9cbiAgICAgICAgZmxhdHRlblhBdDogZnVuY3Rpb24oeCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWN0YW5nbGUoeCwgdGhpcy5vcmlnaW4ueSwgMCwgdGhpcy5leHRlbnQueSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm5zIHtSZWN0YW5nbGV9IEEgY29weSBvZiB0aGlzIHJlY3QgYnV0IHdpdGggdmVydGljYWwgcG9zaXRpb24gcmVzZXQgdG8gZ2l2ZW4gYHlgIGFuZCBubyBoZWlnaHQuXG4gICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gVmVydGljYWwgY29vcmRpbmF0ZSBvZiB0aGUgbmV3IHJlY3QuXG4gICAgICAgICAqIEBtZW1iZXJPZiBSZWN0YW5nbGUucHJvdG90eXBlXG4gICAgICAgICAqL1xuICAgICAgICBmbGF0dGVuWUF0OiBmdW5jdGlvbih5KSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlY3RhbmdsZSh0aGlzLm9yaWdpbi54LCB5LCB0aGlzLmV4dGVudC54LCAwKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZmYgZ2l2ZW4gYHBvaW50YCBlbnRpcmVseSBjb250YWluZWQgd2l0aGluIHRoaXMgcmVjdC5cbiAgICAgICAgICogQHBhcmFtIHtQb2ludH0gcG9pbnRPclJlY3QgLSBUaGUgcG9pbnQgb3IgcmVjdCB0byB0ZXN0IGZvciBjb250YWlubWVudC5cbiAgICAgICAgICogQG1lbWJlck9mIFJlY3RhbmdsZS5wcm90b3R5cGVcbiAgICAgICAgICovXG4gICAgICAgIGNvbnRhaW5zOiBmdW5jdGlvbihwb2ludE9yUmVjdCkge1xuICAgICAgICAgICAgcmV0dXJuIHBvaW50T3JSZWN0LndpdGhpbih0aGlzKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogXyhGb3JtZXJseSBgaXNDb250YWluZWRXaXRoaW5SZWN0YW5nbGVgLilfXG4gICAgICAgICAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWZmIGB0aGlzYCByZWN0IGlzIGVudGlyZWx5IGNvbnRhaW5lZCB3aXRoaW4gZ2l2ZW4gYHJlY3RgLlxuICAgICAgICAgKiBAcGFyYW0ge1JlY3RhbmdsZX0gcmVjdCAtIFJlY3RhbmdsZSB0byB0ZXN0IGFnYWluc3QgdGhpcyByZWN0LlxuICAgICAgICAgKiBAbWVtYmVyT2YgUmVjdGFuZ2xlLnByb3RvdHlwZVxuICAgICAgICAgKi9cbiAgICAgICAgd2l0aGluOiBmdW5jdGlvbihyZWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIHJlY3Qub3JpZ2luLmxlc3NUaGFuT3JFcXVhbFRvKHRoaXMub3JpZ2luKSAmJlxuICAgICAgICAgICAgICAgIHJlY3QuY29ybmVyLmdyZWF0ZXJUaGFuT3JFcXVhbFRvKHRoaXMuY29ybmVyKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogXyhGb3JtZXJseTogYGluc2V0QnlgLilfXG4gICAgICAgICAqIEByZXR1cm5zIHtSZWN0YW5nbGV9IFRoYXQgaXMgZW5sYXJnZWQvc2hydW5rIGJ5IGdpdmVuIGBwYWRkaW5nYC5cbiAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHBhZGRpbmcgLSBBbW91bnQgYnkgd2hpY2ggdG8gaW5jcmVhc2UgKCspIG9yIGRlY3JlYXNlICgtKSB0aGlzIHJlY3RcbiAgICAgICAgICogQHNlZSBUaGUge0BsaW5rIFJlY3RhbmdsZSNzaHJpbmtCeXxzaHJpbmtCeX0gbWV0aG9kLlxuICAgICAgICAgKiBAbWVtYmVyT2YgUmVjdGFuZ2xlLnByb3RvdHlwZVxuICAgICAgICAgKi9cbiAgICAgICAgZ3Jvd0J5OiBmdW5jdGlvbihwYWRkaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlY3RhbmdsZShcbiAgICAgICAgICAgICAgICB0aGlzLm9yaWdpbi54ICsgcGFkZGluZyxcbiAgICAgICAgICAgICAgICB0aGlzLm9yaWdpbi55ICsgcGFkZGluZyxcbiAgICAgICAgICAgICAgICB0aGlzLmV4dGVudC54IC0gcGFkZGluZyAtIHBhZGRpbmcsXG4gICAgICAgICAgICAgICAgdGhpcy5leHRlbnQueSAtIHBhZGRpbmcgLSBwYWRkaW5nKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybnMge1JlY3RhbmdsZX0gVGhhdCBpcyBlbmxhcmdlZC9zaHJ1bmsgYnkgZ2l2ZW4gYHBhZGRpbmdgLlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gcGFkZGluZyAtIEFtb3VudCBieSB3aGljaCB0byBkZWNyZWFzZSAoKykgb3IgaW5jcmVhc2UgKC0pIHRoaXMgcmVjdC5cbiAgICAgICAgICogQHNlZSBUaGUge0BsaW5rIFJlY3RhbmdsZSNncm93Qnl8Z3Jvd0J5fSBtZXRob2QuXG4gICAgICAgICAqIEBtZW1iZXJPZiBSZWN0YW5nbGUucHJvdG90eXBlXG4gICAgICAgICAqL1xuICAgICAgICBzaHJpbmtCeTogZnVuY3Rpb24ocGFkZGluZykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ3Jvd0J5KC1wYWRkaW5nKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHJldHVybnMge1JlY3RhbmdsZX0gQm91bmRpbmcgcmVjdCB0aGF0IGNvbnRhaW5zIGJvdGggdGhpcyByZWN0IGFuZCB0aGUgZ2l2ZW4gYHJlY3RgLlxuICAgICAgICAgKiBAcGFyYW0ge1JlY3RhbmdsZX0gcmVjdCAtIFRoZSByZWN0YW5nbGUgdG8gdW5pb24gd2l0aCB0aGlzIHJlY3QuXG4gICAgICAgICAqIEBtZW1iZXJPZiBSZWN0YW5nbGUucHJvdG90eXBlXG4gICAgICAgICAqL1xuICAgICAgICB1bmlvbjogZnVuY3Rpb24ocmVjdCkge1xuICAgICAgICAgICAgdmFyIG9yaWdpbiA9IHRoaXMub3JpZ2luLm1pbihyZWN0Lm9yaWdpbiksXG4gICAgICAgICAgICAgICAgY29ybmVyID0gdGhpcy5jb3JuZXIubWF4KHJlY3QuY29ybmVyKSxcbiAgICAgICAgICAgICAgICBleHRlbnQgPSBjb3JuZXIubWludXMob3JpZ2luKTtcblxuICAgICAgICAgICAgcmV0dXJuIG5ldyBSZWN0YW5nbGUoXG4gICAgICAgICAgICAgICAgb3JpZ2luLngsIG9yaWdpbi55LFxuICAgICAgICAgICAgICAgIGV4dGVudC54LCBleHRlbnQueVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogaXRlcmF0ZSBvdmVyIGFsbCBwb2ludHMgd2l0aGluIHRoaXMgcmVjdCwgaW52b2tpbmcgYGl0ZXJhdGVlYCBmb3IgZWFjaC5cbiAgICAgICAgICogQHBhcmFtIHtmdW5jdGlvbihudW1iZXIsbnVtYmVyKX0gaXRlcmF0ZWUgLSBGdW5jdGlvbiB0byBjYWxsIGZvciBlYWNoIHBvaW50LlxuICAgICAgICAgKiBCb3VuZCB0byBgY29udGV4dGAgd2hlbiBnaXZlbjsgb3RoZXJ3aXNlIGl0IGlzIGJvdW5kIHRvIHRoaXMgcmVjdC5cbiAgICAgICAgICogRWFjaCBpbnZvY2F0aW9uIG9mIGBpdGVyYXRlZWAgaXMgY2FsbGVkIHdpdGggdHdvIGFyZ3VtZW50czpcbiAgICAgICAgICogdGhlIGhvcml6b250YWwgYW5kIHZlcnRpY2FsIGNvb3JkaW5hdGVzIG9mIHRoZSBwb2ludC5cbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IFtjb250ZXh0PXRoaXNdIC0gQ29udGV4dCB0byBiaW5kIHRvIGBpdGVyYXRlZWAgKHdoZW4gbm90IGB0aGlzYCkuXG4gICAgICAgICAqIEBtZW1iZXJPZiBSZWN0YW5nbGUucHJvdG90eXBlXG4gICAgICAgICAqL1xuICAgICAgICBmb3JFYWNoOiBmdW5jdGlvbihpdGVyYXRlZSwgY29udGV4dCkge1xuICAgICAgICAgICAgY29udGV4dCA9IGNvbnRleHQgfHwgdGhpcztcbiAgICAgICAgICAgIGZvciAodmFyIHggPSB0aGlzLm9yaWdpbi54LCB4MiA9IHRoaXMuY29ybmVyLng7IHggPCB4MjsgeCsrKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgeSA9IHRoaXMub3JpZ2luLnksIHkyID0gdGhpcy5jb3JuZXIueTsgeSA8IHkyOyB5KyspIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlcmF0ZWUuY2FsbChjb250ZXh0LCB4LCB5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEByZXR1cm5zIHtSZWN0YW5nbGV9IE9uZSBvZjpcbiAgICAgICAgICogKiBfSWYgdGhpcyByZWN0IGludGVyc2VjdHMgd2l0aCB0aGUgZ2l2ZW4gYHJlY3RgOl9cbiAgICAgICAgICogICAgICBhIG5ldyByZWN0IHJlcHJlc2VudGluZyB0aGF0IGludGVyc2VjdGlvbi5cbiAgICAgICAgICogKiBfSWYgaXQgZG9lc24ndCBpbnRlcnNlY3QgYW5kIGBpZk5vbmVBY3Rpb25gIGRlZmluZWQ6X1xuICAgICAgICAgKiAgICAgIHJlc3VsdCBvZiBjYWxsaW5nIGBpZk5vbmVBY3Rpb25gLlxuICAgICAgICAgKiAqIF9JZiBpdCBkb2Vzbid0IGludGVyc2VjdCBhbmQgYGlmTm9uZUFjdGlvbmAgdW5kZWZpbmVkOl9cbiAgICAgICAgICogICAgICBgbnVsbGAuXG4gICAgICAgICAqIEBwYXJhbSB7UmVjdGFuZ2xlfSByZWN0IC0gVGhlIHJlY3RhbmdsZSB0byBpbnRlcnNlY3Qgd2l0aCB0aGlzIHJlY3QuXG4gICAgICAgICAqIEBwYXJhbSB7ZnVuY3Rpb24oUmVjdGFuZ2xlKX0gW2lmTm9uZUFjdGlvbl0gLSBXaGVuIG5vIGludGVyc2VjdGlvbiwgaW52b2tlIGFuZCByZXR1cm4gcmVzdWx0LlxuICAgICAgICAgKiBCb3VuZCB0byBgY29udGV4dGAgd2hlbiBnaXZlbjsgb3RoZXJ3aXNlIGJvdW5kIHRvIHRoaXMgcmVjdC5cbiAgICAgICAgICogSW52b2tlZCB3aXRoIGByZWN0YCBhcyBzb2xlIHBhcmFtZXRlci5cbiAgICAgICAgICogQHBhcmFtIHtvYmplY3R9IFtjb250ZXh0PXRoaXNdIC0gQ29udGV4dCB0byBiaW5kIHRvIGBpZk5vbmVBY3Rpb25gICh3aGVuIG5vdCBgdGhpc2ApLlxuICAgICAgICAgKiBAbWVtYmVyT2YgUmVjdGFuZ2xlLnByb3RvdHlwZVxuICAgICAgICAgKi9cbiAgICAgICAgaW50ZXJzZWN0OiBmdW5jdGlvbihyZWN0LCBpZk5vbmVBY3Rpb24sIGNvbnRleHQpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBudWxsLFxuICAgICAgICAgICAgICAgIG9yaWdpbiA9IHRoaXMub3JpZ2luLm1heChyZWN0Lm9yaWdpbiksXG4gICAgICAgICAgICAgICAgY29ybmVyID0gdGhpcy5jb3JuZXIubWluKHJlY3QuY29ybmVyKSxcbiAgICAgICAgICAgICAgICBleHRlbnQgPSBjb3JuZXIubWludXMob3JpZ2luKTtcblxuICAgICAgICAgICAgaWYgKGV4dGVudC54ID4gMCAmJiBleHRlbnQueSA+IDApIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBuZXcgUmVjdGFuZ2xlKFxuICAgICAgICAgICAgICAgICAgICBvcmlnaW4ueCwgb3JpZ2luLnksXG4gICAgICAgICAgICAgICAgICAgIGV4dGVudC54LCBleHRlbnQueVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBpZk5vbmVBY3Rpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBpZk5vbmVBY3Rpb24uY2FsbChjb250ZXh0IHx8IHRoaXMsIHJlY3QpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmZiB0aGlzIHJlY3Qgb3ZlcmxhcHMgd2l0aCBnaXZlbiBgcmVjdGAuXG4gICAgICAgICAqIEBwYXJhbSB7UmVjdGFuZ2xlfSByZWN0IC0gVGhlIHJlY3RhbmdsZSB0byBpbnRlcnNlY3Qgd2l0aCB0aGlzIHJlY3QuXG4gICAgICAgICAqIEBtZW1iZXJPZiBSZWN0YW5nbGUucHJvdG90eXBlXG4gICAgICAgICAqL1xuICAgICAgICBpbnRlcnNlY3RzOiBmdW5jdGlvbihyZWN0KSB7XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIHJlY3QuY29ybmVyLnggPiB0aGlzLm9yaWdpbi54ICYmXG4gICAgICAgICAgICAgICAgcmVjdC5jb3JuZXIueSA+IHRoaXMub3JpZ2luLnkgJiZcbiAgICAgICAgICAgICAgICByZWN0Lm9yaWdpbi54IDwgdGhpcy5jb3JuZXIueCAmJlxuICAgICAgICAgICAgICAgIHJlY3Qub3JpZ2luLnkgPCB0aGlzLmNvcm5lci55XG4gICAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIEludGVyZmFjZVxuICAgIGV4cG9ydHMuUG9pbnQgPSBQb2ludDtcbiAgICBleHBvcnRzLlJlY3RhbmdsZSA9IFJlY3RhbmdsZTtcbn0pKFxuICAgIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIG1vZHVsZSB8fCAod2luZG93LnJlY3Rhbmd1bGFyID0ge30pLFxuICAgIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzIHx8ICh3aW5kb3cucmVjdGFuZ3VsYXIuZXhwb3J0cyA9IHt9KVxuKSB8fCAoXG4gICAgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgfHwgKHdpbmRvdy5yZWN0YW5ndWxhciA9IHdpbmRvdy5yZWN0YW5ndWxhci5leHBvcnRzKVxuKTtcblxuLyogQWJvdXQgdGhlIGFib3ZlIElJRkU6XG4gKiBUaGlzIGZpbGUgaXMgYSBcIm1vZGlmaWVkIG5vZGUgbW9kdWxlLlwiIEl0IGZ1bmN0aW9ucyBhcyB1c3VhbCBpbiBOb2RlLmpzICphbmQqIGlzIGFsc28gdXNhYmxlIGRpcmVjdGx5IGluIHRoZSBicm93c2VyLlxuICogMS4gTm9kZS5qczogVGhlIElJRkUgaXMgc3VwZXJmbHVvdXMgYnV0IGlubm9jdW91cy5cbiAqIDIuIEluIHRoZSBicm93c2VyOiBUaGUgSUlGRSBjbG9zdXJlIHNlcnZlcyB0byBrZWVwIGludGVybmFsIGRlY2xhcmF0aW9ucyBwcml2YXRlLlxuICogMi5hLiBJbiB0aGUgYnJvd3NlciBhcyBhIGdsb2JhbDogVGhlIGxvZ2ljIGluIHRoZSBhY3R1YWwgcGFyYW1ldGVyIGV4cHJlc3Npb25zICsgdGhlIHBvc3QtaW52b2NhdGlvbiBleHByZXNzaW9uXG4gKiB3aWxsIHB1dCB5b3VyIEFQSSBpbiBgd2luZG93LnJlY3Rhbmd1bGFyYC5cbiAqIDIuYi4gSW4gdGhlIGJyb3dzZXIgYXMgYSBtb2R1bGU6IElmIHlvdSBwcmVkZWZpbmUgYSBgd2luZG93Lm1vZHVsZWAgb2JqZWN0LCB0aGUgcmVzdWx0cyB3aWxsIGJlIGluIGBtb2R1bGUuZXhwb3J0c2AuXG4gKiBUaGUgYm93ZXIgY29tcG9uZW50IGBtbm1gIG1ha2VzIHRoaXMgZWFzeSBhbmQgYWxzbyBwcm92aWRlcyBhIGdsb2JhbCBgcmVxdWlyZSgpYCBmdW5jdGlvbiBmb3IgcmVmZXJlbmNpbmcgeW91ciBtb2R1bGVcbiAqIGZyb20gb3RoZXIgY2xvc3VyZXMuIEluIGVpdGhlciBjYXNlLCB0aGlzIHdvcmtzIHdpdGggYm90aCBOb2RlSnMtc3R5bGUgZXhwb3J0IG1lY2hhbmlzbXMgLS0gYSBzaW5nbGUgQVBJIGFzc2lnbm1lbnQsXG4gKiBgbW9kdWxlLmV4cG9ydHMgPSB5b3VyQVBJYCAqb3IqIGEgc2VyaWVzIG9mIGluZGl2aWR1YWwgcHJvcGVydHkgYXNzaWdubWVudHMsIGBtb2R1bGUuZXhwb3J0cy5wcm9wZXJ0eSA9IHByb3BlcnR5YC5cbiAqXG4gKiBCZWZvcmUgdGhlIElJRkUgcnVucywgdGhlIGFjdHVhbCBwYXJhbWV0ZXIgZXhwcmVzc2lvbnMgYXJlIGV4ZWN1dGVkOlxuICogMS4gSWYgYHdpbmRvd2Agb2JqZWN0IHVuZGVmaW5lZCwgd2UncmUgaW4gTm9kZUpzIHNvIGFzc3VtZSB0aGVyZSBpcyBhIGBtb2R1bGVgIG9iamVjdCB3aXRoIGFuIGBleHBvcnRzYCBwcm9wZXJ0eVxuICogMi4gSWYgYHdpbmRvd2Agb2JqZWN0IGRlZmluZWQsIHdlJ3JlIGluIGJyb3dzZXJcbiAqIDIuYS4gSWYgYG1vZHVsZWAgb2JqZWN0IHByZWRlZmluZWQsIHVzZSBpdFxuICogMi5iLiBJZiBgbW9kdWxlYCBvYmplY3QgdW5kZWZpbmVkLCBjcmVhdGUgYSBgcmVjdGFuZ3VsYXJgIG9iamVjdFxuICpcbiAqIEFmdGVyIHRoZSBJSUZFIHJldHVybnM6XG4gKiBCZWNhdXNlIGl0IGFsd2F5cyByZXR1cm5zIHVuZGVmaW5lZCwgdGhlIGV4cHJlc3Npb24gYWZ0ZXIgdGhlIHx8IHdpbGwgZXhlY3V0ZTpcbiAqIDEuIElmIGB3aW5kb3dgIG9iamVjdCB1bmRlZmluZWQsIHRoZW4gd2UncmUgaW4gTm9kZUpzIHNvIHdlJ3JlIGRvbmVcbiAqIDIuIElmIGB3aW5kb3dgIG9iamVjdCBkZWZpbmVkLCB0aGVuIHdlJ3JlIGluIGJyb3dzZXJcbiAqIDIuYS4gSWYgYG1vZHVsZWAgb2JqZWN0IHByZWRlZmluZWQsIHdlJ3JlIGRvbmU7IHJlc3VsdHMgYXJlIGluIGBtb3VkdWxlLmV4cG9ydHNgXG4gKiAyLmIuIElmIGBtb2R1bGVgIG9iamVjdCB1bmRlZmluZWQsIHJlZGVmaW5lYHJlY3Rhbmd1bGFyYCB0byBiZSB0aGUgYHJlY3Rhbmd1bGFyLmV4cG9ydHNgIG9iamVjdFxuICovXG4iLCIndXNlIHN0cmljdCc7XG5cbi8qIGVzbGludC1lbnYgbm9kZSwgYnJvd3NlciAqL1xuXG4oZnVuY3Rpb24gKG1vZHVsZSkgeyAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtZXhwcmVzc2lvbnNcblxuICAgIC8vIFRoaXMgY2xvc3VyZSBzdXBwb3J0cyBOb2RlSlMtbGVzcyBjbGllbnQgc2lkZSBpbmNsdWRlcyB3aXRoIDxzY3JpcHQ+IHRhZ3MuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vam9uZWl0L21ubS5cblxuICAgIC8qKlxuICAgICAqIEBjb25zdHJ1Y3RvciBSYW5nZVNlbGVjdGlvbk1vZGVsXG4gICAgICpcbiAgICAgKiBAZGVzYyBUaGlzIG9iamVjdCBtb2RlbHMgc2VsZWN0aW9uIG9mIFwiY2VsbHNcIiB3aXRoaW4gYW4gYWJzdHJhY3Qgc2luZ2xlLWRpbWVuc2lvbmFsIG1hdHJpeC5cbiAgICAgKlxuICAgICAqIERpc2pvaW50IHNlbGVjdGlvbnMgY2FuIGJlIGJ1aWx0IHdpdGggY2FsbHMgdG8gdGhlIGZvbGxvd2luZyBtZXRob2RzOlxuICAgICAqICoge0BsaW5rIFJhbmdlU2VsZWN0aW9uTW9kZWwjc2VsZWN0fHNlbGVjdChzdGFydCwgc3RvcCl9IC0gQWRkIGEgcmFuZ2UgdG8gdGhlIG1hdHJpeC5cbiAgICAgKiAqIHtAbGluayBSYW5nZVNlbGVjdGlvbk1vZGVsI2Rlc2VsZWN0fGRlc2VsZWN0KHN0YXJ0LCBzdG9wKX0gLSBSZW1vdmUgYSByYW5nZSBmcm9tIHRoZSBtYXRyaXguXG4gICAgICpcbiAgICAgKiBUd28gbW9yZSBtZXRob2RzIGFyZSBhdmFpbGFibGU6XG4gICAgICogKiBUZXN0IGEgY2VsbCB0byBzZWUgaWYgaXQge0BsaW5rIFJhbmdlU2VsZWN0aW9uTW9kZWwjaXNTZWxlY3RlZHxpc1NlbGVjdGVkKGNlbGwpfVxuICAgICAqICoge0BsaW5rIFJhbmdlU2VsZWN0aW9uTW9kZWwjY2xlYXJ8Y2xlYXIoKX0gdGhlIG1hdHJpeFxuICAgICAqXG4gICAgICogSW50ZXJuYWxseSwgdGhlIHNlbGVjdGlvbiBpcyBydW4tbGVuZ3RoLWVuY29kZWQuIEl0IGlzIHRoZXJlZm9yZSBhIFwic3BhcnNlXCIgbWF0cml4XG4gICAgICogd2l0aCB1bmRlZmluZWQgYm91bmRzLiBBIHNpbmdsZSBkYXRhIHByb3BlcnR5IGNhbGxlZCBgc2VsZWN0aW9uYCBpcyBhbiBhcnJheSB0aGF0XG4gICAgICogY29udGFpbnMgYWxsIHRoZSBcInJ1bnNcIiAocmFuZ2VzKSBvZiBzZWxlY3RlZCBjZWxscyBhbGJlaXQgaW4gbm8gcGFydGljdWxhciBvcmRlci5cbiAgICAgKiBUaGlzIHByb3BlcnR5IHNob3VsZCBub3Qgbm9ybWFsbHkgbmVlZCB0byBiZSBhY2Nlc3NlZCBkaXJlY3RseS5cbiAgICAgKlxuICAgICAqIE5vdGU6IFRoaXMgb2JqZWN0IHNob3VsZCBiZSBpbnN0YW50aWF0ZWQgd2l0aCB0aGUgYG5ld2Aga2V5d29yZC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtSYW5nZVNlbGVjdGlvbk1vZGVsfSBTZWxmIChpLmUuLCBgdGhpc2Agb2JqZWN0KS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBSYW5nZVNlbGVjdGlvbk1vZGVsKCkge1xuICAgICAgICAvKipcbiAgICAgICAgICogQG5hbWUgc2VsZWN0aW9uXG4gICAgICAgICAqIEB0eXBlIHtBcnJheS5BcnJheS5udW1iZXJ9XG4gICAgICAgICAqIEBzdW1tYXJ5IFVub3JkZXJlZCBsaXN0IG9mIHJ1bnMuXG4gICAgICAgICAqIEBkZXNjIEEgXCJydW5cIiBpcyBkZWZpbmVkIGFzIGFuIEFycmF5KDIpIHdoZXJlOlxuICAgICAgICAgKiAqIGVsZW1lbnQgWzBdIGlzIHRoZSBiZWdpbm5pbmcgb2YgdGhlIHJ1blxuICAgICAgICAgKiAqIGVsZW1lbnQgWzFdIGlzIHRoZSBlbmQgb2YgdGhlIHJ1biAoaW5jbHVzaXZlKSBhbmQgaXMgYWx3YXlzID49IGVsZW1lbnQgWzBdXG4gICAgICAgICAqIFRoZSBvcmRlciBvZiB0aGUgcnVucyB3aXRoaW4gaXMgdW5kZWZpbmVkLlxuICAgICAgICAgKiBAbWVtYmVyT2YgUmFuZ2VTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGVcbiAgICAgICAgICogQGFic3RyYWN0XG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNlbGVjdGlvbiA9IFtdO1xuXG4gICAgICAgIC8vd2UgbmVlZCB0byBiZSBhYmxlIHRvIGdvIGJhY2sgaW4gdGltZVxuICAgICAgICAvL3RoZSBzdGF0ZXMgZmllbGRcbiAgICAgICAgdGhpcy5zdGF0ZXMgPSBbXTtcblxuICAgICAgICAvL2Nsb25lIGFuZCBzdG9yZSBteSBjdXJyZW50IHN0YXRlXG4gICAgICAgIC8vc28gd2UgY2FuIHVud2luZCBjaGFuZ2VzIGlmIG5lZWQgYmVcbiAgICAgICAgdGhpcy5zdG9yZVN0YXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHNlbHMgPSB0aGlzLnNlbGVjdGlvbjtcbiAgICAgICAgICAgIHZhciBzdGF0ZSA9IFtdO1xuICAgICAgICAgICAgdmFyIGNvcHk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjb3B5ID0gW10uY29uY2F0KHNlbHNbaV0pO1xuICAgICAgICAgICAgICAgIHN0YXRlLnB1c2goY29weSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnN0YXRlcy5wdXNoKHN0YXRlKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBSYW5nZVNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZSA9IHtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHN1bW1hcnkgQWRkIGEgY29udGlndW91cyBydW4gb2YgcG9pbnRzIHRvIHRoZSBzZWxlY3Rpb24uXG4gICAgICAgICAqIEBkZXNjIEluc2VydCBhIG5ldyBydW4gaW50byBgdGhpcy5zZWxlY3Rpb25gLlxuICAgICAgICAgKiBUaGUgbmV3IHJ1biB3aWxsIGJlIG1lcmdlZCB3aXRoIG92ZXJsYXBwaW5nIGFuZCBhZGphY2VudCBydW5zLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGUgdHdvIHBhcmFtZXRlcnMgbWF5IGJlIGdpdmVuIGluIGVpdGhlciBvcmRlci5cbiAgICAgICAgICogVGhlIHN0YXJ0IGFuZCBzdG9wIGVsZW1lbnRzIGluIHRoZSByZXN1bHRpbmcgcnVuIHdpbGwgaG93ZXZlciBhbHdheXMgYmUgb3JkZXJlZC5cbiAgICAgICAgICogKEhvd2V2ZXIsIG5vdGUgdGhhdCB0aGUgb3JkZXIgb2YgdGhlIHJ1bnMgd2l0aGluIGB0aGlzLnNlbGVjdGlvbmAgaXMgaXRzZWxmIGFsd2F5cyB1bm9yZGVyZWQuKVxuICAgICAgICAgKlxuICAgICAgICAgKiBOb3RlIHRoYXQgYHRoaXMuc2VsZWN0aW9uYCBpcyB1cGRhdGVkIGluIHBsYWNlLCBwcmVzZXJ2aW5nIHZhbGlkaXR5IG9mIGFueSBleHRlcm5hbCByZWZlcmVuY2VzLlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgLSBTdGFydCBvZiBydW4uIE1heSBiZSBncmVhdGVyIHRoYW4gYHN0b3BgLlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0b3A9c3RvcF0gLSBFbmQgb2YgcnVuIChpbmNsdXNpdmUpLiBNYXkgYmUgbGVzcyB0aGFuIGBzdGFydGAuXG4gICAgICAgICAqIEByZXR1cm5zIHtSYW5nZVNlbGVjdGlvbk1vZGVsfSBTZWxmIChpLmUuLCBgdGhpc2ApLCBmb3IgY2hhaW5pbmcuXG4gICAgICAgICAqIEBtZW1iZXJPZiBSYW5nZVNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZVxuICAgICAgICAgKi9cbiAgICAgICAgc2VsZWN0OiBmdW5jdGlvbiAoc3RhcnQsIHN0b3ApIHtcbiAgICAgICAgICAgIHRoaXMuc3RvcmVTdGF0ZSgpO1xuICAgICAgICAgICAgdmFyIHJ1biA9IG1ha2VSdW4oc3RhcnQsIHN0b3ApO1xuICAgICAgICAgICAgdmFyIHNwbGljZXIgPSBbMCwgMV07XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbi5mb3JFYWNoKGZ1bmN0aW9uIChlYWNoKSB7XG4gICAgICAgICAgICAgICAgaWYgKG92ZXJsYXBzKGVhY2gsIHJ1bikgfHwgYWJ1dHMoZWFjaCwgcnVuKSkge1xuICAgICAgICAgICAgICAgICAgICBydW4gPSBtZXJnZShlYWNoLCBydW4pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNwbGljZXIucHVzaChlYWNoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNwbGljZXIucHVzaChydW4pO1xuICAgICAgICAgICAgc3BsaWNlclsxXSA9IHRoaXMuc2VsZWN0aW9uLmxlbmd0aDtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uLnNwbGljZS5hcHBseSh0aGlzLnNlbGVjdGlvbiwgc3BsaWNlcik7IC8vIHVwZGF0ZSBpbiBwbGFjZSB0byBwcmVzZXJ2ZSBleHRlcm5hbCByZWZlcmVuY2VzXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHN1bW1hcnkgUmVtb3ZlIGEgY29udGlndW91cyBydW4gb2YgcG9pbnRzIGZyb20gdGhlIHNlbGVjdGlvbi5cbiAgICAgICAgICogQGRlc2MgVHJ1bmNhdGUgYW5kL29yIHJlbW92ZSBydW4ocykgZnJvbSBgdGhpcy5zZWxlY3Rpb25gLlxuICAgICAgICAgKiBSZW1vdmluZyBwYXJ0IG9mIGV4aXN0aW5nIHJ1bnMgd2lsbCAoY29ycmVjdGx5KSBzaG9ydGVuIHRoZW0gb3IgYnJlYWsgdGhlbSBpbnRvIHR3byBmcmFnbWVudHMuXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSB0d28gcGFyYW1ldGVycyBtYXkgYmUgZ2l2ZW4gaW4gZWl0aGVyIG9yZGVyLlxuICAgICAgICAgKlxuICAgICAgICAgKiBOb3RlIHRoYXQgYHRoaXMuc2VsZWN0aW9uYCBpcyB1cGRhdGVkIGluIHBsYWNlLCBwcmVzZXJ2aW5nIHZhbGlkaXR5IG9mIGFueSBleHRlcm5hbCByZWZlcmVuY2VzLlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgLSBTdGFydCBvZiBydW4uIE1heSBiZSBncmVhdGVyIHRoYW4gYHN0b3BgLlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0b3A9c3RvcF0gLSBFbmQgb2YgcnVuIChpbmNsdXNpdmUpLiBNYXkgYmUgbGVzcyB0aGFuIGBzdGFydGAuXG4gICAgICAgICAqIEByZXR1cm5zIHtSYW5nZVNlbGVjdGlvbk1vZGVsfSBTZWxmIChpLmUuLCBgdGhpc2ApLCBmb3IgY2hhaW5pbmcuXG4gICAgICAgICAqIEBtZW1iZXJPZiBSYW5nZVNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZVxuICAgICAgICAgKi9cbiAgICAgICAgZGVzZWxlY3Q6IGZ1bmN0aW9uIChzdGFydCwgc3RvcCkge1xuICAgICAgICAgICAgdmFyIHJ1biA9IG1ha2VSdW4oc3RhcnQsIHN0b3ApO1xuICAgICAgICAgICAgdmFyIHNwbGljZXIgPSBbMCwgMF07XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbi5mb3JFYWNoKGZ1bmN0aW9uIChlYWNoKSB7XG4gICAgICAgICAgICAgICAgaWYgKG92ZXJsYXBzKGVhY2gsIHJ1bikpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBpZWNlcyA9IHN1YnRyYWN0KGVhY2gsIHJ1bik7XG4gICAgICAgICAgICAgICAgICAgIHNwbGljZXIgPSBzcGxpY2VyLmNvbmNhdChwaWVjZXMpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNwbGljZXIucHVzaChlYWNoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNwbGljZXJbMV0gPSB0aGlzLnNlbGVjdGlvbi5sZW5ndGg7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbi5zcGxpY2UuYXBwbHkodGhpcy5zZWxlY3Rpb24sIHNwbGljZXIpOyAvLyB1cGRhdGUgaW4gcGxhY2UgdG8gcHJlc2VydmUgZXh0ZXJuYWwgcmVmZXJlbmNlc1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBzdW1tYXJ5IEVtcHRpZXMgYHRoaXMuc2VsZWN0aW9uYCwgZWZmZWN0aXZlbHkgcmVtb3ZpbmcgYWxsIHJ1bnMuXG4gICAgICAgICAqIEByZXR1cm5zIHtSYW5nZVNlbGVjdGlvbk1vZGVsfSBTZWxmIChpLmUuLCBgdGhpc2ApLCBmb3IgY2hhaW5pbmcuXG4gICAgICAgICAqIEBtZW1iZXJPZiBSYW5nZVNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZVxuICAgICAgICAgKi9cbiAgICAgICAgY2xlYXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhdGVzLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbi5sZW5ndGggPSAwO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH0sXG5cbiAgICAgICAgY2xlYXJNb3N0UmVjZW50U2VsZWN0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5zdGF0ZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zZWxlY3Rpb24gPSB0aGlzLnN0YXRlcy5wb3AoKTtcbiAgICAgICAgfSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHN1bW1hcnkgRGV0ZXJtaW5lcyBpZiB0aGUgZ2l2ZW4gYGNlbGxgIGlzIHNlbGVjdGVkLlxuICAgICAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gYHRydWVgIGlmZiBnaXZlbiBgY2VsbGAgaXMgd2l0aGluIGFueSBvZiB0aGUgcnVucyBpbiBgdGhpcy5zZWxlY3Rpb25gLlxuICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gY2VsbCAtIFRoZSBjZWxsIHRvIHRlc3QgZm9yIGluY2x1c2lvbiBpbiB0aGUgc2VsZWN0aW9uLlxuICAgICAgICAgKiBAbWVtYmVyT2YgUmFuZ2VTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGVcbiAgICAgICAgICovXG4gICAgICAgIGlzU2VsZWN0ZWQ6IGZ1bmN0aW9uIChjZWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3Rpb24uc29tZShmdW5jdGlvbiAoZWFjaCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBlYWNoWzBdIDw9IGNlbGwgJiYgY2VsbCA8PSBlYWNoWzFdO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG5cbiAgICAgICAgaXNFbXB0eTogZnVuY3Rpb24gKCl7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3Rpb24ubGVuZ3RoID09PSAwO1xuICAgICAgICB9LFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAc3VtbWFyeSBSZXR1cm4gdGhlIGluZGV4ZXMgdGhhdCBhcmUgc2VsZWN0ZWQuXG4gICAgICAgICAqIEBkZXNjIFJldHVybiB0aGUgaW5kZXhlcyB0aGF0IGFyZSBzZWxlY3RlZC5cbiAgICAgICAgICogQHJldHVybnMge0FycmF5LkFycmF5Lm51bWJlcn1cbiAgICAgICAgICogQG1lbWJlck9mIFJhbmdlU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlXG4gICAgICAgICAqL1xuICAgICAgICBnZXRTZWxlY3Rpb25zOiBmdW5jdGlvbiAoKXtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0aW9uLmZvckVhY2goZnVuY3Rpb24gKGVhY2gpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gZWFjaFswXTsgaSA8PSBlYWNoWzFdOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goaSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXN1bHQuc29ydChmdW5jdGlvbiAoYSwgYil7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGEgLSBiO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG5cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAc3VtbWFyeSBQcmVwcyBgc3RhcnRgIGFuZCBgc3RvcGAgcGFyYW1zIGludG8gb3JkZXIgYXJyYXlcbiAgICAgKiBAZnVuY3Rpb24gbWFrZVJ1blxuICAgICAqIEBkZXNjIFV0aWxpdHkgZnVuY3Rpb24gY2FsbGVkIGJ5IGJvdGggYHNlbGVjdCgpYCBhbmQgYGRlc2VsZWN0KClgLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfG51bWJlcltdfSBzdGFydCAtIFN0YXJ0IG9mIHJ1bi4gaWYgYXJyYXksIGBzdGFydGAgYW5kIGBzdG9wYCBhcmUgdGFrZW4gZnJvbSBmaXJzdCB0d28gZWxlbWVudHMuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdG9wPXN0YXJ0XSAtIEVuZCBvZiBydW4gKGluY2x1c2l2ZSkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWFrZVJ1bihzdGFydCwgc3RvcCkge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgc3RhcnQgaW5zdGFuY2VvZiBBcnJheVxuICAgICAgICAgICAgICAgID8gbWFrZVJ1bi5hcHBseSh0aGlzLCBzdGFydCkgLy8gZXh0cmFjdCBwYXJhbXMgZnJvbSBnaXZlbiBhcnJheVxuICAgICAgICAgICAgICAgIDogc3RvcCA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgPyBbIHN0YXJ0LCBzdGFydCBdIC8vIHNpbmdsZSBwYXJhbSBpcyBhIHJ1biB0aGF0IHN0b3BzIHdoZXJlIGl0IHN0YXJ0c1xuICAgICAgICAgICAgICAgIDogc3RhcnQgPD0gc3RvcFxuICAgICAgICAgICAgICAgID8gWyBzdGFydCwgc3RvcCBdXG4gICAgICAgICAgICAgICAgOiBbIHN0b3AsIHN0YXJ0IF0gLy8gcmV2ZXJzZSBkZXNjZW5kaW5nIHBhcmFtcyBpbnRvIGFzY2VuZGluZyBvcmRlclxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGZ1bmN0aW9uIG92ZXJsYXBzXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZmYgYHJ1bjFgIG92ZXJsYXBzIGBydW4yYFxuICAgICAqIEBzdW1tYXJ5IENvbXBhcmlzb24gb3BlcmF0b3IgdGhhdCBkZXRlcm1pbmVzIGlmIGdpdmVuIHJ1bnMgb3ZlcmxhcCB3aXRoIG9uZSBhbm90aGVyLlxuICAgICAqIEBkZXNjIEJvdGggcGFyYW1ldGVycyBhcmUgYXNzdW1lZCB0byBiZSBfb3JkZXJlZF8gYXJyYXlzLlxuICAgICAqXG4gICAgICogT3ZlcmxhcCBpcyBkZWZpbmVkIHRvIGluY2x1ZGUgdGhlIGNhc2Ugd2hlcmUgb25lIHJ1biBjb21wbGV0ZWx5IGNvbnRhaW5zIHRoZSBvdGhlci5cbiAgICAgKlxuICAgICAqIE5vdGU6IFRoaXMgb3BlcmF0b3IgaXMgY29tbXV0YXRpdmUuXG4gICAgICogQHBhcmFtIHtudW1iZXJbXX0gcnVuMSAtIGZpcnN0IHJ1blxuICAgICAqIEBwYXJhbSB7bnVtYmVyW119IHJ1bjIgLSBzZWNvbmQgcnVuXG4gICAgICovXG4gICAgZnVuY3Rpb24gb3ZlcmxhcHMocnVuMSwgcnVuMikge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgcnVuMVswXSA8PSBydW4yWzBdICYmIHJ1bjJbMF0gPD0gcnVuMVsxXSB8fCAvLyBydW4yJ3Mgc3RhcnQgaXMgd2l0aGluIHJ1bjEgT1IuLi5cbiAgICAgICAgICAgIHJ1bjFbMF0gPD0gcnVuMlsxXSAmJiBydW4yWzFdIDw9IHJ1bjFbMV0gfHwgLy8gcnVuMidzIHN0b3AgaXMgd2l0aGluIHJ1bjEgT1IuLi5cbiAgICAgICAgICAgIHJ1bjJbMF0gPCAgcnVuMVswXSAmJiBydW4xWzFdIDwgIHJ1bjJbMV0gICAgLy8gcnVuMiBjb21wbGV0ZWx5IGNvbnRhaW5zIHJ1bjFcbiAgICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBmdW5jdGlvbiBhYnV0c1xuICAgICAqIEBzdW1tYXJ5IENvbXBhcmlzb24gb3BlcmF0b3IgdGhhdCBkZXRlcm1pbmVzIGlmIGdpdmVuIHJ1bnMgYXJlIGNvbnNlY3V0aXZlIHdpdGggb25lIGFub3RoZXIuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IGB0cnVlYCBpZmYgYHJ1bjFgIGlzIGNvbnNlY3V0aXZlIHdpdGggYHJ1bjJgXG4gICAgICogQGRlc2MgQm90aCBwYXJhbWV0ZXJzIGFyZSBhc3N1bWVkIHRvIGJlIF9vcmRlcmVkXyBhcnJheXMuXG4gICAgICpcbiAgICAgKiBOb3RlOiBUaGlzIG9wZXJhdG9yIGlzIGNvbW11dGF0aXZlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyW119IHJ1bjEgLSBmaXJzdCBydW5cbiAgICAgKiBAcGFyYW0ge251bWJlcltdfSBydW4yIC0gc2Vjb25kIHJ1blxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFidXRzKHJ1bjEsIHJ1bjIpIHtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIHJ1bjFbMV0gPT09IHJ1bjJbMF0gLSAxIHx8IC8vIHJ1bjEncyB0b3AgaW1tZWRpYXRlbHkgcHJlY2VkZXMgcnVuMidzIHN0YXJ0IE9SLi4uXG4gICAgICAgICAgICBydW4yWzFdID09PSBydW4xWzBdIC0gMSAgICAvLyBydW4yJ3MgdG9wIGltbWVkaWF0ZWx5IHByZWNlZGVzIHJ1bjEncyBzdGFydFxuICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGZ1bmN0aW9uIHN1YnRyYWN0XG4gICAgICogQHN1bW1hcnkgT3BlcmF0b3IgdGhhdCBzdWJ0cmFjdHMgb25lIHJ1biBmcm9tIGFub3RoZXIuXG4gICAgICogQHJldHVybnMge0FycmF5LkFycmF5Lm51bWJlcn0gVGhlIHJlbWFpbmluZyBwaWVjZXMgb2YgYG1pbnVlbmRgIGFmdGVyIHJlbW92aW5nIGBzdWJ0cmFoZW5kYC5cbiAgICAgKiBAZGVzYyBCb3RoIHBhcmFtZXRlcnMgYXJlIGFzc3VtZWQgdG8gYmUgX29yZGVyZWRfIGFycmF5cy5cbiAgICAgKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gX2RvZXMgbm90IGFzc3VtZXNfIHRoYXQgYG92ZXJsYXAoKWAgaGFzIGFscmVhZHkgYmVlbiBjYWxsZWQgd2l0aCB0aGUgc2FtZSBydW5zIGFuZCBoYXMgcmV0dXJuZWQgYHRydWVgLlxuICAgICAqXG4gICAgICogUmV0dXJuZWQgYXJyYXkgY29udGFpbnMgMCwgMSwgb3IgMiBydW5zIHdoaWNoIGFyZSB0aGUgcG9ydGlvbihzKSBvZiBgbWludWVuZGAgdGhhdCBkbyBfbm90XyBpbmNsdWRlIGBzdWJ0cmFoZW5kYC5cbiAgICAgKlxuICAgICAqIENhdmVhdDogVGhpcyBvcGVyYXRvciBpcyAqbm90KiBjb21tdXRhdGl2ZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcltdfSBtaW51ZW5kIC0gYSBydW4gZnJvbSB3aGljaCB0byBcInN1YnRyYWN0XCIgYHN1YnRyYWhlbmRgXG4gICAgICogQHBhcmFtIHtudW1iZXJbXX0gc3VidHJhaGVuZCAtIGEgcnVuIHRvIFwic3VidHJhY3RlZFwiIGZyb20gYG1pbnVlbmRgXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3VidHJhY3QobWludWVuZCwgc3VidHJhaGVuZCkge1xuICAgICAgICB2YXIgbTAgPSBtaW51ZW5kWzBdO1xuICAgICAgICB2YXIgbTEgPSBtaW51ZW5kWzFdO1xuICAgICAgICB2YXIgczAgPSBzdWJ0cmFoZW5kWzBdO1xuICAgICAgICB2YXIgczEgPSBzdWJ0cmFoZW5kWzFdO1xuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICAgICAgaWYgKHMwIDw9IG0wICYmIHMxIDwgbTEpIHtcbiAgICAgICAgICAgIC8vc3VidHJhaGVuZCBleHRlbmRzIGJlZm9yZSBtaW51ZW5kOiByZXR1cm4gcmVtYWluaW5nIHBpZWNlIG9mIGBtaW51ZW5kYFxuICAgICAgICAgICAgcmVzdWx0LnB1c2goW3MxICsgMSwgbTFdKTtcbiAgICAgICAgfSBlbHNlIGlmIChzMCA+IG0wICYmIHMxID49IG0xKSB7XG4gICAgICAgICAgICAvL3N1YnRyYWhlbmQgZXh0ZW5kcyBhZnRlciBtaW51ZW5kOiByZXR1cm4gcmVtYWluaW5nIHBpZWNlIG9mIGBtaW51ZW5kYFxuICAgICAgICAgICAgcmVzdWx0LnB1c2goW20wLCBzMCAtIDFdKTtcbiAgICAgICAgfSBlbHNlIGlmIChtMCA8IHMwICYmIHMxIDwgbTEpIHtcbiAgICAgICAgICAgIC8vY29tcGxldGVseSBpbnNpZGU6IHJldHVybiAyIHNtYWxsZXIgcGllY2VzIHJlc3VsdGluZyBmcm9tIHRoZSBob2xlXG4gICAgICAgICAgICByZXN1bHQucHVzaChbbTAsIHMwIC0gMV0pO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goW3MxICsgMSwgbTFdKTtcbiAgICAgICAgfSBlbHNlIGlmIChzMSA8IG0wIHx8IHMwID4gbTEpIHtcbiAgICAgICAgICAgIC8vIGNvbXBsZXRlbHkgb3V0c2lkZTogcmV0dXJuIGBtaW51ZW5kYCB1bnRvdWNoZWRcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKG1pbnVlbmQpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9lbHNlIHN1YnRyYWhlbmQgbXVzdCBjb21wbGV0ZWx5IG92ZXJsYXAgbWludWVuZCBzbyByZXR1cm4gbm8gcGllY2VzXG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cblxuICAgIC8vIExvY2FsIHV0aWxpdHkgZnVuY3Rpb25zXG5cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBmdW5jdGlvbiBtZXJnZVxuICAgICAqIEBzdW1tYXJ5IE9wZXJhdG9yIHRoYXQgbWVyZ2VzIGdpdmVuIHJ1bnMuXG4gICAgICogQHJldHVybnMge251bWJlcltdfSBBIHNpbmdsZSBtZXJnZWQgcnVuLlxuICAgICAqIEBkZXNjIEJvdGggcGFyYW1ldGVycyBhcmUgYXNzdW1lZCB0byBiZSBfb3JkZXJlZF8gYXJyYXlzLlxuICAgICAqXG4gICAgICogVGhlIHJ1bnMgYXJlIGFzc3VtZWQgdG8gYmUgb3ZlcmxhcHBpbmcgb3IgYWRqYWNlbnQgdG8gb25lIGFub3RoZXIuXG4gICAgICpcbiAgICAgKiBOb3RlOiBUaGlzIG9wZXJhdG9yIGlzIGNvbW11dGF0aXZlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyW119IHJ1bjEgLSBhIHJ1biB0byBtZXJnZSB3aXRoIGBydW4yYFxuICAgICAqIEBwYXJhbSB7bnVtYmVyW119IHJ1bjIgLSBhIHJ1biB0byBtZXJnZSB3aXRoIGBydW4xYFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1lcmdlKHJ1bjEsIHJ1bjIpIHtcbiAgICAgICAgdmFyIG1pbiA9IE1hdGgubWluKE1hdGgubWluLmFwcGx5KE1hdGgsIHJ1bjEpLCBNYXRoLm1pbi5hcHBseShNYXRoLCBydW4yKSk7XG4gICAgICAgIHZhciBtYXggPSBNYXRoLm1heChNYXRoLm1heC5hcHBseShNYXRoLCBydW4xKSwgTWF0aC5tYXguYXBwbHkoTWF0aCwgcnVuMikpO1xuICAgICAgICByZXR1cm4gW21pbiwgbWF4XTtcbiAgICB9XG5cbiAgICAvLyBJbnRlcmZhY2VcbiAgICBtb2R1bGUuZXhwb3J0cyA9IFJhbmdlU2VsZWN0aW9uTW9kZWw7XG59KShcbiAgICB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiBtb2R1bGUgfHwgKHdpbmRvdy5SYW5nZVNlbGVjdGlvbk1vZGVsID0ge30pLFxuICAgIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzIHx8ICh3aW5kb3cuUmFuZ2VTZWxlY3Rpb25Nb2RlbC5leHBvcnRzID0ge30pXG4pIHx8IChcbiAgICB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyB8fCAod2luZG93LlJhbmdlU2VsZWN0aW9uTW9kZWwgPSB3aW5kb3cuUmFuZ2VTZWxlY3Rpb25Nb2RlbC5leHBvcnRzKVxuKTtcblxuLyogQWJvdXQgdGhlIGFib3ZlIElJRkU6XG4gKiBUaGlzIGZpbGUgaXMgYSBcIm1vZGlmaWVkIG5vZGUgbW9kdWxlLlwiIEl0IGZ1bmN0aW9ucyBhcyB1c3VhbCBpbiBOb2RlLmpzICphbmQqIGlzIGFsc28gdXNhYmxlIGRpcmVjdGx5IGluIHRoZSBicm93c2VyLlxuICogMS4gTm9kZS5qczogVGhlIElJRkUgaXMgc3VwZXJmbHVvdXMgYnV0IGlubm9jdW91cy5cbiAqIDIuIEluIHRoZSBicm93c2VyOiBUaGUgSUlGRSBjbG9zdXJlIHNlcnZlcyB0byBrZWVwIGludGVybmFsIGRlY2xhcmF0aW9ucyBwcml2YXRlLlxuICogMi5hLiBJbiB0aGUgYnJvd3NlciBhcyBhIGdsb2JhbDogVGhlIGxvZ2ljIGluIHRoZSBhY3R1YWwgcGFyYW1ldGVyIGV4cHJlc3Npb25zICsgdGhlIHBvc3QtaW52b2NhdGlvbiBleHByZXNzaW9uXG4gKiB3aWxsIHB1dCB5b3VyIEFQSSBpbiBgd2luZG93LlJhbmdlU2VsZWN0aW9uTW9kZWxgLlxuICogMi5iLiBJbiB0aGUgYnJvd3NlciBhcyBhIG1vZHVsZTogSWYgeW91IHByZWRlZmluZSBhIGB3aW5kb3cubW9kdWxlYCBvYmplY3QsIHRoZSByZXN1bHRzIHdpbGwgYmUgaW4gYG1vZHVsZS5leHBvcnRzYC5cbiAqIFRoZSBib3dlciBjb21wb25lbnQgYG1ubWAgbWFrZXMgdGhpcyBlYXN5IGFuZCBhbHNvIHByb3ZpZGVzIGEgZ2xvYmFsIGByZXF1aXJlKClgIGZ1bmN0aW9uIGZvciByZWZlcmVuY2luZyB5b3VyIG1vZHVsZVxuICogZnJvbSBvdGhlciBjbG9zdXJlcy4gSW4gZWl0aGVyIGNhc2UsIHRoaXMgd29ya3Mgd2l0aCBib3RoIE5vZGVKcy1zdHlsZSBleHBvcnQgbWVjaGFuaXNtcyAtLSBhIHNpbmdsZSBBUEkgYXNzaWdubWVudCxcbiAqIGBtb2R1bGUuZXhwb3J0cyA9IHlvdXJBUElgICpvciogYSBzZXJpZXMgb2YgaW5kaXZpZHVhbCBwcm9wZXJ0eSBhc3NpZ25tZW50cywgYG1vZHVsZS5leHBvcnRzLnByb3BlcnR5ID0gcHJvcGVydHlgLlxuICpcbiAqIEJlZm9yZSB0aGUgSUlGRSBydW5zLCB0aGUgYWN0dWFsIHBhcmFtZXRlciBleHByZXNzaW9ucyBhcmUgZXhlY3V0ZWQ6XG4gKiAxLiBJZiBgd2luZG93YCBvYmplY3QgdW5kZWZpbmVkLCB3ZSdyZSBpbiBOb2RlSnMgc28gYXNzdW1lIHRoZXJlIGlzIGEgYG1vZHVsZWAgb2JqZWN0IHdpdGggYW4gYGV4cG9ydHNgIHByb3BlcnR5XG4gKiAyLiBJZiBgd2luZG93YCBvYmplY3QgZGVmaW5lZCwgd2UncmUgaW4gYnJvd3NlclxuICogMi5hLiBJZiBgbW9kdWxlYCBvYmplY3QgcHJlZGVmaW5lZCwgdXNlIGl0XG4gKiAyLmIuIElmIGBtb2R1bGVgIG9iamVjdCB1bmRlZmluZWQsIGNyZWF0ZSBhIGBSYW5nZVNlbGVjdGlvbk1vZGVsYCBvYmplY3RcbiAqXG4gKiBBZnRlciB0aGUgSUlGRSByZXR1cm5zOlxuICogQmVjYXVzZSBpdCBhbHdheXMgcmV0dXJucyB1bmRlZmluZWQsIHRoZSBleHByZXNzaW9uIGFmdGVyIHRoZSB8fCB3aWxsIGV4ZWN1dGU6XG4gKiAxLiBJZiBgd2luZG93YCBvYmplY3QgdW5kZWZpbmVkLCB0aGVuIHdlJ3JlIGluIE5vZGVKcyBzbyB3ZSdyZSBkb25lXG4gKiAyLiBJZiBgd2luZG93YCBvYmplY3QgZGVmaW5lZCwgdGhlbiB3ZSdyZSBpbiBicm93c2VyXG4gKiAyLmEuIElmIGBtb2R1bGVgIG9iamVjdCBwcmVkZWZpbmVkLCB3ZSdyZSBkb25lOyByZXN1bHRzIGFyZSBpbiBgbW91ZHVsZS5leHBvcnRzYFxuICogMi5iLiBJZiBgbW9kdWxlYCBvYmplY3QgdW5kZWZpbmVkLCByZWRlZmluZWBSYW5nZVNlbGVjdGlvbk1vZGVsYCB0byBiZSB0aGUgYFJhbmdlU2VsZWN0aW9uTW9kZWwuZXhwb3J0c2Agb2JqZWN0XG4gKi9cbiIsIi8vIHRlbXBsZXggbm9kZSBtb2R1bGVcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9qb25laXQvdGVtcGxleFxuXG4vKiBlc2xpbnQtZW52IG5vZGUsIGJyb3dzZXIgKi8gLy90byBhbGxvdyByZWZzIHRvIGB3aW5kb3dgIGluIElJRkUncyBjYWxsJ3MgYWN0dWFsIHBhcmFtc1xuXG4oZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC1leHByZXNzaW9ucywgbm8tdW51c2VkLXZhcnNcblxuICAgIC8vIFRoaXMgY2xvc3VyZSBzdXBwb3J0cyBOb2RlSlMtbGVzcyBjbGllbnQgc2lkZSBpbmNsdWRlcyB3aXRoIDxzY3JpcHQ+IHRhZ3MuIFNlZSBub3RlcyBhdCBib3R0b20gb2YgdGhpcyBmaWxlLlxuXG4gICAgLyoqXG4gICAgICogTWVyZ2VzIHZhbHVlcyBvZiBleGVjdXRpb24gY29udGV4dCBwcm9wZXJ0aWVzIG5hbWVkIGluIHRlbXBsYXRlIGJ5IHtwcm9wMX0sXG4gICAgICoge3Byb3AyfSwgZXRjLiwgb3IgYW55IGphdmFzY3JpcHQgZXhwcmVzc2lvbiBpbmNvcnBvcmF0aW5nIHN1Y2ggcHJvcCBuYW1lcy5cbiAgICAgKiBUaGUgY29udGV4dCBhbHdheXMgaW5jbHVkZXMgdGhlIGdsb2JhbCBvYmplY3QuIEluIGFkZGl0aW9uIHlvdSBjYW4gc3BlY2lmeSBhIHNpbmdsZVxuICAgICAqIGNvbnRleHQgb3IgYW4gYXJyYXkgb2YgY29udGV4dHMgdG8gc2VhcmNoIChpbiB0aGUgb3JkZXIgZ2l2ZW4pIGJlZm9yZSBmaW5hbGx5XG4gICAgICogc2VhcmNoaW5nIHRoZSBnbG9iYWwgY29udGV4dC5cbiAgICAgKlxuICAgICAqIE1lcmdlIGV4cHJlc3Npb25zIGNvbnNpc3Rpbmcgb2Ygc2ltcGxlIG51bWVyaWMgdGVybXMsIHN1Y2ggYXMgezB9LCB7MX0sIGV0Yy4sIGRlcmVmXG4gICAgICogdGhlIGZpcnN0IGNvbnRleHQgZ2l2ZW4sIHdoaWNoIGlzIGFzc3VtZWQgdG8gYmUgYW4gYXJyYXkuIEFzIGEgY29udmVuaWVuY2UgZmVhdHVyZSxcbiAgICAgKiBpZiBhZGRpdGlvbmFsIGFyZ3MgYXJlIGdpdmVuIGFmdGVyIGB0ZW1wbGF0ZWAsIGBhcmd1bWVudHNgIGlzIHVuc2hpZnRlZCBvbnRvIHRoZSBjb250ZXh0XG4gICAgICogYXJyYXksIHRodXMgbWFraW5nIGZpcnN0IGFkZGl0aW9uYWwgYXJnIGF2YWlsYWJsZSBhcyB7MX0sIHNlY29uZCBhcyB7Mn0sIGV0Yy4sIGFzIGluXG4gICAgICogYHRlbXBsZXgoJ0hlbGxvLCB7MX0hJywgJ1dvcmxkJylgLiAoezB9IGlzIHRoZSB0ZW1wbGF0ZSBzbyBjb25zaWRlciB0aGlzIHRvIGJlIDEtYmFzZWQuKVxuICAgICAqXG4gICAgICogSWYgeW91IHByZWZlciBzb21ldGhpbmcgb3RoZXIgdGhhbiBicmFjZXMsIHJlZGVmaW5lIGB0ZW1wbGV4LnJlZ2V4cGAuXG4gICAgICpcbiAgICAgKiBTZWUgdGVzdHMgZm9yIGV4YW1wbGVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRlbXBsYXRlXG4gICAgICogQHBhcmFtIHsuLi5zdHJpbmd9IFthcmdzXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRlbXBsZXgodGVtcGxhdGUpIHtcbiAgICAgICAgdmFyIGNvbnRleHRzID0gdGhpcyBpbnN0YW5jZW9mIEFycmF5ID8gdGhpcyA6IFt0aGlzXTtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7IGNvbnRleHRzLnVuc2hpZnQoYXJndW1lbnRzKTsgfVxuICAgICAgICByZXR1cm4gdGVtcGxhdGUucmVwbGFjZSh0ZW1wbGV4LnJlZ2V4cCwgdGVtcGxleC5tZXJnZXIuYmluZChjb250ZXh0cykpO1xuICAgIH1cblxuICAgIHRlbXBsZXgucmVnZXhwID0gL1xceyguKj8pXFx9L2c7XG5cbiAgICB0ZW1wbGV4LndpdGggPSBmdW5jdGlvbiAoaSwgcykge1xuICAgICAgICByZXR1cm4gJ3dpdGgodGhpc1snICsgaSArICddKXsnICsgcyArICd9JztcbiAgICB9O1xuXG4gICAgdGVtcGxleC5jYWNoZSA9IFtdO1xuXG4gICAgdGVtcGxleC5kZXJlZiA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgaWYgKCEodGhpcy5sZW5ndGggaW4gdGVtcGxleC5jYWNoZSkpIHtcbiAgICAgICAgICAgIHZhciBjb2RlID0gJ3JldHVybiBldmFsKGV4cHIpJztcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgY29kZSA9IHRlbXBsZXgud2l0aChpLCBjb2RlKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGVtcGxleC5jYWNoZVt0aGlzLmxlbmd0aF0gPSBldmFsKCcoZnVuY3Rpb24oZXhwcil7JyArIGNvZGUgKyAnfSknKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1ldmFsXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRlbXBsZXguY2FjaGVbdGhpcy5sZW5ndGhdLmNhbGwodGhpcywga2V5KTtcbiAgICB9O1xuXG4gICAgdGVtcGxleC5tZXJnZXIgPSBmdW5jdGlvbiAobWF0Y2gsIGtleSkge1xuICAgICAgICAvLyBBZHZhbmNlZCBmZWF0dXJlczogQ29udGV4dCBjYW4gYmUgYSBsaXN0IG9mIGNvbnRleHRzIHdoaWNoIGFyZSBzZWFyY2hlZCBpbiBvcmRlci5cbiAgICAgICAgdmFyIHJlcGxhY2VtZW50O1xuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXBsYWNlbWVudCA9IGlzTmFOKGtleSkgPyB0ZW1wbGV4LmRlcmVmLmNhbGwodGhpcywga2V5KSA6IHRoaXNbMF1ba2V5XTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgcmVwbGFjZW1lbnQgPSAneycgKyBrZXkgKyAnfSc7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcmVwbGFjZW1lbnQ7XG4gICAgfTtcblxuICAgIC8vIHRoaXMgaW50ZXJmYWNlIGNvbnNpc3RzIHNvbGVseSBvZiB0aGUgdGVtcGxleCBmdW5jdGlvbiBvYmplY3RcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHRlbXBsZXg7XG5cbn0pKFxuICAgIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIG1vZHVsZSB8fCAod2luZG93LnRlbXBsZXggPSB7fSksXG4gICAgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgbW9kdWxlLmV4cG9ydHMgfHwgKHdpbmRvdy50ZW1wbGV4LmV4cG9ydHMgPSB7fSlcbikgfHwgKFxuICAgIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnIHx8ICh3aW5kb3cudGVtcGxleCA9IHdpbmRvdy50ZW1wbGV4LmV4cG9ydHMpXG4pO1xuXG4vKiBBYm91dCB0aGUgYWJvdmUgSUlGRTpcbiAqIFRoaXMgZmlsZSBpcyBhIFwibW9kaWZpZWQgbm9kZSBtb2R1bGUuXCIgSXQgZnVuY3Rpb25zIGFzIHVzdWFsIGluIE5vZGUuanMgKmFuZCogaXMgYWxzbyB1c2FibGUgZGlyZWN0bHkgaW4gdGhlIGJyb3dzZXIuXG4gKiAxLiBOb2RlLmpzOiBUaGUgSUlGRSBpcyBzdXBlcmZsdW91cyBidXQgaW5ub2N1b3VzLlxuICogMi4gSW4gdGhlIGJyb3dzZXI6IFRoZSBJSUZFIGNsb3N1cmUgc2VydmVzIHRvIGtlZXAgaW50ZXJuYWwgZGVjbGFyYXRpb25zIHByaXZhdGUuXG4gKiAyLmEuIEluIHRoZSBicm93c2VyIGFzIGEgZ2xvYmFsOiBUaGUgbG9naWMgaW4gdGhlIGFjdHVhbCBwYXJhbWV0ZXIgZXhwcmVzc2lvbnMgKyB0aGUgcG9zdC1pbnZvY2F0aW9uIGV4cHJlc3Npb25cbiAqIHdpbGwgcHV0IHlvdXIgQVBJIGluIGB3aW5kb3cudGVtcGxleGAuXG4gKiAyLmIuIEluIHRoZSBicm93c2VyIGFzIGEgbW9kdWxlOiBJZiB5b3UgcHJlZGVmaW5lIGEgYHdpbmRvdy5tb2R1bGVgIG9iamVjdCwgdGhlIHJlc3VsdHMgd2lsbCBiZSBpbiBgbW9kdWxlLmV4cG9ydHNgLlxuICogVGhlIGJvd2VyIGNvbXBvbmVudCBgbW5tYCBtYWtlcyB0aGlzIGVhc3kgYW5kIGFsc28gcHJvdmlkZXMgYSBnbG9iYWwgYHJlcXVpcmUoKWAgZnVuY3Rpb24gZm9yIHJlZmVyZW5jaW5nIHlvdXIgbW9kdWxlXG4gKiBmcm9tIG90aGVyIGNsb3N1cmVzLiBJbiBlaXRoZXIgY2FzZSwgdGhpcyB3b3JrcyB3aXRoIGJvdGggTm9kZUpzLXN0eWxlIGV4cG9ydCBtZWNoYW5pc21zIC0tIGEgc2luZ2xlIEFQSSBhc3NpZ25tZW50LFxuICogYG1vZHVsZS5leHBvcnRzID0geW91ckFQSWAgKm9yKiBhIHNlcmllcyBvZiBpbmRpdmlkdWFsIHByb3BlcnR5IGFzc2lnbm1lbnRzLCBgbW9kdWxlLmV4cG9ydHMucHJvcGVydHkgPSBwcm9wZXJ0eWAuXG4gKlxuICogQmVmb3JlIHRoZSBJSUZFIHJ1bnMsIHRoZSBhY3R1YWwgcGFyYW1ldGVyIGV4cHJlc3Npb25zIGFyZSBleGVjdXRlZDpcbiAqIDEuIElmIGBtb2R1bGVgIG9iamVjdCBkZWZpbmVkLCB3ZSdyZSBpbiBOb2RlSnMgc28gYXNzdW1lIHRoZXJlIGlzIGEgYG1vZHVsZWAgb2JqZWN0IHdpdGggYW4gYGV4cG9ydHNgIG9iamVjdFxuICogMi4gSWYgYG1vZHVsZWAgb2JqZWN0IHVuZGVmaW5lZCwgd2UncmUgaW4gYnJvd3NlciBzbyBkZWZpbmUgYSBgd2luZG93LnRlbXBsZXhgIG9iamVjdCB3aXRoIGFuIGBleHBvcnRzYCBvYmplY3RcbiAqXG4gKiBBZnRlciB0aGUgSUlGRSByZXR1cm5zOlxuICogQmVjYXVzZSBpdCBhbHdheXMgcmV0dXJucyB1bmRlZmluZWQsIHRoZSBleHByZXNzaW9uIGFmdGVyIHRoZSB8fCB3aWxsIGFsd2F5cyBleGVjdXRlOlxuICogMS4gSWYgYG1vZHVsZWAgb2JqZWN0IGRlZmluZWQsIHRoZW4gd2UncmUgaW4gTm9kZUpzIHNvIHdlJ3JlIGRvbmVcbiAqIDIuIElmIGBtb2R1bGVgIG9iamVjdCB1bmRlZmluZWQsIHRoZW4gd2UncmUgaW4gYnJvd3NlciBzbyByZWRlZmluZWB3aW5kb3cudGVtcGxleGAgYXMgaXRzIGBleHBvcnRzYCBvYmplY3RcbiAqL1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQmFzZSA9IHJlcXVpcmUoJ2V4dGVuZC1tZScpLkJhc2U7XG5cbi8qKiBAY29uc3RydWN0b3JcbiAqIEBkZXNjIEluc3RhbmNlcyBvZiBmZWF0dXJlcyBhcmUgY29ubmVjdGVkIHRvIG9uZSBhbm90aGVyIHRvIG1ha2UgYSBjaGFpbiBvZiByZXNwb25zaWJpbGl0eSBmb3IgaGFuZGxpbmcgYWxsIHRoZSBpbnB1dCB0byB0aGUgaHlwZXJncmlkLlxuICpcbiAqIFNlZSB7QGxpbmsgQ2VsbFByb3ZpZGVyI2luaXRpYWxpemV8aW5pdGlhbGl6ZX0gd2hpY2ggaXMgY2FsbGVkIGJ5IHRoZSBjb25zdHJ1Y3Rvci5cbiAqL1xudmFyIENlbGxQcm92aWRlciA9IEJhc2UuZXh0ZW5kKCdDZWxsUHJvdmlkZXInLCB7XG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBDb25zdHJ1Y3RvciBsb2dpY1xuICAgICAqIEBkZXNjIFRoaXMgbWV0aG9kIHdpbGwgYmUgY2FsbGVkIHVwb24gaW5zdGFudGlhdGlvbiBvZiB0aGlzIGNsYXNzIG9yIG9mIGFueSBjbGFzcyB0aGF0IGV4dGVuZHMgZnJvbSB0aGlzIGNsYXNzLlxuICAgICAqID4gQWxsIGBpbml0aWFsaXplKClgIG1ldGhvZHMgaW4gdGhlIGluaGVyaXRhbmNlIGNoYWluIGFyZSBjYWxsZWQsIGluIHR1cm4sIGVhY2ggd2l0aCB0aGUgc2FtZSBwYXJhbWV0ZXJzIHRoYXQgd2VyZSBwYXNzZWQgdG8gdGhlIGNvbnN0cnVjdG9yLCBiZWdpbm5pbmcgd2l0aCB0aGF0IG9mIHRoZSBtb3N0IFwic2VuaW9yXCIgY2xhc3MgdGhyb3VnaCB0aGF0IG9mIHRoZSBjbGFzcyBvZiB0aGUgbmV3IGluc3RhbmNlLlxuICAgICAqIEBtZW1iZXJPZiBDZWxsUHJvdmlkZXIucHJvdG90eXBlXG4gICAgICovXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuY2VsbENhY2hlID0ge307XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZUNlbGxzKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBkZXNjIHJlcGxhY2UgdGhpcyBmdW5jdGlvbiBpbiBvbiB5b3VyIGluc3RhbmNlIG9mIGNlbGxQcm92aWRlclxuICAgICAqIEByZXR1cm5zIGNlbGxcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gY29uZmlnIC0gYW4gb2JqZWN0IHdpdGggZXZlcnl0aGluZyB5b3UgbWlnaHQgbmVlZCBmb3IgcmVuZGVyZXJpbmcgYSBjZWxsXG4gICAgICogQG1lbWJlck9mIENlbGxQcm92aWRlci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBnZXRDZWxsOiBmdW5jdGlvbihjb25maWcpIHtcbiAgICAgICAgdmFyIGNlbGwgPSB0aGlzLmNlbGxDYWNoZS5zaW1wbGVDZWxsUmVuZGVyZXI7XG4gICAgICAgIGNlbGwuY29uZmlnID0gY29uZmlnO1xuICAgICAgICByZXR1cm4gY2VsbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQGRlc2MgcmVwbGFjZSB0aGlzIGZ1bmN0aW9uIGluIG9uIHlvdXIgaW5zdGFuY2Ugb2YgY2VsbFByb3ZpZGVyXG4gICAgICogQHJldHVybnMgY2VsbFxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBjb25maWcgLSBhbiBvYmplY3Qgd2l0aCBldmVyeXRoaW5nIHlvdSBtaWdodCBuZWVkIGZvciByZW5kZXJlcmluZyBhIGNlbGxcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbFByb3ZpZGVyLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGdldENvbHVtbkhlYWRlckNlbGw6IGZ1bmN0aW9uKGNvbmZpZykge1xuICAgICAgICB2YXIgY2VsbCA9IHRoaXMuY2VsbENhY2hlLnNpbXBsZUNlbGxSZW5kZXJlcjtcbiAgICAgICAgY2VsbC5jb25maWcgPSBjb25maWc7XG4gICAgICAgIHJldHVybiBjZWxsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAZGVzYyByZXBsYWNlIHRoaXMgZnVuY3Rpb24gaW4gb24geW91ciBpbnN0YW5jZSBvZiBjZWxsUHJvdmlkZXJcbiAgICAgKiBAcmV0dXJucyBjZWxsXG4gICAgICogQHBhcmFtIHtvYmplY3R9IGNvbmZpZyAtIGFuIG9iamVjdCB3aXRoIGV2ZXJ5dGhpbmcgeW91IG1pZ2h0IG5lZWQgZm9yIHJlbmRlcmVyaW5nIGEgY2VsbFxuICAgICAqIEBtZW1iZXJPZiBDZWxsUHJvdmlkZXIucHJvdG90eXBlXG4gICAgICovXG4gICAgZ2V0Um93SGVhZGVyQ2VsbDogZnVuY3Rpb24oY29uZmlnKSB7XG4gICAgICAgIHZhciBjZWxsID0gdGhpcy5jZWxsQ2FjaGUuc2ltcGxlQ2VsbFJlbmRlcmVyO1xuICAgICAgICBjZWxsLmNvbmZpZyA9IGNvbmZpZztcbiAgICAgICAgcmV0dXJuIGNlbGw7XG4gICAgfSxcblxuICAgIHBhaW50QnV0dG9uOiBmdW5jdGlvbihnYywgY29uZmlnKSB7XG4gICAgICAgIHZhciB2YWwgPSBjb25maWcudmFsdWU7XG4gICAgICAgIHZhciBjID0gY29uZmlnLng7XG4gICAgICAgIHZhciByID0gY29uZmlnLnk7XG4gICAgICAgIHZhciBib3VuZHMgPSBjb25maWcuYm91bmRzO1xuICAgICAgICB2YXIgeCA9IGJvdW5kcy54ICsgMjtcbiAgICAgICAgdmFyIHkgPSBib3VuZHMueSArIDI7XG4gICAgICAgIHZhciB3aWR0aCA9IGJvdW5kcy53aWR0aCAtIDM7XG4gICAgICAgIHZhciBoZWlnaHQgPSBib3VuZHMuaGVpZ2h0IC0gMztcbiAgICAgICAgdmFyIHJhZGl1cyA9IGhlaWdodCAvIDI7XG4gICAgICAgIHZhciBhcmNHcmFkaWVudCA9IGdjLmNyZWF0ZUxpbmVhckdyYWRpZW50KHgsIHksIHgsIHkgKyBoZWlnaHQpO1xuICAgICAgICBpZiAoY29uZmlnLm1vdXNlRG93bikge1xuICAgICAgICAgICAgYXJjR3JhZGllbnQuYWRkQ29sb3JTdG9wKDAsICcjQjVDQkVEJyk7XG4gICAgICAgICAgICBhcmNHcmFkaWVudC5hZGRDb2xvclN0b3AoMSwgJyM0ZDc0ZWEnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGFyY0dyYWRpZW50LmFkZENvbG9yU3RvcCgwLCAnI2ZmZmZmZicpO1xuICAgICAgICAgICAgYXJjR3JhZGllbnQuYWRkQ29sb3JTdG9wKDEsICcjYWFhYWFhJyk7XG4gICAgICAgIH1cbiAgICAgICAgZ2MuZmlsbFN0eWxlID0gYXJjR3JhZGllbnQ7XG4gICAgICAgIGdjLnN0cm9rZVN0eWxlID0gJyMwMDAwMDAnO1xuICAgICAgICByb3VuZFJlY3QoZ2MsIHgsIHksIHdpZHRoLCBoZWlnaHQsIHJhZGl1cywgYXJjR3JhZGllbnQsIHRydWUpO1xuXG4gICAgICAgIHZhciBveCA9ICh3aWR0aCAtIGNvbmZpZy5nZXRUZXh0V2lkdGgoZ2MsIHZhbCkpIC8gMjtcbiAgICAgICAgdmFyIG95ID0gKGhlaWdodCAtIGNvbmZpZy5nZXRUZXh0SGVpZ2h0KGdjLmZvbnQpLmRlc2NlbnQpIC8gMjtcblxuICAgICAgICBpZiAoZ2MudGV4dEJhc2VsaW5lICE9PSAnbWlkZGxlJykge1xuICAgICAgICAgICAgZ2MudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG4gICAgICAgIH1cblxuICAgICAgICBnYy5maWxsU3R5bGUgPSAnIzAwMDAwMCc7XG5cbiAgICAgICAgY29uZmlnLmJhY2tncm91bmRDb2xvciA9ICdyZ2JhKDAsMCwwLDApJztcbiAgICAgICAgZ2MuZmlsbFRleHQodmFsLCB4ICsgb3gsIHkgKyBveSk7XG5cbiAgICAgICAgLy9pZGVudGlmeSB0aGF0IHdlIGFyZSBhIGJ1dHRvblxuICAgICAgICBjb25maWcuYnV0dG9uQ2VsbHNbYyArICcsJyArIHJdID0gdHJ1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHN1bW1hcnkgVGhlIGRlZmF1bHQgY2VsbCByZW5kZXJpbmcgZnVuY3Rpb24gZm9yIHJlbmRlcmluZyBhIHZhbmlsbGEgY2VsbC5cbiAgICAgKiBAZGVzYyBHcmVhdCBjYXJlIGhhcyBiZWVuIHRha2VuIGluIGNyYWZ0aW5nIHRoaXMgZnVuY3Rpb24gYXMgaXQgbmVlZHMgdG8gcGVyZm9ybSBleHRyZW1lbHkgZmFzdC4gUmVhZHMgb24gdGhlIGdjIG9iamVjdCBhcmUgZXhwZW5zaXZlIGJ1dCBub3QgcXVpdGUgYXMgZXhwZW5zaXZlIGFzIHdyaXRlcyB0byBpdC4gV2UgZG8gb3VyIGJlc3QgdG8gYXZvaWQgd3JpdGVzLCB0aGVuIGF2b2lkIHJlYWRzLiBDbGlwcGluZyBib3VuZHMgYXJlIG5vdCBzZXQgaGVyZSBhcyB0aGlzIGlzIGFsc28gYW4gZXhwZW5zaXZlIG9wZXJhdGlvbi4gSW5zdGVhZCwgd2UgdHJ1bmNhdGUgb3ZlcmZsb3dpbmcgdGV4dCBhbmQgY29udGVudCBieSBmaWxsaW5nIGEgcmVjdGFuZ2xlIHdpdGggYmFja2dyb3VuZCBjb2xvciBjb2x1bW4gYnkgY29sdW1uIGluc3RlYWQgb2YgY2VsbCBieSBjZWxsLiAgVGhpcyBjb2x1bW4gYnkgY29sdW1uIGZpbGwgaGFwcGVucyBoaWdoZXIgdXAgb24gdGhlIHN0YWNrIGluIGEgY2FsbGluZyBmdW5jdGlvbiBmcm9tIGZpbi1oeXBlcmdyaWQtcmVuZGVyZXIuICBUYWtlIG5vdGUgd2UgZG8gbm90IGRvIGNlbGwgYnkgY2VsbCBib3JkZXIgcmVuZGVyZXJpbmcgYXMgdGhhdCBpcyBleHBlbnNpdmUuICBJbnN0ZWFkIHdlIHJlbmRlciBtYW55IGZld2VyIGdyaWRsaW5lcyBhZnRlciBhbGwgY2VsbHMgYXJlIHJlbmRlcmVkLlxuICAgICAqIEBwYXJhbSB7Q2FudmFzR3JhcGhpY3NDb250ZXh0fSBnYyAtIHRoZSBcInBlblwiIGluIHRoZSBtdmMgbW9kZWwsIHdlIGlzc3VlIGRyYXdpbmcgY29tbWFuZHMgdG9cbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCAtIHRoZSB4IHNjcmVlbiBjb29yZGluYXRlIG9mIG15IG9yaWdpblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gdGhlIHkgc2NyZWVuIGNvb3JkaW5hdGUgb2YgbXkgb3JpZ2luXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIC0gdGhlIHdpZHRoIEknbSBhbGxvd2VkIHRvIGRyYXcgd2l0aGluXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCAtIHRoZSBoZWlnaHQgSSdtIGFsbG93ZWQgdG8gZHJhdyB3aXRoaW5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzTGluayAtIGlzIHRoaXMgYSBoeXBlcmxpbmsgY2VsbFxuICAgICAqIEBtZW1iZXJPZiBDZWxsUHJvdmlkZXIucHJvdG90eXBlXG4gICAgICovXG4gICAgZGVmYXVsdENlbGxQYWludDogZnVuY3Rpb24oZ2MsIGNvbmZpZykge1xuICAgICAgICB2YXIgdmFsID0gY29uZmlnLnZhbHVlLFxuICAgICAgICAgICAgeCA9IGNvbmZpZy5ib3VuZHMueCxcbiAgICAgICAgICAgIHkgPSBjb25maWcuYm91bmRzLnksXG4gICAgICAgICAgICB3aWR0aCA9IGNvbmZpZy5ib3VuZHMud2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQgPSBjb25maWcuYm91bmRzLmhlaWdodCxcbiAgICAgICAgICAgIHdyYXBIZWFkZXJzID0gY29uZmlnLmhlYWRlclRleHRXcmFwcGluZyxcbiAgICAgICAgICAgIGxlZnRQYWRkaW5nID0gMiwgLy9UT0RPOiBmaXggdGhpc1xuICAgICAgICAgICAgaXNIZWFkZXIgPSBjb25maWcueSA9PT0gMDtcblxuICAgICAgICB2YXIgbGVmdEljb24sIHJpZ2h0SWNvbiwgY2VudGVySWNvbiwgaXhvZmZzZXQsIGl5b2Zmc2V0O1xuXG4gICAgICAgIC8vc2V0dGluZyBnYyBwcm9wZXJ0aWVzIGFyZSBleHBlbnNpdmUsIGxldHMgbm90IGRvIGl0IHVubmVjZXNzYXJpbHlcblxuICAgICAgICBpZiAodmFsICYmIHZhbC5jb25zdHJ1Y3RvciA9PT0gQXJyYXkpIHtcbiAgICAgICAgICAgIGxlZnRJY29uID0gdmFsWzBdO1xuICAgICAgICAgICAgcmlnaHRJY29uID0gdmFsWzJdO1xuICAgICAgICAgICAgdmFsID0gdmFsWzFdO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdvYmplY3QnKSB7IC8vIG11c3QgYmUgYW4gaW1hZ2VcbiAgICAgICAgICAgICAgICBjZW50ZXJJY29uID0gdmFsO1xuICAgICAgICAgICAgICAgIHZhbCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGVmdEljb24gJiYgbGVmdEljb24ubm9kZU5hbWUgIT09ICdJTUcnKSB7XG4gICAgICAgICAgICAgICAgbGVmdEljb24gPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJpZ2h0SWNvbiAmJiByaWdodEljb24ubm9kZU5hbWUgIT09ICdJTUcnKSB7XG4gICAgICAgICAgICAgICAgcmlnaHRJY29uID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjZW50ZXJJY29uICYmIGNlbnRlckljb24ubm9kZU5hbWUgIT09ICdJTUcnKSB7XG4gICAgICAgICAgICAgICAgY2VudGVySWNvbiA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YWwgPSB2YWx1ZU9yRnVuY3Rpb25FeGVjdXRlKGNvbmZpZywgdmFsKTtcblxuICAgICAgICBpZiAoZ2MuZm9udCAhPT0gY29uZmlnLmZvbnQpIHtcbiAgICAgICAgICAgIGdjLmZvbnQgPSBjb25maWcuZm9udDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZ2MudGV4dEFsaWduICE9PSAnbGVmdCcpIHtcbiAgICAgICAgICAgIGdjLnRleHRBbGlnbiA9ICdsZWZ0JztcbiAgICAgICAgfVxuICAgICAgICBpZiAoZ2MudGV4dEJhc2VsaW5lICE9PSAnbWlkZGxlJykge1xuICAgICAgICAgICAgZ2MudGV4dEJhc2VsaW5lID0gJ21pZGRsZSc7XG4gICAgICAgIH1cblxuICAgICAgICAvL2ZpbGwgYmFja2dyb3VuZCBvbmx5IGlmIG91ciBiZ0NvbG9yIGlzIHBvcHVsYXRlZCBvciB3ZSBhcmUgYSBzZWxlY3RlZCBjZWxsXG4gICAgICAgIGlmIChjb25maWcuYmFja2dyb3VuZENvbG9yIHx8IGNvbmZpZy5pc1NlbGVjdGVkKSB7XG4gICAgICAgICAgICBnYy5maWxsU3R5bGUgPSB2YWx1ZU9yRnVuY3Rpb25FeGVjdXRlKGNvbmZpZywgY29uZmlnLmlzU2VsZWN0ZWQgPyBjb25maWcuYmFja2dyb3VuZFNlbGVjdGlvbkNvbG9yIDogY29uZmlnLmJhY2tncm91bmRDb2xvcik7XG4gICAgICAgICAgICBnYy5maWxsUmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vZHJhdyB0ZXh0XG4gICAgICAgIHZhciB0aGVDb2xvciA9IHZhbHVlT3JGdW5jdGlvbkV4ZWN1dGUoY29uZmlnLCBjb25maWcuaXNTZWxlY3RlZCA/IGNvbmZpZy5mb3JlZ3JvdW5kU2VsZWN0aW9uQ29sb3IgOiBjb25maWcuY29sb3IpO1xuICAgICAgICBpZiAoZ2MuZmlsbFN0eWxlICE9PSB0aGVDb2xvcikge1xuICAgICAgICAgICAgZ2MuZmlsbFN0eWxlID0gdGhlQ29sb3I7XG4gICAgICAgICAgICBnYy5zdHJva2VTdHlsZSA9IHRoZUNvbG9yO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzSGVhZGVyICYmIHdyYXBIZWFkZXJzKSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlck11bHRpTGluZVRleHQoeCwgeSwgaGVpZ2h0LCB3aWR0aCwgZ2MsIGNvbmZpZywgdmFsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyU2luZ2xlTGluZVRleHQoeCwgeSwgaGVpZ2h0LCB3aWR0aCwgZ2MsIGNvbmZpZywgdmFsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjb25maWcuaXNJbkN1cnJlbnRTZWxlY3Rpb25SZWN0YW5nbGUpIHtcbiAgICAgICAgICAgIGdjLmZpbGxTdHlsZSA9ICdyZ2JhKDAsIDAsIDAsIDAuMiknO1xuICAgICAgICAgICAgZ2MuZmlsbFJlY3QoeCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGljb25XaWR0aCA9IDA7XG4gICAgICAgIGlmIChsZWZ0SWNvbikge1xuICAgICAgICAgICAgaXlvZmZzZXQgPSBNYXRoLnJvdW5kKChoZWlnaHQgLSBsZWZ0SWNvbi5oZWlnaHQpIC8gMik7XG4gICAgICAgICAgICBnYy5kcmF3SW1hZ2UobGVmdEljb24sIHggKyBsZWZ0UGFkZGluZywgeSArIGl5b2Zmc2V0KTtcbiAgICAgICAgICAgIGljb25XaWR0aCA9IE1hdGgubWF4KGxlZnRJY29uLndpZHRoICsgMik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJpZ2h0SWNvbikge1xuICAgICAgICAgICAgaXlvZmZzZXQgPSBNYXRoLnJvdW5kKChoZWlnaHQgLSByaWdodEljb24uaGVpZ2h0KSAvIDIpO1xuICAgICAgICAgICAgaXhvZmZzZXQgPSAwOyAvL01hdGgucm91bmQoKGhhbGlnbk9mZnNldCAtIHJpZ2h0SWNvbi53aWR0aCkgLyAyKTtcbiAgICAgICAgICAgIGdjLmRyYXdJbWFnZShyaWdodEljb24sIHggKyB3aWR0aCAtIGl4b2Zmc2V0IC0gcmlnaHRJY29uLndpZHRoLCB5ICsgaXlvZmZzZXQpO1xuICAgICAgICAgICAgaWNvbldpZHRoID0gTWF0aC5tYXgocmlnaHRJY29uLndpZHRoICsgMik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNlbnRlckljb24pIHtcbiAgICAgICAgICAgIGl5b2Zmc2V0ID0gTWF0aC5yb3VuZCgoaGVpZ2h0IC0gY2VudGVySWNvbi5oZWlnaHQpIC8gMik7XG4gICAgICAgICAgICBpeG9mZnNldCA9IE1hdGgucm91bmQoKHdpZHRoIC0gY2VudGVySWNvbi53aWR0aCkgLyAyKTtcbiAgICAgICAgICAgIGdjLmRyYXdJbWFnZShjZW50ZXJJY29uLCB4ICsgd2lkdGggLSBpeG9mZnNldCAtIGNlbnRlckljb24ud2lkdGgsIHkgKyBpeW9mZnNldCk7XG4gICAgICAgICAgICBpY29uV2lkdGggPSBNYXRoLm1heChjZW50ZXJJY29uLndpZHRoICsgMik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbmZpZy5jZWxsQm9yZGVyVGhpY2tuZXNzKSB7XG4gICAgICAgICAgICBnYy5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGdjLnJlY3QoeCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICBnYy5saW5lV2lkdGggPSBjb25maWcuY2VsbEJvcmRlclRoaWNrbmVzcztcbiAgICAgICAgICAgIGdjLnN0cm9rZVN0eWxlID0gY29uZmlnLmNlbGxCb3JkZXJTdHlsZTtcblxuICAgICAgICAgICAgLy8gYW5pbWF0ZSB0aGUgZGFzaGVkIGxpbmUgYSBiaXQgaGVyZSBmb3IgZnVuXG5cbiAgICAgICAgICAgIGdjLnN0cm9rZSgpO1xuICAgICAgICAgICAgZ2MuY2xvc2VQYXRoKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uZmlnLm1pbldpZHRoID0gY29uZmlnLm1pbldpZHRoICsgMiAqIChpY29uV2lkdGgpO1xuICAgIH0sXG5cbiAgICByZW5kZXJNdWx0aUxpbmVUZXh0OiBmdW5jdGlvbih4LCB5LCBoZWlnaHQsIHdpZHRoLCBnYywgY29uZmlnLCB2YWwpIHtcbiAgICAgICAgdmFyIGxpbmVzID0gZml0VGV4dChnYywgY29uZmlnLCB2YWwsIHdpZHRoKTtcbiAgICAgICAgaWYgKGxpbmVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyU2luZ2xlTGluZVRleHQoeCwgeSwgaGVpZ2h0LCB3aWR0aCwgZ2MsIGNvbmZpZywgc3F1ZWV6ZSh2YWwpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjb2xIRWRnZU9mZnNldCA9IGNvbmZpZy5jZWxsUGFkZGluZyxcbiAgICAgICAgICAgIGhhbGlnbk9mZnNldCA9IDAsXG4gICAgICAgICAgICB2YWxpZ25PZmZzZXQgPSBjb25maWcudm9mZnNldCxcbiAgICAgICAgICAgIGhhbGlnbiA9IGNvbmZpZy5oYWxpZ24sXG4gICAgICAgICAgICB0ZXh0SGVpZ2h0ID0gY29uZmlnLmdldFRleHRIZWlnaHQoY29uZmlnLmZvbnQpLmhlaWdodDtcblxuICAgICAgICBzd2l0Y2ggKGhhbGlnbikge1xuICAgICAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgICAgICAgIGhhbGlnbk9mZnNldCA9IHdpZHRoIC0gY29sSEVkZ2VPZmZzZXQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdjZW50ZXInOlxuICAgICAgICAgICAgICAgIGhhbGlnbk9mZnNldCA9IHdpZHRoIC8gMjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICAgICAgICAgIGhhbGlnbk9mZnNldCA9IGNvbEhFZGdlT2Zmc2V0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGhNaW4gPSAwLCB2TWluID0gTWF0aC5jZWlsKHRleHRIZWlnaHQgLyAyKTtcblxuICAgICAgICB2YWxpZ25PZmZzZXQgKz0gTWF0aC5jZWlsKChoZWlnaHQgLSAobGluZXMubGVuZ3RoIC0gMSkgKiB0ZXh0SGVpZ2h0KSAvIDIpO1xuXG4gICAgICAgIGhhbGlnbk9mZnNldCA9IE1hdGgubWF4KGhNaW4sIGhhbGlnbk9mZnNldCk7XG4gICAgICAgIHZhbGlnbk9mZnNldCA9IE1hdGgubWF4KHZNaW4sIHZhbGlnbk9mZnNldCk7XG5cbiAgICAgICAgZ2Muc2F2ZSgpOyAvLyBkZWZpbmUgYSBjbGlwcGluZyByZWdpb24gZm9yIGNlbGxcbiAgICAgICAgZ2MubW92ZVRvKHgsIHkpO1xuICAgICAgICBnYy5saW5lVG8oeCArIHdpZHRoLCB5KTtcbiAgICAgICAgZ2MubGluZVRvKHggKyB3aWR0aCwgeSArIGhlaWdodCk7XG4gICAgICAgIGdjLmxpbmVUbyh4LCB5ICsgaGVpZ2h0KTtcbiAgICAgICAgZ2MubGluZVRvKHgsIHkpO1xuICAgICAgICBnYy5jbG9zZVBhdGgoKTtcbiAgICAgICAgZ2MuY2xpcCgpO1xuXG4gICAgICAgIGdjLnRleHRBbGlnbiA9IGhhbGlnbjtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBnYy5maWxsVGV4dChsaW5lc1tpXSwgeCArIGhhbGlnbk9mZnNldCwgeSArIHZhbGlnbk9mZnNldCArIChpICogdGV4dEhlaWdodCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgZ2MucmVzdG9yZSgpOyAvLyBkaXNjYXJkIGNsaXBwaW5nIHJlZ2lvblxuICAgIH0sXG5cbiAgICByZW5kZXJTaW5nbGVMaW5lVGV4dDogZnVuY3Rpb24oeCwgeSwgaGVpZ2h0LCB3aWR0aCwgZ2MsIGNvbmZpZywgdmFsKSB7XG4gICAgICAgIHZhciBjb2xIRWRnZU9mZnNldCA9IGNvbmZpZy5jZWxsUGFkZGluZyxcbiAgICAgICAgICAgIGhhbGlnbk9mZnNldCA9IDAsXG4gICAgICAgICAgICB2YWxpZ25PZmZzZXQgPSBjb25maWcudm9mZnNldCxcbiAgICAgICAgICAgIGhhbGlnbiA9IGNvbmZpZy5oYWxpZ24sXG4gICAgICAgICAgICBpc0NvbHVtbkhvdmVyZWQgPSBjb25maWcuaXNDb2x1bW5Ib3ZlcmVkLFxuICAgICAgICAgICAgaXNSb3dIb3ZlcmVkID0gY29uZmlnLmlzUm93SG92ZXJlZCxcbiAgICAgICAgICAgIGlzTGluayA9IGlzTGluayB8fCBmYWxzZTtcblxuICAgICAgICB2YXIgZm9udE1ldHJpY3MgPSBjb25maWcuZ2V0VGV4dEhlaWdodChjb25maWcuZm9udCk7XG4gICAgICAgIHZhciB0ZXh0V2lkdGggPSBjb25maWcuZ2V0VGV4dFdpZHRoKGdjLCB2YWwpO1xuXG4gICAgICAgIC8vd2UgbXVzdCBzZXQgdGhpcyBpbiBvcmRlciB0byBjb21wdXRlIHRoZSBtaW5pbXVtIHdpZHRoXG4gICAgICAgIC8vZm9yIGNvbHVtbiBhdXRvc2l6aW5nIHB1cnBvc2VzXG4gICAgICAgIGNvbmZpZy5taW5XaWR0aCA9IHRleHRXaWR0aCArICgyICogY29sSEVkZ2VPZmZzZXQpO1xuXG4gICAgICAgIHN3aXRjaCAoaGFsaWduKSB7XG4gICAgICAgICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgICAgICAgICAgLy90ZXh0V2lkdGggPSBjb25maWcuZ2V0VGV4dFdpZHRoKGdjLCBjb25maWcudmFsdWUpO1xuICAgICAgICAgICAgICAgIGhhbGlnbk9mZnNldCA9IHdpZHRoIC0gY29sSEVkZ2VPZmZzZXQgLSB0ZXh0V2lkdGg7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdjZW50ZXInOlxuICAgICAgICAgICAgICAgIC8vdGV4dFdpZHRoID0gY29uZmlnLmdldFRleHRXaWR0aChnYywgY29uZmlnLnZhbHVlKTtcbiAgICAgICAgICAgICAgICBoYWxpZ25PZmZzZXQgPSAod2lkdGggLSB0ZXh0V2lkdGgpIC8gMjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICAgICAgICAgIGhhbGlnbk9mZnNldCA9IGNvbEhFZGdlT2Zmc2V0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgaGFsaWduT2Zmc2V0ID0gTWF0aC5tYXgoMCwgaGFsaWduT2Zmc2V0KTtcbiAgICAgICAgdmFsaWduT2Zmc2V0ID0gdmFsaWduT2Zmc2V0ICsgTWF0aC5jZWlsKGhlaWdodCAvIDIpO1xuXG4gICAgICAgIGlmICh2YWwgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGdjLmZpbGxUZXh0KHZhbCwgeCArIGhhbGlnbk9mZnNldCwgeSArIHZhbGlnbk9mZnNldCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNDb2x1bW5Ib3ZlcmVkICYmIGlzUm93SG92ZXJlZCkge1xuICAgICAgICAgICAgZ2MuYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBpZiAoaXNMaW5rKSB7XG4gICAgICAgICAgICAgICAgdW5kZXJsaW5lKGNvbmZpZywgZ2MsIHZhbCwgeCArIGhhbGlnbk9mZnNldCwgeSArIHZhbGlnbk9mZnNldCArIE1hdGguZmxvb3IoZm9udE1ldHJpY3MuaGVpZ2h0IC8gMiksIDEpO1xuICAgICAgICAgICAgICAgIGdjLnN0cm9rZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ2MuY2xvc2VQYXRoKCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtDYW52YXNHcmFwaGljc0NvbnRleHR9IGdjIC0gdGhlIFwicGVuXCIgaW4gdGhlIG12YyBtb2RlbCwgd2UgaXNzdWUgZHJhd2luZyBjb21tYW5kcyB0b1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gdGhlIHggc2NyZWVuIGNvb3JkaW5hdGUgb2YgbXkgb3JpZ2luXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgLSB0aGUgeSBzY3JlZW4gY29vcmRpbmF0ZSBvZiBteSBvcmlnaW5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gd2lkdGggLSB0aGUgd2lkdGggSSdtIGFsbG93ZWQgdG8gZHJhdyB3aXRoaW5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaGVpZ2h0IC0gdGhlIGhlaWdodCBJJ20gYWxsb3dlZCB0byBkcmF3IHdpdGhpblxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNMaW5rIC0gaXMgdGhpcyBhIGh5cGVybGluayBjZWxsXG4gICAgICogQG1lbWJlck9mIENlbGxQcm92aWRlci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBlbWVyc29ucyBwYWludCBmdW5jdGlvbiBmb3IgYSBzbGlkZXIgYnV0dG9uLiBjdXJyZW50bHkgdGhlIHVzZXIgY2Fubm90IGludGVyYWN0IHdpdGggaXRcbiAgICAgKi9cbiAgICBwYWludFNsaWRlcjogZnVuY3Rpb24oZ2MsIHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgLy8gZ2Muc3Ryb2tlU3R5bGUgPSAnd2hpdGUnO1xuICAgICAgICAvLyB2YXIgdmFsID0gdGhpcy5jb25maWcudmFsdWU7XG4gICAgICAgIC8vIHZhciByYWRpdXMgPSBoZWlnaHQgLyAyO1xuICAgICAgICAvLyB2YXIgb2Zmc2V0ID0gd2lkdGggKiB2YWw7XG4gICAgICAgIC8vIHZhciBiZ0NvbG9yID0gdGhpcy5jb25maWcuaXNTZWxlY3RlZCA/IHRoaXMuY29uZmlnLmJnU2VsQ29sb3IgOiAnIzMzMzMzMyc7XG4gICAgICAgIC8vIHZhciBidG5HcmFkaWVudCA9IGdjLmNyZWF0ZUxpbmVhckdyYWRpZW50KHgsIHksIHgsIHkgKyBoZWlnaHQpO1xuICAgICAgICAvLyBidG5HcmFkaWVudC5hZGRDb2xvclN0b3AoMCwgYmdDb2xvcik7XG4gICAgICAgIC8vIGJ0bkdyYWRpZW50LmFkZENvbG9yU3RvcCgxLCAnIzY2NjY2NicpO1xuICAgICAgICAvLyB2YXIgYXJjR3JhZGllbnQgPSBnYy5jcmVhdGVMaW5lYXJHcmFkaWVudCh4LCB5LCB4LCB5ICsgaGVpZ2h0KTtcbiAgICAgICAgLy8gYXJjR3JhZGllbnQuYWRkQ29sb3JTdG9wKDAsICcjYWFhYWFhJyk7XG4gICAgICAgIC8vIGFyY0dyYWRpZW50LmFkZENvbG9yU3RvcCgxLCAnIzc3Nzc3NycpO1xuICAgICAgICAvLyBnYy5maWxsU3R5bGUgPSBidG5HcmFkaWVudDtcbiAgICAgICAgLy8gcm91bmRSZWN0KGdjLCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCByYWRpdXMsIGJ0bkdyYWRpZW50KTtcbiAgICAgICAgLy8gaWYgKHZhbCA8IDEuMCkge1xuICAgICAgICAvLyAgICAgZ2MuZmlsbFN0eWxlID0gYXJjR3JhZGllbnQ7XG4gICAgICAgIC8vIH0gZWxzZSB7XG4gICAgICAgIC8vICAgICBnYy5maWxsU3R5bGUgPSAnI2VlZWVlZSc7XG4gICAgICAgIC8vIH1cbiAgICAgICAgLy8gZ2MuYmVnaW5QYXRoKCk7XG4gICAgICAgIC8vIGdjLmFyYyh4ICsgTWF0aC5tYXgob2Zmc2V0IC0gcmFkaXVzLCByYWRpdXMpLCB5ICsgcmFkaXVzLCByYWRpdXMsIDAsIDIgKiBNYXRoLlBJKTtcbiAgICAgICAgLy8gZ2MuZmlsbCgpO1xuICAgICAgICAvLyBnYy5jbG9zZVBhdGgoKTtcbiAgICAgICAgLy8gdGhpcy5jb25maWcubWluV2lkdGggPSAxMDA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBkZXNjIEEgc2ltcGxlIGltcGxlbWVudGF0aW9uIG9mIGEgc3BhcmtsaW5lLCBiZWNhdXNlIGl0J3MgYSBiYXJjaGFydCB3ZSd2ZSBjaGFuZ2VkIHRoZSBuYW1lIDspLlxuICAgICAqIEBwYXJhbSB7Q2FudmFzR3JhcGhpY3NDb250ZXh0fSBnYyAtIHRoZSBcInBlblwiIGluIHRoZSBtdmMgbW9kZWwsIHdlIGlzc3VlIGRyYXdpbmcgY29tbWFuZHMgdG9cbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCAtIHRoZSB4IHNjcmVlbiBjb29yZGluYXRlIG9mIG15IG9yaWdpblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gdGhlIHkgc2NyZWVuIGNvb3JkaW5hdGUgb2YgbXkgb3JpZ2luXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIC0gdGhlIHdpZHRoIEknbSBhbGxvd2VkIHRvIGRyYXcgd2l0aGluXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCAtIHRoZSBoZWlnaHQgSSdtIGFsbG93ZWQgdG8gZHJhdyB3aXRoaW5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzTGluayAtIGlzIHRoaXMgYSBoeXBlcmxpbmsgY2VsbFxuICAgICAqIEBtZW1iZXJPZiBDZWxsUHJvdmlkZXIucHJvdG90eXBlXG4gICAgICovXG4gICAgcGFpbnRTcGFya2JhcjogZnVuY3Rpb24oZ2MsIHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgZ2MuYmVnaW5QYXRoKCk7XG4gICAgICAgIHZhciB2YWwgPSB0aGlzLmNvbmZpZy52YWx1ZTtcbiAgICAgICAgaWYgKCF2YWwgfHwgIXZhbC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY291bnQgPSB2YWwubGVuZ3RoO1xuICAgICAgICB2YXIgZVdpZHRoID0gd2lkdGggLyBjb3VudDtcbiAgICAgICAgdmFyIGZnQ29sb3IgPSB0aGlzLmNvbmZpZy5pc1NlbGVjdGVkID8gdGhpcy5jb25maWcuZmdTZWxDb2xvciA6IHRoaXMuY29uZmlnLmZnQ29sb3I7XG4gICAgICAgIGlmICh0aGlzLmNvbmZpZy5iZ0NvbG9yIHx8IHRoaXMuY29uZmlnLmlzU2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIGdjLmZpbGxTdHlsZSA9IHRoaXMuY29uZmlnLmlzU2VsZWN0ZWQgPyB0aGlzLmNvbmZpZy5iZ1NlbENvbG9yIDogdGhpcy5jb25maWcuYmdDb2xvcjtcbiAgICAgICAgICAgIGdjLmZpbGxSZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIGdjLmZpbGxTdHlsZSA9IGZnQ29sb3I7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgYmFyaGVpZ2h0ID0gdmFsW2ldIC8gMTEwICogaGVpZ2h0O1xuICAgICAgICAgICAgZ2MuZmlsbFJlY3QoeCArIDUsIHkgKyBoZWlnaHQgLSBiYXJoZWlnaHQsIGVXaWR0aCAqIDAuNjY2NiwgYmFyaGVpZ2h0KTtcbiAgICAgICAgICAgIHggPSB4ICsgZVdpZHRoO1xuICAgICAgICB9XG4gICAgICAgIGdjLmNsb3NlUGF0aCgpO1xuICAgICAgICB0aGlzLmNvbmZpZy5taW5XaWR0aCA9IGNvdW50ICogMTA7XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQGRlc2MgQSBzaW1wbGUgaW1wbGVtZW50YXRpb24gb2YgYSBzcGFya2xpbmUuICBzZWUgW0Vkd2FyZCBUdWZ0ZSBzcGFya2xpbmVdKGh0dHA6Ly93d3cuZWR3YXJkdHVmdGUuY29tL2Jib2FyZC9xLWFuZC1hLWZldGNoLW1zZz9tc2dfaWQ9MDAwMU9SKVxuICAgICAqIEBwYXJhbSB7Q2FudmFzR3JhcGhpY3NDb250ZXh0fSBnYyAtIHRoZSBcInBlblwiIGluIHRoZSBtdmMgbW9kZWwsIHdlIGlzc3VlIGRyYXdpbmcgY29tbWFuZHMgdG9cbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCAtIHRoZSB4IHNjcmVlbiBjb29yZGluYXRlIG9mIG15IG9yaWdpblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gdGhlIHkgc2NyZWVuIGNvb3JkaW5hdGUgb2YgbXkgb3JpZ2luXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIC0gdGhlIHdpZHRoIEknbSBhbGxvd2VkIHRvIGRyYXcgd2l0aGluXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCAtIHRoZSBoZWlnaHQgSSdtIGFsbG93ZWQgdG8gZHJhdyB3aXRoaW5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzTGluayAtIGlzIHRoaXMgYSBoeXBlcmxpbmsgY2VsbFxuICAgICAqIEBtZW1iZXJPZiBDZWxsUHJvdmlkZXIucHJvdG90eXBlXG4gICAgICovXG4gICAgcGFpbnRTcGFya2xpbmU6IGZ1bmN0aW9uKGdjLCB4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIGdjLmJlZ2luUGF0aCgpO1xuICAgICAgICB2YXIgdmFsID0gdGhpcy5jb25maWcudmFsdWU7XG4gICAgICAgIGlmICghdmFsIHx8ICF2YWwubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNvdW50ID0gdmFsLmxlbmd0aDtcbiAgICAgICAgdmFyIGVXaWR0aCA9IHdpZHRoIC8gY291bnQ7XG5cbiAgICAgICAgdmFyIGZnQ29sb3IgPSB0aGlzLmNvbmZpZy5pc1NlbGVjdGVkID8gdGhpcy5jb25maWcuZmdTZWxDb2xvciA6IHRoaXMuY29uZmlnLmZnQ29sb3I7XG4gICAgICAgIGlmICh0aGlzLmNvbmZpZy5iZ0NvbG9yIHx8IHRoaXMuY29uZmlnLmlzU2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIGdjLmZpbGxTdHlsZSA9IHRoaXMuY29uZmlnLmlzU2VsZWN0ZWQgPyB0aGlzLmNvbmZpZy5iZ1NlbENvbG9yIDogdGhpcy5jb25maWcuYmdDb2xvcjtcbiAgICAgICAgICAgIGdjLmZpbGxSZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIGdjLnN0cm9rZVN0eWxlID0gZmdDb2xvcjtcbiAgICAgICAgZ2MuZmlsbFN0eWxlID0gZmdDb2xvcjtcbiAgICAgICAgZ2MuYmVnaW5QYXRoKCk7XG4gICAgICAgIHZhciBwcmV2O1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGJhcmhlaWdodCA9IHZhbFtpXSAvIDExMCAqIGhlaWdodDtcbiAgICAgICAgICAgIGlmICghcHJldikge1xuICAgICAgICAgICAgICAgIHByZXYgPSBiYXJoZWlnaHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBnYy5saW5lVG8oeCArIDUsIHkgKyBoZWlnaHQgLSBiYXJoZWlnaHQpO1xuICAgICAgICAgICAgZ2MuYXJjKHggKyA1LCB5ICsgaGVpZ2h0IC0gYmFyaGVpZ2h0LCAxLCAwLCAyICogTWF0aC5QSSwgZmFsc2UpO1xuICAgICAgICAgICAgeCA9IHggKyBlV2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb25maWcubWluV2lkdGggPSBjb3VudCAqIDEwO1xuICAgICAgICBnYy5zdHJva2UoKTtcbiAgICAgICAgZ2MuY2xvc2VQYXRoKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBkZXNjIEEgc2ltcGxlIGltcGxlbWVudGF0aW9uIG9mIGEgdHJlZSBjZWxsIHJlbmRlcmVyIGZvciB1c2UgbWFpbmx5IHdpdGggdGhlIHF0cmVlLlxuICAgICAqIEBwYXJhbSB7Q2FudmFzR3JhcGhpY3NDb250ZXh0fSBnYyAtIHRoZSBcInBlblwiIGluIHRoZSBtdmMgbW9kZWwsIHdlIGlzc3VlIGRyYXdpbmcgY29tbWFuZHMgdG9cbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCAtIHRoZSB4IHNjcmVlbiBjb29yZGluYXRlIG9mIG15IG9yaWdpblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gdGhlIHkgc2NyZWVuIGNvb3JkaW5hdGUgb2YgbXkgb3JpZ2luXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIC0gdGhlIHdpZHRoIEknbSBhbGxvd2VkIHRvIGRyYXcgd2l0aGluXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCAtIHRoZSBoZWlnaHQgSSdtIGFsbG93ZWQgdG8gZHJhdyB3aXRoaW5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzTGluayAtIGlzIHRoaXMgYSBoeXBlcmxpbmsgY2VsbFxuICAgICAqIEBtZW1iZXJPZiBDZWxsUHJvdmlkZXIucHJvdG90eXBlXG4gICAgICovXG4gICAgdHJlZUNlbGxSZW5kZXJlcjogZnVuY3Rpb24oZ2MsIHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgdmFyIHZhbCA9IHRoaXMuY29uZmlnLnZhbHVlLmRhdGE7XG4gICAgICAgIHZhciBpbmRlbnQgPSB0aGlzLmNvbmZpZy52YWx1ZS5pbmRlbnQ7XG4gICAgICAgIHZhciBpY29uID0gdGhpcy5jb25maWcudmFsdWUuaWNvbjtcblxuICAgICAgICAvL2ZpbGwgYmFja2dyb3VuZCBvbmx5IGlmIG91ciBiZ0NvbG9yIGlzIHBvcHVsYXRlZCBvciB3ZSBhcmUgYSBzZWxlY3RlZCBjZWxsXG4gICAgICAgIGlmICh0aGlzLmNvbmZpZy5iZ0NvbG9yIHx8IHRoaXMuY29uZmlnLmlzU2VsZWN0ZWQpIHtcbiAgICAgICAgICAgIGdjLmZpbGxTdHlsZSA9IHRoaXMuY29uZmlnLmlzU2VsZWN0ZWQgPyB0aGlzLmNvbmZpZy5iZ1NlbENvbG9yIDogdGhpcy5jb25maWcuYmdDb2xvcjtcbiAgICAgICAgICAgIGdjLmZpbGxSZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF2YWwgfHwgIXZhbC5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdmFsaWduT2Zmc2V0ID0gTWF0aC5jZWlsKGhlaWdodCAvIDIpO1xuXG4gICAgICAgIGdjLmZpbGxTdHlsZSA9IHRoaXMuY29uZmlnLmlzU2VsZWN0ZWQgPyB0aGlzLmNvbmZpZy5mZ1NlbENvbG9yIDogdGhpcy5jb25maWcuZmdDb2xvcjtcbiAgICAgICAgZ2MuZmlsbFRleHQoaWNvbiArIHZhbCwgeCArIGluZGVudCwgeSArIHZhbGlnbk9mZnNldCk7XG5cbiAgICAgICAgdmFyIHRleHRXaWR0aCA9IHRoaXMuY29uZmlnLmdldFRleHRXaWR0aChnYywgaWNvbiArIHZhbCk7XG4gICAgICAgIHZhciBtaW5XaWR0aCA9IHggKyBpbmRlbnQgKyB0ZXh0V2lkdGggKyAxMDtcbiAgICAgICAgdGhpcy5jb25maWcubWluV2lkdGggPSBtaW5XaWR0aDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQGRlc2MgQW4gZW1wdHkgaW1wbGVtZW50YXRpb24gb2YgYSBjZWxsIHJlbmRlcmVyLCBzZWUgW3RoZSBudWxsIG9iamVjdCBwYXR0ZXJuXShodHRwOi8vYzIuY29tL2NnaS93aWtpP051bGxPYmplY3QpLlxuICAgICAqIEBwYXJhbSB7Q2FudmFzR3JhcGhpY3NDb250ZXh0fSBnYyAtIHRoZSBcInBlblwiIGluIHRoZSBtdmMgbW9kZWwsIHdlIGlzc3VlIGRyYXdpbmcgY29tbWFuZHMgdG9cbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCAtIHRoZSB4IHNjcmVlbiBjb29yZGluYXRlIG9mIG15IG9yaWdpblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gdGhlIHkgc2NyZWVuIGNvb3JkaW5hdGUgb2YgbXkgb3JpZ2luXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHdpZHRoIC0gdGhlIHdpZHRoIEknbSBhbGxvd2VkIHRvIGRyYXcgd2l0aGluXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCAtIHRoZSBoZWlnaHQgSSdtIGFsbG93ZWQgdG8gZHJhdyB3aXRoaW5cbiAgICAgKiBAbWVtYmVyT2YgQ2VsbFByb3ZpZGVyLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNMaW5rIC0gaXMgdGhpcyBhIGh5cGVybGluayBjZWxsXG4gICAgICovXG4gICAgZW1wdHlDZWxsUmVuZGVyZXI6IGZ1bmN0aW9uKGdjLCB4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7fSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsUHJvdmlkZXIucHJvdG90eXBlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBpbml0aWFsaXplQ2VsbHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHRoaXMuY2VsbENhY2hlLnNpbXBsZUNlbGxSZW5kZXJlciA9IHtcbiAgICAgICAgICAgIHBhaW50OiB0aGlzLmRlZmF1bHRDZWxsUGFpbnQsXG4gICAgICAgICAgICByZW5kZXJTaW5nbGVMaW5lVGV4dDogdGhpcy5yZW5kZXJTaW5nbGVMaW5lVGV4dCxcbiAgICAgICAgICAgIHJlbmRlck11bHRpTGluZVRleHQ6IHRoaXMucmVuZGVyTXVsdGlMaW5lVGV4dFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmNlbGxDYWNoZS5zbGlkZXJDZWxsUmVuZGVyZXIgPSB7XG4gICAgICAgICAgICBwYWludDogdGhpcy5wYWludFNsaWRlclxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmNlbGxDYWNoZS5zcGFya2JhckNlbGxSZW5kZXJlciA9IHtcbiAgICAgICAgICAgIHBhaW50OiB0aGlzLnBhaW50U3BhcmtiYXJcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5jZWxsQ2FjaGUuc3BhcmtsaW5lQ2VsbFJlbmRlcmVyID0ge1xuICAgICAgICAgICAgcGFpbnQ6IHRoaXMucGFpbnRTcGFya2xpbmVcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5jZWxsQ2FjaGUudHJlZUNlbGxSZW5kZXJlciA9IHtcbiAgICAgICAgICAgIHBhaW50OiB0aGlzLnRyZWVDZWxsUmVuZGVyZXJcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5jZWxsQ2FjaGUuZW1wdHlDZWxsUmVuZGVyZXIgPSB7XG4gICAgICAgICAgICBwYWludDogdGhpcy5lbXB0eUNlbGxSZW5kZXJlclxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmNlbGxDYWNoZS5idXR0b25SZW5kZXJlciA9IHtcbiAgICAgICAgICAgIHBhaW50OiB0aGlzLnBhaW50QnV0dG9uLFxuICAgICAgICAgICAgLy9kZWZhdWx0Q2VsbFBhaW50OiB0aGlzLmRlZmF1bHRDZWxsUGFpbnRcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5jZWxsQ2FjaGUubGlua0NlbGxSZW5kZXJlciA9IHtcbiAgICAgICAgICAgIHBhaW50OiBmdW5jdGlvbihnYywgeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICAgICAgICAgIHNlbGYuY29uZmlnID0gdGhpcy5jb25maWc7XG4gICAgICAgICAgICAgICAgc2VsZi5kZWZhdWx0Q2VsbFBhaW50KGdjLCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG59KTtcblxuZnVuY3Rpb24gdmFsdWVPckZ1bmN0aW9uRXhlY3V0ZShjb25maWcsIHZhbHVlT3JGdW5jdGlvbikge1xuICAgIHZhciBpc0Z1bmN0aW9uID0gKCgodHlwZW9mIHZhbHVlT3JGdW5jdGlvbilbMF0pID09PSAnZicpO1xuICAgIHZhciByZXN1bHQgPSBpc0Z1bmN0aW9uID8gdmFsdWVPckZ1bmN0aW9uKGNvbmZpZykgOiB2YWx1ZU9yRnVuY3Rpb247XG4gICAgaWYgKCFyZXN1bHQgJiYgcmVzdWx0ICE9PSAwKSB7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gdW5kZXJsaW5lKGNvbmZpZywgZ2MsIHRleHQsIHgsIHksIHRoaWNrbmVzcykge1xuICAgIHZhciB3aWR0aCA9IGNvbmZpZy5nZXRUZXh0V2lkdGgoZ2MsIHRleHQpO1xuXG4gICAgc3dpdGNoIChnYy50ZXh0QWxpZ24pIHtcbiAgICAgICAgY2FzZSAnY2VudGVyJzpcbiAgICAgICAgICAgIHggLT0gKHdpZHRoIC8gMik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAncmlnaHQnOlxuICAgICAgICAgICAgeCAtPSB3aWR0aDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIC8vZ2MuYmVnaW5QYXRoKCk7XG4gICAgZ2MubGluZVdpZHRoID0gdGhpY2tuZXNzO1xuICAgIGdjLm1vdmVUbyh4ICsgMC41LCB5ICsgMC41KTtcbiAgICBnYy5saW5lVG8oeCArIHdpZHRoICsgMC41LCB5ICsgMC41KTtcbn1cblxuZnVuY3Rpb24gZmluZExpbmVzKGdjLCBjb25maWcsIHdvcmRzLCB3aWR0aCkge1xuXG4gICAgaWYgKHdvcmRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gd29yZHM7XG4gICAgfVxuXG4gICAgLy8gc3RhcnRpbmcgd2l0aCBqdXN0IHRoZSBmaXJzdCB3b3Jk4oCmXG4gICAgdmFyIHN0aWxsRml0cywgbGluZSA9IFt3b3Jkcy5zaGlmdCgpXTtcbiAgICB3aGlsZSAoXG4gICAgICAgIC8vIHNvIGxvbmUgYXMgbGluZSBzdGlsbCBmaXRzIHdpdGhpbiBjdXJyZW50IGNvbHVtbuKAplxuICAgIChzdGlsbEZpdHMgPSBjb25maWcuZ2V0VGV4dFdpZHRoKGdjLCBsaW5lLmpvaW4oJyAnKSkgPCB3aWR0aClcbiAgICAgICAgLy8g4oCmQU5EIHRoZXJlIGFyZSBtb3JlIHdvcmRzIGF2YWlsYWJsZeKAplxuICAgICYmIHdvcmRzLmxlbmd0aFxuICAgICAgICApIHtcbiAgICAgICAgLy8g4oCmYWRkIGFub3RoZXIgd29yZCB0byBlbmQgb2YgbGluZSBhbmQgcmV0ZXN0XG4gICAgICAgIGxpbmUucHVzaCh3b3Jkcy5zaGlmdCgpKTtcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICAgICFzdGlsbEZpdHMgLy8gaWYgbGluZSBpcyBub3cgdG9vIGxvbmfigKZcbiAgICAgICAgJiYgbGluZS5sZW5ndGggPiAxIC8vIOKApkFORCBpcyBtdWx0aXBsZSB3b3Jkc+KAplxuICAgICkge1xuICAgICAgICB3b3Jkcy51bnNoaWZ0KGxpbmUucG9wKCkpOyAvLyDigKZiYWNrIG9mZiBieSAoaS5lLiwgcmVtb3ZlKSBvbmUgd29yZFxuICAgIH1cblxuICAgIGxpbmUgPSBbbGluZS5qb2luKCcgJyldO1xuXG4gICAgaWYgKHdvcmRzLmxlbmd0aCkgeyAvLyBpZiB0aGVyZSdzIGFueXRoaW5nIGxlZnTigKZcbiAgICAgICAgbGluZSA9IGxpbmUuY29uY2F0KGZpbmRMaW5lcyhnYywgY29uZmlnLCB3b3Jkcywgd2lkdGgpKTsgLy8g4oCmYnJlYWsgaXQgdXAgYXMgd2VsbFxuICAgIH1cblxuICAgIHJldHVybiBsaW5lO1xufVxuXG5mdW5jdGlvbiBmaXRUZXh0KGdjLCBjb25maWcsIHN0cmluZywgd2lkdGgpIHtcbiAgICByZXR1cm4gZmluZExpbmVzKGdjLCBjb25maWcsIHNxdWVlemUoc3RyaW5nKS5zcGxpdCgnICcpLCB3aWR0aCk7XG59XG5cbi8vIHRyaW0gc3RyaW5nOyB0aGVuIHJlZHVjZSBhbGwgcnVucyBvZiBtdWx0aXBsZSBzcGFjZXMgdG8gYSBzaW5nbGUgc3BhY2VcbmZ1bmN0aW9uIHNxdWVlemUoc3RyaW5nKSB7XG4gICAgcmV0dXJuIHN0cmluZy50b1N0cmluZygpLnRyaW0oKS5yZXBsYWNlKC9cXHNcXHMrL2csICcgJyk7XG59XG5cbmZ1bmN0aW9uIHJvdW5kUmVjdChnYywgeCwgeSwgd2lkdGgsIGhlaWdodCwgcmFkaXVzLCBmaWxsLCBzdHJva2UpIHtcblxuICAgIGlmICghc3Ryb2tlKSB7XG4gICAgICAgIHN0cm9rZSA9IHRydWU7XG4gICAgfVxuICAgIGlmICghcmFkaXVzKSB7XG4gICAgICAgIHJhZGl1cyA9IDU7XG4gICAgfVxuICAgIGdjLmJlZ2luUGF0aCgpO1xuICAgIGdjLm1vdmVUbyh4ICsgcmFkaXVzLCB5KTtcbiAgICBnYy5saW5lVG8oeCArIHdpZHRoIC0gcmFkaXVzLCB5KTtcbiAgICBnYy5xdWFkcmF0aWNDdXJ2ZVRvKHggKyB3aWR0aCwgeSwgeCArIHdpZHRoLCB5ICsgcmFkaXVzKTtcbiAgICBnYy5saW5lVG8oeCArIHdpZHRoLCB5ICsgaGVpZ2h0IC0gcmFkaXVzKTtcbiAgICBnYy5xdWFkcmF0aWNDdXJ2ZVRvKHggKyB3aWR0aCwgeSArIGhlaWdodCwgeCArIHdpZHRoIC0gcmFkaXVzLCB5ICsgaGVpZ2h0KTtcbiAgICBnYy5saW5lVG8oeCArIHJhZGl1cywgeSArIGhlaWdodCk7XG4gICAgZ2MucXVhZHJhdGljQ3VydmVUbyh4LCB5ICsgaGVpZ2h0LCB4LCB5ICsgaGVpZ2h0IC0gcmFkaXVzKTtcbiAgICBnYy5saW5lVG8oeCwgeSArIHJhZGl1cyk7XG4gICAgZ2MucXVhZHJhdGljQ3VydmVUbyh4LCB5LCB4ICsgcmFkaXVzLCB5KTtcbiAgICBnYy5jbG9zZVBhdGgoKTtcbiAgICBpZiAoc3Ryb2tlKSB7XG4gICAgICAgIGdjLnN0cm9rZSgpO1xuICAgIH1cbiAgICBpZiAoZmlsbCkge1xuICAgICAgICBnYy5maWxsKCk7XG4gICAgfVxuICAgIGdjLmNsb3NlUGF0aCgpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IENlbGxQcm92aWRlcjtcbiIsIi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBleHRlbmQgPSByZXF1aXJlKCdleHRlbmQtbWUnKTtcbnZhciBGaW5CYXIgPSByZXF1aXJlKCdmaW5iYXJzJyk7XG52YXIgQ2FudmFzID0gcmVxdWlyZSgnZmluY2FudmFzJyk7XG52YXIgUG9pbnQgPSByZXF1aXJlKCdyZWN0YW5ndWxhcicpLlBvaW50O1xudmFyIFJlY3RhbmdsZSA9IHJlcXVpcmUoJ3JlY3Rhbmd1bGFyJykuUmVjdGFuZ2xlO1xudmFyIExSVUNhY2hlID0gcmVxdWlyZSgnbHJ1LWNhY2hlJyk7XG52YXIgXyA9IHJlcXVpcmUoJ29iamVjdC1pdGVyYXRvcnMnKTtcblxudmFyIFJlbmRlcmVyID0gcmVxdWlyZSgnLi9SZW5kZXJlcicpO1xudmFyIFNlbGVjdGlvbk1vZGVsID0gcmVxdWlyZSgnLi9TZWxlY3Rpb25Nb2RlbCcpO1xudmFyIGFkZFN0eWxlc2hlZXQgPSByZXF1aXJlKCcuL3N0eWxlc2hlZXRzJyk7XG5cbnZhciBnbG9iYWxDZWxsRWRpdG9ycyA9IHt9LFxuICAgIHByb3BlcnRpZXNJbml0aWFsaXplZCA9IGZhbHNlLFxuICAgIHRleHRXaWR0aENhY2hlID0gbmV3IExSVUNhY2hlKDIwMDApLFxuICAgIGRlZmF1bHRzID0gZGVmYXVsdFByb3BlcnRpZXMoKSxcbiAgICBwb2x5bWVyVGhlbWUgPSBPYmplY3QuY3JlYXRlKGRlZmF1bHRzKSxcbiAgICBnbG9iYWxQcm9wZXJ0aWVzID0gT2JqZWN0LmNyZWF0ZShwb2x5bWVyVGhlbWUpO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHtzdHJpbmd8RWxlbWVudH0gZGl2IC0gQ1NTIHNlbGVjdG9yIG9yIEVsZW1lbnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBiZWhhdmlvck5hbWUgLSBuYW1lIG9mIGEgYmVoYXZpb3IgY29uc3N0cnVjdG9yIGZyb20gLi9iZWhhdmlvcnNcbiAqL1xuZnVuY3Rpb24gSHlwZXJncmlkKGRpdiwgYmVoYXZpb3JGYWN0b3J5KSB7XG5cbiAgICBleHRlbmQuZGVidWcgPSB0cnVlO1xuXG4gICAgaW5zdGFsbFBvbHlmaWxscygpO1xuXG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgdGhpcy5kaXYgPSAodHlwZW9mIGRpdiA9PT0gJ3N0cmluZycpID8gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihkaXYpIDogZGl2O1xuXG4gICAgYWRkU3R5bGVzaGVldCgnZ3JpZCcpO1xuXG4gICAgdGhpcy5sYXN0RWRnZVNlbGVjdGlvbiA9IFswLCAwXTtcblxuICAgIHRoaXMubG5mUHJvcGVydGllcyA9IE9iamVjdC5jcmVhdGUoZ2xvYmFsUHJvcGVydGllcyk7XG5cbiAgICB0aGlzLmlzV2Via2l0ID0gbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLmluZGV4T2YoJ3dlYmtpdCcpID4gLTE7XG4gICAgdGhpcy5zZWxlY3Rpb25Nb2RlbCA9IG5ldyBTZWxlY3Rpb25Nb2RlbCgpO1xuICAgIHRoaXMuc2VsZWN0aW9uTW9kZWwuZ2V0R3JpZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gc2VsZjtcbiAgICB9O1xuICAgIHRoaXMuY2VsbEVkaXRvcnMgPSBPYmplY3QuY3JlYXRlKGdsb2JhbENlbGxFZGl0b3JzKTtcbiAgICB0aGlzLnJlbmRlck92ZXJyaWRlc0NhY2hlID0ge307XG5cbiAgICB0aGlzLmJlaGF2aW9yID0gYmVoYXZpb3JGYWN0b3J5KHRoaXMpO1xuXG4gICAgLy9wcmV2ZW50IHRoZSBkZWZhdWx0IGNvbnRleHQgbWVudSBmb3IgYXBwZWFyaW5nXG4gICAgdGhpcy5kaXYub25jb250ZXh0bWVudSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgdGhpcy5jbGVhck1vdXNlRG93bigpO1xuICAgIHRoaXMuZHJhZ0V4dGVudCA9IG5ldyBQb2ludCgwLCAwKTtcbiAgICB0aGlzLm51bVJvd3MgPSAwO1xuICAgIHRoaXMubnVtQ29sdW1ucyA9IDA7XG5cbiAgICAvL2luc3RhbGwgYW55IHBsdWdpbnNcbiAgICB0aGlzLnBsdWdpbnNEbyhmdW5jdGlvbihlYWNoKSB7XG4gICAgICAgIGlmIChlYWNoLmluc3RhbGxPbikge1xuICAgICAgICAgICAgZWFjaC5pbnN0YWxsT24oc2VsZik7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vaW5pdGlhbGl6ZSBvdXIgdmFyaW91cyBwaWVjZXNcbiAgICB0aGlzLmluaXRSZW5kZXJlcigpO1xuICAgIHRoaXMuaW5pdENhbnZhcygpO1xuICAgIHRoaXMuaW5pdFNjcm9sbGJhcnMoKTtcbiAgICB0aGlzLmluaXRHbG9iYWxDZWxsRWRpdG9ycygpO1xuXG4gICAgdGhpcy5jaGVja1Njcm9sbGJhclZpc2liaWxpdHkoKTtcbiAgICAvL1JlZ2lzdGVyIGEgbGlzdGVuZXIgZm9yIHRoZSBjb3B5IGV2ZW50IHNvIHdlIGNhbiBjb3B5IG91ciBzZWxlY3RlZCByZWdpb24gdG8gdGhlIHBhc3RlYnVmZmVyIGlmIGNvbmRpdGlvbnMgYXJlIHJpZ2h0LlxuICAgIGRvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcignY29weScsIGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICBzZWxmLmNoZWNrQ2xpcGJvYXJkQ29weShldnQpO1xuICAgIH0pO1xuICAgIHRoaXMuZ2V0Q2FudmFzKCkucmVzaXplKCk7XG4gICAgLy90aGlzLmNvbXB1dGVDZWxsc0JvdW5kcygpO1xufVxuXG5IeXBlcmdyaWQucHJvdG90eXBlID0ge1xuICAgIGNvbnN0cnVjdG9yOiBIeXBlcmdyaWQucHJvdG90eXBlLmNvbnN0cnVjdG9yLFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBBIG51bGwgb2JqZWN0IGJlaGF2aW9yIHNlcnZlcyBhcyBhIHBsYWNlIGhvbGRlci5cbiAgICAgKiBAdHlwZSB7b2JqZWN0fVxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICovXG4gICAgYmVoYXZpb3I6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBDYWNoZWQgcmVzdWx0IG9mIGlmIHdlIGFyZSBydW5uaW5nIGluIHdlYmtpdC5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGlzV2Via2l0OiB0cnVlLFxuXG4gICAgLyoqXG4gICAgICogVGhlIHBpeGVsIGxvY2F0aW9uIG9mIGFuIGluaXRpYWwgbW91c2Vkb3duIGNsaWNrLCBlaXRoZXIgZm9yIGVkaXRpbmcgYSBjZWxsIG9yIGZvciBkcmFnZ2luZyBhIHNlbGVjdGlvbi5cbiAgICAgKiBAdHlwZSB7UG9pbnR9XG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBtb3VzZURvd246IFtdLFxuXG4gICAgLyoqXG4gICAgICogVGhlIGV4dGVudCBmcm9tIHRoZSBtb3VzZWRvd24gcG9pbnQgZHVyaW5nIGEgZHJhZyBvcGVyYXRpb24uXG4gICAgICogQHR5cGUge1BvaW50fVxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICovXG5cbiAgICBkcmFnRXh0ZW50OiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogQSBmbG9hdCB2YWx1ZSBiZXR3ZWVuIDAuMCAtIDEuMCBvZiB0aGUgdmVydGljYWwgc2Nyb2xsIHBvc2l0aW9uLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKi9cbiAgICB2U2Nyb2xsVmFsdWU6IDAsXG5cbiAgICAvKipcbiAgICAgKiBBIGZsb2F0IHZhbHVlIGJldHdlZW4gMC4wIC0gMS4wIG9mIHRoZSBob3Jpem9udGFsIHNjcm9sbCBwb3NpdGlvbi5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICovXG4gICAgaFNjcm9sbFZhbHVlOiAwLFxuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHt3aW5kb3cuZmluLnJlY3Rhbmd1bGFyfSByZWN0YW5ndWxhciAtIE5hbWVzcGFjZSBmb3IgUG9pbnQgYW5kIFJlY3RhbmdsZSBcImNsYXNzZXNcIiAoY29uc3RydWN0b3JzKS5cbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHJlY3Rhbmd1bGFyOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogQHByb3BlcnR5IHtmaW4taHlwZXJncmlkLXNlbGVjdGlvbi1tb2RlbH0gc2VsZWN0aW9uTW9kZWwgLSBBIFtmaW4taHlwZXJncmlkLXNlbGVjdGlvbi1tb2RlbF0obW9kdWxlLS5fc2VsZWN0aW9uLW1vZGVsLmh0bWwpIGluc3RhbmNlLlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICovXG4gICAgc2VsZWN0aW9uTW9kZWw6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge2Zpbi1oeXBlcmdyaWQtY2VsbC1lZGl0b3J9IGNlbGxFZGl0b3IgLSBUaGUgY3VycmVudCBpbnN0YW5jZSBvZiBbZmluLWh5cGVyZ3JpZC1jZWxsLWVkaXRvcl0obW9kdWxlLWNlbGwtZWRpdG9yc19iYXNlLmh0bWwpLlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICovXG4gICAgY2VsbEVkaXRvcjogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIEBwcm9wZXJ0eSB7ZmluLXZhbXBpcmUtYmFyfSBzYkhTY3JvbGxlciAtIEFuIGluc3RhbmNlIG9mIFtmaW4tdmFtcGlyZS1iYXJdKGh0dHA6Ly9kYXRhbWFkaWMuZ2l0aHViLmlvL2Zpbi12YW1waXJlLWJhci9jb21wb25lbnRzL2Zpbi12YW1waXJlLWJhci8pLlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICovXG4gICAgc2JIU2Nyb2xsZXI6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBAcHJvcGVydHkge2Zpbi12YW1waXJlLWJhcn0gc2JWU2Nyb2xsZXIgLSBBbiBpbnN0YW5jZSBvZiBbZmluLXZhbXBpcmUtYmFyXShodHRwOi8vZGF0YW1hZGljLmdpdGh1Yi5pby9maW4tdmFtcGlyZS1iYXIvY29tcG9uZW50cy9maW4tdmFtcGlyZS1iYXIvKS5cbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHNiVlNjcm9sbGVyOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogVGhlIHByZXZpb3VzIHZhbHVlIG9mIHNiVlNjcm9sbFZhbC5cbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICovXG4gICAgc2JQcmV2VlNjcm9sbFZhbHVlOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogVGhlIHByZXZpb3VzIHZhbHVlIG9mIHNiSFNjcm9sbFZhbHVlLlxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBzYlByZXZIU2Nyb2xsVmFsdWU6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgY2FjaGUgb2Ygc2luZ2xldG9uIGNlbGxFZGl0b3JzLlxuICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBjZWxsRWRpdG9yczogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIGlzIHRoZSBzaG9ydCB0ZXJtIG1lbW9yeSBvZiB3aGF0IGNvbHVtbiBJIG1pZ2h0IGJlIGRyYWdnaW5nIGFyb3VuZFxuICAgICAqIEB0eXBlIHtvYmplY3R9XG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKi9cblxuICAgIHJlbmRlck92ZXJyaWRlc0NhY2hlOiB7fSxcblxuICAgIC8qKlxuICAgICAqIFRoZSBwaXhlbCBsb2NhdGlvbiBvZiB0aGUgY3VycmVudCBob3ZlcmVkIGNlbGwuXG4gICAgICogQHR5cGUge1BvaW50fVxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICovXG4gICAgaG92ZXJDZWxsOiBudWxsLFxuXG4gICAgc2Nyb2xsaW5nTm93OiBmYWxzZSxcblxuICAgIGxhc3RFZGdlU2VsZWN0aW9uOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICBjbGVhciBvdXQgdGhlIExSVSBjYWNoZSBvZiB0ZXh0IHdpZHRoc1xuICAgICAqL1xuICAgIHNldEF0dHJpYnV0ZTogZnVuY3Rpb24oYXR0cmlidXRlLCB2YWx1ZSkge1xuICAgICAgICB0aGlzLmRpdi5zZXRBdHRyaWJ1dGUoYXR0cmlidXRlLCB2YWx1ZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgY2xlYXIgb3V0IGFsbCBzdGF0ZSBhbmQgZGF0YSBvZiB0aGUgZ3JpZFxuICAgICAqL1xuICAgIHJlc2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB0aGlzLmxhc3RFZGdlU2VsZWN0aW9uID0gWzAsIDBdO1xuICAgICAgICB0aGlzLmxuZlByb3BlcnRpZXMgPSBPYmplY3QuY3JlYXRlKGdsb2JhbFByb3BlcnRpZXMpO1xuICAgICAgICB0aGlzLnNlbGVjdGlvbk1vZGVsID0gbmV3IFNlbGVjdGlvbk1vZGVsKCk7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9uTW9kZWwuZ2V0R3JpZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY2VsbEVkaXRvcnMgPSBPYmplY3QuY3JlYXRlKGdsb2JhbENlbGxFZGl0b3JzKTtcbiAgICAgICAgdGhpcy5yZW5kZXJPdmVycmlkZXNDYWNoZSA9IHt9O1xuICAgICAgICB0aGlzLmNsZWFyTW91c2VEb3duKCk7XG4gICAgICAgIHRoaXMuZHJhZ0V4dGVudCA9IG5ldyBQb2ludCgwLCAwKTtcblxuICAgICAgICB0aGlzLm51bVJvd3MgPSAwO1xuICAgICAgICB0aGlzLm51bUNvbHVtbnMgPSAwO1xuXG4gICAgICAgIHRoaXMudlNjcm9sbFZhbHVlID0gMDtcbiAgICAgICAgdGhpcy5oU2Nyb2xsVmFsdWUgPSAwO1xuXG4gICAgICAgIHRoaXMuY2VsbEVkaXRvciA9IG51bGw7XG5cbiAgICAgICAgdGhpcy5zYlByZXZWU2Nyb2xsVmFsdWUgPSBudWxsO1xuICAgICAgICB0aGlzLnNiUHJldkhTY3JvbGxWYWx1ZSA9IG51bGw7XG5cbiAgICAgICAgdGhpcy5ob3ZlckNlbGwgPSBudWxsO1xuICAgICAgICB0aGlzLnNjcm9sbGluZ05vdyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmxhc3RFZGdlU2VsZWN0aW9uID0gWzAsIDBdO1xuXG4gICAgICAgIHRoaXMuZ2V0QmVoYXZpb3IoKS5yZXNldCgpO1xuICAgICAgICB0aGlzLmdldFJlbmRlcmVyKCkucmVzZXQoKTtcbiAgICAgICAgdGhpcy5nZXRDYW52YXMoKS5yZXNpemUoKTtcbiAgICAgICAgdGhpcy5iZWhhdmlvckNoYW5nZWQoKTtcbiAgICB9LFxuXG4gICAgcmVzZXRUZXh0V2lkdGhDYWNoZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRleHRXaWR0aENhY2hlID0gbmV3IExSVUNhY2hlKDIwMDApO1xuICAgIH0sXG5cbiAgICBnZXRQcm9wZXJ0aWVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UHJpdmF0ZVN0YXRlKCk7XG4gICAgfSxcblxuICAgIF9nZXRQcm9wZXJ0aWVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG5mUHJvcGVydGllcztcbiAgICB9LFxuXG4gICAgY29tcHV0ZUNlbGxzQm91bmRzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5nZXRSZW5kZXJlcigpLmNvbXB1dGVDZWxsc0JvdW5kcygpO1xuICAgIH0sXG5cbiAgICBpbml0Q2VsbEVkaXRvcjogZnVuY3Rpb24oY2VsbEVkaXRvcikge1xuICAgICAgICB2YXIgZGl2Q2VsbEVkaXRvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0aGlzLmRpdi5hcHBlbmRDaGlsZChkaXZDZWxsRWRpdG9yKTtcblxuICAgICAgICBnbG9iYWxDZWxsRWRpdG9yc1tjZWxsRWRpdG9yLmFsaWFzXSA9IGNlbGxFZGl0b3I7XG4gICAgfSxcblxuICAgIGluaXRHbG9iYWxDZWxsRWRpdG9yczogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghcHJvcGVydGllc0luaXRpYWxpemVkKSB7XG4gICAgICAgICAgICBwcm9wZXJ0aWVzSW5pdGlhbGl6ZWQgPSB0cnVlO1xuXG4gICAgICAgICAgICBidWlsZFBvbHltZXJUaGVtZSgpO1xuXG4gICAgICAgICAgICB2YXIgY2VsbEVkaXRvcnMgPSBbXG4gICAgICAgICAgICAgICAgJ1RleHRmaWVsZCcsXG4gICAgICAgICAgICAgICAgJ0Nob2ljZScsXG4gICAgICAgICAgICAgICAgLy8nQ29tYm8nLFxuICAgICAgICAgICAgICAgICdDb2xvcicsXG4gICAgICAgICAgICAgICAgJ0RhdGUnLFxuICAgICAgICAgICAgICAgICdTbGlkZXInLFxuICAgICAgICAgICAgICAgICdTcGlubmVyJ1xuICAgICAgICAgICAgXTtcblxuICAgICAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAgICAgY2VsbEVkaXRvcnMuZm9yRWFjaChmdW5jdGlvbihuYW1lKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5pbml0Q2VsbEVkaXRvcihuZXcgSHlwZXJncmlkLmNlbGxFZGl0b3JzW25hbWVdKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHRvZ2dsZUNvbHVtblBpY2tlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuZ2V0QmVoYXZpb3IoKS50b2dnbGVDb2x1bW5QaWNrZXIoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVGhlIHBvaW50ZXIgaXMgb3ZlciB0aGUgZ2l2ZW4gY2VsbC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCAtIFRoZSB4IGNlbGwgY29vcmRpbmF0ZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSAtIFRoZSB5IGNlbGwgY29vcmRpbmF0ZS5cbiAgICAgKi9cbiAgICBpc0hvdmVyZWQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgdmFyIHAgPSB0aGlzLmdldEhvdmVyQ2VsbCgpO1xuICAgICAgICBpZiAoIXApIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcC54ID09PSB4ICYmIHAueSA9PT0geTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyBib29sZWFufSBUaGUgcG9pbnRlciBpcyBob3ZlcmluZyBvdmVyIHRoZSBnaXZlbiBjb2x1bW4uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggLSBUaGUgaG9yaXpvbnRhbCBjZWxsIGNvb3JkaW5hdGUuXG4gICAgICovXG4gICAgaXNDb2x1bW5Ib3ZlcmVkOiBmdW5jdGlvbih4KSB7XG4gICAgICAgIHZhciBwID0gdGhpcy5nZXRIb3ZlckNlbGwoKTtcbiAgICAgICAgaWYgKCFwKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHAueCA9PT0geDtcbiAgICB9LFxuXG4gICAgaXNSb3dSZXNpemVhYmxlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzb2x2ZVByb3BlcnR5KCdyb3dSZXNpemUnKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFRoZSBwb2ludGVyIGlzIGhvdmVyaW5nIG92ZXIgdGhlIHJvdyBgeWAuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgLSBUaGUgdmVydGljYWwgY2VsbCBjb29yZGluYXRlLlxuICAgICAqL1xuICAgIGlzUm93SG92ZXJlZDogZnVuY3Rpb24oeSkge1xuICAgICAgICB2YXIgcCA9IHRoaXMuZ2V0SG92ZXJDZWxsKCk7XG4gICAgICAgIGlmICghcCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwLnkgPT09IHk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge1BvaW50fSBUaGUgY2VsbCBvdmVyIHdoaWNoIHRoZSBjdXJzb3IgaXMgaG92ZXJpbmcuXG4gICAgICovXG4gICAgZ2V0SG92ZXJDZWxsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaG92ZXJDZWxsO1xuICAgIH0sXG5cblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQGRlc2MgU2V0IHRoZSBjZWxsIHVuZGVyIHRoZSBjdXJzb3IuXG4gICAgICogQHBhcmFtIHtQb2ludH0gcG9pbnRcbiAgICAgKi9cbiAgICBzZXRIb3ZlckNlbGw6IGZ1bmN0aW9uKHBvaW50KSB7XG4gICAgICAgIHZhciBtZSA9IHRoaXMuaG92ZXJDZWxsO1xuICAgICAgICB2YXIgbmV3UG9pbnQgPSBuZXcgUG9pbnQocG9pbnQueCwgcG9pbnQueSk7XG4gICAgICAgIGlmIChtZSAmJiBtZS5lcXVhbHMobmV3UG9pbnQpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ob3ZlckNlbGwgPSBuZXdQb2ludDtcbiAgICAgICAgdGhpcy5maXJlU3ludGhldGljT25DZWxsRW50ZXJFdmVudChuZXdQb2ludCk7XG4gICAgICAgIHRoaXMucmVwYWludCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIEFtbWVuZCBwcm9wZXJ0aWVzIGZvciBhbGwgaHlwZXJncmlkcyBpbiB0aGlzIHByb2Nlc3MuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHByb3BlcnRpZXMgLSBBIHNpbXBsZSBwcm9wZXJ0aWVzIGhhc2guXG4gICAgICovXG4gICAgYWRkR2xvYmFsUHJvcGVydGllczogZnVuY3Rpb24ocHJvcGVydGllcykge1xuICAgICAgICAvL3dlIGNoZWNrIGZvciBleGlzdGVuY2UgdG8gYXZvaWQgcmFjZSBjb25kaXRpb24gaW4gaW5pdGlhbGl6YXRpb25cbiAgICAgICAgaWYgKCFnbG9iYWxQcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHNlbGYuYWRkR2xvYmFsUHJvcGVydGllcyhwcm9wZXJ0aWVzKTtcbiAgICAgICAgICAgIH0sIDEwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2FkZEdsb2JhbFByb3BlcnRpZXMocHJvcGVydGllcyk7XG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIEFtbWVuZCBwcm9wZXJ0aWVzIGZvciBhbGwgaHlwZXJncmlkcyBpbiB0aGlzIHByb2Nlc3MuXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHByb3BlcnRpZXMgLSBBIHNpbXBsZSBwcm9wZXJ0aWVzIGhhc2guXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfYWRkR2xvYmFsUHJvcGVydGllczogZnVuY3Rpb24ocHJvcGVydGllcykge1xuICAgICAgICBfKHByb3BlcnRpZXMpLmVhY2goZnVuY3Rpb24ocHJvcGVydHksIGtleSkge1xuICAgICAgICAgICAgZ2xvYmFsUHJvcGVydGllc1trZXldID0gcHJvcGVydHk7XG4gICAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIEFtbWVuZCBwcm9wZXJ0aWVzIGZvciB0aGlzIGh5cGVyZ3JpZCBvbmx5LlxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBwcm9wZXJ0aWVzIC0gQSBzaW1wbGUgcHJvcGVydGllcyBoYXNoLlxuICAgICAqL1xuICAgIGFkZFByb3BlcnRpZXM6IGZ1bmN0aW9uKG1vcmVQcm9wZXJ0aWVzKSB7XG4gICAgICAgIHZhciBwcm9wZXJ0aWVzID0gdGhpcy5nZXRQcm9wZXJ0aWVzKCk7XG4gICAgICAgIF8obW9yZVByb3BlcnRpZXMpLmVhY2goZnVuY3Rpb24ocHJvcGVydHksIGtleSkge1xuICAgICAgICAgICAgcHJvcGVydGllc1trZXldID0gbW9yZVByb3BlcnRpZXNba2V5XTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVmcmVzaFByb3BlcnRpZXMoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBVdGlsaXR5IGZ1bmN0aW9uIHRvIHB1c2ggb3V0IHByb3BlcnRpZXMgaWYgd2UgY2hhbmdlIHRoZW0uXG4gICAgICogQHBhcmFtIHtvYmplY3R9IHByb3BlcnRpZXMgLSBBbiBvYmplY3Qgb2YgdmFyaW91cyBrZXkgdmFsdWUgcGFpcnMuXG4gICAgICovXG5cbiAgICByZWZyZXNoUHJvcGVydGllczogZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIHRoaXMuY2FudmFzID0gdGhpcy5zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoJ2Zpbi1jYW52YXMnKTtcbiAgICAgICAgLy90aGlzLmNhbnZhcyA9IG5ldyBDYW52YXModGhpcy5kaXZDYW52YXMsIHRoaXMucmVuZGVyZXIpOyAvL1RPRE86IERvIHdlIHJlYWxseSBuZWVkIHRvIGJlIHJlY3JlYXRpbmcgaXQgaGVyZT9cbiAgICAgICAgdGhpcy5jaGVja1Njcm9sbGJhclZpc2liaWxpdHkoKTtcbiAgICAgICAgdGhpcy5nZXRCZWhhdmlvcigpLmRlZmF1bHRSb3dIZWlnaHQgPSBudWxsO1xuICAgICAgICBpZiAodGhpcy5pc0NvbHVtbkF1dG9zaXppbmcoKSkge1xuICAgICAgICAgICAgdGhpcy5nZXRCZWhhdmlvcigpLmF1dG9zaXplQWxsQ29sdW1ucygpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge29iamVjdH0gVGhlIHN0YXRlIG9iamVjdCBmb3IgcmVtZW1iZXJpbmcgb3VyIHN0YXRlLlxuICAgICAqIEBzZWUgW01lbWVudG8gcGF0dGVybl0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9NZW1lbnRvX3BhdHRlcm4pXG4gICAgICovXG4gICAgZ2V0UHJpdmF0ZVN0YXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QmVoYXZpb3IoKS5nZXRQcml2YXRlU3RhdGUoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBTZXQgdGhlIHN0YXRlIG9iamVjdCB0byByZXR1cm4gdG8gdGhlIGdpdmVuIHVzZXIgY29uZmlndXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge29iamVjdH0gc3RhdGUgLSBBIG1lbWVudG8gb2JqZWN0LlxuICAgICAqIEBzZWUgW01lbWVudG8gcGF0dGVybl0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9NZW1lbnRvX3BhdHRlcm4pXG4gICAgICovXG4gICAgc2V0U3RhdGU6IGZ1bmN0aW9uKHN0YXRlKSB7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdGhpcy5nZXRCZWhhdmlvcigpLnNldFN0YXRlKHN0YXRlKTtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHNlbGYuYmVoYXZpb3JDaGFuZ2VkKCk7XG4gICAgICAgICAgICBzZWxmLnN5bmNocm9uaXplU2Nyb2xsaW5nQm91bmRyaWVzKCk7XG4gICAgICAgIH0sIDEwMCk7XG4gICAgfSxcblxuICAgIGdldFN0YXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QmVoYXZpb3IoKS5nZXRTdGF0ZSgpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSBUaGUgaW5pdGlhbCBtb3VzZSBwb3NpdGlvbiBvbiBhIG1vdXNlIGRvd24gZXZlbnQgZm9yIGNlbGwgZWRpdGluZyBvciBhIGRyYWcgb3BlcmF0aW9uLlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICovXG4gICAgZ2V0TW91c2VEb3duOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGxhc3QgPSB0aGlzLm1vdXNlRG93bi5sZW5ndGggLSAxO1xuICAgICAgICBpZiAobGFzdCA8IDApIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLm1vdXNlRG93bltsYXN0XTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBSZW1vdmUgdGhlIGxhc3QgaXRlbSBmcm9tIHRoZSBtb3VzZSBkb3duIHN0YWNrLlxuICAgICAqL1xuICAgIHBvcE1vdXNlRG93bjogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLm1vdXNlRG93bi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1vdXNlRG93bi5sZW5ndGggPSB0aGlzLm1vdXNlRG93bi5sZW5ndGggLSAxO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIEVtcHR5IG91dCB0aGUgbW91c2UgZG93biBzdGFjay5cbiAgICAgKi9cbiAgICBjbGVhck1vdXNlRG93bjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMubW91c2VEb3duID0gW25ldyBQb2ludCgtMSwgLTEpXTtcbiAgICAgICAgdGhpcy5kcmFnRXh0ZW50ID0gbnVsbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgc2V0IHRoZSBtb3VzZSBwb2ludCB0aGF0IGluaXRhdGVkIGEgY2VsbCBlZGl0IG9yIGRyYWcgb3BlcmF0aW9uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BvaW50fSBwb2ludFxuICAgICAqL1xuICAgIHNldE1vdXNlRG93bjogZnVuY3Rpb24ocG9pbnQpIHtcbiAgICAgICAgdGhpcy5tb3VzZURvd24ucHVzaChwb2ludCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge1BvaW50fSBUaGUgZXh0ZW50IHBvaW50IG9mIHRoZSBjdXJyZW50IGRyYWcgc2VsZWN0aW9uIHJlY3RhbmdsZS5cbiAgICAgKi9cbiAgICBnZXREcmFnRXh0ZW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZHJhZ0V4dGVudDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAc3VtbWFyeSBTZXRzIHRoZSBleHRlbnQgcG9pbnQgb2YgdGhlIGN1cnJlbnQgZHJhZyBzZWxlY3Rpb24gb3BlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7UG9pbnR9IHBvaW50XG4gICAgICovXG4gICAgc2V0RHJhZ0V4dGVudDogZnVuY3Rpb24ocG9pbnQpIHtcbiAgICAgICAgdGhpcy5kcmFnRXh0ZW50ID0gcG9pbnQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHN1bW1hcnkgSXRlcmF0ZSBvdmVyIHRoZSBwbHVnaW5zIGludm9raW5nIHRoZSBnaXZlbiBmdW5jdGlvbiB3aXRoIGVhY2guXG4gICAgICogQHRvZG8gV2UgbmVlZCBhIG5ldyBwbHVnaW4gbWVjaGFuaXNtIVxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGZ1bmMgLSBUaGUgZnVuY3Rpb24gdG8gaW52b2tlIG9uIGFsbCB0aGUgcGx1Z2lucy5cbiAgICAgKi9cbiAgICBwbHVnaW5zRG86IGZ1bmN0aW9uKGZ1bmMpIHtcbiAgICAgICAgLy9UT0RPOiBXZSBuZWVkIGEgbmV3IHBsdWdpbiBtZWNoYW5pc20hXG4gICAgICAgIC8vdmFyIHVzZXJQbHVnaW5zID0gdGhpcy5jaGlsZHJlbi5hcnJheSgpO1xuICAgICAgICAvL3ZhciBwbHVnaW5zVGFnID0gdGhpcy5zaGFkb3dSb290LnF1ZXJ5U2VsZWN0b3IoJ2Zpbi1wbHVnaW5zJyk7XG4gICAgICAgIC8vXG4gICAgICAgIC8vdmFyIHBsdWdpbnMgPSB1c2VyUGx1Z2lucztcbiAgICAgICAgLy9pZiAocGx1Z2luc1RhZykge1xuICAgICAgICAvLyAgICB2YXIgc3lzdGVtUGx1Z2lucyA9IHBsdWdpbnNUYWcuY2hpbGRyZW4uYXJyYXkoKTtcbiAgICAgICAgLy8gICAgcGx1Z2lucyA9IHN5c3RlbVBsdWdpbnMuY29uY2F0KHBsdWdpbnMpO1xuICAgICAgICAvL31cbiAgICAgICAgLy9cbiAgICAgICAgLy9wbHVnaW5zLmZvckVhY2goZnVuY3Rpb24ocGx1Z2luKSB7XG4gICAgICAgIC8vICAgIGZ1bmMocGx1Z2luKTtcbiAgICAgICAgLy99KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBUaGUgQ2VsbFByb3ZpZGVyIGlzIGFjY2Vzc2VkIHRocm91Z2ggSHlwZXJncmlkIGJlY2F1c2UgSHlwZXJncmlkIGlzIHRoZSBtZWRpYXRvciBhbmQgc2hvdWxkIGhhdmUgdWx0aW1hdGUgY29udHJvbCBvbiB3aGVyZSBpdCBjb21lcyBmcm9tLiBUaGUgZGVmYXVsdCBpcyB0byBkZWxlZ2F0ZSB0aHJvdWdoIHRoZSBiZWhhdmlvciBvYmplY3QuXG4gICAgICogQHJldHVybnMge2Zpbi1oeXBlcmdyaWQtY2VsbC1wcm92aWRlcn1cbiAgICAgKi9cbiAgICBnZXRDZWxsUHJvdmlkZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcHJvdmlkZXIgPSB0aGlzLmdldEJlaGF2aW9yKCkuZ2V0Q2VsbFByb3ZpZGVyKCk7XG4gICAgICAgIHJldHVybiBwcm92aWRlcjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBUaGlzIGZ1bmN0aW9uIGlzIGEgY2FsbGJhY2sgZnJvbSB0aGUgSHlwZXJncmlkUmVuZGVyZXIgc3ViLWNvbXBvbmVudC4gSXQgaXMgY2FsbGVkIGFmdGVyIGVhY2ggcGFpbnQgb2YgdGhlIGNhbnZhcy5cbiAgICAgKi9cbiAgICBncmlkUmVuZGVyZWROb3RpZmljYXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnVwZGF0ZVJlbmRlcmVkU2l6ZXMoKTtcbiAgICAgICAgaWYgKHRoaXMuY2VsbEVkaXRvcikge1xuICAgICAgICAgICAgdGhpcy5jZWxsRWRpdG9yLmdyaWRSZW5kZXJlZE5vdGlmaWNhdGlvbigpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2hlY2tDb2x1bW5BdXRvc2l6aW5nKCk7XG4gICAgICAgIHRoaXMuZmlyZVN5bnRoZXRpY0dyaWRSZW5kZXJlZEV2ZW50KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQGRlc2MgVGhlIGdyaWQgaGFzIGp1c3QgYmVlbiByZW5kZXJlZCwgbWFrZSBzdXJlIHRoZSBjb2x1bW4gd2lkdGhzIGFyZSBvcHRpbWFsLlxuICAgICAqL1xuICAgIGNoZWNrQ29sdW1uQXV0b3NpemluZzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBiZWhhdmlvciA9IHRoaXMuZ2V0QmVoYXZpb3IoKTtcbiAgICAgICAgYmVoYXZpb3IuYXV0b1NpemVSb3dOdW1iZXJDb2x1bW4oKTtcbiAgICAgICAgaWYgKHRoaXMuaXNDb2x1bW5BdXRvc2l6aW5nKCkpIHtcbiAgICAgICAgICAgIGJlaGF2aW9yLmNoZWNrQ29sdW1uQXV0b3NpemluZyhmYWxzZSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQGRlc2MgTm90aWZ5IHRoZSBHcmlkQmVoYXZpb3IgaG93IG1hbnkgcm93cyBhbmQgY29sdW1ucyB3ZSBqdXN0IHJlbmRlcmVkLlxuICAgICAqL1xuICAgIHVwZGF0ZVJlbmRlcmVkU2l6ZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYmVoYXZpb3IgPSB0aGlzLmdldEJlaGF2aW9yKCk7XG4gICAgICAgIC8vYWRkIG9uZSB0byBlYWNoIG9mIHRoZXNlIHZhbHVlcyBhcyB3ZSB3YW50IGFsc28gdG8gaW5jbHVkZVxuICAgICAgICAvL3RoZSBjb2x1bW5zIGFuZCByb3dzIHRoYXQgYXJlIHBhcnRpYWxseSB2aXNpYmxlXG4gICAgICAgIGJlaGF2aW9yLnNldFJlbmRlcmVkQ29sdW1uQ291bnQodGhpcy5nZXRWaXNpYmxlQ29sdW1ucygpICsgMSk7XG4gICAgICAgIGJlaGF2aW9yLnNldFJlbmRlcmVkUm93Q291bnQodGhpcy5nZXRWaXNpYmxlUm93cygpICsgMSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHN1bW1hcnkgQ29uZGl0aW9uYWxseSBjb3B5IHRvIGNsaXBib2FyZC5cbiAgICAgKiBAZGVzYyBJZiB3ZSBoYXZlIGZvY3VzLCBjb3B5IG91ciBjdXJyZW50IHNlbGVjdGlvbiBkYXRhIHRvIHRoZSBzeXN0ZW0gY2xpcGJvYXJkLlxuICAgICAqIEBwYXJhbSB7ZXZlbnR9IGV2ZW50IC0gVGhlIGNvcHkgc3lzdGVtIGV2ZW50LlxuICAgICAqL1xuICAgIGNoZWNrQ2xpcGJvYXJkQ29weTogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgaWYgKCF0aGlzLmhhc0ZvY3VzKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB2YXIgY3N2RGF0YSA9IHRoaXMuZ2V0U2VsZWN0aW9uQXNUU1YoKTtcbiAgICAgICAgZXZlbnQuY2xpcGJvYXJkRGF0YS5zZXREYXRhKCd0ZXh0L3BsYWluJywgY3N2RGF0YSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFdlIGhhdmUgYW55IHNlbGVjdGlvbnMuXG4gICAgICovXG4gICAgaGFzU2VsZWN0aW9uczogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghdGhpcy5nZXRTZWxlY3Rpb25Nb2RlbCkge1xuICAgICAgICAgICAgcmV0dXJuOyAvLyB3ZXJlIG5vdCBmdWxseSBpbml0aWFsaXplZCB5ZXRcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5nZXRTZWxlY3Rpb25Nb2RlbCgpLmhhc1NlbGVjdGlvbnMoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBUYWIgc2VwYXJhdGVkIHZhbHVlIHN0cmluZyBmcm9tIHRoZSBzZWxlY3Rpb24gYW5kIG91ciBkYXRhLlxuICAgICAqL1xuICAgIGdldFNlbGVjdGlvbkFzVFNWOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNtID0gdGhpcy5nZXRTZWxlY3Rpb25Nb2RlbCgpO1xuICAgICAgICBpZiAoc20uaGFzU2VsZWN0aW9ucygpKSB7XG4gICAgICAgICAgICB2YXIgc2VsZWN0aW9ucyA9IHRoaXMuZ2V0U2VsZWN0aW9uTWF0cml4KCk7XG4gICAgICAgICAgICBzZWxlY3Rpb25zID0gc2VsZWN0aW9uc1tzZWxlY3Rpb25zLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TWF0cml4U2VsZWN0aW9uQXNUU1Yoc2VsZWN0aW9ucyk7XG4gICAgICAgIH0gZWxzZSBpZiAoc20uaGFzUm93U2VsZWN0aW9ucygpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRNYXRyaXhTZWxlY3Rpb25Bc1RTVih0aGlzLmdldFJvd1NlbGVjdGlvbk1hdHJpeCgpKTtcbiAgICAgICAgfSBlbHNlIGlmIChzbS5oYXNDb2x1bW5TZWxlY3Rpb25zKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldE1hdHJpeFNlbGVjdGlvbkFzVFNWKHRoaXMuZ2V0Q29sdW1uU2VsZWN0aW9uTWF0cml4KCkpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGdldE1hdHJpeFNlbGVjdGlvbkFzVFNWOiBmdW5jdGlvbihzZWxlY3Rpb25zKSB7XG4gICAgICAgIC8vb25seSB1c2UgdGhlIGRhdGEgZnJvbSB0aGUgbGFzdCBzZWxlY3Rpb25cbiAgICAgICAgaWYgKHNlbGVjdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgd2lkdGggPSBzZWxlY3Rpb25zLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBoZWlnaHQgPSBzZWxlY3Rpb25zWzBdLmxlbmd0aCxcbiAgICAgICAgICAgICAgICBhcmVhID0gd2lkdGggKiBoZWlnaHQsXG4gICAgICAgICAgICAgICAgY29sbGVjdG9yID0gW107XG5cbiAgICAgICAgICAgIC8vZGlzYWxsb3cgaWYgc2VsZWN0aW9uIGlzIHRvbyBiaWdcbiAgICAgICAgICAgIGlmIChhcmVhID4gMjAwMDApIHtcbiAgICAgICAgICAgICAgICBhbGVydCgnc2VsZWN0aW9uIHNpemUgaXMgdG9vIGJpZyB0byBjb3B5IHRvIHRoZSBwYXN0ZSBidWZmZXInKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1hbGVydFxuICAgICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGNvbGxlY3RDZWxscyA9IGZ1bmN0aW9uKHNlbGVjdGlvbkNlbGwsIHgpIHtcbiAgICAgICAgICAgICAgICBjb2xsZWN0b3IucHVzaChzZWxlY3Rpb25DZWxsKTtcbiAgICAgICAgICAgICAgICBpZiAoeCA8IHdpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbGxlY3Rvci5wdXNoKCdcXHQnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB2YXIgY29sbGVjdFJvd3MgPSBmdW5jdGlvbihzZWxlY3Rpb25Sb3csIHkpIHtcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb25Sb3cuZm9yRWFjaChjb2xsZWN0Q2VsbHMpO1xuICAgICAgICAgICAgICAgIGlmICh5IDwgaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbGxlY3Rvci5wdXNoKCdcXG4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBzZWxlY3Rpb25zLmZvckVhY2goY29sbGVjdFJvd3MpO1xuXG4gICAgICAgICAgICByZXR1cm4gY29sbGVjdG9yLmpvaW4oJycpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFdlIGhhdmUgZm9jdXMuXG4gICAgICovXG4gICAgaGFzRm9jdXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRDYW52YXMoKS5oYXNGb2N1cygpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIENsZWFyIGFsbCB0aGUgc2VsZWN0aW9ucy5cbiAgICAgKi9cbiAgICBjbGVhclNlbGVjdGlvbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmdldFNlbGVjdGlvbk1vZGVsKCkuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5jbGVhck1vdXNlRG93bigpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIENsZWFyIHRoZSBtb3N0IHJlY2VudCBzZWxlY3Rpb24uXG4gICAgICovXG4gICAgY2xlYXJNb3N0UmVjZW50U2VsZWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5nZXRTZWxlY3Rpb25Nb2RlbCgpLmNsZWFyTW9zdFJlY2VudFNlbGVjdGlvbigpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIENsZWFyIHRoZSBtb3N0IHJlY2VudCBjb2x1bW4gc2VsZWN0aW9uLlxuICAgICAqL1xuICAgIGNsZWFyTW9zdFJlY2VudENvbHVtblNlbGVjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuZ2V0U2VsZWN0aW9uTW9kZWwoKS5jbGVhck1vc3RSZWNlbnRDb2x1bW5TZWxlY3Rpb24oKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBDbGVhciB0aGUgbW9zdCByZWNlbnQgcm93IHNlbGVjdGlvbi5cbiAgICAgKi9cbiAgICBjbGVhck1vc3RSZWNlbnRSb3dTZWxlY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmdldFNlbGVjdGlvbk1vZGVsKCkuY2xlYXJNb3N0UmVjZW50Um93U2VsZWN0aW9uKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHN1bW1hcnkgU2VsZWN0IGdpdmVuIHJlZ2lvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb3ggLSBvcmlnaW4geFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBveSAtIG9yaWdpbiB5XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGV4IC0gZXh0ZW50IHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZXggLSBleHRlbnQgeVxuICAgICAqL1xuICAgIHNlbGVjdDogZnVuY3Rpb24ob3gsIG95LCBleCwgZXkpIHtcbiAgICAgICAgaWYgKG94IDwgMCB8fCBveSA8IDApIHtcbiAgICAgICAgICAgIC8vd2UgZG9uJ3Qgc2VsZWN0IG5lZ2F0aXZlIGFyZWFcbiAgICAgICAgICAgIC8vYWxzbyB0aGlzIG1lYW5zIHRoZXJlIGlzIG5vIG9yaWdpbiBtb3VzZSBkb3duIGZvciBhIHNlbGVjdGlvbiByZWN0XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5nZXRTZWxlY3Rpb25Nb2RlbCgpLnNlbGVjdChveCwgb3ksIGV4LCBleSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IEdpdmVuIHBvaW50IGlzIHNlbGVjdGVkLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gVGhlIGhvcml6b250YWwgY29vcmRpbmF0ZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSAtIFRoZSB2ZXJ0aWNhbCBjb29yZGluYXRlLlxuICAgICAqL1xuICAgIGlzU2VsZWN0ZWQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U2VsZWN0aW9uTW9kZWwoKS5pc1NlbGVjdGVkKHgsIHkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBUaGUgZ2l2ZW4gY29sdW1uIGlzIHNlbGVjdGVkIGFueXdoZXJlIGluIHRoZSBlbnRpcmUgdGFibGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbCAtIFRoZSBjb2x1bW4gaW5kZXguXG4gICAgICovXG4gICAgaXNDZWxsU2VsZWN0ZWRJblJvdzogZnVuY3Rpb24oY29sKSB7XG4gICAgICAgIHZhciBzZWxlY3Rpb25Nb2RlbCA9IHRoaXMuZ2V0U2VsZWN0aW9uTW9kZWwoKTtcbiAgICAgICAgdmFyIGlzU2VsZWN0ZWQgPSBzZWxlY3Rpb25Nb2RlbC5pc0NlbGxTZWxlY3RlZEluUm93KGNvbCk7XG4gICAgICAgIHJldHVybiBpc1NlbGVjdGVkO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBUaGUgZ2l2ZW4gcm93IGlzIHNlbGVjdGVkIGFueXdoZXJlIGluIHRoZSBlbnRpcmUgdGFibGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJvdyAtIFRoZSByb3cgaW5kZXguXG4gICAgICovXG4gICAgaXNDZWxsU2VsZWN0ZWRJbkNvbHVtbjogZnVuY3Rpb24ocm93KSB7XG4gICAgICAgIHZhciBzZWxlY3Rpb25Nb2RlbCA9IHRoaXMuZ2V0U2VsZWN0aW9uTW9kZWwoKTtcbiAgICAgICAgdmFyIGlzU2VsZWN0ZWQgPSBzZWxlY3Rpb25Nb2RlbC5pc0NlbGxTZWxlY3RlZEluQ29sdW1uKHJvdyk7XG4gICAgICAgIHJldHVybiBpc1NlbGVjdGVkO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtmaW4taHlwZXJncmlkLXNlbGVjdGlvbi1tb2RlbH0gVGhlIHNlbGVjdGlvbiBtb2RlbC5cbiAgICAgKi9cbiAgICBnZXRTZWxlY3Rpb25Nb2RlbDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbGVjdGlvbk1vZGVsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtCZWhhdmlvcn0gVGhlIGJlaGF2aW9yIChtb2RlbCkuXG4gICAgICovXG4gICAgZ2V0QmVoYXZpb3I6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5iZWhhdmlvcjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAc3VtbWFyeSBTZXQgdGhlIEJlaGF2aW9yIChtb2RlbCkgb2JqZWN0IGZvciB0aGlzIGdyaWQgY29udHJvbC5cbiAgICAgKiBAZGVzYyBUaGlzIGNhbiBiZSBkb25lIGR5bmFtaWNhbGx5LlxuICAgICAqIEBwYXJhbSB7QmVoYXZpb3J9IFRoZSBiZWhhdmlvciAobW9kZWwpLlxuICAgICAqL1xuICAgIHNldEJlaGF2aW9yOiBmdW5jdGlvbihuZXdCZWhhdmlvcikge1xuXG4gICAgICAgIHRoaXMuYmVoYXZpb3IgPSBuZXdCZWhhdmlvcjtcbiAgICAgICAgdGhpcy5iZWhhdmlvci5zZXRHcmlkKHRoaXMpO1xuXG4gICAgICAgIHRoaXMuYmVoYXZpb3IuY2hhbmdlZCA9IHRoaXMuYmVoYXZpb3JDaGFuZ2VkLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuYmVoYXZpb3Iuc2hhcGVDaGFuZ2VkID0gdGhpcy5iZWhhdmlvclNoYXBlQ2hhbmdlZC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLmJlaGF2aW9yLnN0YXRlQ2hhbmdlZCA9IHRoaXMuYmVoYXZpb3JTdGF0ZUNoYW5nZWQuYmluZCh0aGlzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBJJ3ZlIGJlZW4gbm90aWZpZWQgdGhhdCB0aGUgYmVoYXZpb3IgaGFzIGNoYW5nZWQuXG4gICAgICovXG4gICAgYmVoYXZpb3JDaGFuZ2VkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMubnVtQ29sdW1ucyAhPT0gdGhpcy5nZXRDb2x1bW5Db3VudCgpIHx8IHRoaXMubnVtUm93cyAhPT0gdGhpcy5nZXRSb3dDb3VudCgpKSB7XG4gICAgICAgICAgICB0aGlzLm51bUNvbHVtbnMgPSB0aGlzLmdldENvbHVtbkNvdW50KCk7XG4gICAgICAgICAgICB0aGlzLm51bVJvd3MgPSB0aGlzLmdldFJvd0NvdW50KCk7XG4gICAgICAgICAgICB0aGlzLmJlaGF2aW9yU2hhcGVDaGFuZ2VkKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb21wdXRlQ2VsbHNCb3VuZHMoKTtcbiAgICAgICAgdGhpcy5yZXBhaW50KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge1JlY3RhbmdsZX0gTXkgYm91bmRzLlxuICAgICAqL1xuICAgIGdldEJvdW5kczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFJlbmRlcmVyKCkuZ2V0Qm91bmRzKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge3N0cmluZ30gVGhlIHZhbHVlIG9mIGEgbG5mIHByb3BlcnR5LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgLSBBIGxvb2stYW5kLWZlZWwga2V5LlxuICAgICAqL1xuICAgIHJlc29sdmVQcm9wZXJ0eTogZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFByb3BlcnRpZXMoKVtrZXldO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIFRoZSBkaW1lbnNpb25zIG9mIHRoZSBncmlkIGRhdGEgaGF2ZSBjaGFuZ2VkLiBZb3UndmUgYmVlbiBub3RpZmllZC5cbiAgICAgKi9cbiAgICBiZWhhdmlvclNoYXBlQ2hhbmdlZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuc3luY2hyb25pemVTY3JvbGxpbmdCb3VuZHJpZXMoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBUaGUgZGltZW5zaW9ucyBvZiB0aGUgZ3JpZCBkYXRhIGhhdmUgY2hhbmdlZC4gWW91J3ZlIGJlZW4gbm90aWZpZWQuXG4gICAgICovXG4gICAgYmVoYXZpb3JTdGF0ZUNoYW5nZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmdldFJlbmRlcmVyKCkuY29tcHV0ZUNlbGxzQm91bmRzKCk7XG4gICAgICAgIHRoaXMucmVwYWludCgpO1xuICAgIH0sXG5cbiAgICByZXBhaW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG5vdyA9IHRoaXMucmVzb2x2ZVByb3BlcnR5KCdyZXBhaW50SW1tZWRpYXRlbHknKTtcbiAgICAgICAgdmFyIGNhbnZhcyA9IHRoaXMuZ2V0Q2FudmFzKCk7XG4gICAgICAgIGlmIChjYW52YXMpIHtcbiAgICAgICAgICAgIGlmIChub3cgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICBjYW52YXMucGFpbnROb3coKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2FudmFzLnJlcGFpbnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIFBhaW50IGltbWVkaWF0ZWx5IGluIHRoaXMgbWljcm90YXNrLlxuICAgICAqL1xuICAgIHBhaW50Tm93OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGNhbnZhcyA9IHRoaXMuZ2V0Q2FudmFzKCk7XG4gICAgICAgIGNhbnZhcy5wYWludE5vdygpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBJbiBIaURQSSBtb2RlIChoYXMgYW4gYXR0cmlidXRlIGFzIHN1Y2gpLlxuICAgICAqL1xuICAgIHVzZUhpRFBJOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzb2x2ZVByb3BlcnR5KCd1c2VIaURQSScpICE9PSBmYWxzZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAc3VtbWFyeSBJbml0aWFsaXplIGRyYXdpbmcgc3VyZmFjZS5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGluaXRDYW52YXM6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgICAgICB2YXIgZGl2Q2FudmFzID0gdGhpcy5kaXZDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy5kaXYuYXBwZW5kQ2hpbGQoZGl2Q2FudmFzKTtcbiAgICAgICAgdGhpcy5jYW52YXMgPSBuZXcgQ2FudmFzKGRpdkNhbnZhcywgdGhpcy5yZW5kZXJlcik7XG5cbiAgICAgICAgdmFyIHN0eWxlID0gZGl2Q2FudmFzLnN0eWxlO1xuICAgICAgICBzdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICAgIHN0eWxlLnRvcCA9IDA7XG4gICAgICAgIHN0eWxlLnJpZ2h0ID0gJy0yMDBweCc7XG4gICAgICAgIC8vbGVhdmUgcm9vbSBmb3IgdGhlIHZlcnRpY2FsIHNjcm9sbGJhclxuICAgICAgICAvL3N0eWxlLm1hcmdpblJpZ2h0ID0gJzE1cHgnO1xuICAgICAgICBzdHlsZS5ib3R0b20gPSAwO1xuICAgICAgICAvL2xlYXZlIHJvb20gZm9yIHRoZSBob3Jpem9udGFsIHNjcm9sbGJhclxuICAgICAgICAvL3N0eWxlLm1hcmdpbkJvdHRvbSA9ICcxNXB4JztcbiAgICAgICAgc3R5bGUubGVmdCA9IDA7XG5cbiAgICAgICAgdGhpcy5jYW52YXMucmVzaXplTm90aWZpY2F0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBzZWxmLnJlc2l6ZWQoKTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmFkZEZpbkV2ZW50TGlzdGVuZXIoJ2Zpbi1jYW52YXMtbW91c2Vtb3ZlJywgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgaWYgKHNlbGYucmVzb2x2ZVByb3BlcnR5KCdyZWFkT25seScpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG1vdXNlID0gZS5kZXRhaWwubW91c2U7XG4gICAgICAgICAgICB2YXIgbW91c2VFdmVudCA9IHNlbGYuZ2V0R3JpZENlbGxGcm9tTW91c2VQb2ludChtb3VzZSk7XG4gICAgICAgICAgICBtb3VzZUV2ZW50LnByaW1pdGl2ZUV2ZW50ID0gZTtcbiAgICAgICAgICAgIHNlbGYuZGVsZWdhdGVNb3VzZU1vdmUobW91c2VFdmVudCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuYWRkRmluRXZlbnRMaXN0ZW5lcignZmluLWNhbnZhcy1tb3VzZWRvd24nLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5yZXNvbHZlUHJvcGVydHkoJ3JlYWRPbmx5JykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL3NlbGYuc3RvcEVkaXRpbmcoKTtcbiAgICAgICAgICAgIHZhciBtb3VzZSA9IGUuZGV0YWlsLm1vdXNlO1xuICAgICAgICAgICAgdmFyIG1vdXNlRXZlbnQgPSBzZWxmLmdldEdyaWRDZWxsRnJvbU1vdXNlUG9pbnQobW91c2UpO1xuICAgICAgICAgICAgbW91c2VFdmVudC5rZXlzID0gZS5kZXRhaWwua2V5cztcbiAgICAgICAgICAgIG1vdXNlRXZlbnQucHJpbWl0aXZlRXZlbnQgPSBlO1xuICAgICAgICAgICAgc2VsZi5tb3VzZURvd25TdGF0ZSA9IG1vdXNlRXZlbnQ7XG4gICAgICAgICAgICBzZWxmLmRlbGVnYXRlTW91c2VEb3duKG1vdXNlRXZlbnQpO1xuICAgICAgICAgICAgc2VsZi5maXJlU3ludGhldGljTW91c2VEb3duRXZlbnQobW91c2VFdmVudCk7XG4gICAgICAgICAgICBzZWxmLnJlcGFpbnQoKTtcbiAgICAgICAgfSk7XG5cblxuICAgICAgICAvLyB0aGlzLmFkZEZpbkV2ZW50TGlzdGVuZXIoJ2Zpbi1jYW52YXMtY2xpY2snLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIC8vICAgICBpZiAoc2VsZi5yZXNvbHZlUHJvcGVydHkoJ3JlYWRPbmx5JykpIHtcbiAgICAgICAgLy8gICAgICAgICByZXR1cm47XG4gICAgICAgIC8vICAgICB9XG4gICAgICAgIC8vICAgICAvL3NlbGYuc3RvcEVkaXRpbmcoKTtcbiAgICAgICAgLy8gICAgIHZhciBtb3VzZSA9IGUuZGV0YWlsLm1vdXNlO1xuICAgICAgICAvLyAgICAgdmFyIG1vdXNlRXZlbnQgPSBzZWxmLmdldEdyaWRDZWxsRnJvbU1vdXNlUG9pbnQobW91c2UpO1xuICAgICAgICAvLyAgICAgbW91c2VFdmVudC5wcmltaXRpdmVFdmVudCA9IGU7XG4gICAgICAgIC8vICAgICBzZWxmLmZpcmVTeW50aGV0aWNDbGlja0V2ZW50KG1vdXNlRXZlbnQpO1xuICAgICAgICAvLyB9KTtcblxuICAgICAgICB0aGlzLmFkZEZpbkV2ZW50TGlzdGVuZXIoJ2Zpbi1jYW52YXMtbW91c2V1cCcsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGlmIChzZWxmLnJlc29sdmVQcm9wZXJ0eSgncmVhZE9ubHknKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGYuZHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIGlmIChzZWxmLmlzU2Nyb2xsaW5nTm93KCkpIHtcbiAgICAgICAgICAgICAgICBzZWxmLnNldFNjcm9sbGluZ05vdyhmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2VsZi5jb2x1bW5EcmFnQXV0b1Njcm9sbGluZykge1xuICAgICAgICAgICAgICAgIHNlbGYuY29sdW1uRHJhZ0F1dG9TY3JvbGxpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vc2VsZi5zdG9wRWRpdGluZygpO1xuICAgICAgICAgICAgdmFyIG1vdXNlID0gZS5kZXRhaWwubW91c2U7XG4gICAgICAgICAgICB2YXIgbW91c2VFdmVudCA9IHNlbGYuZ2V0R3JpZENlbGxGcm9tTW91c2VQb2ludChtb3VzZSk7XG4gICAgICAgICAgICBtb3VzZUV2ZW50LnByaW1pdGl2ZUV2ZW50ID0gZTtcbiAgICAgICAgICAgIHNlbGYuZGVsZWdhdGVNb3VzZVVwKG1vdXNlRXZlbnQpO1xuICAgICAgICAgICAgaWYgKHNlbGYubW91c2VEb3duU3RhdGUpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmZpcmVTeW50aGV0aWNCdXR0b25QcmVzc2VkRXZlbnQoc2VsZi5tb3VzZURvd25TdGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZWxmLm1vdXNlRG93blN0YXRlID0gbnVsbDtcbiAgICAgICAgICAgIHNlbGYuZmlyZVN5bnRoZXRpY01vdXNlVXBFdmVudChtb3VzZUV2ZW50KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5hZGRGaW5FdmVudExpc3RlbmVyKCdmaW4tY2FudmFzLXRhcCcsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGlmIChzZWxmLnJlc29sdmVQcm9wZXJ0eSgncmVhZE9ubHknKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vc2VsZi5zdG9wRWRpdGluZygpO1xuICAgICAgICAgICAgdmFyIG1vdXNlID0gZS5kZXRhaWwubW91c2U7XG4gICAgICAgICAgICB2YXIgdGFwRXZlbnQgPSBzZWxmLmdldEdyaWRDZWxsRnJvbU1vdXNlUG9pbnQobW91c2UpO1xuICAgICAgICAgICAgdGFwRXZlbnQucHJpbWl0aXZlRXZlbnQgPSBlO1xuICAgICAgICAgICAgdGFwRXZlbnQua2V5cyA9IGUuZGV0YWlsLmtleXM7XG4gICAgICAgICAgICBzZWxmLmZpcmVTeW50aGV0aWNDbGlja0V2ZW50KHRhcEV2ZW50KTtcbiAgICAgICAgICAgIHNlbGYuZGVsZWdhdGVUYXAodGFwRXZlbnQpO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmFkZEZpbkV2ZW50TGlzdGVuZXIoJ2Zpbi1jYW52YXMtZHJhZycsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGlmIChzZWxmLnJlc29sdmVQcm9wZXJ0eSgncmVhZE9ubHknKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGYuZHJhZ2dpbmcgPSB0cnVlO1xuICAgICAgICAgICAgdmFyIG1vdXNlID0gZS5kZXRhaWwubW91c2U7XG4gICAgICAgICAgICB2YXIgbW91c2VFdmVudCA9IHNlbGYuZ2V0R3JpZENlbGxGcm9tTW91c2VQb2ludChtb3VzZSk7XG4gICAgICAgICAgICBtb3VzZUV2ZW50LnByaW1pdGl2ZUV2ZW50ID0gZTtcbiAgICAgICAgICAgIHNlbGYuZGVsZWdhdGVNb3VzZURyYWcobW91c2VFdmVudCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuYWRkRmluRXZlbnRMaXN0ZW5lcignZmluLWNhbnZhcy1rZXlkb3duJywgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgaWYgKHNlbGYucmVzb2x2ZVByb3BlcnR5KCdyZWFkT25seScpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VsZi5maXJlU3ludGhldGljS2V5ZG93bkV2ZW50KGUpO1xuICAgICAgICAgICAgc2VsZi5kZWxlZ2F0ZUtleURvd24oZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuYWRkRmluRXZlbnRMaXN0ZW5lcignZmluLWNhbnZhcy1rZXl1cCcsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGlmIChzZWxmLnJlc29sdmVQcm9wZXJ0eSgncmVhZE9ubHknKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGYuZmlyZVN5bnRoZXRpY0tleXVwRXZlbnQoZSk7XG4gICAgICAgICAgICBzZWxmLmRlbGVnYXRlS2V5VXAoZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuYWRkRmluRXZlbnRMaXN0ZW5lcignZmluLWNhbnZhcy10cmFjaycsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGlmIChzZWxmLnJlc29sdmVQcm9wZXJ0eSgncmVhZE9ubHknKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzZWxmLmRyYWdnaW5nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHByaW1FdmVudCA9IGUuZGV0YWlsLnByaW1pdGl2ZUV2ZW50O1xuICAgICAgICAgICAgaWYgKE1hdGguYWJzKHByaW1FdmVudC5keSkgPiBNYXRoLmFicyhwcmltRXZlbnQuZHgpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHByaW1FdmVudC55RGlyZWN0aW9uID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLnNjcm9sbFZCeSgtMik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwcmltRXZlbnQueURpcmVjdGlvbiA8IC0wKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuc2Nyb2xsVkJ5KDIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHByaW1FdmVudC54RGlyZWN0aW9uID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLnNjcm9sbEhCeSgtMSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwcmltRXZlbnQueERpcmVjdGlvbiA8IC0wKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuc2Nyb2xsSEJ5KDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gdGhpcy5hZGRGaW5FdmVudExpc3RlbmVyKCdmaW4tY2FudmFzLWhvbGRwdWxzZScsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgLy8gICAgIGNvbnNvbGUubG9nKCdob2xkcHVsc2UnKTtcbiAgICAgICAgLy8gICAgIGlmIChzZWxmLnJlc29sdmVQcm9wZXJ0eSgncmVhZE9ubHknKSkge1xuICAgICAgICAvLyAgICAgICAgIHJldHVybjtcbiAgICAgICAgLy8gICAgIH1cbiAgICAgICAgLy8gICAgIHZhciBtb3VzZSA9IGUuZGV0YWlsLm1vdXNlO1xuICAgICAgICAvLyAgICAgdmFyIG1vdXNlRXZlbnQgPSBzZWxmLmdldEdyaWRDZWxsRnJvbU1vdXNlUG9pbnQobW91c2UpO1xuICAgICAgICAvLyAgICAgbW91c2VFdmVudC5wcmltaXRpdmVFdmVudCA9IGU7XG4gICAgICAgIC8vICAgICBzZWxmLmRlbGVnYXRlSG9sZFB1bHNlKG1vdXNlRXZlbnQpO1xuICAgICAgICAvLyB9KTtcblxuICAgICAgICB0aGlzLmFkZEZpbkV2ZW50TGlzdGVuZXIoJ2Zpbi1jYW52YXMtZGJsY2xpY2snLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5yZXNvbHZlUHJvcGVydHkoJ3JlYWRPbmx5JykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbW91c2UgPSBlLmRldGFpbC5tb3VzZTtcbiAgICAgICAgICAgIHZhciBtb3VzZUV2ZW50ID0gc2VsZi5nZXRHcmlkQ2VsbEZyb21Nb3VzZVBvaW50KG1vdXNlKTtcbiAgICAgICAgICAgIG1vdXNlRXZlbnQucHJpbWl0aXZlRXZlbnQgPSBlO1xuICAgICAgICAgICAgc2VsZi5maXJlU3ludGhldGljRG91YmxlQ2xpY2tFdmVudChtb3VzZUV2ZW50LCBlKTtcbiAgICAgICAgICAgIHNlbGYuZGVsZWdhdGVEb3VibGVDbGljayhtb3VzZUV2ZW50KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5hZGRGaW5FdmVudExpc3RlbmVyKCdmaW4tY2FudmFzLXdoZWVsbW92ZWQnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICB2YXIgbW91c2UgPSBlLmRldGFpbC5tb3VzZTtcbiAgICAgICAgICAgIHZhciBtb3VzZUV2ZW50ID0gc2VsZi5nZXRHcmlkQ2VsbEZyb21Nb3VzZVBvaW50KG1vdXNlKTtcbiAgICAgICAgICAgIG1vdXNlRXZlbnQucHJpbWl0aXZlRXZlbnQgPSBlLmRldGFpbC5wcmltaXRpdmVFdmVudDtcbiAgICAgICAgICAgIHNlbGYuZGVsZWdhdGVXaGVlbE1vdmVkKG1vdXNlRXZlbnQpO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmFkZEZpbkV2ZW50TGlzdGVuZXIoJ2Zpbi1jYW52YXMtbW91c2VvdXQnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5yZXNvbHZlUHJvcGVydHkoJ3JlYWRPbmx5JykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbW91c2UgPSBlLmRldGFpbC5tb3VzZTtcbiAgICAgICAgICAgIHZhciBtb3VzZUV2ZW50ID0gc2VsZi5nZXRHcmlkQ2VsbEZyb21Nb3VzZVBvaW50KG1vdXNlKTtcbiAgICAgICAgICAgIG1vdXNlRXZlbnQucHJpbWl0aXZlRXZlbnQgPSBlLmRldGFpbC5wcmltaXRpdmVFdmVudDtcbiAgICAgICAgICAgIHNlbGYuZGVsZWdhdGVNb3VzZUV4aXQobW91c2VFdmVudCk7XG4gICAgICAgIH0pO1xuXG5cbiAgICAgICAgdGhpcy5hZGRGaW5FdmVudExpc3RlbmVyKCdmaW4tY2FudmFzLWNvbnRleHQtbWVudScsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIHZhciBtb3VzZSA9IGUuZGV0YWlsLm1vdXNlO1xuICAgICAgICAgICAgdmFyIG1vdXNlRXZlbnQgPSBzZWxmLmdldEdyaWRDZWxsRnJvbU1vdXNlUG9pbnQobW91c2UpO1xuICAgICAgICAgICAgbW91c2VFdmVudC5wcmltaXRpdmVFdmVudCA9IGUuZGV0YWlsLnByaW1pdGl2ZUV2ZW50O1xuICAgICAgICAgICAgc2VsZi5kZWxlZ2F0ZUNvbnRleHRNZW51KG1vdXNlRXZlbnQpO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmRpdi5yZW1vdmVBdHRyaWJ1dGUoJ3RhYmluZGV4Jyk7XG5cbiAgICB9LFxuXG4gICAgY29udmVydFZpZXdQb2ludFRvRGF0YVBvaW50OiBmdW5jdGlvbih2aWV3UG9pbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QmVoYXZpb3IoKS5jb252ZXJ0Vmlld1BvaW50VG9EYXRhUG9pbnQodmlld1BvaW50KTtcbiAgICB9LFxuXG4gICAgY29udmVydERhdGFQb2ludFRvVmlld1BvaW50OiBmdW5jdGlvbihkYXRhUG9pbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QmVoYXZpb3IoKS5jb252ZXJ0RGF0YVBvaW50VG9WaWV3UG9pbnQoZGF0YVBvaW50KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAc3VtbWFyeSBBZGQgYW4gZXZlbnQgbGlzdGVuZXIgdG8gbWUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50TmFtZSAtIFRoZSB0eXBlIG9mIGV2ZW50IHdlIGFyZSBpbnRlcmVzdGVkIGluLlxuICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIC0gVGhlIGV2ZW50IGhhbmRsZXIuXG4gICAgICovXG4gICAgYWRkRmluRXZlbnRMaXN0ZW5lcjogZnVuY3Rpb24oZXZlbnROYW1lLCBjYWxsYmFjaykge1xuICAgICAgICB0aGlzLmNhbnZhcy5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgY2FsbGJhY2spO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBzdW1tYXJ5IFNldCBmb3IgYHNjcm9sbGluZ05vd2AgZmllbGQuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBpc0l0Tm93IC0gVGhlIHR5cGUgb2YgZXZlbnQgd2UgYXJlIGludGVyZXN0ZWQgaW4uXG4gICAgICovXG4gICAgc2V0U2Nyb2xsaW5nTm93OiBmdW5jdGlvbihpc0l0Tm93KSB7XG4gICAgICAgIHRoaXMuc2Nyb2xsaW5nTm93ID0gaXNJdE5vdztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVGhlIGBzY3JvbGxpbmdOb3dgIGZpZWxkLlxuICAgICAqL1xuICAgIGlzU2Nyb2xsaW5nTm93OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2Nyb2xsaW5nTm93O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBpbmRleCBvZiB0aGUgY29sdW1uIGRpdmlkZXIgdW5kZXIgdGhlIG1vdXNlIGNvb3JkaW5hdGVzLlxuICAgICAqIEBwYXJhbSB7TW91c2VFdmVudH0gbW91c2VFdmVudCAtIFRoZSBldmVudCB0byBpbnRlcm9nYXRlLlxuICAgICAqL1xuICAgIG92ZXJDb2x1bW5EaXZpZGVyOiBmdW5jdGlvbihtb3VzZUV2ZW50KSB7XG4gICAgICAgIHZhciB4ID0gbW91c2VFdmVudC5wcmltaXRpdmVFdmVudC5kZXRhaWwubW91c2UueDtcbiAgICAgICAgdmFyIHdoaWNoQ29sID0gdGhpcy5nZXRSZW5kZXJlcigpLm92ZXJDb2x1bW5EaXZpZGVyKHgpO1xuICAgICAgICByZXR1cm4gd2hpY2hDb2w7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge251bWJlcn0gVGhlIGluZGV4IG9mIHRoZSByb3cgZGl2aWRlciB1bmRlciB0aGUgbW91c2UgY29vcmRpbmF0ZXMuXG4gICAgICogQHBhcmFtIHtNb3VzZUV2ZW50fSBtb3VzZUV2ZW50IC0gVGhlIGV2ZW50IHRvIGludGVyb2dhdGUuXG4gICAgICovXG4gICAgb3ZlclJvd0RpdmlkZXI6IGZ1bmN0aW9uKG1vdXNlRXZlbnQpIHtcbiAgICAgICAgdmFyIHkgPSBtb3VzZUV2ZW50LnByaW1pdGl2ZUV2ZW50LmRldGFpbC5tb3VzZS55O1xuICAgICAgICB2YXIgd2hpY2ggPSB0aGlzLmdldFJlbmRlcmVyKCkub3ZlclJvd0RpdmlkZXIoeSk7XG4gICAgICAgIHJldHVybiB3aGljaDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBTd2l0Y2ggdGhlIGN1cnNvciBmb3IgdGhlIGdyaWQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGN1cnNvck5hbWUgLSBBIHdlbGwga25vdyBjdXJzb3IgbmFtZS5cbiAgICAgKiBAc2VlIFtjdXJzb3IgbmFtZXNdKGh0dHA6Ly93d3cuamF2YXNjcmlwdGVyLm5ldC9mYXEvc3R5bGVzYy5odG0pXG4gICAgICovXG4gICAgYmVDdXJzb3I6IGZ1bmN0aW9uKGN1cnNvck5hbWUpIHtcbiAgICAgICAgaWYgKCFjdXJzb3JOYW1lKSB7XG4gICAgICAgICAgICBjdXJzb3JOYW1lID0gJ2RlZmF1bHQnO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGl2LnN0eWxlLmN1cnNvciA9IGN1cnNvck5hbWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQGRlc2MgRGVsZWdhdGUgdGhlIHdoZWVsIG1vdmVkIGV2ZW50IHRvIHRoZSBiZWhhdmlvci5cbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudCAtIFRoZSBwZXJ0aW5lbnQgZXZlbnQuXG4gICAgICovXG4gICAgZGVsZWdhdGVXaGVlbE1vdmVkOiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICB2YXIgYmVoYXZpb3IgPSB0aGlzLmdldEJlaGF2aW9yKCk7XG4gICAgICAgIGJlaGF2aW9yLm9uV2hlZWxNb3ZlZCh0aGlzLCBldmVudCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQGRlc2MgRGVsZWdhdGUgTW91c2VFeGl0IHRvIHRoZSBiZWhhdmlvciAobW9kZWwpLlxuICAgICAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IC0gVGhlIHBlcnRpbmVudCBldmVudC5cbiAgICAgKi9cbiAgICBkZWxlZ2F0ZU1vdXNlRXhpdDogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgdmFyIGJlaGF2aW9yID0gdGhpcy5nZXRCZWhhdmlvcigpO1xuICAgICAgICBiZWhhdmlvci5oYW5kbGVNb3VzZUV4aXQodGhpcywgZXZlbnQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIERlbGVnYXRlIE1vdXNlRXhpdCB0byB0aGUgYmVoYXZpb3IgKG1vZGVsKS5cbiAgICAgKiBAcGFyYW0ge0V2ZW50fSBldmVudCAtIFRoZSBwZXJ0aW5lbnQgZXZlbnQuXG4gICAgICovXG4gICAgZGVsZWdhdGVDb250ZXh0TWVudTogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgdmFyIGJlaGF2aW9yID0gdGhpcy5nZXRCZWhhdmlvcigpO1xuICAgICAgICBiZWhhdmlvci5vbkNvbnRleHRNZW51KHRoaXMsIGV2ZW50KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBEZWxlZ2F0ZSBNb3VzZU1vdmUgdG8gdGhlIGJlaGF2aW9yIChtb2RlbCkuXG4gICAgICogQHBhcmFtIHttb3VzZURldGFpbHN9IG1vdXNlRGV0YWlscyAtIEFuIGVucmljaGVkIG1vdXNlIGV2ZW50IGZyb20gZmluLWNhbnZhcy5cbiAgICAgKi9cbiAgICBkZWxlZ2F0ZU1vdXNlTW92ZTogZnVuY3Rpb24obW91c2VEZXRhaWxzKSB7XG4gICAgICAgIHZhciBiZWhhdmlvciA9IHRoaXMuZ2V0QmVoYXZpb3IoKTtcbiAgICAgICAgYmVoYXZpb3Iub25Nb3VzZU1vdmUodGhpcywgbW91c2VEZXRhaWxzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBEZWxlZ2F0ZSBtb3VzZWRvd24gdG8gdGhlIGJlaGF2aW9yIChtb2RlbCkuXG4gICAgICogQHBhcmFtIHttb3VzZURldGFpbHN9IG1vdXNlRGV0YWlscyAtIEFuIGVucmljaGVkIG1vdXNlIGV2ZW50IGZyb20gZmluLWNhbnZhcy5cbiAgICAgKi9cbiAgICBkZWxlZ2F0ZU1vdXNlRG93bjogZnVuY3Rpb24obW91c2VEZXRhaWxzKSB7XG4gICAgICAgIHZhciBiZWhhdmlvciA9IHRoaXMuZ2V0QmVoYXZpb3IoKTtcbiAgICAgICAgYmVoYXZpb3IuaGFuZGxlTW91c2VEb3duKHRoaXMsIG1vdXNlRGV0YWlscyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQGRlc2MgRGVsZWdhdGUgbW91c2V1cCB0byB0aGUgYmVoYXZpb3IgKG1vZGVsKS5cbiAgICAgKiBAcGFyYW0ge21vdXNlRGV0YWlsc30gbW91c2VEZXRhaWxzIC0gQW4gZW5yaWNoZWQgbW91c2UgZXZlbnQgZnJvbSBmaW4tY2FudmFzLlxuICAgICAqL1xuICAgIGRlbGVnYXRlTW91c2VVcDogZnVuY3Rpb24obW91c2VEZXRhaWxzKSB7XG4gICAgICAgIHZhciBiZWhhdmlvciA9IHRoaXMuZ2V0QmVoYXZpb3IoKTtcbiAgICAgICAgYmVoYXZpb3Iub25Nb3VzZVVwKHRoaXMsIG1vdXNlRGV0YWlscyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQGRlc2MgRGVsZWdhdGUgdGFwIHRvIHRoZSBiZWhhdmlvciAobW9kZWwpLlxuICAgICAqIEBwYXJhbSB7bW91c2VEZXRhaWxzfSBtb3VzZURldGFpbHMgLSBBbiBlbnJpY2hlZCBtb3VzZSBldmVudCBmcm9tIGZpbi1jYW52YXMuXG4gICAgICovXG4gICAgZGVsZWdhdGVUYXA6IGZ1bmN0aW9uKG1vdXNlRGV0YWlscykge1xuICAgICAgICB2YXIgYmVoYXZpb3IgPSB0aGlzLmdldEJlaGF2aW9yKCk7XG4gICAgICAgIGJlaGF2aW9yLm9uVGFwKHRoaXMsIG1vdXNlRGV0YWlscyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQGRlc2MgRGVsZWdhdGUgbW91c2VEcmFnIHRvIHRoZSBiZWhhdmlvciAobW9kZWwpLlxuICAgICAqIEBwYXJhbSB7bW91c2VEZXRhaWxzfSBtb3VzZURldGFpbHMgLSBBbiBlbnJpY2hlZCBtb3VzZSBldmVudCBmcm9tIGZpbi1jYW52YXMuXG4gICAgICovXG4gICAgZGVsZWdhdGVNb3VzZURyYWc6IGZ1bmN0aW9uKG1vdXNlRGV0YWlscykge1xuICAgICAgICB2YXIgYmVoYXZpb3IgPSB0aGlzLmdldEJlaGF2aW9yKCk7XG4gICAgICAgIGJlaGF2aW9yLm9uTW91c2VEcmFnKHRoaXMsIG1vdXNlRGV0YWlscyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQGRlc2MgV2UndmUgYmVlbiBkb3VibGVjbGlja2VkIG9uLiBEZWxlZ2F0ZSB0aHJvdWdoIHRoZSBiZWhhdmlvciAobW9kZWwpLlxuICAgICAqIEBwYXJhbSB7bW91c2VEZXRhaWxzfSBtb3VzZURldGFpbHMgLSBBbiBlbnJpY2hlZCBtb3VzZSBldmVudCBmcm9tIGZpbi1jYW52YXMuXG4gICAgICovXG4gICAgZGVsZWdhdGVEb3VibGVDbGljazogZnVuY3Rpb24obW91c2VEZXRhaWxzKSB7XG4gICAgICAgIHZhciBiZWhhdmlvciA9IHRoaXMuZ2V0QmVoYXZpb3IoKTtcbiAgICAgICAgYmVoYXZpb3Iub25Eb3VibGVDbGljayh0aGlzLCBtb3VzZURldGFpbHMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIERlbGVnYXRlIGhvbGRwdWxzZSB0aHJvdWdoIHRoZSBiZWhhdmlvciAobW9kZWwpLlxuICAgICAqIEBwYXJhbSB7bW91c2VEZXRhaWxzfSBtb3VzZURldGFpbHMgLSBBbiBlbnJpY2hlZCBtb3VzZSBldmVudCBmcm9tIGZpbi1jYW52YXMuXG4gICAgICovXG4gICAgZGVsZWdhdGVIb2xkUHVsc2U6IGZ1bmN0aW9uKG1vdXNlRGV0YWlscykge1xuICAgICAgICB2YXIgYmVoYXZpb3IgPSB0aGlzLmdldEJlaGF2aW9yKCk7XG4gICAgICAgIGJlaGF2aW9yLm9uSG9sZFB1bHNlKHRoaXMsIG1vdXNlRGV0YWlscyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHN1bW1hcnkgR2VuZXJhdGUgYSBmdW5jdGlvbiBuYW1lIGFuZCBjYWxsIGl0IG9uIHNlbGYuXG4gICAgICogQGRlc2MgVGhpcyBzaG91bGQgYWxzbyBiZSBkZWxlZ2F0ZWQgdGhyb3VnaCBCZWhhdmlvciBrZWVwaW5nIHRoZSBkZWZhdWx0IGltcGxlbWVudGF0aW9uIGhlcmUgdGhvdWdoLlxuICAgICAqIEBwYXJhbSB7ZXZlbnR9IGV2ZW50IC0gVGhlIHBlcnRpbmVudCBldmVudC5cbiAgICAgKi9cbiAgICBkZWxlZ2F0ZUtleURvd246IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIHZhciBiZWhhdmlvciA9IHRoaXMuZ2V0QmVoYXZpb3IoKTtcbiAgICAgICAgYmVoYXZpb3Iub25LZXlEb3duKHRoaXMsIGV2ZW50KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAc3VtbWFyeSBHZW5lcmF0ZSBhIGZ1bmN0aW9uIG5hbWUgYW5kIGNhbGwgaXQgb24gc2VsZi5cbiAgICAgKiBAZGVzYyBUaGlzIHNob3VsZCBhbHNvIGJlIGRlbGVnYXRlZCB0aHJvdWdoIEJlaGF2aW9yIGtlZXBpbmcgdGhlIGRlZmF1bHQgaW1wbGVtZW50YXRpb24gaGVyZSB0aG91Z2guXG4gICAgICogQHBhcmFtIHtldmVudH0gZXZlbnQgLSBUaGUgcGVydGluZW50IGV2ZW50LlxuICAgICAqL1xuICAgIGRlbGVnYXRlS2V5VXA6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIHZhciBiZWhhdmlvciA9IHRoaXMuZ2V0QmVoYXZpb3IoKTtcbiAgICAgICAgYmVoYXZpb3Iub25LZXlVcCh0aGlzLCBldmVudCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHN1bW1hcnkgU2h1dCBkb3duIHRoZSBjdXJyZW50IGNlbGwgZWRpdG9yLlxuICAgICAqL1xuICAgIHN0b3BFZGl0aW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuY2VsbEVkaXRvcikge1xuICAgICAgICAgICAgaWYgKHRoaXMuY2VsbEVkaXRvci5zdG9wRWRpdGluZykge1xuICAgICAgICAgICAgICAgIHRoaXMuY2VsbEVkaXRvci5zdG9wRWRpdGluZygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jZWxsRWRpdG9yID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBzdW1tYXJ5IFJlZ2lzdGVyIGEgY2VsbCBlZGl0b3IuXG4gICAgICogQGRlc2MgVGhpcyBpcyB0eXBpY2FsbHkgY2FsbGVkIGZyb20gd2l0aGluIGEgY2VsbC1lZGl0b3IncyBgaW5zdGFsbE9uYCBtZXRob2QsIHdoZW4gaXQgaXMgYmVpbmcgaW5pdGlhbGl6ZWQgYXMgYSBwbHVnaW4uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGFsaWFzIC0gVGhlIG5hbWUvaWQgb2YgdGhlIGNlbGwgZWRpdG9yLlxuICAgICAqIEBwYXJhbSB7ZmluLWh5cGVyZ3JpZC1jZWxsLWVkaXRvci1iYXNlfSBjZWxsRWRpdG9yIC0gc2VlIFtmaW4taHlwZXJncmlkLWNlbGwtZWRpdG9yLWJhc2VdKG1vZHVsZS1jZWxsLWVkaXRvcnNfYmFzZS5odG1sKVxuICAgICAqL1xuICAgIHJlZ2lzdGVyQ2VsbEVkaXRvcjogZnVuY3Rpb24oYWxpYXMsIGNlbGxFZGl0b3IpIHtcbiAgICAgICAgdGhpcy5jZWxsRWRpdG9yc1thbGlhc10gPSBjZWxsRWRpdG9yO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtSZWN0YW5nbGV9IFRoZSBwaXhlbCBjb29yZGluYXRlcyBvZiBqdXN0IHRoZSBjZW50ZXIgJ21haW5cIiBkYXRhIGFyZWEuXG4gICAgICovXG4gICAgZ2V0RGF0YUJvdW5kczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjb2xETkRIYWNrV2lkdGggPSAyMDA7IC8vdGhpcyB3YXMgYSBoYWNrIHRvIGhlbHAgd2l0aCBjb2x1bW4gZG5kLCBuZWVkIHRvIGZhY3RvciB0aGlzIGludG8gYSBzaGFyZWQgdmFyaWFibGVcbiAgICAgICAgLy92YXIgYmVoYXZpb3IgPSB0aGlzLmdldEJlaGF2aW9yKCk7XG4gICAgICAgIHZhciBiID0gdGhpcy5jYW52YXMuYm91bmRzO1xuXG4gICAgICAgIC8vdmFyIHggPSB0aGlzLmdldFJvd051bWJlcnNXaWR0aCgpO1xuICAgICAgICAvLyB2YXIgeSA9IGJlaGF2aW9yLmdldEZpeGVkUm93c0hlaWdodCgpICsgMjtcblxuICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IFJlY3RhbmdsZSgwLCAwLCBiLm9yaWdpbi54ICsgYi5leHRlbnQueCAtIGNvbEROREhhY2tXaWR0aCwgYi5vcmlnaW4ueSArIGIuZXh0ZW50LnkpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICBnZXRSb3dOdW1iZXJzV2lkdGg6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5pc1Nob3dSb3dOdW1iZXJzKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldFJlbmRlcmVyKCkuZ2V0Um93TnVtYmVyc1dpZHRoKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtDYW52YXN9IE91ciBmaW4tY2FudmFzIGluc3RhbmNlLlxuICAgICAqL1xuICAgIGdldENhbnZhczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNhbnZhcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAc3VtbWFyeSBPcGVuIHRoZSBnaXZlbiBjZWxsLWVkaXRvciBhdCB0aGUgcHJvdmlkZWQgbW9kZWwgY29vcmRpbmF0ZXMuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGNlbGxFZGl0b3IgLSBUaGUgc3BlY2lmaWMgY2VsbCBlZGl0b3IgdG8gdXNlLlxuICAgICAqIEBwYXJhbSB7UG9pbnR9IGNvb3JkaW5hdGVzIC0gVGhlIHBpeGVsIGxvY2FpdG9uIG9mIHRoZSBjZWxsIHRvIGVkaXQgYXQuXG4gICAgICovXG4gICAgZWRpdEF0OiBmdW5jdGlvbihjZWxsRWRpdG9yLCBjb29yZGluYXRlcykge1xuXG4gICAgICAgIHRoaXMuY2VsbEVkaXRvciA9IGNlbGxFZGl0b3I7XG5cbiAgICAgICAgdmFyIGNlbGwgPSBjb29yZGluYXRlcy5ncmlkQ2VsbDtcblxuICAgICAgICB2YXIgeCA9IGNlbGwueDtcbiAgICAgICAgdmFyIHkgPSBjZWxsLnk7XG5cbiAgICAgICAgaWYgKHggPCAwIHx8IHkgPCAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZWRpdFBvaW50ID0gbmV3IFBvaW50KHgsIHkpO1xuICAgICAgICB0aGlzLnNldE1vdXNlRG93bihlZGl0UG9pbnQpO1xuICAgICAgICB0aGlzLnNldERyYWdFeHRlbnQobmV3IFBvaW50KDAsIDApKTtcblxuICAgICAgICBpZiAoIWNlbGxFZGl0b3IuaXNBZGRlZCkge1xuICAgICAgICAgICAgY2VsbEVkaXRvci5pc0FkZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuZGl2LmFwcGVuZENoaWxkKGNlbGxFZGl0b3IuZ2V0SW5wdXQoKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2VsbEVkaXRvci5ncmlkID0gdGhpcztcbiAgICAgICAgY2VsbEVkaXRvci5iZWdpbkVkaXRBdChlZGl0UG9pbnQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBUaGUgZ2l2ZW4gY29sdW1uIGlzIGZ1bGx5IHZpc2libGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbHVtbkluZGV4IC0gVGhlIGNvbHVtbiBpbmRleCBpbiBxdWVzdGlvbi5cbiAgICAgKi9cbiAgICBpc0NvbHVtblZpc2libGU6IGZ1bmN0aW9uKGNvbHVtbkluZGV4KSB7XG4gICAgICAgIHZhciBpc1Zpc2libGUgPSB0aGlzLmdldFJlbmRlcmVyKCkuaXNDb2x1bW5WaXNpYmxlKGNvbHVtbkluZGV4KTtcbiAgICAgICAgcmV0dXJuIGlzVmlzaWJsZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVGhlIGdpdmVuIHJvdyBpcyBmdWxseSB2aXNpYmxlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByb3dJbmRleCAtIFRoZSByb3cgaW5kZXggaW4gcXVlc3Rpb24uXG4gICAgICovXG4gICAgaXNEYXRhUm93VmlzaWJsZTogZnVuY3Rpb24ocm93SW5kZXgpIHtcbiAgICAgICAgdmFyIGlzVmlzaWJsZSA9IHRoaXMuZ2V0UmVuZGVyZXIoKS5pc1Jvd1Zpc2libGUocm93SW5kZXgpO1xuICAgICAgICByZXR1cm4gaXNWaXNpYmxlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBUaGUgZ2l2ZW4gY2VsbCBpcyBmdWxseSBpcyB2aXNpYmxlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb2x1bW5JbmRleCAtIFRoZSBjb2x1bW4gaW5kZXggaW4gcXVlc3Rpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJvd0luZGV4IC0gVGhlIHJvdyBpbmRleCBpbiBxdWVzdGlvbi5cbiAgICAgKi9cbiAgICBpc0RhdGFWaXNpYmxlOiBmdW5jdGlvbihjb2x1bW5JbmRleCwgcm93SW5kZXgpIHtcbiAgICAgICAgdmFyIGlzVmlzaWJsZSA9IHRoaXMuaXNEYXRhUm93VmlzaWJsZShyb3dJbmRleCkgJiYgdGhpcy5pc0NvbHVtblZpc2libGUoY29sdW1uSW5kZXgpO1xuICAgICAgICByZXR1cm4gaXNWaXNpYmxlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBzdW1tYXJ5IFNjcm9sbCBpbiB0aGUgYG9mZnNldFhgIGRpcmVjdGlvbiBpZiBjb2x1bW4gaW5kZXggYGNvbEluZGV4YCBpcyBub3QgdmlzaWJsZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY29sSW5kZXggLSBUaGUgY29sdW1uIGluZGV4IGluIHF1ZXN0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRYIC0gVGhlIGRpcmVjdGlvbiBhbmQgbWFnbml0dWRlIHRvIHNjcm9sbCBpZiB3ZSBuZWVkIHRvLlxuICAgICAqL1xuICAgIGluc3VyZU1vZGVsQ29sSXNWaXNpYmxlOiBmdW5jdGlvbihjb2xJbmRleCwgb2Zmc2V0WCkge1xuICAgICAgICAvLy0xIGJlY2F1c2Ugd2Ugd2FudCBvbmx5IGZ1bGx5IHZpc2libGUgY29sdW1ucywgZG9uJ3QgaW5jbHVkZSBwYXJ0aWFsbHlcbiAgICAgICAgLy92aXNpYmxlIGNvbHVtbnNcbiAgICAgICAgdmFyIG1heENvbHMgPSB0aGlzLmdldENvbHVtbkNvdW50KCkgLSAxO1xuICAgICAgICB2YXIgaW5kZXhUb0NoZWNrID0gY29sSW5kZXg7XG5cbiAgICAgICAgaWYgKG9mZnNldFggPiAwKSB7XG4gICAgICAgICAgICBpbmRleFRvQ2hlY2srKztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5pc0NvbHVtblZpc2libGUoaW5kZXhUb0NoZWNrKSB8fCBjb2xJbmRleCA9PT0gbWF4Q29scykge1xuICAgICAgICAgICAgLy90aGUgc2Nyb2xsIHBvc2l0aW9uIGlzIHRoZSBsZWZ0bW9zdCBjb2x1bW4ge1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxCeShvZmZzZXRYLCAwKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAc3VtbWFyeSBTY3JvbGwgaW4gdGhlIG9mZnNldFkgZGlyZWN0aW9uIGlmIGNvbHVtbiBpbmRleCBjIGlzIG5vdCB2aXNpYmxlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByb3dJbmRleCAtIFRoZSBjb2x1bW4gaW5kZXggaW4gcXVlc3Rpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFggLSBUaGUgZGlyZWN0aW9uIGFuZCBtYWduaXR1ZGUgdG8gc2Nyb2xsIGlmIHdlIG5lZWQgdG8uXG4gICAgICovXG4gICAgaW5zdXJlTW9kZWxSb3dJc1Zpc2libGU6IGZ1bmN0aW9uKHJvd0luZGV4LCBvZmZzZXRZKSB7XG4gICAgICAgIC8vLTEgYmVjYXVzZSB3ZSB3YW50IG9ubHkgZnVsbHkgdmlzaWJsZSByb3dzLCBkb24ndCBpbmNsdWRlIHBhcnRpYWxseVxuICAgICAgICAvL3ZpZXdhYmxlIHJvd3NcbiAgICAgICAgdmFyIG1heFJvd3MgPSB0aGlzLmdldFJvd0NvdW50KCkgLSAxO1xuICAgICAgICB2YXIgaW5kZXhUb0NoZWNrID0gcm93SW5kZXg7XG5cbiAgICAgICAgaWYgKG9mZnNldFkgPiAwKSB7XG4gICAgICAgICAgICBpbmRleFRvQ2hlY2srKztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdGhpcy5pc0RhdGFSb3dWaXNpYmxlKGluZGV4VG9DaGVjaykgfHwgcm93SW5kZXggPT09IG1heFJvd3MpIHtcbiAgICAgICAgICAgIC8vdGhlIHNjcm9sbCBwb3NpdGlvbiBpcyB0aGUgdG9wbW9zdCByb3dcbiAgICAgICAgICAgIHRoaXMuc2Nyb2xsQnkoMCwgb2Zmc2V0WSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHN1bW1hcnkgU2Nyb2xsIGhvcml6b250YWwgYW5kIHZlcnRpY2FsbHkgYnkgdGhlIHByb3ZpZGVkIG9mZnNldHMuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFggLSBTY3JvbGwgaW4gdGhlIHggZGlyZWN0aW9uIHRoaXMgbXVjaC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0WSAtIFNjcm9sbCBpbiB0aGUgeSBkaXJlY3Rpb24gdGhpcyBtdWNoLlxuICAgICAqL1xuICAgIHNjcm9sbEJ5OiBmdW5jdGlvbihvZmZzZXRYLCBvZmZzZXRZKSB7XG4gICAgICAgIHRoaXMuc2Nyb2xsSEJ5KG9mZnNldFgpO1xuICAgICAgICB0aGlzLnNjcm9sbFZCeShvZmZzZXRZKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAc3VtbWFyeSBTY3JvbGwgdmVydGljYWxseSBieSB0aGUgcHJvdmlkZWQgb2Zmc2V0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRZIC0gU2Nyb2xsIGluIHRoZSB5IGRpcmVjdGlvbiB0aGlzIG11Y2guXG4gICAgICovXG4gICAgc2Nyb2xsVkJ5OiBmdW5jdGlvbihvZmZzZXRZKSB7XG4gICAgICAgIHZhciBtYXggPSB0aGlzLnNiVlNjcm9sbGVyLnJhbmdlLm1heDtcbiAgICAgICAgdmFyIG9sZFZhbHVlID0gdGhpcy5nZXRWU2Nyb2xsVmFsdWUoKTtcbiAgICAgICAgdmFyIG5ld1ZhbHVlID0gTWF0aC5taW4obWF4LCBNYXRoLm1heCgwLCBvbGRWYWx1ZSArIG9mZnNldFkpKTtcbiAgICAgICAgaWYgKG5ld1ZhbHVlID09PSBvbGRWYWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0VlNjcm9sbFZhbHVlKG5ld1ZhbHVlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAc3VtbWFyeSBTY3JvbGwgaG9yaXpvbnRhbGx5IGJ5IHRoZSBwcm92aWRlZCBvZmZzZXQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFggLSBTY3JvbGwgaW4gdGhlIHggZGlyZWN0aW9uIHRoaXMgbXVjaC5cbiAgICAgKi9cbiAgICBzY3JvbGxIQnk6IGZ1bmN0aW9uKG9mZnNldFgpIHtcbiAgICAgICAgdmFyIG1heCA9IHRoaXMuc2JIU2Nyb2xsZXIucmFuZ2UubWF4O1xuICAgICAgICB2YXIgb2xkVmFsdWUgPSB0aGlzLmdldEhTY3JvbGxWYWx1ZSgpO1xuICAgICAgICB2YXIgbmV3VmFsdWUgPSBNYXRoLm1pbihtYXgsIE1hdGgubWF4KDAsIG9sZFZhbHVlICsgb2Zmc2V0WCkpO1xuICAgICAgICBpZiAobmV3VmFsdWUgPT09IG9sZFZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXRIU2Nyb2xsVmFsdWUobmV3VmFsdWUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBzdW1tYXJ5IEFuc3dlciB3aGljaCBkYXRhIGNlbGwgaXMgdW5kZXIgYSBwaXhlbCB2YWx1ZSBtb3VzZSBwb2ludC5cbiAgICAgKiBAcGFyYW0ge21vdXNlUG9pbnR9IG1vdXNlIC0gVGhlIG1vdXNlIHBvaW50IHRvIGludGVycm9nYXRlLlxuICAgICAqL1xuXG4gICAgZ2V0R3JpZENlbGxGcm9tTW91c2VQb2ludDogZnVuY3Rpb24obW91c2UpIHtcbiAgICAgICAgdmFyIGNlbGwgPSB0aGlzLmdldFJlbmRlcmVyKCkuZ2V0R3JpZENlbGxGcm9tTW91c2VQb2ludChtb3VzZSk7XG4gICAgICAgIHJldHVybiBjZWxsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJucyB7UmVjdGFuZ2xlfSBUaGUgcGl4ZWwgYmFzZWQgYm91bmRzIHJlY3RhbmdsZSBnaXZlbiBhIGRhdGEgY2VsbCBwb2ludC5cbiAgICAgKiBAcGFyYW0ge1BvaW50fSBjZWxsIC0gVGhlIHBpeGVsIGxvY2F0aW9uIG9mIHRoZSBtb3VzZS5cbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGdldEJvdW5kc09mQ2VsbDogZnVuY3Rpb24oY2VsbCkge1xuICAgICAgICB2YXIgYiA9IHRoaXMuZ2V0UmVuZGVyZXIoKS5nZXRCb3VuZHNPZkNlbGwoY2VsbCk7XG5cbiAgICAgICAgLy93ZSBuZWVkIHRvIGNvbnZlcnQgdGhpcyB0byBhIHByb3BlciByZWN0YW5nbGVcbiAgICAgICAgdmFyIG5ld0JvdW5kcyA9IG5ldyBSZWN0YW5nbGUoYi54LCBiLnksIGIud2lkdGgsIGIuaGVpZ2h0KTtcbiAgICAgICAgcmV0dXJuIG5ld0JvdW5kcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBUaGlzIGlzIGNhbGxlZCBieSB0aGUgZmluLWNhbnZhcyB3aGVuIGEgcmVzaXplIG9jY3Vycy5cbiAgICAgKi9cbiAgICByZXNpemVkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5zeW5jaHJvbml6ZVNjcm9sbGluZ0JvdW5kcmllcygpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBzdW1tYXJ5IEEgY2xpY2sgZXZlbnQgb2NjdXJlZC5cbiAgICAgKiBAZGVzYyBEZXRlcm1pbmUgdGhlIGNlbGwgYW5kIGRlbGVnYXRlIHRvIHRoZSBiZWhhdmlvciAobW9kZWwpLlxuICAgICAqIEBwYXJhbSB7TW91c2VFdmVudH0gZXZlbnQgLSBUaGUgbW91c2UgZXZlbnQgdG8gaW50ZXJyb2dhdGUuXG4gICAgICovXG4gICAgY2VsbENsaWNrZWQ6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIHZhciBjZWxsID0gZXZlbnQuZ3JpZENlbGw7XG4gICAgICAgIHZhciBjb2xDb3VudCA9IHRoaXMuZ2V0Q29sdW1uQ291bnQoKTtcbiAgICAgICAgdmFyIHJvd0NvdW50ID0gdGhpcy5nZXRSb3dDb3VudCgpO1xuXG4gICAgICAgIC8vY2xpY2sgb2NjdXJlZCBpbiBiYWNrZ3JvdW5kIGFyZWFcbiAgICAgICAgaWYgKGNlbGwueCA+IGNvbENvdW50IHx8IGNlbGwueSA+IHJvd0NvdW50KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvL3ZhciBiZWhhdmlvciA9IHRoaXMuZ2V0QmVoYXZpb3IoKTtcbiAgICAgICAgdmFyIGhvdmVyZWQgPSB0aGlzLmdldEhvdmVyQ2VsbCgpO1xuICAgICAgICB2YXIgc3kgPSB0aGlzLmdldFZTY3JvbGxWYWx1ZSgpO1xuICAgICAgICB2YXIgeCA9IGhvdmVyZWQueDtcbiAgICAgICAgLy8gaWYgKGhvdmVyZWQueCA+IC0xKSB7XG4gICAgICAgIC8vICAgICB4ID0gYmVoYXZpb3IudHJhbnNsYXRlQ29sdW1uSW5kZXgoaG92ZXJlZC54ICsgdGhpcy5nZXRIU2Nyb2xsVmFsdWUoKSk7XG4gICAgICAgIC8vIH1cbiAgICAgICAgaWYgKGhvdmVyZWQueSA8IDApIHtcbiAgICAgICAgICAgIHN5ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBob3ZlcmVkID0gbmV3IFBvaW50KHgsIGhvdmVyZWQueSArIHN5KTtcbiAgICAgICAgdGhpcy5nZXRCZWhhdmlvcigpLmNlbGxDbGlja2VkKGhvdmVyZWQsIGV2ZW50KTtcbiAgICB9LFxuXG4gICAgc2V0VG90YWxzVmFsdWVOb3RpZmljYXRpb246IGZ1bmN0aW9uKHgsIHksIHZhbHVlKSB7XG4gICAgICAgIHRoaXMuZmlyZVN5bnRoZXRpY1NldFRvdGFsc1ZhbHVlKHgsIHksIHZhbHVlKTtcbiAgICB9LFxuXG4gICAgZmlyZVN5bnRoZXRpY1NldFRvdGFsc1ZhbHVlOiBmdW5jdGlvbih4LCB5LCB2YWx1ZSkge1xuICAgICAgICB2YXIgY2xpY2tFdmVudCA9IG5ldyBDdXN0b21FdmVudCgnZmluLXNldC10b3RhbHMtdmFsdWUnLCB7XG4gICAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgICAgICB4OiB4LFxuICAgICAgICAgICAgICAgIHk6IHksXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNhbnZhcy5kaXNwYXRjaEV2ZW50KGNsaWNrRXZlbnQpO1xuICAgIH0sXG5cbiAgICBmaXJlU3ludGhldGljRWRpdG9yS2V5VXBFdmVudDogZnVuY3Rpb24oaW5wdXRDb250cm9sLCBrZXlFdmVudCkge1xuICAgICAgICB2YXIgY2xpY2tFdmVudCA9IG5ldyBDdXN0b21FdmVudCgnZmluLWVkaXRvci1rZXktdXAnLCB7XG4gICAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgICAgICBpbnB1dDogaW5wdXRDb250cm9sLFxuICAgICAgICAgICAgICAgIGtleUV2ZW50OiBrZXlFdmVudFxuICAgICAgICAgICAgfSxcblxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jYW52YXMuZGlzcGF0Y2hFdmVudChjbGlja0V2ZW50KTtcbiAgICB9LFxuXG4gICAgZmlyZVN5bnRoZXRpY0VkaXRvcktleURvd25FdmVudDogZnVuY3Rpb24oaW5wdXRDb250cm9sLCBrZXlFdmVudCkge1xuICAgICAgICB2YXIgY2xpY2tFdmVudCA9IG5ldyBDdXN0b21FdmVudCgnZmluLWVkaXRvci1rZXktZG93bicsIHtcbiAgICAgICAgICAgIGRldGFpbDoge1xuICAgICAgICAgICAgICAgIGlucHV0OiBpbnB1dENvbnRyb2wsXG4gICAgICAgICAgICAgICAga2V5RXZlbnQ6IGtleUV2ZW50XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNhbnZhcy5kaXNwYXRjaEV2ZW50KGNsaWNrRXZlbnQpO1xuICAgIH0sXG5cbiAgICBmaXJlU3ludGhldGljRWRpdG9yS2V5UHJlc3NFdmVudDogZnVuY3Rpb24oaW5wdXRDb250cm9sLCBrZXlFdmVudCkge1xuICAgICAgICB2YXIgY2xpY2tFdmVudCA9IG5ldyBDdXN0b21FdmVudCgnZmluLWVkaXRvci1rZXktcHJlc3MnLCB7XG4gICAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgICAgICBpbnB1dDogaW5wdXRDb250cm9sLFxuICAgICAgICAgICAgICAgIGtleUV2ZW50OiBrZXlFdmVudFxuICAgICAgICAgICAgfSxcblxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jYW52YXMuZGlzcGF0Y2hFdmVudChjbGlja0V2ZW50KTtcbiAgICB9LFxuXG4gICAgZmlyZVN5bnRoZXRpY0VkaXRvckRhdGFDaGFuZ2VFdmVudDogZnVuY3Rpb24oaW5wdXRDb250cm9sLCBvbGRWYWx1ZSwgbmV3VmFsdWUpIHtcbiAgICAgICAgdmFyIGNsaWNrRXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoJ2Zpbi1lZGl0b3ItZGF0YS1jaGFuZ2UnLCB7XG4gICAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgICAgICBpbnB1dDogaW5wdXRDb250cm9sLFxuICAgICAgICAgICAgICAgIG9sZFZhbHVlOiBvbGRWYWx1ZSxcbiAgICAgICAgICAgICAgICBuZXdWYWx1ZTogbmV3VmFsdWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjYW5jZWxhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5jYW52YXMuZGlzcGF0Y2hFdmVudChjbGlja0V2ZW50KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBTeW50aGVzaXplIGFuZCBmaXJlIGEgYGZpbi1yb3ctc2VsZWN0aW9uLWNoYW5nZWRgIGV2ZW50LlxuICAgICAqL1xuICAgIGZpcmVTeW50aGV0aWNSb3dTZWxlY3Rpb25DaGFuZ2VkRXZlbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2VsZWN0aW9uRXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoJ2Zpbi1yb3ctc2VsZWN0aW9uLWNoYW5nZWQnLCB7XG4gICAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgICAgICByb3dzOiB0aGlzLmdldFNlbGVjdGVkUm93cygpLFxuICAgICAgICAgICAgICAgIGNvbHVtbnM6IHRoaXMuZ2V0U2VsZWN0ZWRDb2x1bW5zKCksXG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uczogdGhpcy5nZXRTZWxlY3Rpb25Nb2RlbCgpLmdldFNlbGVjdGlvbnMoKSxcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY2FudmFzLmRpc3BhdGNoRXZlbnQoc2VsZWN0aW9uRXZlbnQpO1xuICAgIH0sXG5cbiAgICBmaXJlU3ludGhldGljQ29sdW1uU2VsZWN0aW9uQ2hhbmdlZEV2ZW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNlbGVjdGlvbkV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KCdmaW4tY29sdW1uLXNlbGVjdGlvbi1jaGFuZ2VkJywge1xuICAgICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICAgICAgcm93czogdGhpcy5nZXRTZWxlY3RlZFJvd3MoKSxcbiAgICAgICAgICAgICAgICBjb2x1bW5zOiB0aGlzLmdldFNlbGVjdGVkQ29sdW1ucygpLFxuICAgICAgICAgICAgICAgIHNlbGVjdGlvbnM6IHRoaXMuZ2V0U2VsZWN0aW9uTW9kZWwoKS5nZXRTZWxlY3Rpb25zKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY2FudmFzLmRpc3BhdGNoRXZlbnQoc2VsZWN0aW9uRXZlbnQpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBTeW50aGVzaXplIGFuZCBkaXNwYXRjaCBhIGBmaW4tc2VsZWN0aW9uLWNoYW5nZWRgIGV2ZW50LlxuICAgICAqL1xuICAgIHNlbGVjdGlvbkNoYW5nZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2VsZWN0ZWRSb3dzID0gdGhpcy5nZXRTZWxlY3RlZFJvd3MoKTtcbiAgICAgICAgdmFyIHNlbGVjdGlvbkV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KCdmaW4tc2VsZWN0aW9uLWNoYW5nZWQnLCB7XG4gICAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgICAgICByb3dzOiBzZWxlY3RlZFJvd3MsXG4gICAgICAgICAgICAgICAgY29sdW1uczogdGhpcy5nZXRTZWxlY3RlZENvbHVtbnMoKSxcbiAgICAgICAgICAgICAgICBzZWxlY3Rpb25zOiB0aGlzLmdldFNlbGVjdGlvbk1vZGVsKCkuZ2V0U2VsZWN0aW9ucygpLFxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jYW52YXMuZGlzcGF0Y2hFdmVudChzZWxlY3Rpb25FdmVudCk7XG4gICAgfSxcblxuXG4gICAgZ2V0Um93U2VsZWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGMsIGNvbHVtbiwgc2VsZiA9IHRoaXMsXG4gICAgICAgICAgICBzZWxlY3RlZFJvd0luZGV4ZXMgPSB0aGlzLmdldFNlbGVjdGlvbk1vZGVsKCkuZ2V0U2VsZWN0ZWRSb3dzKCksXG4gICAgICAgICAgICBudW1Db2xzID0gdGhpcy5nZXRDb2x1bW5Db3VudCgpLFxuICAgICAgICAgICAgcmVzdWx0ID0ge307XG5cbiAgICAgICAgZnVuY3Rpb24gc2V0VmFsdWUoc2VsZWN0ZWRSb3dJbmRleCwgcikge1xuICAgICAgICAgICAgY29sdW1uW3JdID0gdmFsdWVPckZ1bmN0aW9uRXhlY3V0ZShzZWxmLmdldFZhbHVlKGMsIHNlbGVjdGVkUm93SW5kZXgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoYyA9IDA7IGMgPCBudW1Db2xzOyBjKyspIHtcbiAgICAgICAgICAgIGNvbHVtbiA9IG5ldyBBcnJheShzZWxlY3RlZFJvd0luZGV4ZXMubGVuZ3RoKTtcbiAgICAgICAgICAgIHJlc3VsdFt0aGlzLmdldEZpZWxkKGMpXSA9IGNvbHVtbjtcbiAgICAgICAgICAgIHNlbGVjdGVkUm93SW5kZXhlcy5mb3JFYWNoKHNldFZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIGdldFJvd1NlbGVjdGlvbk1hdHJpeDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjLCBzZWxmID0gdGhpcyxcbiAgICAgICAgICAgIHNlbGVjdGVkUm93SW5kZXhlcyA9IHRoaXMuZ2V0U2VsZWN0aW9uTW9kZWwoKS5nZXRTZWxlY3RlZFJvd3MoKSxcbiAgICAgICAgICAgIG51bUNvbHMgPSB0aGlzLmdldENvbHVtbkNvdW50KCksXG4gICAgICAgICAgICByZXN1bHQgPSBuZXcgQXJyYXkobnVtQ29scyk7XG5cbiAgICAgICAgZnVuY3Rpb24gZ2V0VmFsdWUoc2VsZWN0ZWRSb3dJbmRleCwgcikge1xuICAgICAgICAgICAgcmVzdWx0W2NdW3JdID0gdmFsdWVPckZ1bmN0aW9uRXhlY3V0ZShzZWxmLmdldFZhbHVlKGMsIHNlbGVjdGVkUm93SW5kZXgpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoYyA9IDA7IGMgPCBudW1Db2xzOyBjKyspIHtcbiAgICAgICAgICAgIHJlc3VsdFtjXSA9IG5ldyBBcnJheShzZWxlY3RlZFJvd0luZGV4ZXMubGVuZ3RoKTtcbiAgICAgICAgICAgIHNlbGVjdGVkUm93SW5kZXhlcy5mb3JFYWNoKGdldFZhbHVlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIGdldENvbHVtblNlbGVjdGlvbk1hdHJpeDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzZWxlY3RlZENvbHVtbkluZGV4ZXMgPSB0aGlzLmdldFNlbGVjdGVkQ29sdW1ucygpO1xuICAgICAgICB2YXIgbnVtUm93cyA9IHRoaXMuZ2V0Um93Q291bnQoKTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IG5ldyBBcnJheShzZWxlY3RlZENvbHVtbkluZGV4ZXMubGVuZ3RoKTtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICBzZWxlY3RlZENvbHVtbkluZGV4ZXMuZm9yRWFjaChmdW5jdGlvbihzZWxlY3RlZENvbHVtbkluZGV4LCBjKSB7XG4gICAgICAgICAgICByZXN1bHRbY10gPSBuZXcgQXJyYXkobnVtUm93cyk7XG4gICAgICAgICAgICBmb3IgKHZhciByID0gMDsgciA8IG51bVJvd3M7IHIrKykge1xuICAgICAgICAgICAgICAgIHJlc3VsdFtjXVtyXSA9IHZhbHVlT3JGdW5jdGlvbkV4ZWN1dGUoc2VsZi5nZXRWYWx1ZShzZWxlY3RlZENvbHVtbkluZGV4LCByKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICBnZXRDb2x1bW5TZWxlY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2VsZWN0ZWRDb2x1bW5JbmRleGVzID0gdGhpcy5nZXRTZWxlY3RlZENvbHVtbnMoKTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgICB2YXIgcm93Q291bnQgPSB0aGlzLmdldFJvd0NvdW50KCk7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgc2VsZWN0ZWRDb2x1bW5JbmRleGVzLmZvckVhY2goZnVuY3Rpb24oc2VsZWN0ZWRDb2x1bW5JbmRleCkge1xuICAgICAgICAgICAgdmFyIGNvbHVtbiA9IG5ldyBBcnJheShyb3dDb3VudCk7XG4gICAgICAgICAgICByZXN1bHRbc2VsZi5nZXRGaWVsZChzZWxlY3RlZENvbHVtbkluZGV4KV0gPSBjb2x1bW47XG4gICAgICAgICAgICBmb3IgKHZhciByID0gMDsgciA8IHJvd0NvdW50OyByKyspIHtcbiAgICAgICAgICAgICAgICBjb2x1bW5bcl0gPSB2YWx1ZU9yRnVuY3Rpb25FeGVjdXRlKHNlbGYuZ2V0VmFsdWUoc2VsZWN0ZWRDb2x1bW5JbmRleCwgcikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgZ2V0U2VsZWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgc2VsZWN0aW9ucyA9IHRoaXMuZ2V0U2VsZWN0aW9ucygpO1xuICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IEFycmF5KHNlbGVjdGlvbnMubGVuZ3RoKTtcbiAgICAgICAgc2VsZWN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uKHNlbGVjdGlvblJlY3QsIGkpIHtcbiAgICAgICAgICAgIHJlc3VsdFtpXSA9IHNlbGYuX2dldFNlbGVjdGlvbihzZWxlY3Rpb25SZWN0KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIF9nZXRTZWxlY3Rpb246IGZ1bmN0aW9uKHJlY3QpIHtcbiAgICAgICAgcmVjdCA9IG5vcm1hbGl6ZVJlY3QocmVjdCk7XG4gICAgICAgIHZhciBjb2xDb3VudCA9IHJlY3QuZXh0ZW50LnggKyAxO1xuICAgICAgICB2YXIgcm93Q291bnQgPSByZWN0LmV4dGVudC55ICsgMTtcbiAgICAgICAgdmFyIG94ID0gcmVjdC5vcmlnaW4ueDtcbiAgICAgICAgdmFyIG95ID0gcmVjdC5vcmlnaW4ueTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgICB2YXIgcjtcbiAgICAgICAgZm9yICh2YXIgYyA9IDA7IGMgPCBjb2xDb3VudDsgYysrKSB7XG4gICAgICAgICAgICB2YXIgY29sdW1uID0gbmV3IEFycmF5KHJvd0NvdW50KTtcbiAgICAgICAgICAgIHJlc3VsdFt0aGlzLmdldEZpZWxkKGMgKyBveCldID0gY29sdW1uO1xuICAgICAgICAgICAgZm9yIChyID0gMDsgciA8IHJvd0NvdW50OyByKyspIHtcbiAgICAgICAgICAgICAgICBjb2x1bW5bcl0gPSB2YWx1ZU9yRnVuY3Rpb25FeGVjdXRlKHRoaXMuZ2V0VmFsdWUob3ggKyBjLCBveSArIHIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICBnZXRTZWxlY3Rpb25NYXRyaXg6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHZhciBzZWxlY3Rpb25zID0gdGhpcy5nZXRTZWxlY3Rpb25zKCk7XG4gICAgICAgIHZhciByZXN1bHQgPSBuZXcgQXJyYXkoc2VsZWN0aW9ucy5sZW5ndGgpO1xuICAgICAgICBzZWxlY3Rpb25zLmZvckVhY2goZnVuY3Rpb24oc2VsZWN0aW9uUmVjdCwgaSkge1xuICAgICAgICAgICAgcmVzdWx0W2ldID0gc2VsZi5fZ2V0U2VsZWN0aW9uTWF0cml4KHNlbGVjdGlvblJlY3QpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgX2dldFNlbGVjdGlvbk1hdHJpeDogZnVuY3Rpb24ocmVjdCkge1xuICAgICAgICByZWN0ID0gbm9ybWFsaXplUmVjdChyZWN0KTtcbiAgICAgICAgdmFyIGNvbENvdW50ID0gcmVjdC5leHRlbnQueCArIDE7XG4gICAgICAgIHZhciByb3dDb3VudCA9IHJlY3QuZXh0ZW50LnkgKyAxO1xuICAgICAgICB2YXIgb3ggPSByZWN0Lm9yaWdpbi54O1xuICAgICAgICB2YXIgb3kgPSByZWN0Lm9yaWdpbi55O1xuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAodmFyIGMgPSAwOyBjIDwgY29sQ291bnQ7IGMrKykge1xuICAgICAgICAgICAgdmFyIGNvbHVtbiA9IG5ldyBBcnJheShyb3dDb3VudCk7XG4gICAgICAgICAgICByZXN1bHRbY10gPSBjb2x1bW47XG4gICAgICAgICAgICBmb3IgKHZhciByID0gMDsgciA8IHJvd0NvdW50OyByKyspIHtcbiAgICAgICAgICAgICAgICBjb2x1bW5bcl0gPSB2YWx1ZU9yRnVuY3Rpb25FeGVjdXRlKHRoaXMuZ2V0VmFsdWUob3ggKyBjLCBveSArIHIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBTeW50aGVzaXplIGFuZCBmaXJlIGEgYGZpbi1jb250ZXh0LW1lbnVgIGV2ZW50XG4gICAgICogQHBhcmFtIHtrZXlFdmVudH0gZXZlbnQgLSBUaGUgY2FudmFzIGV2ZW50LlxuICAgICAqL1xuICAgIGZpcmVTeW50aGV0aWNDb250ZXh0TWVudUV2ZW50OiBmdW5jdGlvbihlKSB7XG4gICAgICAgIGUuZ3JpZENlbGwgPSB0aGlzLmNvbnZlcnRWaWV3UG9pbnRUb0RhdGFQb2ludChlLmdyaWRDZWxsKTtcbiAgICAgICAgdmFyIGV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KCdmaW4tY29udGV4dC1tZW51Jywge1xuICAgICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICAgICAgZ3JpZENlbGw6IGUuZ3JpZENlbGwsXG4gICAgICAgICAgICAgICAgbW91c2VQb2ludDogZS5tb3VzZVBvaW50LFxuICAgICAgICAgICAgICAgIHZpZXdQb2ludDogZS52aWV3UG9pbnQsXG4gICAgICAgICAgICAgICAgcHJpbWl0aXZlRXZlbnQ6IGUucHJpbWl0aXZlRXZlbnQsXG4gICAgICAgICAgICAgICAgcm93czogdGhpcy5nZXRTZWxlY3RlZFJvd3MoKSxcbiAgICAgICAgICAgICAgICBjb2x1bW5zOiB0aGlzLmdldFNlbGVjdGVkQ29sdW1ucygpLFxuICAgICAgICAgICAgICAgIHNlbGVjdGlvbnM6IHRoaXMuZ2V0U2VsZWN0aW9uTW9kZWwoKS5nZXRTZWxlY3Rpb25zKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY2FudmFzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgIH0sXG5cbiAgICBmaXJlU3ludGhldGljTW91c2VVcEV2ZW50OiBmdW5jdGlvbihlKSB7XG4gICAgICAgIHZhciBldmVudCA9IG5ldyBDdXN0b21FdmVudCgnZmluLW1vdXNldXAnLCB7XG4gICAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgICAgICBncmlkQ2VsbDogZS5ncmlkQ2VsbCxcbiAgICAgICAgICAgICAgICBtb3VzZVBvaW50OiBlLm1vdXNlUG9pbnQsXG4gICAgICAgICAgICAgICAgdmlld1BvaW50OiBlLnZpZXdQb2ludCxcbiAgICAgICAgICAgICAgICBwcmltaXRpdmVFdmVudDogZS5wcmltaXRpdmVFdmVudCxcbiAgICAgICAgICAgICAgICByb3dzOiB0aGlzLmdldFNlbGVjdGVkUm93cygpLFxuICAgICAgICAgICAgICAgIGNvbHVtbnM6IHRoaXMuZ2V0U2VsZWN0ZWRDb2x1bW5zKCksXG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uczogdGhpcy5nZXRTZWxlY3Rpb25Nb2RlbCgpLmdldFNlbGVjdGlvbnMoKVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jYW52YXMuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgfSxcblxuICAgIGZpcmVTeW50aGV0aWNNb3VzZURvd25FdmVudDogZnVuY3Rpb24oZSkge1xuICAgICAgICB2YXIgZXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoJ2Zpbi1tb3VzZWRvd24nLCB7XG4gICAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgICAgICBncmlkQ2VsbDogZS5ncmlkQ2VsbCxcbiAgICAgICAgICAgICAgICBtb3VzZVBvaW50OiBlLm1vdXNlUG9pbnQsXG4gICAgICAgICAgICAgICAgdmlld1BvaW50OiBlLnZpZXdQb2ludCxcbiAgICAgICAgICAgICAgICBwcmltaXRpdmVFdmVudDogZS5wcmltaXRpdmVFdmVudCxcbiAgICAgICAgICAgICAgICByb3dzOiB0aGlzLmdldFNlbGVjdGVkUm93cygpLFxuICAgICAgICAgICAgICAgIGNvbHVtbnM6IHRoaXMuZ2V0U2VsZWN0ZWRDb2x1bW5zKCksXG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uczogdGhpcy5nZXRTZWxlY3Rpb25Nb2RlbCgpLmdldFNlbGVjdGlvbnMoKVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jYW52YXMuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgfSxcblxuICAgIGlzVmlld2FibGVCdXR0b246IGZ1bmN0aW9uKGMsIHIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UmVuZGVyZXIoKS5pc1ZpZXdhYmxlQnV0dG9uKGMsIHIpO1xuICAgIH0sXG5cbiAgICBmaXJlU3ludGhldGljQnV0dG9uUHJlc3NlZEV2ZW50OiBmdW5jdGlvbihldnQpIHtcbiAgICAgICAgdmFyIGRhdGFDZWxsID0gZXZ0LmRhdGFDZWxsO1xuICAgICAgICB2YXIgZ3JpZENlbGwgPSBldnQuZ3JpZENlbGw7XG4gICAgICAgIGlmICghdGhpcy5pc1ZpZXdhYmxlQnV0dG9uKGRhdGFDZWxsLngsIGRhdGFDZWxsLnkpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGV2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KCdmaW4tYnV0dG9uLXByZXNzZWQnLCB7XG4gICAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgICAgICBncmlkQ2VsbDogZ3JpZENlbGxcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY2FudmFzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIFN5bnRoZXNpemUgYW5kIGZpcmUgYSBgZmluLWtleWRvd25gIGV2ZW50LlxuICAgICAqIEBwYXJhbSB7a2V5RXZlbnR9IGV2ZW50IC0gVGhlIGNhbnZhcyBldmVudC5cbiAgICAgKi9cbiAgICBmaXJlU3ludGhldGljS2V5ZG93bkV2ZW50OiBmdW5jdGlvbihrZXlFdmVudCkge1xuICAgICAgICB2YXIgY2xpY2tFdmVudCA9IG5ldyBDdXN0b21FdmVudCgnZmluLWtleWRvd24nLCB7XG4gICAgICAgICAgICBkZXRhaWw6IGtleUV2ZW50LmRldGFpbFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jYW52YXMuZGlzcGF0Y2hFdmVudChjbGlja0V2ZW50KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBTeW50aGVzaXplIGFuZCBmaXJlIGEgYGZpbi1rZXl1cGAgZXZlbnQuXG4gICAgICogQHBhcmFtIHtrZXlFdmVudH0gZXZlbnQgLSBUaGUgY2FudmFzIGV2ZW50LlxuICAgICAqL1xuICAgIGZpcmVTeW50aGV0aWNLZXl1cEV2ZW50OiBmdW5jdGlvbihrZXlFdmVudCkge1xuICAgICAgICB2YXIgY2xpY2tFdmVudCA9IG5ldyBDdXN0b21FdmVudCgnZmluLWtleXVwJywge1xuICAgICAgICAgICAgZGV0YWlsOiBrZXlFdmVudC5kZXRhaWxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY2FudmFzLmRpc3BhdGNoRXZlbnQoY2xpY2tFdmVudCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQGRlc2MgU3ludGhlc2l6ZSBhbmQgZmlyZSBhIGBmaW4tY2VsbC1lbnRlcmAgZXZlbnRcbiAgICAgKiBAcGFyYW0ge1BvaW50fSBjZWxsIC0gVGhlIHBpeGVsIGxvY2F0aW9uIG9mIHRoZSBjZWxsIGluIHdoaWNoIHRoZSBjbGljayBldmVudCBvY2N1cnJlZC5cbiAgICAgKiBAcGFyYW0ge01vdXNlRXZlbnR9IGV2ZW50IC0gVGhlIHN5c3RlbSBtb3VzZSBldmVudC5cbiAgICAgKi9cbiAgICBmaXJlU3ludGhldGljT25DZWxsRW50ZXJFdmVudDogZnVuY3Rpb24oY2VsbCkge1xuICAgICAgICB2YXIgZGV0YWlsID0ge1xuICAgICAgICAgICAgZ3JpZENlbGw6IGNlbGwsXG4gICAgICAgICAgICB0aW1lOiBEYXRlLm5vdygpLFxuICAgICAgICAgICAgZ3JpZDogdGhpc1xuICAgICAgICB9O1xuICAgICAgICB2YXIgY2xpY2tFdmVudCA9IG5ldyBDdXN0b21FdmVudCgnZmluLWNlbGwtZW50ZXInLCB7XG4gICAgICAgICAgICBkZXRhaWw6IGRldGFpbFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jYW52YXMuZGlzcGF0Y2hFdmVudChjbGlja0V2ZW50KTtcbiAgICB9LFxuXG4gICAgZmlyZVN5bnRoZXRpY0dyb3Vwc0NoYW5nZWRFdmVudDogZnVuY3Rpb24oZ3JvdXBzKSB7XG4gICAgICAgIHZhciBkZXRhaWwgPSB7XG4gICAgICAgICAgICBncm91cHM6IGdyb3VwcyxcbiAgICAgICAgICAgIHRpbWU6IERhdGUubm93KCksXG4gICAgICAgICAgICBncmlkOiB0aGlzXG4gICAgICAgIH07XG4gICAgICAgIHZhciBjbGlja0V2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KCdmaW4tZ3JvdXBzLWNoYW5nZWQnLCB7XG4gICAgICAgICAgICBkZXRhaWw6IGRldGFpbFxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jYW52YXMuZGlzcGF0Y2hFdmVudChjbGlja0V2ZW50KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBTeW50aGVzaXplIGFuZCBmaXJlIGEgYGZpbi1jZWxsLWV4aXRgIGV2ZW50LlxuICAgICAqIEBwYXJhbSB7UG9pbnR9IGNlbGwgLSBUaGUgcGl4ZWwgbG9jYXRpb24gb2YgdGhlIGNlbGwgaW4gd2hpY2ggdGhlIGNsaWNrIGV2ZW50IG9jY3VyZWQuXG4gICAgICogQHBhcmFtIHtNb3VzZUV2ZW50fSBldmVudCAtIFRoZSBzeXN0ZW0gbW91c2UgZXZlbnQuXG4gICAgICovXG4gICAgZmlyZVN5bnRoZXRpY09uQ2VsbEV4aXRFdmVudDogZnVuY3Rpb24oY2VsbCkge1xuICAgICAgICB2YXIgZGV0YWlsID0ge1xuICAgICAgICAgICAgZ3JpZENlbGw6IGNlbGwsXG4gICAgICAgICAgICB0aW1lOiBEYXRlLm5vdygpLFxuICAgICAgICAgICAgZ3JpZDogdGhpc1xuICAgICAgICB9O1xuICAgICAgICB2YXIgY2xpY2tFdmVudCA9IG5ldyBDdXN0b21FdmVudCgnZmluLWNlbGwtZXhpdCcsIHtcbiAgICAgICAgICAgIGRldGFpbDogZGV0YWlsXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmNhbnZhcy5kaXNwYXRjaEV2ZW50KGNsaWNrRXZlbnQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIFN5bnRoZXNpemUgYW5kIGZpcmUgYSBgZmluLWNlbGwtY2xpY2tgIGV2ZW50LlxuICAgICAqIEBwYXJhbSB7UG9pbnR9IGNlbGwgLSBUaGUgcGl4ZWwgbG9jYXRpb24gb2YgdGhlIGNlbGwgaW4gd2hpY2ggdGhlIGNsaWNrIGV2ZW50IG9jY3VyZWQuXG4gICAgICogQHBhcmFtIHtNb3VzZUV2ZW50fSBldmVudCAtIFRoZSBzeXN0ZW0gbW91c2UgZXZlbnQuXG4gICAgICovXG4gICAgZmlyZVN5bnRoZXRpY0NsaWNrRXZlbnQ6IGZ1bmN0aW9uKG1vdXNlRXZlbnQpIHtcbiAgICAgICAgdmFyIGNlbGwgPSBtb3VzZUV2ZW50LmdyaWRDZWxsO1xuICAgICAgICB2YXIgZGV0YWlsID0ge1xuICAgICAgICAgICAgZ3JpZENlbGw6IGNlbGwsXG4gICAgICAgICAgICBtb3VzZVBvaW50OiBtb3VzZUV2ZW50Lm1vdXNlUG9pbnQsXG4gICAgICAgICAgICBrZXlzOiBtb3VzZUV2ZW50LmtleXMsXG4gICAgICAgICAgICBwcmltaXRpdmVFdmVudDogbW91c2VFdmVudCxcbiAgICAgICAgICAgIHRpbWU6IERhdGUubm93KCksXG4gICAgICAgICAgICBncmlkOiB0aGlzXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZ2V0QmVoYXZpb3IoKS5lbmhhbmNlRG91YmxlQ2xpY2tFdmVudChkZXRhaWwpO1xuICAgICAgICB2YXIgY2xpY2tFdmVudCA9IG5ldyBDdXN0b21FdmVudCgnZmluLWNsaWNrJywge1xuICAgICAgICAgICAgZGV0YWlsOiBkZXRhaWxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY2FudmFzLmRpc3BhdGNoRXZlbnQoY2xpY2tFdmVudCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQGRlc2MgU3ludGhlc2l6ZSBhbmQgZmlyZSBhIGBmaW4tZG91YmxlLWNsaWNrYCBldmVudC5cbiAgICAgKiBAcGFyYW0ge1BvaW50fSBjZWxsIC0gVGhlIHBpeGVsIGxvY2F0aW9uIG9mIHRoZSBjZWxsIGluIHdoaWNoIHRoZSBjbGljayBldmVudCBvY2N1cmVkLlxuICAgICAqIEBwYXJhbSB7TW91c2VFdmVudH0gZXZlbnQgLSBUaGUgc3lzdGVtIG1vdXNlIGV2ZW50LlxuICAgICAqL1xuICAgIGZpcmVTeW50aGV0aWNEb3VibGVDbGlja0V2ZW50OiBmdW5jdGlvbihtb3VzZUV2ZW50KSB7XG4gICAgICAgIHZhciBjZWxsID0gbW91c2VFdmVudC5ncmlkQ2VsbDtcbiAgICAgICAgdmFyIGJlaGF2aW9yID0gdGhpcy5nZXRCZWhhdmlvcigpO1xuICAgICAgICB2YXIgZGV0YWlsID0ge1xuICAgICAgICAgICAgZ3JpZENlbGw6IGNlbGwsXG4gICAgICAgICAgICBtb3VzZVBvaW50OiBtb3VzZUV2ZW50Lm1vdXNlUG9pbnQsXG4gICAgICAgICAgICB0aW1lOiBEYXRlLm5vdygpLFxuICAgICAgICAgICAgZ3JpZDogdGhpc1xuICAgICAgICB9O1xuICAgICAgICBiZWhhdmlvci5lbmhhbmNlRG91YmxlQ2xpY2tFdmVudChtb3VzZUV2ZW50KTtcbiAgICAgICAgdmFyIGNsaWNrRXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoJ2Zpbi1kb3VibGUtY2xpY2snLCB7XG4gICAgICAgICAgICBkZXRhaWw6IGRldGFpbFxuICAgICAgICB9KTtcbiAgICAgICAgYmVoYXZpb3IuY2VsbERvdWJsZUNsaWNrZWQoY2VsbCwgbW91c2VFdmVudCk7XG4gICAgICAgIHRoaXMuY2FudmFzLmRpc3BhdGNoRXZlbnQoY2xpY2tFdmVudCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQGRlc2MgU3ludGhlc2l6ZSBhbmQgZmlyZSBhIHJlbmRlcmVkIGV2ZW50LlxuICAgICAqL1xuICAgIGZpcmVTeW50aGV0aWNHcmlkUmVuZGVyZWRFdmVudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBldmVudCA9IG5ldyBDdXN0b21FdmVudCgnZmluLWdyaWQtcmVuZGVyZWQnLCB7XG4gICAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgICAgICBzb3VyY2U6IHRoaXMsXG4gICAgICAgICAgICAgICAgdGltZTogRGF0ZS5ub3coKVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHRoaXMuY2FudmFzKSB7XG4gICAgICAgICAgICB0aGlzLmNhbnZhcy5kaXNwYXRjaEV2ZW50KGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIFN5bnRoZXNpemUgYW5kIGZpcmUgYSBzY3JvbGwgZXZlbnQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgLSBTaG91bGQgYmUgZWl0aGVyIGBmaW4tc2Nyb2xsLXhgIG9yIGBmaW4tc2Nyb2xsLXlgLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvbGRWYWx1ZSAtIFRoZSBvbGQgc2Nyb2xsIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuZXdWYWx1ZSAtIFRoZSBuZXcgc2Nyb2xsIHZhbHVlLlxuICAgICAqL1xuICAgIGZpcmVTY3JvbGxFdmVudDogZnVuY3Rpb24odHlwZSwgb2xkVmFsdWUsIG5ld1ZhbHVlKSB7XG4gICAgICAgIHZhciBldmVudCA9IG5ldyBDdXN0b21FdmVudCh0eXBlLCB7XG4gICAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgICAgICBvbGRWYWx1ZTogb2xkVmFsdWUsXG4gICAgICAgICAgICAgICAgdmFsdWU6IG5ld1ZhbHVlLFxuICAgICAgICAgICAgICAgIHRpbWU6IERhdGUubm93KClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY2FudmFzLmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQGRlc2MgU2V0IHRoZSB2ZXJ0aWNhbCBzY3JvbGwgdmFsdWUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG5ld1ZhbHVlIC0gVGhlIG5ldyBzY3JvbGwgdmFsdWUuXG4gICAgICovXG4gICAgc2V0VlNjcm9sbFZhbHVlOiBmdW5jdGlvbih5KSB7XG4gICAgICAgIHkgPSBNYXRoLnJvdW5kKHkpO1xuICAgICAgICB2YXIgbWF4ID0gdGhpcy5zYlZTY3JvbGxlci5yYW5nZS5tYXg7XG4gICAgICAgIHkgPSBNYXRoLm1pbihtYXgsIE1hdGgubWF4KDAsIHkpKTtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICBpZiAoeSA9PT0gdGhpcy52U2Nyb2xsVmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmdldEJlaGF2aW9yKCkuX3NldFNjcm9sbFBvc2l0aW9uWSh5KTtcbiAgICAgICAgdmFyIG9sZFkgPSB0aGlzLnZTY3JvbGxWYWx1ZTtcbiAgICAgICAgdGhpcy52U2Nyb2xsVmFsdWUgPSB5O1xuICAgICAgICB0aGlzLnNjcm9sbFZhbHVlQ2hhbmdlZE5vdGlmaWNhdGlvbigpO1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgLy8gc2VsZi5zYlZSYW5nZUFkYXB0ZXIuc3ViamVjdENoYW5nZWQoKTtcbiAgICAgICAgICAgIHNlbGYuZmlyZVNjcm9sbEV2ZW50KCdmaW4tc2Nyb2xsLXknLCBvbGRZLCB5KTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgdmVydGljYWwgc2Nyb2xsIHZhbHVlLlxuICAgICAqL1xuICAgIGdldFZTY3JvbGxWYWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZTY3JvbGxWYWx1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBTZXQgdGhlIGhvcml6b250YWwgc2Nyb2xsIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuZXdWYWx1ZSAtIFRoZSBuZXcgc2Nyb2xsIHZhbHVlLlxuICAgICAqL1xuICAgIHNldEhTY3JvbGxWYWx1ZTogZnVuY3Rpb24oeCkge1xuICAgICAgICB4ID0gTWF0aC5yb3VuZCh4KTtcbiAgICAgICAgdmFyIG1heCA9IHRoaXMuc2JIU2Nyb2xsZXIucmFuZ2UubWF4O1xuICAgICAgICB4ID0gTWF0aC5taW4obWF4LCBNYXRoLm1heCgwLCB4KSk7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgaWYgKHggPT09IHRoaXMuaFNjcm9sbFZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5nZXRCZWhhdmlvcigpLl9zZXRTY3JvbGxQb3NpdGlvblgoeCk7XG4gICAgICAgIHZhciBvbGRYID0gdGhpcy5oU2Nyb2xsVmFsdWU7XG4gICAgICAgIHRoaXMuaFNjcm9sbFZhbHVlID0geDtcbiAgICAgICAgdGhpcy5zY3JvbGxWYWx1ZUNoYW5nZWROb3RpZmljYXRpb24oKTtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vc2VsZi5zYkhSYW5nZUFkYXB0ZXIuc3ViamVjdENoYW5nZWQoKTtcbiAgICAgICAgICAgIHNlbGYuZmlyZVNjcm9sbEV2ZW50KCdmaW4tc2Nyb2xsLXgnLCBvbGRYLCB4KTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHJldHVybnMgVGhlIHZlcnRpY2FsIHNjcm9sbCB2YWx1ZS5cbiAgICAgKi9cbiAgICBnZXRIU2Nyb2xsVmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oU2Nyb2xsVmFsdWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQGRlc2MgUmVxdWVzdCBpbnB1dCBmb2N1cy5cbiAgICAgKi9cbiAgICB0YWtlRm9jdXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5pc0VkaXRpbmcoKSkge1xuICAgICAgICAgICAgdGhpcy5zdG9wRWRpdGluZygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5nZXRDYW52YXMoKS50YWtlRm9jdXMoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIFJlcXVlc3QgZm9jdXMgZm9yIG91ciBjZWxsIGVkaXRvci5cbiAgICAgKi9cbiAgICBlZGl0b3JUYWtlRm9jdXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5jZWxsRWRpdG9yKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jZWxsRWRpdG9yLnRha2VGb2N1cygpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFdlIGhhdmUgYSBjdXJyZW50bHkgYWN0aXZlIGNlbGwgZWRpdG9yLlxuICAgICAqL1xuICAgIGlzRWRpdGluZzogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLmNlbGxFZGl0b3IpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNlbGxFZGl0b3IuaXNFZGl0aW5nO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBJbml0aWFsaXplIHRoZSBzY3JvbGwgYmFycy5cbiAgICAgKi9cbiAgICBpbml0U2Nyb2xsYmFyczogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgIHZhciBob3J6QmFyID0gbmV3IEZpbkJhcih7XG4gICAgICAgICAgICBvcmllbnRhdGlvbjogJ2hvcml6b250YWwnLFxuICAgICAgICAgICAgb25jaGFuZ2U6IHNlbGYuc2V0SFNjcm9sbFZhbHVlLmJpbmQoc2VsZiksXG4gICAgICAgICAgICBjc3NTdHlsZXNoZWV0UmVmZXJlbmNlRWxlbWVudDogdGhpcy5kaXZcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdmFyIHZlcnRCYXIgPSBuZXcgRmluQmFyKHtcbiAgICAgICAgICAgIG9yaWVudGF0aW9uOiAndmVydGljYWwnLFxuICAgICAgICAgICAgb25jaGFuZ2U6IHNlbGYuc2V0VlNjcm9sbFZhbHVlLmJpbmQoc2VsZiksXG4gICAgICAgICAgICBwYWdpbmc6IHtcbiAgICAgICAgICAgICAgICB1cDogc2VsZi5wYWdlVXAuYmluZChzZWxmKSxcbiAgICAgICAgICAgICAgICBkb3duOiBzZWxmLnBhZ2VEb3duLmJpbmQoc2VsZilcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5zYkhTY3JvbGxlciA9IGhvcnpCYXI7XG4gICAgICAgIHRoaXMuc2JWU2Nyb2xsZXIgPSB2ZXJ0QmFyO1xuXG4gICAgICAgIHZhciBoUHJlZml4ID0gdGhpcy5yZXNvbHZlUHJvcGVydHkoJ2hTY3JvbGxiYXJDbGFzc1ByZWZpeCcpO1xuICAgICAgICB2YXIgdlByZWZpeCA9IHRoaXMucmVzb2x2ZVByb3BlcnR5KCd2U2Nyb2xsYmFyQ2xhc3NQcmVmaXgnKTtcblxuICAgICAgICBpZiAoaFByZWZpeCAmJiBoUHJlZml4ICE9PSAnJykge1xuICAgICAgICAgICAgdGhpcy5zYkhTY3JvbGxlci5jbGFzc1ByZWZpeCA9IGhQcmVmaXg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodlByZWZpeCAmJiB2UHJlZml4ICE9PSAnJykge1xuICAgICAgICAgICAgdGhpcy5zYlZTY3JvbGxlci5jbGFzc1ByZWZpeCA9IHZQcmVmaXg7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmRpdi5hcHBlbmRDaGlsZChob3J6QmFyLmJhcik7XG4gICAgICAgIHRoaXMuZGl2LmFwcGVuZENoaWxkKHZlcnRCYXIuYmFyKTtcblxuICAgICAgICB0aGlzLnJlc2l6ZVNjcm9sbGJhcnMoKTtcblxuICAgIH0sXG5cbiAgICByZXNpemVTY3JvbGxiYXJzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5zYkhTY3JvbGxlci5zaG9ydGVuQnkodGhpcy5zYlZTY3JvbGxlcikucmVzaXplKCk7XG4gICAgICAgIC8vdGhpcy5zYlZTY3JvbGxlci5zaG9ydGVuQnkodGhpcy5zYkhTY3JvbGxlcik7XG4gICAgICAgIHRoaXMuc2JWU2Nyb2xsZXIucmVzaXplKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQGRlc2MgU2Nyb2xsIHZhbHVlcyBoYXZlIGNoYW5nZWQsIHdlJ3ZlIGJlZW4gbm90aWZpZWQuXG4gICAgICovXG4gICAgc2V0VlNjcm9sbGJhclZhbHVlczogZnVuY3Rpb24obWF4KSB7XG4gICAgICAgIHRoaXMuc2JWU2Nyb2xsZXIucmFuZ2UgPSB7XG4gICAgICAgICAgICBtaW46IDAsXG4gICAgICAgICAgICBtYXg6IG1heFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICBzZXRIU2Nyb2xsYmFyVmFsdWVzOiBmdW5jdGlvbihtYXgpIHtcbiAgICAgICAgdGhpcy5zYkhTY3JvbGxlci5yYW5nZSA9IHtcbiAgICAgICAgICAgIG1pbjogMCxcbiAgICAgICAgICAgIG1heDogbWF4XG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIHNjcm9sbFZhbHVlQ2hhbmdlZE5vdGlmaWNhdGlvbjogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgaWYgKHRoaXMuaFNjcm9sbFZhbHVlID09PSB0aGlzLnNiUHJldkhTY3JvbGxWYWx1ZSAmJiB0aGlzLnZTY3JvbGxWYWx1ZSA9PT0gdGhpcy5zYlByZXZWU2Nyb2xsVmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc2JQcmV2SFNjcm9sbFZhbHVlID0gdGhpcy5oU2Nyb2xsVmFsdWU7XG4gICAgICAgIHRoaXMuc2JQcmV2VlNjcm9sbFZhbHVlID0gdGhpcy52U2Nyb2xsVmFsdWU7XG5cbiAgICAgICAgaWYgKHRoaXMuY2VsbEVkaXRvcikge1xuICAgICAgICAgICAgdGhpcy5jZWxsRWRpdG9yLnNjcm9sbFZhbHVlQ2hhbmdlZE5vdGlmaWNhdGlvbigpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5jb21wdXRlQ2VsbHNCb3VuZHMoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAc3VtbWFyeSBHZXQgZGF0YSB2YWx1ZSBhdCBnaXZlbiBjZWxsLlxuICAgICAqIEBkZXNjIERlbGVnYXRlcyB0byB0aGUgYmVoYXZpb3IuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggLSBUaGUgaG9yaXpvbnRhbCBjb29yZGluYXRlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gVGhlIHZlcnRpY2FsIGNvb3JkaW5hdGUuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqL1xuICAgIGdldFZhbHVlOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEJlaGF2aW9yKCkuZ2V0VmFsdWUoeCwgeSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQGRlc2MgU2V0IGEgZGF0YSB2YWx1ZSBpbnRvIHRoZSBiZWhhdmlvciAobW9kZWwpIGF0IHRoZSBnaXZlbiBwb2ludFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gVGhlIGhvcml6b250YWwgY29vcmRpbmF0ZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSAtIFRoZSB2ZXJ0aWNhbCBjb29yZGluYXRlLlxuICAgICAqL1xuICAgIHNldFZhbHVlOiBmdW5jdGlvbih4LCB5LCB2YWx1ZSkge1xuICAgICAgICB0aGlzLmdldEJlaGF2aW9yKCkuc2V0VmFsdWUoeCwgeSwgdmFsdWUpO1xuICAgIH0sXG5cbiAgICBnZXRDb2x1bW5BbGlnbm1lbnQ6IGZ1bmN0aW9uKGMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QmVoYXZpb3IoKS5nZXRDb2x1bW5BbGlnbm1lbnQoYyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQGRlc2MgVGhlIGRhdGEgZGltZW5zaW9ucyBoYXZlIGNoYW5nZWQsIG9yIG91ciBwaXhlbCBib3VuZHJpZXMgaGF2ZSBjaGFuZ2VkLlxuICAgICAqIEFkanVzdCB0aGUgc2Nyb2xsYmFyIHByb3BlcnRpZXMgYXMgbmVjZXNzYXJ5LlxuICAgICAqL1xuICAgIHN5bmNocm9uaXplU2Nyb2xsaW5nQm91bmRyaWVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8zMjcvNjY0XG4gICAgICAgIHZhciBiZWhhdmlvciA9IHRoaXMuZ2V0QmVoYXZpb3IoKTtcblxuICAgICAgICB2YXIgbnVtRml4ZWRDb2x1bW5zID0gdGhpcy5nZXRGaXhlZENvbHVtbkNvdW50KCk7XG4gICAgICAgIHZhciBudW1GaXhlZFJvd3MgPSB0aGlzLmdldEZpeGVkUm93Q291bnQoKTtcblxuICAgICAgICB2YXIgbnVtQ29sdW1ucyA9IHRoaXMuZ2V0Q29sdW1uQ291bnQoKTtcbiAgICAgICAgdmFyIG51bVJvd3MgPSB0aGlzLmdldFJvd0NvdW50KCk7XG5cbiAgICAgICAgdmFyIGJvdW5kcyA9IHRoaXMuZ2V0Qm91bmRzKCk7XG4gICAgICAgIGlmICghYm91bmRzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNjcm9sbGFibGVIZWlnaHQgPSBib3VuZHMuaGVpZ2h0IC0gYmVoYXZpb3IuZ2V0Rml4ZWRSb3dzTWF4SGVpZ2h0KCkgLSAxNTsgLy81cHggcGFkZGluZyBhdCBib3R0b20gYW5kIHJpZ2h0IHNpZGVcbiAgICAgICAgdmFyIHNjcm9sbGFibGVXaWR0aCA9IChib3VuZHMud2lkdGggLSAyMDApIC0gYmVoYXZpb3IuZ2V0Rml4ZWRDb2x1bW5zTWF4V2lkdGgoKSAtIDE1O1xuXG4gICAgICAgIHZhciBsYXN0UGFnZUNvbHVtbkNvdW50ID0gMDtcbiAgICAgICAgdmFyIGNvbHVtbnNXaWR0aCA9IDA7XG4gICAgICAgIGZvciAoOyBsYXN0UGFnZUNvbHVtbkNvdW50IDwgbnVtQ29sdW1uczsgbGFzdFBhZ2VDb2x1bW5Db3VudCsrKSB7XG4gICAgICAgICAgICB2YXIgZWFjaFdpZHRoID0gdGhpcy5nZXRDb2x1bW5XaWR0aChudW1Db2x1bW5zIC0gbGFzdFBhZ2VDb2x1bW5Db3VudCAtIDEpO1xuICAgICAgICAgICAgY29sdW1uc1dpZHRoID0gY29sdW1uc1dpZHRoICsgZWFjaFdpZHRoO1xuICAgICAgICAgICAgaWYgKGNvbHVtbnNXaWR0aCA+IHNjcm9sbGFibGVXaWR0aCkge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxhc3RQYWdlUm93Q291bnQgPSAwO1xuICAgICAgICB2YXIgcm93c0hlaWdodCA9IDA7XG4gICAgICAgIGZvciAoOyBsYXN0UGFnZVJvd0NvdW50IDwgbnVtUm93czsgbGFzdFBhZ2VSb3dDb3VudCsrKSB7XG4gICAgICAgICAgICB2YXIgZWFjaEhlaWdodCA9IHRoaXMuZ2V0Um93SGVpZ2h0KG51bVJvd3MgLSBsYXN0UGFnZVJvd0NvdW50IC0gMSk7XG4gICAgICAgICAgICByb3dzSGVpZ2h0ID0gcm93c0hlaWdodCArIGVhY2hIZWlnaHQ7XG4gICAgICAgICAgICBpZiAocm93c0hlaWdodCA+IHNjcm9sbGFibGVIZWlnaHQpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBoTWF4ID0gMSArIE1hdGgubWF4KDAsIG51bUNvbHVtbnMgLSBudW1GaXhlZENvbHVtbnMgLSBsYXN0UGFnZUNvbHVtbkNvdW50KTtcbiAgICAgICAgdGhpcy5zZXRIU2Nyb2xsYmFyVmFsdWVzKGhNYXgpO1xuXG4gICAgICAgIHZhciB2TWF4ID0gTWF0aC5tYXgoMCwgbnVtUm93cyAtIG51bUZpeGVkUm93cyAtIGxhc3RQYWdlUm93Q291bnQpO1xuICAgICAgICB0aGlzLnNldFZTY3JvbGxiYXJWYWx1ZXModk1heCk7XG5cbiAgICAgICAgdGhpcy5zZXRIU2Nyb2xsVmFsdWUoTWF0aC5taW4odGhpcy5nZXRIU2Nyb2xsVmFsdWUoKSwgaE1heCkpO1xuICAgICAgICB0aGlzLnNldFZTY3JvbGxWYWx1ZShNYXRoLm1pbih0aGlzLmdldFZTY3JvbGxWYWx1ZSgpLCB2TWF4KSk7XG5cbiAgICAgICAgLy90aGlzLmdldENhbnZhcygpLnJlc2l6ZSgpO1xuICAgICAgICB0aGlzLmNvbXB1dGVDZWxsc0JvdW5kcygpO1xuICAgICAgICB0aGlzLnJlcGFpbnQoKTtcblxuICAgICAgICB0aGlzLnJlc2l6ZVNjcm9sbGJhcnMoKTtcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIE5vdGUgdGhhdCBcInZpZXdhYmxlIHJvd3NcIiBpbmNsdWRlcyBhbnkgcGFydGlhbGx5IHZpZXdhYmxlIHJvd3MuXG4gICAgICogQHJldHVybnMge251bWJlcn0gVGhlIG51bWJlciBvZiB2aWV3YWJsZSByb3dzLlxuICAgICAqL1xuICAgIGdldFZpc2libGVSb3dzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UmVuZGVyZXIoKS5nZXRWaXNpYmxlUm93cygpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIE5vdGUgdGhhdCBcInZpZXdhYmxlIGNvbHVtbnNcIiBpbmNsdWRlcyBhbnkgcGFydGlhbGx5IHZpZXdhYmxlIGNvbHVtbnMuXG4gICAgICogQHJldHVybnMge251bWJlcn0gVGhlIG51bWJlciBvZiB2aWV3YWJsZSBjb2x1bW5zLlxuICAgICAqL1xuICAgIGdldFZpc2libGVDb2x1bW5zOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UmVuZGVyZXIoKS5nZXRWaXNpYmxlQ29sdW1ucygpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBzdW1tYXJ5IEluaXRpYWxpemUgdGhlIHJlbmRlcmVyIHN1Yi1jb21wb25lbnQuXG4gICAgICovXG4gICAgaW5pdFJlbmRlcmVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IG5ldyBSZW5kZXJlcih0aGlzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7UmVuZGVyZXJ9IHN1Yi1jb21wb25lbnRcbiAgICAgKi9cbiAgICBnZXRSZW5kZXJlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlbmRlcmVyO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSB3aWR0aCBvZiB0aGUgZ2l2ZW4gY29sdW1uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb2x1bW5JbmRleCAtIFRoZSB1bnRyYW5zbGF0ZWQgY29sdW1uIGluZGV4LlxuICAgICAqL1xuICAgIGdldENvbHVtbldpZHRoOiBmdW5jdGlvbihjb2x1bW5JbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRCZWhhdmlvcigpLmdldENvbHVtbldpZHRoKGNvbHVtbkluZGV4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBTZXQgdGhlIHdpZHRoIG9mIHRoZSBnaXZlbiBjb2x1bW4uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbHVtbkluZGV4IC0gVGhlIHVudHJhbnNsYXRlZCBjb2x1bW4gaW5kZXguXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbHVtbldpZHRoIC0gVGhlIHdpZHRoIGluIHBpeGVscy5cbiAgICAgKi9cbiAgICBzZXRDb2x1bW5XaWR0aDogZnVuY3Rpb24oY29sdW1uSW5kZXgsIGNvbHVtbldpZHRoKSB7XG4gICAgICAgIHRoaXMuZ2V0QmVoYXZpb3IoKS5zZXRDb2x1bW5XaWR0aChjb2x1bW5JbmRleCwgY29sdW1uV2lkdGgpO1xuICAgIH0sXG5cbiAgICBnZXRDb2x1bW5FZGdlOiBmdW5jdGlvbihjKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEJlaGF2aW9yKCkuZ2V0Q29sdW1uRWRnZShjLCB0aGlzLmdldFJlbmRlcmVyKCkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSB0b3RhbCB3aWR0aCBvZiBhbGwgdGhlIGZpeGVkIGNvbHVtbnMuXG4gICAgICovXG4gICAgZ2V0Rml4ZWRDb2x1bW5zV2lkdGg6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRCZWhhdmlvcigpLmdldEZpeGVkQ29sdW1uc1dpZHRoKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge251bWJlcn0gVGhlIGhlaWdodCBvZiB0aGUgZ2l2ZW4gcm93XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJvd0luZGV4IC0gVGhlIHVudHJhbnNsYXRlZCBmaXhlZCBjb2x1bW4gaW5kZXguXG4gICAgICovXG4gICAgZ2V0Um93SGVpZ2h0OiBmdW5jdGlvbihyb3dJbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRCZWhhdmlvcigpLmdldFJvd0hlaWdodChyb3dJbmRleCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQGRlc2MgU2V0IHRoZSBoZWlnaHQgb2YgdGhlIGdpdmVuIHJvdy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcm93SW5kZXggLSBUaGUgcm93IGluZGV4LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByb3dIZWlnaHQgLSBUaGUgd2lkdGggaW4gcGl4ZWxzLlxuICAgICAqL1xuICAgIHNldFJvd0hlaWdodDogZnVuY3Rpb24ocm93SW5kZXgsIHJvd0hlaWdodCkge1xuICAgICAgICB0aGlzLmdldEJlaGF2aW9yKCkuc2V0Um93SGVpZ2h0KHJvd0luZGV4LCByb3dIZWlnaHQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSB0b3RhbCBmaXhlZCByb3dzIGhlaWdodFxuICAgICAqL1xuICAgIGdldEZpeGVkUm93c0hlaWdodDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEJlaGF2aW9yKCkuZ2V0Rml4ZWRSb3dzSGVpZ2h0KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge251bWJlcn0gVGhlIG51bWJlciBvZiBjb2x1bW5zLlxuICAgICAqL1xuICAgIGdldENvbHVtbkNvdW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QmVoYXZpb3IoKS5nZXRDb2x1bW5Db3VudCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgZml4ZWQgcm93cy5cbiAgICAgKi9cbiAgICBnZXRSb3dDb3VudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEJlaGF2aW9yKCkuZ2V0Um93Q291bnQoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIGZpeGVkIGNvbHVtbnMuXG4gICAgICovXG4gICAgZ2V0Rml4ZWRDb2x1bW5Db3VudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEJlaGF2aW9yKCkuZ2V0Rml4ZWRDb2x1bW5Db3VudCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIFRoZSBudW1iZXIgb2YgZml4ZWQgcm93cy5cbiAgICAgKi9cbiAgICBnZXRGaXhlZFJvd0NvdW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QmVoYXZpb3IoKS5nZXRGaXhlZFJvd0NvdW50KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHN1bW1hcnkgVGhlIHRvcCBsZWZ0IGFyZWEgaGFzIGJlZW4gY2xpY2tlZCBvblxuICAgICAqIEBkZXNjIERlbGVnYXRlcyB0byB0aGUgYmVoYXZpb3IuXG4gICAgICogQHBhcmFtIHtldmVudH0gZXZlbnQgLSBUaGUgZXZlbnQgZGV0YWlscy5cbiAgICAgKi9cbiAgICB0b3BMZWZ0Q2xpY2tlZDogZnVuY3Rpb24obW91c2UpIHtcbiAgICAgICAgdGhpcy5nZXRCZWhhdmlvcigpLnRvcExlZnRDbGlja2VkKHRoaXMsIG1vdXNlKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAc3VtbWFyeSBBIGZpeGVkIHJvdyBoYXMgYmVlbiBjbGlja2VkLlxuICAgICAqIEBkZXNjIERlbGVnYXRlcyB0byB0aGUgYmVoYXZpb3IuXG4gICAgICogQHBhcmFtIHtldmVudH0gZXZlbnQgLSBUaGUgZXZlbnQgZGV0YWlscy5cbiAgICAgKi9cbiAgICByb3dIZWFkZXJDbGlja2VkOiBmdW5jdGlvbihtb3VzZSkge1xuICAgICAgICB0aGlzLmdldEJlaGF2aW9yKCkucm93SGVhZGVyQ2xpY2tlZCh0aGlzLCBtb3VzZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHN1bW1hcnkgQSBmaXhlZCBjb2x1bW4gaGFzIGJlZW4gY2xpY2tlZC5cbiAgICAgKiBAZGVzYyBEZWxlZ2F0ZXMgdG8gdGhlIGJlaGF2aW9yLlxuICAgICAqIEBwYXJhbSB7ZXZlbnR9IGV2ZW50IC0gVGhlIGV2ZW50IGRldGFpbHMuXG4gICAgICovXG4gICAgY29sdW1uSGVhZGVyQ2xpY2tlZDogZnVuY3Rpb24obW91c2UpIHtcbiAgICAgICAgdGhpcy5nZXRCZWhhdmlvcigpLmNvbHVtbkhlYWRlckNsaWNrZWQodGhpcywgbW91c2UpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIEFuIGVkaXQgZXZlbnQgaGFzIG9jY3VycmVkLiBBY3RpdmF0ZSB0aGUgZWRpdG9yLlxuICAgICAqIEBwYXJhbSB7ZXZlbnR9IGV2ZW50IC0gVGhlIGV2ZW50IGRldGFpbHMuXG4gICAgICovXG4gICAgX2FjdGl2YXRlRWRpdG9yOiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICB2YXIgZ3JpZENlbGwgPSBldmVudC5ncmlkQ2VsbDtcbiAgICAgICAgdGhpcy5hY3RpdmF0ZUVkaXRvcihncmlkQ2VsbC54LCBncmlkQ2VsbC55KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBBY3RpdmF0ZSB0aGUgZWRpdG9yIGF0IHRoZSBnaXZlbiBjb29yZGluYXRlcy5cbiAgICAgKiBAcGFyYW0ge3h9IHggLSBUaGUgaG9yaXpvbnRhbCBjb29yZGluYXRlLlxuICAgICAqIEBwYXJhbSB7eX0geSAtIFRoZSB2ZXJ0aWNhbCBjb29yZGluYXRlLlxuICAgICAqL1xuICAgIGFjdGl2YXRlRWRpdG9yOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgIGlmICghdGhpcy5pc0VkaXRhYmxlKCkgJiYgIXRoaXMuaXNGaWx0ZXJSb3coeSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZWRpdG9yID0gdGhpcy5nZXRDZWxsRWRpdG9yQXQoeCwgeSk7XG4gICAgICAgIGlmICghZWRpdG9yKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBvaW50ID0gZWRpdG9yLmVkaXRvclBvaW50O1xuICAgICAgICBpZiAoZWRpdG9yKSB7XG4gICAgICAgICAgICBpZiAocG9pbnQueCA9PT0geCAmJiBwb2ludC55ID09PSB5ICYmIGVkaXRvci5pc0VkaXRpbmcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47IC8vd2UncmUgYWxyZWFkeSBvcGVuIGF0IHRoaXMgbG9jYXRpb25cbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5pc0VkaXRpbmcoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3RvcEVkaXRpbmcoKTsgLy9vdGhlciBlZGl0b3IgaXMgb3BlbiwgY2xvc2UgaXQgZmlyc3RcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGV2ZW50LmdyaWRDZWxsID0ge1xuICAgICAgICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgICAgICAgeTogeVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuZWRpdEF0KGVkaXRvciwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHN1bW1hcnkgR2V0IHRoZSBjZWxsIGVkaXRvci5cbiAgICAgKiBAZGVzYyBEZWxlZ2F0ZXMgdG8gdGhlIGJlaGF2aW9yLlxuICAgICAqIEByZXR1cm5zIFRoZSBjZWxsIGVkaXRvciBhdCB0aGUgZ2l2ZW4gY29vcmRpbmF0ZXMuXG4gICAgICogQHBhcmFtIHt4fSB4IC0gVGhlIGhvcml6b250YWwgY29vcmRpbmF0ZS5cbiAgICAgKiBAcGFyYW0ge3l9IHkgLSBUaGUgdmVydGljYWwgY29vcmRpbmF0ZS5cbiAgICAgKi9cbiAgICBnZXRDZWxsRWRpdG9yQXQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QmVoYXZpb3IoKS5nZXRDZWxsRWRpdG9yQXQoeCwgeSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHN1bW1hcnkgVG9nZ2xlIEhpRFBJIHN1cHBvcnQuXG4gICAgICogQGRlc2MgSGlEUEkgc3VwcG9ydCBpcyBub3cgKm9uKiBieSBkZWZhdWx0LlxuICAgICAqID4gVGhlcmUgdXNlZCB0byBiZSBhIGJ1ZyBpbiBDaHJvbWUgdGhhdCBjYXVzZWQgc2V2ZXJlIHNsb3cgZG93biBvbiBiaXQgYmxpdCBvZiBsYXJnZSBpbWFnZXMsIHNvIHRoaXMgSGlEUEkgbmVlZGVkIHRvIGJlIG9wdGlvbmFsLlxuICAgICAqL1xuICAgIHRvZ2dsZUhpRFBJOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMudXNlSGlEUEkoKSkge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVBdHRyaWJ1dGUoJ2hpZHBpJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSgnaGlkcGknLCBudWxsKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNhbnZhcy5yZXNpemUoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUZSBIaURQSSByYXRpby5cbiAgICAgKi9cbiAgICBnZXRIaURQSTogZnVuY3Rpb24oY3R4KSB7XG4gICAgICAgIGlmICh3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyAmJiB0aGlzLnVzZUhpRFBJKCkpIHtcbiAgICAgICAgICAgIHZhciBkZXZpY2VQaXhlbFJhdGlvID0gd2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMTtcbiAgICAgICAgICAgIHZhciBiYWNraW5nU3RvcmVSYXRpbyA9IGN0eC53ZWJraXRCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8XG4gICAgICAgICAgICAgICAgY3R4Lm1vekJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHxcbiAgICAgICAgICAgICAgICBjdHgubXNCYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8XG4gICAgICAgICAgICAgICAgY3R4Lm9CYWNraW5nU3RvcmVQaXhlbFJhdGlvIHx8XG4gICAgICAgICAgICAgICAgY3R4LmJhY2tpbmdTdG9yZVBpeGVsUmF0aW8gfHwgMTtcblxuICAgICAgICAgICAgdmFyIHJhdGlvID0gZGV2aWNlUGl4ZWxSYXRpbyAvIGJhY2tpbmdTdG9yZVJhdGlvO1xuICAgICAgICAgICAgcmV0dXJuIHJhdGlvO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgd2lkdGggb2YgdGhlIGdpdmVuIChyZWNlbnRseSByZW5kZXJlZCkgY29sdW1uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb2xJbmRleCAtIFRoZSBjb2x1bW4gaW5kZXguXG4gICAgICovXG4gICAgZ2V0UmVuZGVyZWRXaWR0aDogZnVuY3Rpb24oY29sSW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVuZGVyZXIuZ2V0UmVuZGVyZWRXaWR0aChjb2xJbmRleCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge251bWJlcn0gVGhlIGhlaWdodCBvZiB0aGUgZ2l2ZW4gKHJlY2VudGx5IHJlbmRlcmVkKSByb3cuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHJvd0luZGV4IC0gVHRoZSByb3cgaW5kZXguXG4gICAgICovXG4gICAgZ2V0UmVuZGVyZWRIZWlnaHQ6IGZ1bmN0aW9uKHJvd0luZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlbmRlcmVyLmdldFJlbmRlcmVkSGVpZ2h0KHJvd0luZGV4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7Q2VsbEVkaXRvcn0gVGhlIGNlbGwgZWRpdG9yIGF0IGFsaWFzIFwibmFtZVwiIChhIHN1Yi1jb21wb25lbnQpLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICovXG4gICAgcmVzb2x2ZUNlbGxFZGl0b3I6IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2VsbEVkaXRvcnNbbmFtZV07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgdXBkYXRlIHRoZSBjdXJzb3IgdW5kZXIgdGhlIGhvdmVyIGNlbGxcbiAgICAgKi9cbiAgICB1cGRhdGVDdXJzb3I6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdHJhbnNsYXRlID0gdGhpcy5nZXRCZWhhdmlvcigpO1xuICAgICAgICB2YXIgY3Vyc29yID0gdHJhbnNsYXRlLmdldEN1cnNvckF0KC0xLCAtMSk7XG4gICAgICAgIHZhciBob3ZlckNlbGwgPSB0aGlzLmdldEhvdmVyQ2VsbCgpO1xuICAgICAgICBpZiAoaG92ZXJDZWxsICYmIGhvdmVyQ2VsbC54ID4gLTEgJiYgaG92ZXJDZWxsLnkgPiAtMSkge1xuICAgICAgICAgICAgdmFyIHggPSBob3ZlckNlbGwueCArIHRoaXMuZ2V0SFNjcm9sbFZhbHVlKCk7XG4gICAgICAgICAgICBjdXJzb3IgPSB0cmFuc2xhdGUuZ2V0Q3Vyc29yQXQoeCwgaG92ZXJDZWxsLnkgKyB0aGlzLmdldFZTY3JvbGxWYWx1ZSgpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJlQ3Vyc29yKGN1cnNvcik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQGRlc2MgUmVwYWludCB0aGUgZ2l2ZW4gY2VsbC5cbiAgICAgKiBAcGFyYW0ge3h9IHggLSBUaGUgaG9yaXpvbnRhbCBjb29yZGluYXRlLlxuICAgICAqIEBwYXJhbSB7eX0geSAtIFRoZSB2ZXJ0aWNhbCBjb29yZGluYXRlLlxuICAgICAqL1xuICAgIHJlcGFpbnRDZWxsOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgIHRoaXMuZ2V0UmVuZGVyZXIoKS5yZXBhaW50Q2VsbCh4LCB5KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVGhlIHVzZXIgaXMgY3VycmVudGx5IGRyYWdnaW5nIGEgY29sdW1uIHRvIHJlb3JkZXIgaXQuXG4gICAgICovXG4gICAgaXNEcmFnZ2luZ0NvbHVtbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAhIXRoaXMucmVuZGVyT3ZlcnJpZGVzQ2FjaGUuZHJhZ2dlcjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBTY3JvbGwgdXAgb25lIGZ1bGwgcGFnZS5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIHBhZ2VVcDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciByb3dOdW0gPSB0aGlzLmdldFJlbmRlcmVyKCkuZ2V0UGFnZVVwUm93KCk7XG4gICAgICAgIHRoaXMuc2V0VlNjcm9sbFZhbHVlKHJvd051bSk7XG4gICAgICAgIHJldHVybiByb3dOdW07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQGRlc2MgU2Nyb2xsIGRvd24gb25lIGZ1bGwgcGFnZS5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIHBhZ2VEb3duOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHJvd051bSA9IHRoaXMuZ2V0UmVuZGVyZXIoKS5nZXRQYWdlRG93blJvdygpO1xuICAgICAgICB0aGlzLnNldFZTY3JvbGxWYWx1ZShyb3dOdW0pO1xuICAgICAgICByZXR1cm4gcm93TnVtO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIE5vdCB5ZXQgaW1wbGVtZW50ZWQuXG4gICAgICovXG4gICAgcGFnZUxlZnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBjb25zb2xlLmxvZygncGFnZSBsZWZ0Jyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQGRlc2MgTm90IHlldCBpbXBsZW1lbnRlZC5cbiAgICAgKi9cbiAgICBwYWdlUmlnaHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBjb25zb2xlLmxvZygncGFnZSByaWdodCcpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtvYmplY3RbXX0gT2JqZWN0cyB3aXRoIHRoZSB2YWx1ZXMgdGhhdCB3ZXJlIGp1c3QgcmVuZGVyZWQuXG4gICAgICovXG4gICAgZ2V0UmVuZGVyZWREYXRhOiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gYXNzdW1lcyBvbmUgcm93IG9mIGhlYWRlcnNcbiAgICAgICAgdmFyIGJlaGF2aW9yID0gdGhpcy5nZXRCZWhhdmlvcigpLFxuICAgICAgICAgICAgcmVuZGVyZXIgPSB0aGlzLmdldFJlbmRlcmVyKCksXG4gICAgICAgICAgICBjb2xDb3VudCA9IHRoaXMuZ2V0Q29sdW1uQ291bnQoKSxcbiAgICAgICAgICAgIHJvd0NvdW50ID0gcmVuZGVyZXIuZ2V0VmlzaWJsZVJvd3MoKSxcbiAgICAgICAgICAgIGhlYWRlcnMgPSBuZXcgQXJyYXkoY29sQ291bnQpLFxuICAgICAgICAgICAgcmVzdWx0cyA9IG5ldyBBcnJheShyb3dDb3VudCksXG4gICAgICAgICAgICByb3c7XG5cbiAgICAgICAgaGVhZGVycy5mb3JFYWNoKGZ1bmN0aW9uKGhlYWRlciwgYykge1xuICAgICAgICAgICAgaGVhZGVyc1tjXSA9IGJlaGF2aW9yLmdldENvbHVtbklkKGMsIDApO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXN1bHRzLmZvckVhY2goZnVuY3Rpb24ocmVzdWx0LCByKSB7XG4gICAgICAgICAgICByb3cgPSByZXN1bHRzW3JdID0ge1xuICAgICAgICAgICAgICAgIGhpZXJhcmNoeTogYmVoYXZpb3IuZ2V0Rml4ZWRDb2x1bW5WYWx1ZSgwLCByKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGhlYWRlcnMuZm9yRWFjaChmdW5jdGlvbihmaWVsZCwgYykge1xuICAgICAgICAgICAgICAgIHJvd1tmaWVsZF0gPSBiZWhhdmlvci5nZXRWYWx1ZShjLCByKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fSBBbiBvYmplY3QgdGhhdCByZXByZXNlbnRzIHRoZSBjdXJyZW50bHkgc2VsZWN0aW9uIHJvdy5cbiAgICAgKi9cbiAgICBnZXRTZWxlY3RlZFJvdzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzZWxzID0gdGhpcy5nZXRTZWxlY3Rpb25Nb2RlbCgpLmdldFNlbGVjdGlvbnMoKTtcbiAgICAgICAgaWYgKHNlbHMubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgYmVoYXZpb3IgPSB0aGlzLmdldEJlaGF2aW9yKCksXG4gICAgICAgICAgICAgICAgY29sQ291bnQgPSB0aGlzLmdldENvbHVtbkNvdW50KCksXG4gICAgICAgICAgICAgICAgdG9wUm93ID0gc2Vsc1swXS5vcmlnaW4ueSxcbiAgICAgICAgICAgICAgICByb3cgPSB7XG4gICAgICAgICAgICAgICAgICAgIC8vaGllcmFyY2h5OiBiZWhhdmlvci5nZXRGaXhlZENvbHVtblZhbHVlKDAsIHRvcFJvdylcbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBmb3IgKHZhciBjID0gMDsgYyA8IGNvbENvdW50OyBjKyspIHtcbiAgICAgICAgICAgICAgICByb3dbYmVoYXZpb3IuZ2V0Q29sdW1uSWQoYywgMCldID0gYmVoYXZpb3IuZ2V0VmFsdWUoYywgdG9wUm93KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJvdztcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBmaXJlUmVxdWVzdENlbGxFZGl0OiBmdW5jdGlvbihjZWxsLCB2YWx1ZSkge1xuICAgICAgICB2YXIgY2xpY2tFdmVudCA9IG5ldyBDdXN0b21FdmVudCgnZmluLXJlcXVlc3QtY2VsbC1lZGl0Jywge1xuICAgICAgICAgICAgY2FuY2VsYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGRldGFpbDoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgICAgICBncmlkQ2VsbDogY2VsbCxcbiAgICAgICAgICAgICAgICB0aW1lOiBEYXRlLm5vdygpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5jYW52YXMuZGlzcGF0Y2hFdmVudChjbGlja0V2ZW50KTsgLy9JIHdhc24ndCBjYW5jZWxsZWRcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQGRlc2MgU3ludGhlc2l6ZSBhbmQgZmlyZSBhIGZpbi1iZWZvcmUtY2VsbC1lZGl0IGV2ZW50LlxuICAgICAqIEBwYXJhbSB7UG9pbnR9IGNlbGwgLSBUaGUgeCx5IGNvb3JkaW5hdGVzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZSAtIFRoZSBjdXJyZW50IHZhbHVlLlxuICAgICAqL1xuICAgIGZpcmVCZWZvcmVDZWxsRWRpdDogZnVuY3Rpb24oY2VsbCwgb2xkVmFsdWUsIG5ld1ZhbHVlLCBjb250cm9sKSB7XG4gICAgICAgIHZhciBjbGlja0V2ZW50ID0gbmV3IEN1c3RvbUV2ZW50KCdmaW4tYmVmb3JlLWNlbGwtZWRpdCcsIHtcbiAgICAgICAgICAgIGNhbmNlbGFibGU6IHRydWUsXG4gICAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgICAgICBvbGRWYWx1ZTogb2xkVmFsdWUsXG4gICAgICAgICAgICAgICAgbmV3VmFsdWU6IG5ld1ZhbHVlLFxuICAgICAgICAgICAgICAgIGdyaWRDZWxsOiBjZWxsLFxuICAgICAgICAgICAgICAgIHRpbWU6IERhdGUubm93KCksXG4gICAgICAgICAgICAgICAgaW5wdXQ6IGNvbnRyb2xcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBwcm9jZWVkID0gdGhpcy5jYW52YXMuZGlzcGF0Y2hFdmVudChjbGlja0V2ZW50KTtcbiAgICAgICAgcmV0dXJuIHByb2NlZWQ7IC8vSSB3YXNuJ3QgY2FuY2VsbGVkXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge1JlbmRlcmVyfSBzdWItY29tcG9uZW50XG4gICAgICogQHBhcmFtIHtQb2ludH0gY2VsbCAtIFRoZSB4LHkgY29vcmRpbmF0ZXMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9sZFZhbHVlIC0gVGhlIG9sZCB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbmV3VmFsdWUgLSBUaGUgbmV3IHZhbHVlLlxuICAgICAqL1xuICAgIGZpcmVBZnRlckNlbGxFZGl0OiBmdW5jdGlvbihjZWxsLCBvbGRWYWx1ZSwgbmV3VmFsdWUsIGNvbnRyb2wpIHtcbiAgICAgICAgdmFyIGNsaWNrRXZlbnQgPSBuZXcgQ3VzdG9tRXZlbnQoJ2Zpbi1hZnRlci1jZWxsLWVkaXQnLCB7XG4gICAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgICAgICBuZXdWYWx1ZTogbmV3VmFsdWUsXG4gICAgICAgICAgICAgICAgb2xkVmFsdWU6IG9sZFZhbHVlLFxuICAgICAgICAgICAgICAgIGdyaWRDZWxsOiBjZWxsLFxuICAgICAgICAgICAgICAgIHRpbWU6IERhdGUubm93KCksXG4gICAgICAgICAgICAgICAgaW5wdXQ6IGNvbnRyb2xcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY2FudmFzLmRpc3BhdGNoRXZlbnQoY2xpY2tFdmVudCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQGRlc2MgQXV0b3NpemUgdGhlIGNvbHVtbiBhdCBjb2xJbmRleCBmb3IgYmVzdCBmaXQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbEluZGV4IC0gVGhlIGNvbHVtbiBpbmRleCB0byBtb2RpZnkgYXRcbiAgICAgKi9cbiAgICBhdXRvc2l6ZUNvbHVtbjogZnVuY3Rpb24oY29sSW5kZXgpIHtcbiAgICAgICAgdmFyIGNvbHVtbiA9IHRoaXMuZ2V0QmVoYXZpb3IoKS5nZXRDb2x1bW4oY29sSW5kZXgpO1xuICAgICAgICBjb2x1bW4uY2hlY2tDb2x1bW5BdXRvc2l6aW5nKHRydWUpO1xuICAgICAgICB0aGlzLmNvbXB1dGVDZWxsc0JvdW5kcygpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIEVuYWJsZS9kaXNhYmxlIGlmIHRoaXMgY29tcG9uZW50IGNhbiByZWNlaXZlIHRoZSBmb2N1cy5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IC0gY2FuUmVjZWl2ZUZvY3VzXG4gICAgICovXG4gICAgc2V0Rm9jdXNhYmxlOiBmdW5jdGlvbihjYW5SZWNlaXZlRm9jdXMpIHtcbiAgICAgICAgdGhpcy5nZXRDYW52YXMoKS5zZXRGb2N1c2FibGUoY2FuUmVjZWl2ZUZvY3VzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIGNvbHVtbnMgdGhhdCB3ZXJlIGp1c3QgcmVuZGVyZWRcbiAgICAgKi9cbiAgICBnZXRWaXNpYmxlQ29sdW1uc0NvdW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UmVuZGVyZXIoKS5nZXRWaXNpYmxlQ29sdW1uc0NvdW50KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge251bWJlcn0gVGhlIG51bWJlciBvZiByb3dzIHRoYXQgd2VyZSBqdXN0IHJlbmRlcmVkXG4gICAgICovXG4gICAgZ2V0VmlzaWJsZVJvd3NDb3VudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFJlbmRlcmVyKCkuZ2V0VmlzaWJsZVJvd3NDb3VudCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgIHVwZGF0ZSB0aGUgc2l6ZSBvZiB0aGUgZ3JpZFxuICAgICAqXG4gICAgICogIyMjIyByZXR1cm5zOiBpbnRlZ2VyXG4gICAgICovXG4gICAgdXBkYXRlU2l6ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuY2FudmFzLmNoZWNrc2l6ZSgpO1xuICAgIH0sXG5cblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQGRlc2MgU3RvcCB0aGUgZ2xvYmFsIHJlcGFpbnRpbmcgZmxhZyB0aHJlYWQuXG4gICAgICovXG4gICAgc3RvcFBhaW50VGhyZWFkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5jYW52YXMuc3RvcFBhaW50VGhyZWFkKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBIeXBlcmdyaWQucHJvdG90eXBlXG4gICAgICogQGRlc2MgU3RvcCB0aGUgZ2xvYmFsIHJlc2l6ZSBjaGVjayBmbGFnIHRocmVhZC5cbiAgICAgKi9cbiAgICBzdG9wUmVzaXplVGhyZWFkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5jYW52YXMuc3RvcFJlc2l6ZVRocmVhZCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgSHlwZXJncmlkLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIFJlc3RhcnQgdGhlIGdsb2JhbCByZXNpemUgY2hlY2sgZmxhZyB0aHJlYWQuXG4gICAgICovXG4gICAgcmVzdGFydFJlc2l6ZVRocmVhZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuY2FudmFzLnJlc3RhcnRSZXNpemVUaHJlYWQoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEh5cGVyZ3JpZC5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBSZXN0YXJ0IHRoZSBnbG9iYWwgcmVwYWludGluZyBjaGVjayBmbGFnIHRocmVhZC5cbiAgICAgKi9cbiAgICByZXN0YXJ0UGFpbnRUaHJlYWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmNhbnZhcy5yZXN0YXJ0UGFpbnRUaHJlYWQoKTtcbiAgICB9LFxuXG4gICAgc3dhcENvbHVtbnM6IGZ1bmN0aW9uKHNvdXJjZSwgdGFyZ2V0KSB7XG4gICAgICAgIHRoaXMuZ2V0QmVoYXZpb3IoKS5zd2FwQ29sdW1ucyhzb3VyY2UsIHRhcmdldCk7XG4gICAgfSxcblxuICAgIGVuZERyYWdDb2x1bW5Ob3RpZmljYXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmdldEJlaGF2aW9yKCkuZW5kRHJhZ0NvbHVtbk5vdGlmaWNhdGlvbigpO1xuICAgIH0sXG5cbiAgICBnZXRGaXhlZENvbHVtbnNNYXhXaWR0aDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEJlaGF2aW9yKCkuZ2V0Rml4ZWRDb2x1bW5zTWF4V2lkdGgoKTtcbiAgICB9LFxuXG4gICAgaXNNb3VzZURvd25JbkhlYWRlckFyZWE6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbnVtSGVhZGVyQ29sdW1ucyA9IHRoaXMuZ2V0SGVhZGVyQ29sdW1uQ291bnQoKTtcbiAgICAgICAgdmFyIG51bUhlYWRlclJvd3MgPSB0aGlzLmdldEhlYWRlclJvd0NvdW50KCk7XG4gICAgICAgIHZhciBtb3VzZURvd24gPSB0aGlzLmdldE1vdXNlRG93bigpO1xuICAgICAgICByZXR1cm4gbW91c2VEb3duLnggPCBudW1IZWFkZXJDb2x1bW5zIHx8IG1vdXNlRG93bi55IDwgbnVtSGVhZGVyUm93cztcbiAgICB9LFxuXG4gICAgaXNIZWFkZXJXcmFwcGluZzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlc29sdmVQcm9wZXJ0eSgnaGVhZGVyVGV4dFdyYXBwaW5nJyk7XG4gICAgfSxcblxuICAgIF9nZXRCb3VuZHNPZkNlbGw6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgdmFyIGJvdW5kcyA9IHRoaXMuZ2V0UmVuZGVyZXIoKS5fZ2V0Qm91bmRzT2ZDZWxsKHgsIHkpO1xuICAgICAgICByZXR1cm4gYm91bmRzO1xuICAgIH0sXG5cbiAgICBnZXRDb2x1bW5Qcm9wZXJ0aWVzOiBmdW5jdGlvbihjb2x1bW5JbmRleCkge1xuICAgICAgICB2YXIgcHJvcGVydGllcyA9IHRoaXMuZ2V0QmVoYXZpb3IoKS5nZXRDb2x1bW5Qcm9wZXJ0aWVzKGNvbHVtbkluZGV4KTtcbiAgICAgICAgcmV0dXJuIHByb3BlcnRpZXM7XG4gICAgfSxcblxuICAgIHNldENvbHVtblByb3BlcnRpZXM6IGZ1bmN0aW9uKGNvbHVtbkluZGV4LCBwcm9wZXJ0aWVzKSB7XG4gICAgICAgIHRoaXMuZ2V0QmVoYXZpb3IoKS5zZXRDb2x1bW5Qcm9wZXJ0aWVzKGNvbHVtbkluZGV4LCBwcm9wZXJ0aWVzKTtcbiAgICB9LFxuXG4gICAgbW92ZVNpbmdsZVNlbGVjdDogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICB0aGlzLmdldEJlaGF2aW9yKCkubW92ZVNpbmdsZVNlbGVjdCh0aGlzLCB4LCB5KTtcbiAgICB9LFxuXG4gICAgc2VsZWN0Q2VsbDogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICB0aGlzLmdldFNlbGVjdGlvbk1vZGVsKCkuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5nZXRTZWxlY3Rpb25Nb2RlbCgpLnNlbGVjdCh4LCB5LCAwLCAwKTtcbiAgICB9LFxuXG4gICAgZ2V0SGVhZGVyQ29sdW1uQ291bnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRCZWhhdmlvcigpLmdldEhlYWRlckNvbHVtbkNvdW50KCk7XG4gICAgfSxcblxuICAgIHRvZ2dsZVNvcnQ6IGZ1bmN0aW9uKHgsIGtleXMpIHtcbiAgICAgICAgdGhpcy5zdG9wRWRpdGluZygpO1xuICAgICAgICB2YXIgYmVoYXZpb3IgPSB0aGlzLmdldEJlaGF2aW9yKCk7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgYmVoYXZpb3IudG9nZ2xlU29ydCh4LCBrZXlzKTtcblxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgc2VsZi5zeW5jaHJvbml6ZVNjcm9sbGluZ0JvdW5kcmllcygpO1xuICAgICAgICAgICAgLy9zZWxmLmJlaGF2aW9yQ2hhbmdlZCgpO1xuICAgICAgICAgICAgaWYgKHNlbGYuaXNDb2x1bW5BdXRvc2l6aW5nKCkpIHtcbiAgICAgICAgICAgICAgICBiZWhhdmlvci5hdXRvc2l6ZUFsbENvbHVtbnMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNlbGYucmVwYWludCgpO1xuICAgICAgICB9LCAxMCk7XG4gICAgfSxcblxuICAgIHRvZ2dsZVNlbGVjdENvbHVtbjogZnVuY3Rpb24oeCwga2V5cykge1xuICAgICAgICBrZXlzID0ga2V5cyB8fCBbXTtcbiAgICAgICAgdmFyIG1vZGVsID0gdGhpcy5nZXRTZWxlY3Rpb25Nb2RlbCgpO1xuICAgICAgICB2YXIgYWxyZWFkeVNlbGVjdGVkID0gbW9kZWwuaXNDb2x1bW5TZWxlY3RlZCh4KTtcbiAgICAgICAgdmFyIGhhc0NUUkwgPSBrZXlzLmluZGV4T2YoJ0NUUkwnKSA+IC0xO1xuICAgICAgICB2YXIgaGFzU0hJRlQgPSBrZXlzLmluZGV4T2YoJ1NISUZUJykgPiAtMTtcbiAgICAgICAgaWYgKCFoYXNDVFJMICYmICFoYXNTSElGVCkge1xuICAgICAgICAgICAgbW9kZWwuY2xlYXIoKTtcbiAgICAgICAgICAgIGlmICghYWxyZWFkeVNlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgbW9kZWwuc2VsZWN0Q29sdW1uKHgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGhhc0NUUkwpIHtcbiAgICAgICAgICAgICAgICBpZiAoYWxyZWFkeVNlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIG1vZGVsLmRlc2VsZWN0Q29sdW1uKHgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG1vZGVsLnNlbGVjdENvbHVtbih4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaGFzU0hJRlQpIHtcbiAgICAgICAgICAgICAgICBtb2RlbC5jbGVhcigpO1xuICAgICAgICAgICAgICAgIG1vZGVsLnNlbGVjdENvbHVtbih0aGlzLmxhc3RFZGdlU2VsZWN0aW9uWzBdLCB4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoIWFscmVhZHlTZWxlY3RlZCAmJiAhaGFzU0hJRlQpIHtcbiAgICAgICAgICAgIHRoaXMubGFzdEVkZ2VTZWxlY3Rpb25bMF0gPSB4O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVwYWludCgpO1xuICAgICAgICB0aGlzLmZpcmVTeW50aGV0aWNDb2x1bW5TZWxlY3Rpb25DaGFuZ2VkRXZlbnQoKTtcbiAgICB9LFxuXG4gICAgdG9nZ2xlU2VsZWN0Um93OiBmdW5jdGlvbih5LCBrZXlzKSB7XG5cbiAgICAgICAgLy93ZSBjYW4gc2VsZWN0IHRoZSB0b3RhbHMgcm93cyBpZiB0aGV5IGV4aXN0LFxuICAgICAgICAvL2J1dCBub3Qgcm93cyBhYm92ZSB0aGF0XG4gICAgICAgIHZhciBzZWxlY3Rpb25FZGdlID0gdGhpcy5nZXRGaWx0ZXJSb3dJbmRleCgpICsgMTtcbiAgICAgICAgaWYgKHkgPCBzZWxlY3Rpb25FZGdlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBrZXlzID0ga2V5cyB8fCBbXTtcblxuICAgICAgICB2YXIgaXNTaW5nbGVSb3dTZWxlY3Rpb24gPSB0aGlzLmlzU2luZ2xlUm93U2VsZWN0aW9uTW9kZSgpO1xuICAgICAgICB2YXIgbW9kZWwgPSB0aGlzLmdldFNlbGVjdGlvbk1vZGVsKCk7XG4gICAgICAgIHZhciBhbHJlYWR5U2VsZWN0ZWQgPSBtb2RlbC5pc1Jvd1NlbGVjdGVkKHkpO1xuICAgICAgICB2YXIgaGFzQ1RSTCA9IGtleXMuaW5kZXhPZignQ1RSTCcpID4gLTE7XG4gICAgICAgIHZhciBoYXNTSElGVCA9IGtleXMuaW5kZXhPZignU0hJRlQnKSA+IC0xO1xuXG4gICAgICAgIGlmICghaGFzQ1RSTCAmJiAhaGFzU0hJRlQpIHtcbiAgICAgICAgICAgIG1vZGVsLmNsZWFyKCk7XG4gICAgICAgICAgICBpZiAoIWFscmVhZHlTZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgIG1vZGVsLnNlbGVjdFJvdyh5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChoYXNDVFJMKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFscmVhZHlTZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgICAgICBtb2RlbC5kZXNlbGVjdFJvdyh5KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNTaW5nbGVSb3dTZWxlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVsLmNsZWFyUm93U2VsZWN0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbW9kZWwuc2VsZWN0Um93KHkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChoYXNTSElGVCkge1xuICAgICAgICAgICAgICAgIG1vZGVsLmNsZWFyKCk7XG4gICAgICAgICAgICAgICAgbW9kZWwuc2VsZWN0Um93KHRoaXMubGFzdEVkZ2VTZWxlY3Rpb25bMV0sIHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghYWxyZWFkeVNlbGVjdGVkICYmICFoYXNTSElGVCkge1xuICAgICAgICAgICAgdGhpcy5sYXN0RWRnZVNlbGVjdGlvblsxXSA9IHk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZXBhaW50KCk7XG4gICAgfSxcblxuICAgIHNlbGVjdFZpZXdwb3J0Q2VsbDogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICB2YXIgaGVhZGVyUm93Q291bnQgPSB0aGlzLmdldEhlYWRlclJvd0NvdW50KCk7XG4gICAgICAgIHZhciByZW5kZXJlciA9IHRoaXMuZ2V0UmVuZGVyZXIoKTtcbiAgICAgICAgdmFyIHJlYWxYID0gcmVuZGVyZXIuZ2V0VmlzaWJsZUNvbHVtbnMoKVt4XTtcbiAgICAgICAgdmFyIHJlYWxZID0gcmVuZGVyZXIuZ2V0VmlzaWJsZVJvd3MoKVt5XTtcbiAgICAgICAgdGhpcy5jbGVhclNlbGVjdGlvbnMoKTtcbiAgICAgICAgdGhpcy5zZWxlY3QocmVhbFgsIHJlYWxZICsgaGVhZGVyUm93Q291bnQsIDAsIDApO1xuICAgICAgICB0aGlzLnNldE1vdXNlRG93bih0aGlzLm5ld1BvaW50KHJlYWxYLCByZWFsWSArIGhlYWRlclJvd0NvdW50KSk7XG4gICAgICAgIHRoaXMuc2V0RHJhZ0V4dGVudCh0aGlzLm5ld1BvaW50KDAsIDApKTtcbiAgICAgICAgdGhpcy5yZXBhaW50KCk7XG4gICAgfSxcblxuICAgIHNlbGVjdFRvVmlld3BvcnRDZWxsOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgIHZhciBzZWxlY3Rpb25zID0gdGhpcy5nZXRTZWxlY3Rpb25zKCk7XG4gICAgICAgIGlmICghc2VsZWN0aW9ucyB8fCBzZWxlY3Rpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBoZWFkZXJSb3dDb3VudCA9IHRoaXMuZ2V0SGVhZGVyUm93Q291bnQoKTtcbiAgICAgICAgdmFyIHJlbmRlcmVyID0gdGhpcy5nZXRSZW5kZXJlcigpO1xuICAgICAgICB2YXIgcmVhbFggPSByZW5kZXJlci5nZXRWaXNpYmxlQ29sdW1ucygpW3hdO1xuICAgICAgICB2YXIgcmVhbFkgPSByZW5kZXJlci5nZXRWaXNpYmxlUm93cygpW3ldICsgaGVhZGVyUm93Q291bnQ7XG4gICAgICAgIHZhciBzZWxlY3Rpb24gPSBzZWxlY3Rpb25zWzBdO1xuICAgICAgICB2YXIgb3JpZ2luID0gc2VsZWN0aW9uLm9yaWdpbjtcbiAgICAgICAgdGhpcy5zZXREcmFnRXh0ZW50KHRoaXMubmV3UG9pbnQocmVhbFggLSBvcmlnaW4ueCwgcmVhbFkgLSBvcmlnaW4ueSkpO1xuICAgICAgICB0aGlzLnNlbGVjdChvcmlnaW4ueCwgb3JpZ2luLnksIHJlYWxYIC0gb3JpZ2luLngsIHJlYWxZIC0gb3JpZ2luLnkpO1xuICAgICAgICB0aGlzLnJlcGFpbnQoKTtcbiAgICB9LFxuXG4gICAgc2VsZWN0RmluYWxDZWxsT2ZDdXJyZW50Um93OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHggPSB0aGlzLmdldENvbHVtbkNvdW50KCkgLSAxO1xuICAgICAgICB2YXIgeSA9IHRoaXMuZ2V0U2VsZWN0ZWRSb3dzKClbMF07XG4gICAgICAgIHZhciBoZWFkZXJSb3dDb3VudCA9IHRoaXMuZ2V0SGVhZGVyUm93Q291bnQoKTtcbiAgICAgICAgdGhpcy5jbGVhclNlbGVjdGlvbnMoKTtcbiAgICAgICAgdGhpcy5zY3JvbGxCeSh0aGlzLmdldENvbHVtbkNvdW50KCksIDApO1xuICAgICAgICB0aGlzLnNlbGVjdCh4LCB5ICsgaGVhZGVyUm93Q291bnQsIDAsIDApO1xuICAgICAgICB0aGlzLnNldE1vdXNlRG93bih0aGlzLm5ld1BvaW50KHgsIHkgKyBoZWFkZXJSb3dDb3VudCkpO1xuICAgICAgICB0aGlzLnNldERyYWdFeHRlbnQodGhpcy5uZXdQb2ludCgwLCAwKSk7XG4gICAgICAgIHRoaXMucmVwYWludCgpO1xuICAgIH0sXG5cbiAgICBzZWxlY3RUb0ZpbmFsQ2VsbE9mQ3VycmVudFJvdzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzZWxlY3Rpb25zID0gdGhpcy5nZXRTZWxlY3Rpb25zKCk7XG4gICAgICAgIGlmICghc2VsZWN0aW9ucyB8fCBzZWxlY3Rpb25zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzZWxlY3Rpb24gPSBzZWxlY3Rpb25zWzBdO1xuICAgICAgICB2YXIgb3JpZ2luID0gc2VsZWN0aW9uLm9yaWdpbjtcbiAgICAgICAgdmFyIGV4dGVudCA9IHNlbGVjdGlvbi5leHRlbnQ7XG4gICAgICAgIHZhciBjb2x1bW5Db3VudCA9IHRoaXMuZ2V0Q29sdW1uQ291bnQoKTtcbiAgICAgICAgdGhpcy5zY3JvbGxCeShjb2x1bW5Db3VudCwgMCk7XG5cbiAgICAgICAgdGhpcy5jbGVhclNlbGVjdGlvbnMoKTtcbiAgICAgICAgdGhpcy5zZWxlY3Qob3JpZ2luLngsIG9yaWdpbi55LCBjb2x1bW5Db3VudCAtIG9yaWdpbi54IC0gMSwgZXh0ZW50LnkpO1xuXG4gICAgICAgIHRoaXMucmVwYWludCgpO1xuICAgIH0sXG5cbiAgICBzZWxlY3RGaXJzdENlbGxPZkN1cnJlbnRSb3c6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgeCA9IDA7XG4gICAgICAgIHZhciB5ID0gdGhpcy5nZXRTZWxlY3RlZFJvd3MoKVswXTtcbiAgICAgICAgdmFyIGhlYWRlclJvd0NvdW50ID0gdGhpcy5nZXRIZWFkZXJSb3dDb3VudCgpO1xuICAgICAgICB0aGlzLmNsZWFyU2VsZWN0aW9ucygpO1xuICAgICAgICB0aGlzLnNldEhTY3JvbGxWYWx1ZSgwKTtcbiAgICAgICAgdGhpcy5zZWxlY3QoeCwgeSArIGhlYWRlclJvd0NvdW50LCAwLCAwKTtcbiAgICAgICAgdGhpcy5zZXRNb3VzZURvd24odGhpcy5uZXdQb2ludCh4LCB5ICsgaGVhZGVyUm93Q291bnQpKTtcbiAgICAgICAgdGhpcy5zZXREcmFnRXh0ZW50KHRoaXMubmV3UG9pbnQoMCwgMCkpO1xuICAgICAgICB0aGlzLnJlcGFpbnQoKTtcbiAgICB9LFxuXG4gICAgc2VsZWN0VG9GaXJzdENlbGxPZkN1cnJlbnRSb3c6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2VsZWN0aW9ucyA9IHRoaXMuZ2V0U2VsZWN0aW9ucygpO1xuICAgICAgICBpZiAoIXNlbGVjdGlvbnMgfHwgc2VsZWN0aW9ucy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2VsZWN0aW9uID0gc2VsZWN0aW9uc1swXTtcbiAgICAgICAgdmFyIG9yaWdpbiA9IHNlbGVjdGlvbi5vcmlnaW47XG4gICAgICAgIHZhciBleHRlbnQgPSBzZWxlY3Rpb24uZXh0ZW50O1xuICAgICAgICB0aGlzLmNsZWFyU2VsZWN0aW9ucygpO1xuICAgICAgICB0aGlzLnNlbGVjdChvcmlnaW4ueCwgb3JpZ2luLnksIC1vcmlnaW4ueCwgZXh0ZW50LnkpO1xuICAgICAgICB0aGlzLnNldEhTY3JvbGxWYWx1ZSgwKTtcbiAgICAgICAgdGhpcy5yZXBhaW50KCk7XG4gICAgfSxcblxuICAgIHNlbGVjdEZpbmFsQ2VsbDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuc2VsZWN0Q2VsbCh0aGlzLmdldENvbHVtbkNvdW50KCkgLSAxLCB0aGlzLmdldFJvd0NvdW50KCkgLSAxKTtcbiAgICAgICAgdGhpcy5zY3JvbGxCeSh0aGlzLmdldENvbHVtbkNvdW50KCksIHRoaXMuZ2V0Um93Q291bnQoKSk7XG4gICAgICAgIHRoaXMucmVwYWludCgpO1xuICAgIH0sXG5cbiAgICBzZWxlY3RUb0ZpbmFsQ2VsbDogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIHNlbGVjdGlvbnMgPSB0aGlzLmdldFNlbGVjdGlvbnMoKTtcbiAgICAgICAgaWYgKCFzZWxlY3Rpb25zIHx8IHNlbGVjdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNlbGVjdGlvbiA9IHNlbGVjdGlvbnNbMF07XG4gICAgICAgIHZhciBvcmlnaW4gPSBzZWxlY3Rpb24ub3JpZ2luO1xuICAgICAgICB2YXIgY29sdW1uQ291bnQgPSB0aGlzLmdldENvbHVtbkNvdW50KCk7XG4gICAgICAgIHZhciByb3dDb3VudCA9IHRoaXMuZ2V0Um93Q291bnQoKTtcblxuICAgICAgICB0aGlzLmNsZWFyU2VsZWN0aW9ucygpO1xuICAgICAgICB0aGlzLnNlbGVjdChvcmlnaW4ueCwgb3JpZ2luLnksIGNvbHVtbkNvdW50IC0gb3JpZ2luLnggLSAxLCByb3dDb3VudCAtIG9yaWdpbi55IC0gMSk7XG4gICAgICAgIHRoaXMuc2Nyb2xsQnkoY29sdW1uQ291bnQsIHJvd0NvdW50KTtcbiAgICAgICAgdGhpcy5yZXBhaW50KCk7XG4gICAgfSxcblxuICAgIGlzU2hvd1Jvd051bWJlcnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXNvbHZlUHJvcGVydHkoJ3Nob3dSb3dOdW1iZXJzJyk7XG4gICAgfSxcbiAgICBpc0VkaXRhYmxlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzb2x2ZVByb3BlcnR5KCdlZGl0YWJsZScpID09PSB0cnVlO1xuICAgIH0sXG4gICAgaXNTaG93RmlsdGVyUm93OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzb2x2ZVByb3BlcnR5KCdzaG93RmlsdGVyUm93Jyk7XG4gICAgfSxcbiAgICBpc1Nob3dIZWFkZXJSb3c6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXNvbHZlUHJvcGVydHkoJ3Nob3dIZWFkZXJSb3cnKTtcbiAgICB9LFxuICAgIGdldEhlYWRlclJvd0NvdW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QmVoYXZpb3IoKS5nZXRIZWFkZXJSb3dDb3VudCgpO1xuICAgIH0sXG4gICAgaXNGaWx0ZXJSb3c6IGZ1bmN0aW9uKHkpIHtcbiAgICAgICAgcmV0dXJuIHkgPT09IHRoaXMuZ2V0RmlsdGVyUm93SW5kZXgoKTtcbiAgICB9LFxuICAgIGdldEZpbHRlclJvd0luZGV4OiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzU2hvd0ZpbHRlclJvdygpKSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaXNTaG93SGVhZGVyUm93KCkpIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHNldEdyb3VwczogZnVuY3Rpb24oYXJyYXlPZkNvbHVtbkluZGV4ZXMpIHtcbiAgICAgICAgdGhpcy5nZXRCZWhhdmlvcigpLnNldEdyb3VwcyhhcnJheU9mQ29sdW1uSW5kZXhlcyk7XG4gICAgfSxcbiAgICBmaWx0ZXJDbGlja2VkOiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICB0aGlzLmFjdGl2YXRlRWRpdG9yKGV2ZW50LmdyaWRDZWxsLngsIGV2ZW50LmdyaWRDZWxsLnkpO1xuICAgIH0sXG4gICAgaGFzSGllcmFyY2h5Q29sdW1uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QmVoYXZpb3IoKS5oYXNIaWVyYXJjaHlDb2x1bW4oKTtcbiAgICB9LFxuICAgIGlzSGllcmFyY2h5Q29sdW1uOiBmdW5jdGlvbih4KSB7XG4gICAgICAgIGlmICghdGhpcy5oYXNIaWVyYXJjaHlDb2x1bW4oKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB4ID09PSAwO1xuICAgIH0sXG4gICAgY2hlY2tTY3JvbGxiYXJWaXNpYmlsaXR5OiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gdmFyIGhvdmVyQ2xhc3NPdmVyID0gdGhpcy5yZXNvbHZlUHJvcGVydHkoJ3Njcm9sbGJhckhvdmVyT3ZlcicpO1xuICAgICAgICAvLyB2YXIgaG92ZXJDbGFzc09mZiA9IHRoaXMucmVzb2x2ZVByb3BlcnR5KCdzY3JvbGxiYXJIb3Zlck9mZicpO1xuXG4gICAgICAgIC8vIGlmIChob3ZlckNsYXNzT2ZmID09PSAndmlzaWJsZScpIHtcbiAgICAgICAgLy8gICAgIHRoaXMuc2JIU2Nyb2xsZXIuY2xhc3NMaXN0LnJlbW92ZShob3ZlckNsYXNzT3Zlcik7XG4gICAgICAgIC8vICAgICB0aGlzLnNiVlNjcm9sbGVyLmNsYXNzTGlzdC5yZW1vdmUoaG92ZXJDbGFzc09mZik7XG4gICAgICAgIC8vICAgICB0aGlzLnNiSFNjcm9sbGVyLmNsYXNzTGlzdC5hZGQoJ3Zpc2libGUnKTtcbiAgICAgICAgLy8gICAgIHRoaXMuc2JWU2Nyb2xsZXIuY2xhc3NMaXN0LmFkZCgndmlzaWJsZScpO1xuICAgICAgICAvLyB9XG4gICAgfSxcbiAgICBpc0NvbHVtbk9yUm93U2VsZWN0ZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRTZWxlY3Rpb25Nb2RlbCgpLmlzQ29sdW1uT3JSb3dTZWxlY3RlZCgpO1xuICAgIH0sXG4gICAgc2VsZWN0Q29sdW1uOiBmdW5jdGlvbih4MSwgeDIpIHtcbiAgICAgICAgdGhpcy5nZXRTZWxlY3Rpb25Nb2RlbCgpLnNlbGVjdENvbHVtbih4MSwgeDIpO1xuICAgIH0sXG4gICAgc2VsZWN0Um93OiBmdW5jdGlvbih5MSwgeTIpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNTaW5nbGVSb3dTZWxlY3Rpb25Nb2RlKCkpIHtcbiAgICAgICAgICAgIHRoaXMuZ2V0U2VsZWN0aW9uTW9kZWwoKS5jbGVhclJvd1NlbGVjdGlvbigpO1xuICAgICAgICAgICAgeTEgPSB5MjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHkyID0geTIgfHwgeTE7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1pbiA9IE1hdGgubWluKHkxLCB5Mik7XG4gICAgICAgIHZhciBtYXggPSBNYXRoLm1heCh5MSwgeTIpO1xuICAgICAgICB2YXIgc2VsZWN0aW9uRWRnZSA9IHRoaXMuZ2V0RmlsdGVyUm93SW5kZXgoKSArIDE7XG4gICAgICAgIGlmIChtaW4gPCBzZWxlY3Rpb25FZGdlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5nZXRTZWxlY3Rpb25Nb2RlbCgpLnNlbGVjdFJvdyhtaW4sIG1heCk7XG4gICAgfSxcbiAgICBpc1Jvd1NlbGVjdGVkOiBmdW5jdGlvbihyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFNlbGVjdGlvbk1vZGVsKCkuaXNSb3dTZWxlY3RlZChyKTtcbiAgICB9LFxuICAgIGlzQ29sdW1uU2VsZWN0ZWQ6IGZ1bmN0aW9uKGMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U2VsZWN0aW9uTW9kZWwoKS5pc0NvbHVtblNlbGVjdGVkKGMpO1xuICAgIH0sXG4gICAgbG9va3VwRmVhdHVyZTogZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEJlaGF2aW9yKCkubG9va3VwRmVhdHVyZShrZXkpO1xuICAgIH0sXG4gICAgZ2V0Um93OiBmdW5jdGlvbih5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEJlaGF2aW9yKCkuZ2V0Um93KHkpO1xuICAgIH0sXG4gICAgZ2V0RmllbGROYW1lOiBmdW5jdGlvbihpbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRCZWhhdmlvcigpLmdldEZpZWxkTmFtZShpbmRleCk7XG4gICAgfSxcblxuICAgIGdldENvbHVtbkluZGV4OiBmdW5jdGlvbihmaWVsZE5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QmVoYXZpb3IoKS5nZXRDb2x1bW5JbmRleChmaWVsZE5hbWUpO1xuICAgIH0sXG4gICAgaXNDZWxsU2VsZWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzb2x2ZVByb3BlcnR5KCdjZWxsU2VsZWN0aW9uJykgPT09IHRydWU7XG4gICAgfSxcbiAgICBpc1Jvd1NlbGVjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlc29sdmVQcm9wZXJ0eSgncm93U2VsZWN0aW9uJykgPT09IHRydWU7XG4gICAgfSxcbiAgICBpc0NvbHVtblNlbGVjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJlc29sdmVQcm9wZXJ0eSgnY29sdW1uU2VsZWN0aW9uJykgPT09IHRydWU7XG4gICAgfSxcbiAgICBnZXRDb21wdXRlZFJvdzogZnVuY3Rpb24oeSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRCZWhhdmlvcigpLmdldENvbXB1dGVkUm93KHkpO1xuICAgIH0sXG4gICAgaXNDb2x1bW5BdXRvc2l6aW5nOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzb2x2ZVByb3BlcnR5KCdjb2x1bW5BdXRvc2l6aW5nJykgPT09IHRydWU7XG4gICAgfSxcbiAgICBzZXRHbG9iYWxGaWx0ZXI6IGZ1bmN0aW9uKHN0cmluZykge1xuICAgICAgICB0aGlzLmdldEJlaGF2aW9yKCkuc2V0R2xvYmFsRmlsdGVyKHN0cmluZyk7XG4gICAgfSxcbiAgICBzZWxlY3RSb3dzRnJvbUNlbGxzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNtID0gdGhpcy5nZXRTZWxlY3Rpb25Nb2RlbCgpO1xuICAgICAgICBpZiAodGhpcy5pc1NpbmdsZVJvd1NlbGVjdGlvbk1vZGUoKSkge1xuICAgICAgICAgICAgdmFyIGxhc3QgPSBzbS5nZXRMYXN0U2VsZWN0aW9uKCk7XG4gICAgICAgICAgICBpZiAoIWxhc3QpIHtcbiAgICAgICAgICAgICAgICBzbS5jbGVhclJvd1NlbGVjdGlvbigpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdFJvdyhudWxsLCBsYXN0LmNvcm5lci55KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNtLnNlbGVjdFJvd3NGcm9tQ2VsbHMoKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgc2VsZWN0Q29sdW1uc0Zyb21DZWxsczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuZ2V0U2VsZWN0aW9uTW9kZWwoKS5zZWxlY3RDb2x1bW5zRnJvbUNlbGxzKCk7XG4gICAgfSxcbiAgICBnZXRTZWxlY3RlZFJvd3M6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRCZWhhdmlvcigpLmdldFNlbGVjdGVkUm93cygpO1xuICAgIH0sXG4gICAgZ2V0U2VsZWN0ZWRDb2x1bW5zOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QmVoYXZpb3IoKS5nZXRTZWxlY3RlZENvbHVtbnMoKTtcbiAgICB9LFxuICAgIGdldFNlbGVjdGlvbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRCZWhhdmlvcigpLmdldFNlbGVjdGlvbnMoKTtcbiAgICB9LFxuICAgIGdldExhc3RTZWxlY3Rpb25UeXBlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U2VsZWN0aW9uTW9kZWwoKS5nZXRMYXN0U2VsZWN0aW9uVHlwZSgpO1xuICAgIH0sXG4gICAgaXNDZWxsU2VsZWN0ZWQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U2VsZWN0aW9uTW9kZWwoKS5pc0NlbGxTZWxlY3RlZCh4LCB5KTtcbiAgICB9LFxuICAgIGlzSW5DdXJyZW50U2VsZWN0aW9uUmVjdGFuZ2xlOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFNlbGVjdGlvbk1vZGVsKCkuaXNJbkN1cnJlbnRTZWxlY3Rpb25SZWN0YW5nbGUoeCwgeSk7XG4gICAgfSxcbiAgICBzZWxlY3RBbGxSb3dzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5nZXRTZWxlY3Rpb25Nb2RlbCgpLnNlbGVjdEFsbFJvd3MoKTtcbiAgICB9LFxuICAgIGFyZUFsbFJvd3NTZWxlY3RlZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldFNlbGVjdGlvbk1vZGVsKCkuYXJlQWxsUm93c1NlbGVjdGVkKCk7XG4gICAgfSxcbiAgICB0b2dnbGVTZWxlY3RBbGxSb3dzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuYXJlQWxsUm93c1NlbGVjdGVkKCkpIHtcbiAgICAgICAgICAgIHRoaXMuZ2V0U2VsZWN0aW9uTW9kZWwoKS5jbGVhcigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zZWxlY3RBbGxSb3dzKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZXBhaW50KCk7XG4gICAgfSxcbiAgICBnZXRGaWVsZDogZnVuY3Rpb24oeCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRCZWhhdmlvcigpLmdldEZpZWxkKHgpO1xuICAgIH0sXG4gICAgaXNTaW5nbGVSb3dTZWxlY3Rpb25Nb2RlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzb2x2ZVByb3BlcnR5KCdzaW5nbGVSb3dTZWxlY3Rpb25Nb2RlJyk7XG4gICAgfSxcbiAgICBuZXdQb2ludDogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICByZXR1cm4gbmV3IFBvaW50KHgsIHkpO1xuICAgIH0sXG4gICAgbmV3UmVjdGFuZ2xlOiBmdW5jdGlvbih4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVjdGFuZ2xlKHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgIH1cbn07XG5cbmZ1bmN0aW9uIGdldFRleHRXaWR0aChnYywgc3RyaW5nKSB7XG4gICAgaWYgKHN0cmluZyA9PT0gbnVsbCB8fCBzdHJpbmcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgc3RyaW5nID0gc3RyaW5nICsgJyc7XG4gICAgaWYgKHN0cmluZy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIHZhciBrZXkgPSBnYy5mb250ICsgc3RyaW5nO1xuICAgIHZhciB3aWR0aCA9IHRleHRXaWR0aENhY2hlLmdldChrZXkpO1xuICAgIGlmICghd2lkdGgpIHtcbiAgICAgICAgd2lkdGggPSBnYy5tZWFzdXJlVGV4dChzdHJpbmcpLndpZHRoO1xuICAgICAgICB0ZXh0V2lkdGhDYWNoZS5zZXQoa2V5LCB3aWR0aCk7XG4gICAgfVxuICAgIHJldHVybiB3aWR0aDtcbn1cblxuZnVuY3Rpb24gZ2V0VGV4dEhlaWdodChmb250KSB7XG5cbiAgICB2YXIgcmVzdWx0ID0gZ2V0VGV4dEhlaWdodC5mb250RGF0YVtmb250XTtcbiAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHJlc3VsdCA9IHt9O1xuICAgIHZhciB0ZXh0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3BhbicpO1xuICAgIHRleHQudGV4dENvbnRlbnQgPSAnSGcnO1xuICAgIHRleHQuc3R5bGUuZm9udCA9IGZvbnQ7XG5cbiAgICB2YXIgYmxvY2sgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBibG9jay5zdHlsZS5kaXNwbGF5ID0gJ2lubGluZS1ibG9jayc7XG4gICAgYmxvY2suc3R5bGUud2lkdGggPSAnMXB4JztcbiAgICBibG9jay5zdHlsZS5oZWlnaHQgPSAnMHB4JztcblxuICAgIHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBkaXYuYXBwZW5kQ2hpbGQodGV4dCk7XG4gICAgZGl2LmFwcGVuZENoaWxkKGJsb2NrKTtcblxuICAgIGRpdi5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChkaXYpO1xuXG4gICAgdHJ5IHtcblxuICAgICAgICBibG9jay5zdHlsZS52ZXJ0aWNhbEFsaWduID0gJ2Jhc2VsaW5lJztcblxuICAgICAgICB2YXIgYmxvY2tSZWN0ID0gYmxvY2suZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHZhciB0ZXh0UmVjdCA9IHRleHQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICAgICAgcmVzdWx0LmFzY2VudCA9IGJsb2NrUmVjdC50b3AgLSB0ZXh0UmVjdC50b3A7XG5cbiAgICAgICAgYmxvY2suc3R5bGUudmVydGljYWxBbGlnbiA9ICdib3R0b20nO1xuICAgICAgICByZXN1bHQuaGVpZ2h0ID0gYmxvY2tSZWN0LnRvcCAtIHRleHRSZWN0LnRvcDtcblxuICAgICAgICByZXN1bHQuZGVzY2VudCA9IHJlc3VsdC5oZWlnaHQgLSByZXN1bHQuYXNjZW50O1xuXG4gICAgfSBmaW5hbGx5IHtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChkaXYpO1xuICAgIH1cbiAgICBpZiAocmVzdWx0LmhlaWdodCAhPT0gMCkge1xuICAgICAgICBnZXRUZXh0SGVpZ2h0LmZvbnREYXRhW2ZvbnRdID0gcmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZ2V0VGV4dEhlaWdodC5mb250RGF0YSA9IHt9O1xuXG5mdW5jdGlvbiBkZWZhdWx0UHJvcGVydGllcygpIHtcbiAgICB2YXIgcHJvcGVydGllcyA9IHtcbiAgICAgICAgLy90aGVzZSBhcmUgZm9yIHRoZSB0aGVtZVxuICAgICAgICBmb250OiAnMTNweCBUYWhvbWEsIEdlbmV2YSwgc2Fucy1zZXJpZicsXG4gICAgICAgIGNvbG9yOiAncmdiKDI1LCAyNSwgMjUpJyxcbiAgICAgICAgYmFja2dyb3VuZENvbG9yOiAncmdiKDI0MSwgMjQxLCAyNDEpJyxcbiAgICAgICAgZm9yZWdyb3VuZFNlbGVjdGlvbkNvbG9yOiAncmdiKDI1LCAyNSwgMjUpJyxcbiAgICAgICAgYmFja2dyb3VuZFNlbGVjdGlvbkNvbG9yOiAncmdiKDE4MywgMjE5LCAyNTUpJyxcblxuICAgICAgICBjb2x1bW5IZWFkZXJGb250OiAnMTJweCBUYWhvbWEsIEdlbmV2YSwgc2Fucy1zZXJpZicsXG4gICAgICAgIGNvbHVtbkhlYWRlckNvbG9yOiAncmdiKDI1LCAyNSwgMjUpJyxcbiAgICAgICAgY29sdW1uSGVhZGVyQmFja2dyb3VuZENvbG9yOiAncmdiKDIyMywgMjI3LCAyMzIpJyxcbiAgICAgICAgY29sdW1uSGVhZGVyRm9yZWdyb3VuZFNlbGVjdGlvbkNvbG9yOiAncmdiKDI1LCAyNSwgMjUpJyxcbiAgICAgICAgY29sdW1uSGVhZGVyQmFja2dyb3VuZFNlbGVjdGlvbkNvbG9yOiAncmdiKDI1NSwgMjIwLCA5NyknLFxuICAgICAgICBjb2x1bW5IZWFkZXJGb3JlZ3JvdW5kQ29sdW1uU2VsZWN0aW9uQ29sb3I6ICdyZ2IoMjUsIDI1LCAyNSknLFxuICAgICAgICBjb2x1bW5IZWFkZXJCYWNrZ3JvdW5kQ29sdW1uU2VsZWN0aW9uQ29sb3I6ICdyZ2IoMjU1LCAxODAsIDApJyxcblxuICAgICAgICByb3dIZWFkZXJGb250OiAnMTJweCBUYWhvbWEsIEdlbmV2YSwgc2Fucy1zZXJpZicsXG4gICAgICAgIHJvd0hlYWRlckNvbG9yOiAncmdiKDI1LCAyNSwgMjUpJyxcbiAgICAgICAgcm93SGVhZGVyQmFja2dyb3VuZENvbG9yOiAncmdiKDIyMywgMjI3LCAyMzIpJyxcbiAgICAgICAgcm93SGVhZGVyRm9yZWdyb3VuZFNlbGVjdGlvbkNvbG9yOiAncmdiKDI1LCAyNSwgMjUpJyxcbiAgICAgICAgcm93SGVhZGVyQmFja2dyb3VuZFNlbGVjdGlvbkNvbG9yOiAncmdiKDI1NSwgMjIwLCA5NyknLFxuICAgICAgICByb3dIZWFkZXJGb3JlZ3JvdW5kUm93U2VsZWN0aW9uQ29sb3I6ICdyZ2IoMjUsIDI1LCAyNSknLFxuICAgICAgICByb3dIZWFkZXJCYWNrZ3JvdW5kUm93U2VsZWN0aW9uQ29sb3I6ICdyZ2IoMjU1LCAxODAsIDApJyxcblxuICAgICAgICBmaWx0ZXJGb250OiAnMTJweCBUYWhvbWEsIEdlbmV2YSwgc2Fucy1zZXJpZicsXG4gICAgICAgIGZpbHRlckNvbG9yOiAncmdiKDI1LCAyNSwgMjUpJyxcbiAgICAgICAgZmlsdGVyQmFja2dyb3VuZENvbG9yOiAnd2hpdGUnLFxuICAgICAgICBmaWx0ZXJGb3JlZ3JvdW5kU2VsZWN0aW9uQ29sb3I6ICdyZ2IoMjUsIDI1LCAyNSknLFxuICAgICAgICBmaWx0ZXJCYWNrZ3JvdW5kU2VsZWN0aW9uQ29sb3I6ICdyZ2IoMjU1LCAyMjAsIDk3KScsXG4gICAgICAgIGZpbHRlckNlbGxCb3JkZXJTdHlsZTogJ3JnYmEoMCwwLDAsMC44KScsXG4gICAgICAgIGZpbHRlckNlbGxCb3JkZXJUaGlja25lc3M6ICcwLjQnLFxuXG4gICAgICAgIHRyZWVDb2x1bW5Gb250OiAnMTJweCBUYWhvbWEsIEdlbmV2YSwgc2Fucy1zZXJpZicsXG4gICAgICAgIHRyZWVDb2x1bW5Db2xvcjogJ3JnYigyNSwgMjUsIDI1KScsXG4gICAgICAgIHRyZWVDb2x1bW5CYWNrZ3JvdW5kQ29sb3I6ICdyZ2IoMjIzLCAyMjcsIDIzMiknLFxuICAgICAgICB0cmVlQ29sdW1uRm9yZWdyb3VuZFNlbGVjdGlvbkNvbG9yOiAncmdiKDI1LCAyNSwgMjUpJyxcbiAgICAgICAgdHJlZUNvbHVtbkJhY2tncm91bmRTZWxlY3Rpb25Db2xvcjogJ3JnYigyNTUsIDIyMCwgOTcpJyxcbiAgICAgICAgdHJlZUNvbHVtbkZvcmVncm91bmRDb2x1bW5TZWxlY3Rpb25Db2xvcjogJ3JnYigyNSwgMjUsIDI1KScsXG4gICAgICAgIHRyZWVDb2x1bW5CYWNrZ3JvdW5kQ29sdW1uU2VsZWN0aW9uQ29sb3I6ICdyZ2IoMjU1LCAxODAsIDApJyxcblxuICAgICAgICBiYWNrZ3JvdW5kQ29sb3IyOiAncmdiKDIwMSwgMjAxLCAyMDEpJyxcbiAgICAgICAgdm9mZnNldDogMCxcbiAgICAgICAgc2Nyb2xsYmFySG92ZXJPdmVyOiAndmlzaWJsZScsXG4gICAgICAgIHNjcm9sbGJhckhvdmVyT2ZmOiAnaGlkZGVuJyxcbiAgICAgICAgc2Nyb2xsaW5nRW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgdlNjcm9sbGJhckNsYXNzUHJlZml4OiAnJyxcbiAgICAgICAgaFNjcm9sbGJhckNsYXNzUHJlZml4OiAnJyxcblxuICAgICAgICAvL3RoZXNlIHVzZWQgdG8gYmUgaW4gdGhlIGNvbnN0YW50cyBlbGVtZW50XG4gICAgICAgIGZpeGVkUm93QWxpZ246ICdjZW50ZXInLFxuICAgICAgICBmaXhlZENvbEFsaWduOiAnY2VudGVyJyxcbiAgICAgICAgY2VsbFBhZGRpbmc6IDUsXG4gICAgICAgIGdyaWRMaW5lc0g6IHRydWUsXG4gICAgICAgIGdyaWRMaW5lc1Y6IHRydWUsXG4gICAgICAgIGxpbmVDb2xvcjogJ3JnYigxOTksIDE5OSwgMTk5KScsXG4gICAgICAgIGxpbmVXaWR0aDogMC40LFxuXG4gICAgICAgIGRlZmF1bHRSb3dIZWlnaHQ6IDE1LFxuICAgICAgICBkZWZhdWx0Q29sdW1uV2lkdGg6IDEwMCxcblxuICAgICAgICAvL2ZvciBpbW1lZGlhdGUgcGFpbnRpbmcsIHNldCB0aGVzZSB2YWx1ZXMgdG8gMCwgdHJ1ZSByZXNwZWN0aXZlbHlcbiAgICAgICAgcmVwYWludEludGVydmFsUmF0ZTogNjAsXG4gICAgICAgIHJlcGFpbnRJbW1lZGlhdGVseTogZmFsc2UsXG5cbiAgICAgICAgLy9lbmFibGUgb3IgZGlzYWJsZSBkb3VibGUgYnVmZmVyaW5nXG4gICAgICAgIHVzZUJpdEJsaXQ6IGZhbHNlLFxuXG4gICAgICAgIHVzZUhpRFBJOiB0cnVlLFxuICAgICAgICBlZGl0b3JBY3RpdmF0aW9uS2V5czogWydhbHQnLCAnZXNjJ10sXG4gICAgICAgIHJlYWRPbmx5OiBmYWxzZSxcblxuICAgICAgICAvL2luaGVydGllZCBieSBjZWxsIHJlbmRlcmVyc1xuICAgICAgICBnZXRUZXh0V2lkdGg6IGdldFRleHRXaWR0aCxcbiAgICAgICAgZ2V0VGV4dEhlaWdodDogZ2V0VGV4dEhlaWdodCxcblxuICAgICAgICBmaXhlZENvbHVtbkNvdW50OiAwLFxuICAgICAgICBmaXhlZFJvd0NvdW50OiAwLFxuICAgICAgICBoZWFkZXJDb2x1bW5Db3VudDogMCxcblxuICAgICAgICBzaG93Um93TnVtYmVyczogdHJ1ZSxcbiAgICAgICAgc2hvd0hlYWRlclJvdzogdHJ1ZSxcbiAgICAgICAgc2hvd0ZpbHRlclJvdzogdHJ1ZSxcblxuICAgICAgICBjZWxsU2VsZWN0aW9uOiB0cnVlLFxuICAgICAgICBjb2x1bW5TZWxlY3Rpb246IHRydWUsXG4gICAgICAgIHJvd1NlbGVjdGlvbjogdHJ1ZSxcbiAgICAgICAgc2luZ2xlUm93U2VsZWN0aW9uTW9kZTogdHJ1ZSxcblxuICAgICAgICBjb2x1bW5BdXRvc2l6aW5nOiB0cnVlLFxuICAgICAgICBoZWFkZXJUZXh0V3JhcHBpbmc6IGZhbHNlLFxuICAgICAgICByb3dSZXNpemU6IGZhbHNlXG5cbiAgICB9O1xuICAgIHJldHVybiBwcm9wZXJ0aWVzO1xufVxuXG5mdW5jdGlvbiBub3JtYWxpemVSZWN0KHJlY3QpIHtcbiAgICB2YXIgbyA9IHJlY3Qub3JpZ2luO1xuICAgIHZhciBjID0gcmVjdC5jb3JuZXI7XG5cbiAgICB2YXIgb3ggPSBNYXRoLm1pbihvLngsIGMueCk7XG4gICAgdmFyIG95ID0gTWF0aC5taW4oby55LCBjLnkpO1xuXG4gICAgdmFyIGN4ID0gTWF0aC5tYXgoby54LCBjLngpO1xuICAgIHZhciBjeSA9IE1hdGgubWF4KG8ueSwgYy55KTtcblxuICAgIHZhciByZXN1bHQgPSBuZXcgUmVjdGFuZ2xlKG94LCBveSwgY3ggLSBveCwgY3kgLSBveSk7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiBidWlsZFBvbHltZXJUaGVtZSgpIHtcbiAgICBjbGVhck9iamVjdFByb3BlcnRpZXMocG9seW1lclRoZW1lKTtcbiAgICB2YXIgcGIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdwYXBlci1idXR0b24nKTtcblxuICAgIHBiLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgcGIuc2V0QXR0cmlidXRlKCdkaXNhYmxlZCcsIHRydWUpO1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQocGIpO1xuICAgIHZhciBwID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUocGIpO1xuXG4gICAgdmFyIHNlY3Rpb24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzZWN0aW9uJyk7XG4gICAgc2VjdGlvbi5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIHNlY3Rpb24uc2V0QXR0cmlidXRlKCdoZXJvJywgdHJ1ZSk7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChzZWN0aW9uKTtcblxuICAgIHZhciBoID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZG9jdW1lbnQucXVlcnlTZWxlY3RvcignaHRtbCcpKTtcbiAgICB2YXIgaGIgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdodG1sLCBib2R5JykpO1xuICAgIHZhciBzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoc2VjdGlvbik7XG5cbiAgICBwb2x5bWVyVGhlbWUuY29sdW1uSGVhZGVyQmFja2dyb3VuZENvbG9yID0gcC5jb2xvcjtcbiAgICBwb2x5bWVyVGhlbWUucm93SGVhZGVyQmFja2dyb3VuZENvbG9yID0gcC5jb2xvcjtcbiAgICBwb2x5bWVyVGhlbWUudG9wTGVmdEJhY2tncm91bmRDb2xvciA9IHAuY29sb3I7XG4gICAgcG9seW1lclRoZW1lLmxpbmVDb2xvciA9IHAuYmFja2dyb3VuZENvbG9yO1xuXG4gICAgcG9seW1lclRoZW1lLmJhY2tncm91bmRDb2xvcjIgPSBoYi5iYWNrZ3JvdW5kQ29sb3I7XG5cbiAgICBwb2x5bWVyVGhlbWUuY29sb3IgPSBoLmNvbG9yO1xuICAgIHBvbHltZXJUaGVtZS5mb250RmFtaWx5ID0gaC5mb250RmFtaWx5O1xuICAgIHBvbHltZXJUaGVtZS5iYWNrZ3JvdW5kQ29sb3IgPSBzLmJhY2tncm91bmRDb2xvcjtcblxuICAgIHBiLnNldEF0dHJpYnV0ZSgnZGlzYWJsZWQnLCBmYWxzZSk7XG4gICAgcGIuc2V0QXR0cmlidXRlKCdzZWNvbmRhcnknLCB0cnVlKTtcbiAgICBwYi5zZXRBdHRyaWJ1dGUoJ3JhaXNlZCcsIHRydWUpO1xuICAgIHAgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShwYik7XG5cbiAgICBwb2x5bWVyVGhlbWUuY29sdW1uSGVhZGVyQ29sb3IgPSBwLmNvbG9yO1xuICAgIHBvbHltZXJUaGVtZS5yb3dIZWFkZXJDb2xvciA9IHAuY29sb3I7XG4gICAgcG9seW1lclRoZW1lLnRvcExlZnRDb2xvciA9IHAuY29sb3I7XG5cblxuICAgIHBvbHltZXJUaGVtZS5iYWNrZ3JvdW5kU2VsZWN0aW9uQ29sb3IgPSBwLmJhY2tncm91bmRDb2xvcjtcbiAgICBwb2x5bWVyVGhlbWUuZm9yZWdyb3VuZFNlbGVjdGlvbkNvbG9yID0gcC5jb2xvcjtcblxuICAgIHBiLnNldEF0dHJpYnV0ZSgnc2Vjb25kYXJ5JywgZmFsc2UpO1xuICAgIHBiLnNldEF0dHJpYnV0ZSgnd2FybmluZycsIHRydWUpO1xuXG4gICAgcG9seW1lclRoZW1lLmNvbHVtbkhlYWRlckZvcmVncm91bmRTZWxlY3Rpb25Db2xvciA9IHAuY29sb3I7XG4gICAgcG9seW1lclRoZW1lLmNvbHVtbkhlYWRlckJhY2tncm91bmRTZWxlY3Rpb25Db2xvciA9IHAuYmFja2dyb3VuZENvbG9yO1xuICAgIHBvbHltZXJUaGVtZS5yb3dIZWFkZXJGb3JlZ3JvdW5kU2VsZWN0aW9uQ29sb3IgPSBwLmNvbG9yO1xuICAgIHBvbHltZXJUaGVtZS5maXhlZENvbHVtbkJhY2tncm91bmRTZWxlY3Rpb25Db2xvciA9IHAuYmFja2dyb3VuZENvbG9yO1xuXG4gICAgLy9jaGVjayBpZiB0aGVyZSBpcyBhY3R1YWxseSBhIHRoZW1lIGxvYWRlZCBpZiBub3QsIGNsZWFyIG91dCBhbGwgYm9ndXMgdmFsdWVzXG4gICAgLy9mcm9tIG15IGNhY2hlXG4gICAgaWYgKHBvbHltZXJUaGVtZS5jb2x1bW5IZWFkZXJCYWNrZ3JvdW5kU2VsZWN0aW9uQ29sb3IgPT09ICdyZ2JhKDAsIDAsIDAsIDApJyB8fFxuICAgICAgICBwb2x5bWVyVGhlbWUubGluZUNvbG9yID09PSAndHJhbnNwYXJlbnQnKSB7XG4gICAgICAgIGNsZWFyT2JqZWN0UHJvcGVydGllcyhwb2x5bWVyVGhlbWUpO1xuICAgIH1cblxuICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQocGIpO1xuICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlQ2hpbGQoc2VjdGlvbik7XG59XG5cbmZ1bmN0aW9uIGNsZWFyT2JqZWN0UHJvcGVydGllcyhvYmopIHtcbiAgICBmb3IgKHZhciBwcm9wIGluIG9iaikge1xuICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KHByb3ApKSB7XG4gICAgICAgICAgICBkZWxldGUgb2JqW3Byb3BdO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5mdW5jdGlvbiB2YWx1ZU9yRnVuY3Rpb25FeGVjdXRlKHZhbHVlT3JGdW5jdGlvbikge1xuICAgIHZhciByZXN1bHQgPSB0eXBlb2YgdmFsdWVPckZ1bmN0aW9uID09PSAnZnVuY3Rpb24nID8gdmFsdWVPckZ1bmN0aW9uKCkgOiB2YWx1ZU9yRnVuY3Rpb247XG4gICAgcmV0dXJuIHJlc3VsdCB8fCByZXN1bHQgPT09IDAgPyByZXN1bHQgOiAnJztcbn1cblxuZnVuY3Rpb24gaW5zdGFsbFBvbHlmaWxscygpIHtcbiAgICBpZiAoIUFycmF5LnByb3RvdHlwZS5maW5kKSB7XG4gICAgICAgIEFycmF5LnByb3RvdHlwZS5maW5kID0gZnVuY3Rpb24ocHJlZGljYXRlKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZXh0ZW5kLW5hdGl2ZVxuICAgICAgICAgICAgaWYgKHRoaXMgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcnJheS5wcm90b3R5cGUuZmluZCBjYWxsZWQgb24gbnVsbCBvciB1bmRlZmluZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgcHJlZGljYXRlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncHJlZGljYXRlIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGxpc3QgPSBPYmplY3QodGhpcyk7XG4gICAgICAgICAgICB2YXIgbGVuZ3RoID0gbGlzdC5sZW5ndGggPj4+IDA7XG4gICAgICAgICAgICB2YXIgdGhpc0FyZyA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgICAgIHZhciB2YWx1ZTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gbGlzdFtpXTtcbiAgICAgICAgICAgICAgICBpZiAocHJlZGljYXRlLmNhbGwodGhpc0FyZywgdmFsdWUsIGksIGxpc3QpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9O1xuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBIeXBlcmdyaWQ7XG4iLCIvKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cbi8qIGdsb2JhbCByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgXyA9IHJlcXVpcmUoJ29iamVjdC1pdGVyYXRvcnMnKTtcbnZhciBCYXNlID0gcmVxdWlyZSgnZXh0ZW5kLW1lJykuQmFzZTtcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBkZXNjIGZpbi1oeXBlcmdyaWQtcmVuZGVyZXIgaXMgdGhlIGNhbnZhcyBlbmFibGVkIHRvcCBsZXZlbCBzdWIgY29tcG9uZW50IHRoYXQgaGFuZGxlcyB0aGUgcmVuZGVyZXJpbmcgb2YgdGhlIEdyaWQuXG4gKlxuICogSXQgcmVsaWVzIG9uIHR3byBvdGhlciBleHRlcm5hbCBzdWJwcm9qZWN0c1xuICpcbiAqIDEuIGZpbi1jYW52YXM6IGEgd3JhcHBlciB0byBwcm92aWRlIGEgc2ltcGxlciBpbnRlcmZhY2UgdG8gdGhlIEhUTUw1IGNhbnZhcyBjb21wb25lbnRcbiAqIDIuIHJlY3Rhbmd1bGFyOiBhIHNtYWxsIG5wbSBtb2R1bGUgcHJvdmlkaW5nIFBvaW50IGFuZCBSZWN0YW5nbGUgb2JqZWN0c1xuICpcbiAqIFRoZSBmaW4taHlwZXJncmlkLXJlbmRlcmVyIGlzIGluIGEgdW5pcXVlIHBvc2l0aW9uIHRvIHByb3ZpZGUgY3JpdGljYWwgZnVuY3Rpb25hbGl0eSB0byB0aGUgZmluLWh5cGVyZ3JpZCBpbiBhIGhpZ2h0bHkgcGVyZm9ybWFudCBtYW5uZXIuXG4gKiBCZWNhdXNlIGl0IE1VU1QgaXRlcmF0ZSBvdmVyIGFsbCB0aGUgdmlzaWJsZSBjZWxscyBpdCBjYW4gc3RvcmUgdmFyaW91cyBiaXRzIG9mIGluZm9ybWF0aW9uIHRoYXQgY2FuIGJlIGVuY2Fwc3VsYXRlZCBhcyBhIHNlcnZpY2UgZm9yIGNvbnN1bXB0aW9uIGJ5IHRoZSBmaW4taHlwZXJncmlkIGNvbXBvbmVudC5cbiAqXG4gKiBJbnN0YW5jZXMgb2YgdGhpcyBvYmplY3QgaGF2ZSBiYXNpY2FsbHkgZm91ciBtYWluIGZ1bmN0aW9ucy5cbiAqXG4gKiAxLiByZW5kZXIgZml4ZWQgcm93IGhlYWRlcnNcbiAqIDIuIHJlbmRlciBmaXhlZCBjb2wgaGVhZGVyc1xuICogMy4gcmVuZGVyIG1haW4gZGF0YSBjZWxsc1xuICogNC4gcmVuZGVyIGdyaWQgbGluZXNcbiAqXG4gKiBTYW1lIHBhcmFtZXRlcnMgYXMge0BsaW5rIFJlbmRlcmVyI2luaXRpYWxpemV8aW5pdGlhbGl6ZX0sIHdoaWNoIGlzIGNhbGxlZCBieSB0aGlzIGNvbnN0cnVjdG9yLlxuICpcbiAqL1xudmFyIFJlbmRlcmVyID0gQmFzZS5leHRlbmQoJ1JlbmRlcmVyJywge1xuXG4gICAgLy90aGUgc2hhcmVkIHNpbmdsZSBpdGVtIFwicG9vbGVkXCIgY2VsbCBvYmplY3QgZm9yIGRyYXdpbmcgZWFjaCBjZWxsXG4gICAgY2VsbDoge1xuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAwLFxuICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgaGVpZ2h0OiAwXG4gICAgfSxcblxuICAgIHNjcm9sbEhlaWdodDogMCxcblxuICAgIHZpZXdIZWlnaHQ6IDAsXG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBDb25zdHJ1Y3RvciBsb2dpY1xuICAgICAqIEBkZXNjIFRoaXMgbWV0aG9kIHdpbGwgYmUgY2FsbGVkIHVwb24gaW5zdGFudGlhdGlvbiBvZiB0aGlzIGNsYXNzIG9yIG9mIGFueSBjbGFzcyB0aGF0IGV4dGVuZHMgZnJvbSB0aGlzIGNsYXNzLlxuICAgICAqID4gQWxsIGBpbml0aWFsaXplKClgIG1ldGhvZHMgaW4gdGhlIGluaGVyaXRhbmNlIGNoYWluIGFyZSBjYWxsZWQsIGluIHR1cm4sIGVhY2ggd2l0aCB0aGUgc2FtZSBwYXJhbWV0ZXJzIHRoYXQgd2VyZSBwYXNzZWQgdG8gdGhlIGNvbnN0cnVjdG9yLCBiZWdpbm5pbmcgd2l0aCB0aGF0IG9mIHRoZSBtb3N0IFwic2VuaW9yXCIgY2xhc3MgdGhyb3VnaCB0aGF0IG9mIHRoZSBjbGFzcyBvZiB0aGUgbmV3IGluc3RhbmNlLlxuICAgICAqIEBtZW1iZXJPZiBSZW5kZXJlci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihncmlkKSB7XG4gICAgICAgIHRoaXMuZ3JpZCA9IGdyaWQ7XG4gICAgICAgIHRoaXMuYm91bmRzID0ge1xuICAgICAgICAgICAgd2lkdGg6MCxcbiAgICAgICAgICAgIGhlaWdodDowXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuY29sdW1uRWRnZXMgPSBbXTtcbiAgICAgICAgdGhpcy5jb2x1bW5FZGdlc0luZGV4TWFwID0ge307XG4gICAgICAgIHRoaXMucmVuZGVyZWRDb2x1bW5NaW5XaWR0aHMgPSBbXTtcbiAgICAgICAgdGhpcy5yZW5kZXJlZEhlaWdodCA9IDA7XG4gICAgICAgIHRoaXMucm93RWRnZXMgPSBbXTtcbiAgICAgICAgdGhpcy5yb3dFZGdlc0luZGV4TWFwID0ge307XG4gICAgICAgIHRoaXMudmlzaWJsZUNvbHVtbnMgPSBbXTtcbiAgICAgICAgdGhpcy52aXNpYmxlUm93cyA9IFtdO1xuICAgICAgICB0aGlzLmluc2VydGlvbkJvdW5kcyA9IFtdO1xuICAgIH0sXG5cbiAgICAvL3RoaXMgZnVuY3Rpb24gY29tcHV0ZXMgdGhlIGdyaWQgY29vcmRpbmF0ZXMgdXNlZCBmb3IgZXh0cmVtZWx5IGZhc3QgaXRlcmF0aW9uIG92ZXJcbiAgICAvL3BhaW50aW5nIHRoZSBncmlkIGNlbGxzLiB0aGlzIGZ1bmN0aW9uIGlzIHZlcnkgZmFzdCwgZm9yIHRob3VzYW5kIHJvd3MgWCAxMDAgY29sdW1uc1xuICAgIC8vb24gYSBtb2Rlc3QgbWFjaGluZSB0YWtpbmcgdXN1YWxseSAwbXMgYW5kIG5vIG1vcmUgdGhhdCAzIG1zLlxuICAgIGNvbXB1dGVDZWxsc0JvdW5kczogZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgLy92YXIgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcblxuICAgICAgICB2YXIgZ3JpZCA9IHRoaXMuZ2V0R3JpZCgpO1xuICAgICAgICB2YXIgc2Nyb2xsVG9wID0gdGhpcy5nZXRTY3JvbGxUb3AoKTtcbiAgICAgICAgdmFyIHNjcm9sbExlZnQgPSB0aGlzLmdldFNjcm9sbExlZnQoKTtcblxuICAgICAgICB2YXIgbnVtQ29sdW1ucyA9IHRoaXMuZ2V0Q29sdW1uQ291bnQoKTtcbiAgICAgICAgdmFyIG51bUZpeGVkQ29sdW1ucyA9IHRoaXMuZ2V0Rml4ZWRDb2x1bW5Db3VudCgpO1xuXG4gICAgICAgIHZhciBudW1Sb3dzID0gdGhpcy5nZXRSb3dDb3VudCgpO1xuICAgICAgICB2YXIgbnVtRml4ZWRSb3dzID0gdGhpcy5nZXRGaXhlZFJvd0NvdW50KCk7XG5cbiAgICAgICAgdmFyIGJvdW5kcyA9IHRoaXMuZ2V0Qm91bmRzKCk7XG4gICAgICAgIHZhciB2aWV3V2lkdGggPSBib3VuZHMud2lkdGg7XG5cbiAgICAgICAgLy93ZSBtdXN0IGJlIGluIGJvb3RzdHJhcFxuICAgICAgICBpZiAodmlld1dpZHRoID09PSAwKSB7XG4gICAgICAgICAgICAvL3ZpZXdXaWR0aCA9IGdyaWQuc2JIU2Nyb2xsZXIuZ2V0Q2xpZW50UmVjdHMoKVswXS53aWR0aDtcbiAgICAgICAgICAgIHZpZXdXaWR0aCA9IGdyaWQuY2FudmFzLndpZHRoO1xuICAgICAgICB9XG4gICAgICAgIHZhciB2aWV3SGVpZ2h0ID0gYm91bmRzLmhlaWdodDtcblxuICAgICAgICB2YXIgeCwgeSwgYywgciwgdngsIHZ5LCB3aWR0aCwgaGVpZ2h0O1xuXG4gICAgICAgIHRoaXMuZ2V0Q29sdW1uRWRnZXMoKS5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLnJvd0VkZ2VzLmxlbmd0aCA9IDA7XG5cbiAgICAgICAgdGhpcy5jb2x1bW5FZGdlc1swXSA9IDA7XG4gICAgICAgIHRoaXMucm93RWRnZXNbMF0gPSAwO1xuICAgICAgICB0aGlzLnNjcm9sbEhlaWdodCA9IDA7XG5cbiAgICAgICAgdGhpcy52aXNpYmxlQ29sdW1ucy5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLnZpc2libGVSb3dzLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMuY29sdW1uRWRnZXNJbmRleE1hcCA9IHt9O1xuICAgICAgICB0aGlzLnJvd0VkZ2VzSW5kZXhNYXAgPSB7fTtcblxuICAgICAgICB0aGlzLmluc2VydGlvbkJvdW5kcyA9IFtdO1xuICAgICAgICB2YXIgaW5zZXJ0aW9uQm91bmRzQ3Vyc29yID0gMDtcbiAgICAgICAgdmFyIHByZXZpb3VzSW5zZXJ0aW9uQm91bmRzQ3Vyc29yVmFsdWUgPSAwO1xuXG4gICAgICAgIHggPSAwO1xuICAgICAgICB2YXIgc3RhcnQgPSAwO1xuICAgICAgICB2YXIgZmlyc3RWWCwgbGFzdFZYO1xuICAgICAgICB2YXIgZmlyc3RWWSwgbGFzdFZZO1xuICAgICAgICBpZiAoZ3JpZC5pc1Nob3dSb3dOdW1iZXJzKCkpIHtcbiAgICAgICAgICAgIHN0YXJ0LS07XG4gICAgICAgICAgICB0aGlzLmNvbHVtbkVkZ2VzWy0xXSA9IC0xO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoYyA9IHN0YXJ0OyBjIDwgbnVtQ29sdW1uczsgYysrKSB7XG4gICAgICAgICAgICB2eCA9IGM7XG4gICAgICAgICAgICBpZiAoYyA+PSBudW1GaXhlZENvbHVtbnMpIHtcbiAgICAgICAgICAgICAgICB2eCA9IHZ4ICsgc2Nyb2xsTGVmdDtcbiAgICAgICAgICAgICAgICBpZiAoZmlyc3RWWCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpcnN0VlggPSB2eDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGFzdFZYID0gdng7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoeCA+IHZpZXdXaWR0aCB8fCBudW1Db2x1bW5zIDw9IHZ4KSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aWR0aCA9IHRoaXMuZ2V0Q29sdW1uV2lkdGgodngpO1xuICAgICAgICAgICAgeCA9IHggKyB3aWR0aDtcbiAgICAgICAgICAgIHRoaXMuY29sdW1uRWRnZXNbYyArIDFdID0gTWF0aC5yb3VuZCh4KTtcbiAgICAgICAgICAgIHRoaXMudmlzaWJsZUNvbHVtbnNbY10gPSB2eDtcbiAgICAgICAgICAgIHRoaXMuY29sdW1uRWRnZXNJbmRleE1hcFt2eF0gPSBjO1xuXG4gICAgICAgICAgICBpbnNlcnRpb25Cb3VuZHNDdXJzb3IgPSBpbnNlcnRpb25Cb3VuZHNDdXJzb3IgKyBNYXRoLnJvdW5kKHdpZHRoIC8gMikgKyBwcmV2aW91c0luc2VydGlvbkJvdW5kc0N1cnNvclZhbHVlO1xuICAgICAgICAgICAgdGhpcy5pbnNlcnRpb25Cb3VuZHMucHVzaChpbnNlcnRpb25Cb3VuZHNDdXJzb3IpO1xuICAgICAgICAgICAgcHJldmlvdXNJbnNlcnRpb25Cb3VuZHNDdXJzb3JWYWx1ZSA9IE1hdGgucm91bmQod2lkdGggLyAyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHkgPSAwO1xuICAgICAgICBmb3IgKHIgPSAwOyByIDwgbnVtUm93czsgcisrKSB7XG4gICAgICAgICAgICB2eSA9IHI7XG4gICAgICAgICAgICBpZiAociA+PSBudW1GaXhlZFJvd3MpIHtcbiAgICAgICAgICAgICAgICB2eSA9IHZ5ICsgc2Nyb2xsVG9wO1xuICAgICAgICAgICAgICAgIGlmIChmaXJzdFZZID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZmlyc3RWWSA9IHZ5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsYXN0VlkgPSB2eTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh5ID4gdmlld0hlaWdodCB8fCBudW1Sb3dzIDw9IHZ5KSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBoZWlnaHQgPSB0aGlzLmdldFJvd0hlaWdodCh2eSk7XG4gICAgICAgICAgICB5ID0geSArIGhlaWdodDtcbiAgICAgICAgICAgIHRoaXMucm93RWRnZXNbciArIDFdID0gTWF0aC5yb3VuZCh5KTtcbiAgICAgICAgICAgIHRoaXMudmlzaWJsZVJvd3Nbcl0gPSB2eTtcbiAgICAgICAgICAgIHRoaXMucm93RWRnZXNJbmRleE1hcFt2eV0gPSByO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudmlld0hlaWdodCA9IHZpZXdIZWlnaHQ7XG4gICAgICAgIHRoaXMuZGF0YVdpbmRvdyA9IGdyaWQubmV3UmVjdGFuZ2xlKGZpcnN0VlgsIGZpcnN0VlksIGxhc3RWWCAtIGZpcnN0VlgsIGxhc3RWWSAtIGZpcnN0VlkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUmVuZGVyZXIucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge09iamVjdH0gYSBwcm9wZXJ0eSB2YWx1ZSBhdCBhIGtleSwgZGVsZWdhdGVzIHRvIHRoZSBncmlkXG4gICAgICovXG4gICAgcmVzb2x2ZVByb3BlcnR5OiBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0R3JpZCgpLnJlc29sdmVQcm9wZXJ0eShrZXkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUmVuZGVyZXIucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqL1xuICAgIGdldEdyaWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ncmlkO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUmVuZGVyZXIucHJvdG90eXBlXG4gICAgICogQHN1bW1hcnkgTm90aWZ5IHRoZSBmaW4taHlwZXJncmlkIGV2ZXJ5dGltZSB3ZSd2ZSByZXBhaW50ZWQuXG4gICAgICogQGRlc2MgVGhpcyBpcyB0aGUgZW50cnkgcG9pbnQgZnJvbSBmaW4tY2FudmFzLlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBnYyAtIFtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkRdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQpXG4gICAgICovXG4gICAgX3BhaW50OiBmdW5jdGlvbihnYykge1xuICAgICAgICBpZiAodGhpcy5ncmlkKSB7XG4gICAgICAgICAgICB0aGlzLnJlbmRlckdyaWQoZ2MpO1xuICAgICAgICAgICAgdGhpcy5nZXRHcmlkKCkuZ3JpZFJlbmRlcmVkTm90aWZpY2F0aW9uKCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJlbmRlcmVyLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IEFuc3dlciBob3cgbWFueSByb3dzIHdlIHJlbmRlcmVkXG4gICAgICovXG4gICAgZ2V0VmlzaWJsZVJvd3NDb3VudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpc2libGVSb3dzLmxlbmd0aCAtIDE7XG4gICAgfSxcblxuICAgIGdldFZpc2libGVTY3JvbGxIZWlnaHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZ3JpZCA9IHRoaXMuZ2V0R3JpZCgpLFxuICAgICAgICAgICAgZnJoID0gZ3JpZC5nZXRGaXhlZFJvd3NIZWlnaHQoKTtcblxuICAgICAgICByZXR1cm4gdGhpcy52aWV3SGVpZ2h0IC0gZnJoO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUmVuZGVyZXIucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge251bWJlcltdfSBSb3dzIHdlIGp1c3QgcmVuZGVyZWQuXG4gICAgICovXG4gICAgZ2V0VmlzaWJsZVJvd3M6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy52aXNpYmxlUm93cztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJlbmRlcmVyLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IE51bWVyIG9mIGNvbHVtbnMgd2UganVzdCByZW5kZXJlZC5cbiAgICAgKi9cbiAgICBnZXRWaXNpYmxlQ29sdW1uc0NvdW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmlzaWJsZUNvbHVtbnMubGVuZ3RoIC0gMTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJlbmRlcmVyLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IENvbHVtbnMgd2UganVzdCByZW5kZXJlZC5cbiAgICAgKi9cbiAgICBnZXRWaXNpYmxlQ29sdW1uczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZpc2libGVDb2x1bW5zO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUmVuZGVyZXIucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge251bWJlcn0gVGhlIGNvbHVtbiBpbmRleCB3aG5lIHRoZSBtb3VzZUV2ZW50IGNvb3JkaW5hdGVzIGFyZSBvdmVyIGEgY29sdW1uIGRpdmlkZXIuXG4gICAgICovXG4gICAgb3ZlckNvbHVtbkRpdmlkZXI6IGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgeCA9IE1hdGgucm91bmQoeCk7XG4gICAgICAgIHZhciBlZGdlcyA9IHRoaXMuZ2V0Q29sdW1uRWRnZXMoKTtcbiAgICAgICAgdmFyIHdoaWNoQ29sID0gZWRnZXMuaW5kZXhPZih4IC0gMSk7XG4gICAgICAgIGlmICh3aGljaENvbCA8IDApIHtcbiAgICAgICAgICAgIHdoaWNoQ29sID0gZWRnZXMuaW5kZXhPZih4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAod2hpY2hDb2wgPCAwKSB7XG4gICAgICAgICAgICB3aGljaENvbCA9IGVkZ2VzLmluZGV4T2YoeCAtIDIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh3aGljaENvbCA8IDApIHtcbiAgICAgICAgICAgIHdoaWNoQ29sID0gZWRnZXMuaW5kZXhPZih4ICsgMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdoaWNoQ29sIDwgMCkge1xuICAgICAgICAgICAgd2hpY2hDb2wgPSBlZGdlcy5pbmRleE9mKHggLSAzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB3aGljaENvbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJlbmRlcmVyLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSByb3cgaW5kZXggd2hlbiB0aGUgbW91c2VFdmVudCBjb29yZGluYXRlcyBhcmUgb3ZlciBhIHJvdyBkaXZpZGVyLlxuICAgICAqL1xuICAgIG92ZXJSb3dEaXZpZGVyOiBmdW5jdGlvbih5KSB7XG4gICAgICAgIHkgPSBNYXRoLnJvdW5kKHkpO1xuICAgICAgICB2YXIgd2hpY2ggPSB0aGlzLnJvd0VkZ2VzLmluZGV4T2YoeSArIDEpO1xuICAgICAgICBpZiAod2hpY2ggPCAwKSB7XG4gICAgICAgICAgICB3aGljaCA9IHRoaXMucm93RWRnZXMuaW5kZXhPZih5KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAod2hpY2ggPCAwKSB7XG4gICAgICAgICAgICB3aGljaCA9IHRoaXMucm93RWRnZXMuaW5kZXhPZih5IC0gMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdoaWNoO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUmVuZGVyZXIucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtQb2ludH0gY2VsbFxuICAgICAqIEByZXR1cm5zIHtSZWN0YW5nbGV9IEJvdW5kaW5nIHJlY3Qgb2YgdGhlIGdpdmVuIGBjZWxsYC5cbiAgICAgKi9cbiAgICBnZXRCb3VuZHNPZkNlbGw6IGZ1bmN0aW9uKGNlbGwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldEJvdW5kc09mQ2VsbChjZWxsLngsIGNlbGwueSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSZW5kZXJlci5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYyAtIFRoZSBob3Jpem9udGFsIGNvb3JkaW5hdGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHIgLSBUaGUgdmVydGljYWwgY29vcmRpbmF0ZS5cbiAgICAgKiBAcmV0dXJucyB7UmVjdGFuZ2xlfSBCb3VuZGluZyByZWN0IG9mIGNlbGwgd2l0aCB0aGUgZ2l2ZW4gY29vcmRpbmF0ZXMuXG4gICAgICovXG4gICAgX2dldEJvdW5kc09mQ2VsbDogZnVuY3Rpb24oYywgcikge1xuICAgICAgICB2YXIgeE91dHNpZGUgPSBmYWxzZTtcbiAgICAgICAgdmFyIHlPdXRzaWRlID0gZmFsc2U7XG4gICAgICAgIHZhciBjb2x1bW5FZGdlcyA9IHRoaXMuZ2V0Q29sdW1uRWRnZXMoKTtcbiAgICAgICAgdmFyIHJvd0VkZ2VzID0gdGhpcy5nZXRSb3dFZGdlcygpO1xuXG4gICAgICAgIHZhciB4ID0gdGhpcy5jb2x1bW5FZGdlc0luZGV4TWFwW2NdO1xuICAgICAgICB2YXIgeSA9IHRoaXMucm93RWRnZXNJbmRleE1hcFtyXTtcbiAgICAgICAgaWYgKHggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgeCA9IHRoaXMuY29sdW1uRWRnZXNJbmRleE1hcFtjIC0gMV07XG4gICAgICAgICAgICB4T3V0c2lkZSA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoeSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB5ID0gdGhpcy5yb3dFZGdlc0luZGV4TWFwW3IgLSAxXTtcbiAgICAgICAgICAgIHlPdXRzaWRlID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBveCA9IGNvbHVtbkVkZ2VzW3hdLFxuICAgICAgICAgICAgb3kgPSByb3dFZGdlc1t5XSxcbiAgICAgICAgICAgIGN4ID0gY29sdW1uRWRnZXNbeCArIDFdLFxuICAgICAgICAgICAgY3kgPSByb3dFZGdlc1t5ICsgMV0sXG4gICAgICAgICAgICBleCA9IGN4IC0gb3gsXG4gICAgICAgICAgICBleSA9IGN5IC0gb3k7XG5cbiAgICAgICAgdmFyIGNlbGwgPSB0aGlzLmNlbGw7XG4gICAgICAgIGNlbGwueCA9IHhPdXRzaWRlID8gY3ggOiBveDtcbiAgICAgICAgY2VsbC55ID0geU91dHNpZGUgPyBjeSA6IG95O1xuICAgICAgICBjZWxsLndpZHRoID0geE91dHNpZGUgPyAwIDogZXg7XG4gICAgICAgIGNlbGwuaGVpZ2h0ID0geU91dHNpZGUgPyAwIDogZXk7XG5cbiAgICAgICAgcmV0dXJuIGNlbGw7XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJlbmRlcmVyLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGFuc3dlciB0aGUgY29sdW1uIGluZGV4IHVuZGVyIHRoZSBjb29yZGluYXRlIGF0IHBpeGVsWFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwaXhlbFggLSBUaGUgaG9yaXpvbnRhbCBjb29yZGluYXRlLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBjb2x1bW4gaW5kZXggdW5kZXIgdGhlIGNvb3JkaW5hdGUgYXQgcGl4ZWxYLlxuICAgICAqL1xuICAgIGdldENvbHVtbkZyb21QaXhlbFg6IGZ1bmN0aW9uKHBpeGVsWCkge1xuICAgICAgICB2YXIgd2lkdGggPSAwO1xuICAgICAgICB2YXIgZ3JpZCA9IHRoaXMuZ2V0R3JpZCgpO1xuICAgICAgICB2YXIgZml4ZWRDb2x1bW5Db3VudCA9IHRoaXMuZ2V0Rml4ZWRDb2x1bW5Db3VudCgpO1xuICAgICAgICB2YXIgc2Nyb2xsTGVmdCA9IGdyaWQuZ2V0SFNjcm9sbFZhbHVlKCk7XG4gICAgICAgIHZhciBjO1xuICAgICAgICB2YXIgZWRnZXMgPSB0aGlzLmdldENvbHVtbkVkZ2VzKCk7XG4gICAgICAgIGZvciAoYyA9IDE7IGMgPCBlZGdlcy5sZW5ndGggLSAxOyBjKyspIHtcbiAgICAgICAgICAgIHdpZHRoID0gZWRnZXNbY10gLSAoZWRnZXNbY10gLSBlZGdlc1tjIC0gMV0pIC8gMjtcbiAgICAgICAgICAgIGlmIChwaXhlbFggPCB3aWR0aCkge1xuICAgICAgICAgICAgICAgIGlmIChjID4gZml4ZWRDb2x1bW5Db3VudCkge1xuICAgICAgICAgICAgICAgICAgICBjID0gYyArIHNjcm9sbExlZnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBjIC0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoYyA+IGZpeGVkQ29sdW1uQ291bnQpIHtcbiAgICAgICAgICAgIGMgPSBjICsgc2Nyb2xsTGVmdDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYyAtIDE7XG4gICAgfSxcblxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJlbmRlcmVyLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIEFuc3dlciBzcGVjaWZpYyBkYXRhIGNlbGwgY29vcmRpbmF0ZXMgZ2l2ZW4gbW91c2UgY29vcmRpbmF0ZXMgaW4gcGl4ZWxzLlxuICAgICAqIEBwYXJhbSB7UG9pbnR9IHBvaW50XG4gICAgICogQHJldHVybnMge1BvaW50fSBDZWxsIGNvb3JkaW5hdGVzXG4gICAgICovXG4gICAgZ2V0R3JpZENlbGxGcm9tTW91c2VQb2ludDogZnVuY3Rpb24ocG9pbnQpIHtcblxuICAgICAgICB2YXIgZ3JpZCA9IHRoaXMuZ2V0R3JpZCgpO1xuICAgICAgICB2YXIgYmVoYXZpb3IgPSBncmlkLmdldEJlaGF2aW9yKCk7XG4gICAgICAgIHZhciB3aWR0aCA9IDA7XG4gICAgICAgIHZhciBoZWlnaHQgPSAwO1xuICAgICAgICB2YXIgeCwgeSwgYywgcjtcbiAgICAgICAgdmFyIHByZXZpb3VzID0gMDtcbiAgICAgICAgdmFyIGNvbHVtbkVkZ2VzID0gdGhpcy5nZXRDb2x1bW5FZGdlcygpO1xuICAgICAgICB2YXIgZml4ZWRDb2x1bW5Db3VudCA9IHRoaXMuZ2V0Rml4ZWRDb2x1bW5Db3VudCgpOyAvLyArIGdyaWRTaXplO1xuICAgICAgICB2YXIgZml4ZWRSb3dDb3VudCA9IHRoaXMuZ2V0Rml4ZWRSb3dDb3VudCgpO1xuXG4gICAgICAgIC8vIHZhciBmaXhlZENvbHVtbkNvdW50ID0gdGhpcy5nZXRGaXhlZENvbHVtbkNvdW50KCk7XG4gICAgICAgIC8vIHZhciBmaXhlZFJvd0NvdW50ID0gdGhpcy5nZXRGaXhlZFJvd0NvdW50KCk7XG4gICAgICAgIHZhciBzY3JvbGxYID0gdGhpcy5nZXRTY3JvbGxMZWZ0KCk7XG4gICAgICAgIHZhciBzY3JvbGxZID0gdGhpcy5nZXRTY3JvbGxUb3AoKTtcblxuICAgICAgICBmb3IgKGMgPSAwOyBjIDwgY29sdW1uRWRnZXMubGVuZ3RoOyBjKyspIHtcbiAgICAgICAgICAgIHdpZHRoID0gY29sdW1uRWRnZXNbY107XG4gICAgICAgICAgICBpZiAocG9pbnQueCA8IHdpZHRoKSB7XG4gICAgICAgICAgICAgICAgeCA9IE1hdGgubWF4KDAsIHBvaW50LnggLSBwcmV2aW91cyAtIDIpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJldmlvdXMgPSB3aWR0aDtcbiAgICAgICAgfVxuICAgICAgICBjLS07XG4gICAgICAgIHByZXZpb3VzID0gMDtcbiAgICAgICAgZm9yIChyID0gMDsgciA8IHRoaXMucm93RWRnZXMubGVuZ3RoOyByKyspIHtcbiAgICAgICAgICAgIGhlaWdodCA9IHRoaXMucm93RWRnZXNbcl07XG4gICAgICAgICAgICBpZiAocG9pbnQueSA8IGhlaWdodCkge1xuICAgICAgICAgICAgICAgIHkgPSBNYXRoLm1heCgwLCBwb2ludC55IC0gcHJldmlvdXMgLSAyKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHByZXZpb3VzID0gaGVpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIHItLTtcbiAgICAgICAgaWYgKHBvaW50LnggPCAwKSB7XG4gICAgICAgICAgICBjID0gLTE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBvaW50LnkgPCAwKSB7XG4gICAgICAgICAgICByID0gLTE7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdmlld1BvaW50ID0gZ3JpZC5uZXdQb2ludChjLCByKTtcblxuICAgICAgICAvL2NvbXBlbnNhdGUgaWYgd2UgYXJlIHNjcm9sbGVkXG4gICAgICAgIGlmIChjID49IGZpeGVkQ29sdW1uQ291bnQpIHtcbiAgICAgICAgICAgIGMgPSBjICsgc2Nyb2xsWDtcbiAgICAgICAgfVxuICAgICAgICBpZiAociA+PSBmaXhlZFJvd0NvdW50KSB7XG4gICAgICAgICAgICByID0gciArIHNjcm9sbFk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdHJhbnNsYXRlZEluZGV4ID0gLTE7XG5cbiAgICAgICAgdmFyIGNvbHVtbiA9IGJlaGF2aW9yLmdldENvbHVtbihjKTtcbiAgICAgICAgaWYgKGNvbHVtbikge1xuICAgICAgICAgICAgdHJhbnNsYXRlZEluZGV4ID0gY29sdW1uLmluZGV4O1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGdyaWRDZWxsOiBncmlkLm5ld1BvaW50KGMsIHIpLFxuICAgICAgICAgICAgbW91c2VQb2ludDogZ3JpZC5uZXdQb2ludCh4LCB5KSxcbiAgICAgICAgICAgIHZpZXdQb2ludDogdmlld1BvaW50LFxuICAgICAgICAgICAgZGF0YUNlbGw6IGdyaWQubmV3UG9pbnQodHJhbnNsYXRlZEluZGV4LCByKSxcbiAgICAgICAgfTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJlbmRlcmVyLnByb3RvdHlwZVxuICAgICAqIEBzdW1tYXJ5IERldGVybWluZXMgaWYgYSBjb2x1bW4gaXMgdmlzaWJsZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY29sSW5kZXggLSB0aGUgY29sdW1uIGluZGV4KlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBUaGUgZ2l2ZW4gY29sdW1uIGlzIGZ1bGx5IHZpc2libGUuXG4gICAgICovXG4gICAgaXNDb2x1bW5WaXNpYmxlOiBmdW5jdGlvbihjb2xJbmRleCkge1xuICAgICAgICB2YXIgaXNWaXNpYmxlID0gdGhpcy52aXNpYmxlQ29sdW1ucy5pbmRleE9mKGNvbEluZGV4KSAhPT0gLTE7XG4gICAgICAgIHJldHVybiBpc1Zpc2libGU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSZW5kZXJlci5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgd2lkdGggeCBjb29yZGluYXRlIG9mIHRoZSBsYXN0IHJlbmRlcmVkIGNvbHVtblxuICAgICAqL1xuICAgIGdldEZpbmFsVmlzYWJsZUNvbHVtbkJvdW5kcnk6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaXNNYXhYID0gdGhpcy5pc0xhc3RDb2x1bW5WaXNpYmxlKCk7XG4gICAgICAgIHZhciBjaG9wID0gaXNNYXhYID8gMiA6IDE7XG4gICAgICAgIHZhciBjb2xXYWxsID0gdGhpcy5nZXRDb2x1bW5FZGdlcygpW3RoaXMuZ2V0Q29sdW1uRWRnZXMoKS5sZW5ndGggLSBjaG9wXTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IE1hdGgubWluKGNvbFdhbGwsIHRoaXMuZ2V0Qm91bmRzKCkud2lkdGggLSAyMDApO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUmVuZGVyZXIucHJvdG90eXBlXG4gICAgICogQHN1bW1hcnkgRGV0ZXJtaW5lcyB2aXNpYmlsaXR5IG9mIGEgcm93LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByb3dJbmRleCAtIHRoZSByb3cgaW5kZXhcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVGhlIGdpdmVuIHJvdyBpcyBmdWxseSB2aXNpYmxlLlxuICAgICAqL1xuICAgIGlzUm93VmlzaWJsZTogZnVuY3Rpb24ocm93SW5kZXgpIHtcbiAgICAgICAgdmFyIGlzVmlzaWJsZSA9IHRoaXMudmlzaWJsZVJvd3MuaW5kZXhPZihyb3dJbmRleCkgIT09IC0xO1xuICAgICAgICByZXR1cm4gaXNWaXNpYmxlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUmVuZGVyZXIucHJvdG90eXBlXG4gICAgICogQHN1bW1hcnkgRGV0ZXJtaW5lcyBpZiBhIGNlbGwgaXMgc2VsZWN0ZWQuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggLSB0aGUgeCBjZWxsIGNvb3JkaW5hdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSAtIHRoZSB5IGNlbGwgY29vcmRpbmF0ZSpcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVGhlIGdpdmVuIGNlbGwgaXMgZnVsbHkgdmlzaWJsZS5cbiAgICAgKi9cbiAgICBpc1NlbGVjdGVkOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEdyaWQoKS5pc1NlbGVjdGVkKHgsIHkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUmVuZGVyZXIucHJvdG90eXBlXG4gICAgICogQGRlc2MgVGhpcyBpcyB0aGUgbWFpbiBmb3JraW5nIG9mIHRoZSByZW5kZXJlcmluZyB0YXNrLlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBnYyAtIFtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkRdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQpXG4gICAgICovXG4gICAgcmVuZGVyR3JpZDogZnVuY3Rpb24oZ2MpIHtcbiAgICAgICAgZ2MuYmVnaW5QYXRoKCk7XG5cbiAgICAgICAgdGhpcy5wYWludENlbGxzKGdjKTtcbiAgICAgICAgdGhpcy5wYWludEdyaWRsaW5lcyhnYyk7XG4gICAgICAgIC8vdGhpcy5ibGFua091dE92ZXJmbG93KGdjKTsgLy8gbm8gbG9uZ2VyIG5lZWRlZFxuICAgICAgICB0aGlzLnJlbmRlck92ZXJyaWRlcyhnYyk7XG4gICAgICAgIHRoaXMucmVuZGVyRm9jdXNDZWxsKGdjKTtcbiAgICAgICAgZ2MuY2xvc2VQYXRoKCk7XG4gICAgfSxcblxuICAgIGZvY3VzTGluZVN0ZXA6IFtcbiAgICAgICAgWzUsIDVdLFxuICAgICAgICBbMCwgMSwgNSwgNF0sXG4gICAgICAgIFswLCAyLCA1LCAzXSxcbiAgICAgICAgWzAsIDMsIDUsIDJdLFxuICAgICAgICBbMCwgNCwgNSwgMV0sXG4gICAgICAgIFswLCA1LCA1LCAwXSxcbiAgICAgICAgWzEsIDUsIDQsIDBdLFxuICAgICAgICBbMiwgNSwgMywgMF0sXG4gICAgICAgIFszLCA1LCAyLCAwXSxcbiAgICAgICAgWzQsIDUsIDEsIDBdXG4gICAgXSxcblxuICAgIHJlbmRlckZvY3VzQ2VsbDogZnVuY3Rpb24oZ2MpIHtcbiAgICAgICAgZ2MuYmVnaW5QYXRoKCk7XG4gICAgICAgIHRoaXMuX3JlbmRlckZvY3VzQ2VsbChnYyk7XG4gICAgICAgIGdjLmNsb3NlUGF0aCgpO1xuICAgIH0sXG5cbiAgICBfcmVuZGVyRm9jdXNDZWxsOiBmdW5jdGlvbihnYykge1xuXG4gICAgICAgIHZhciBncmlkID0gdGhpcy5nZXRHcmlkKCk7XG4gICAgICAgIHZhciBzZWxlY3Rpb25zID0gZ3JpZC5nZXRTZWxlY3Rpb25Nb2RlbCgpLmdldFNlbGVjdGlvbnMoKTtcbiAgICAgICAgaWYgKCFzZWxlY3Rpb25zIHx8IHNlbGVjdGlvbnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNlbGVjdGlvbiA9IHNlbGVjdGlvbnNbc2VsZWN0aW9ucy5sZW5ndGggLSAxXTtcbiAgICAgICAgdmFyIG1vdXNlRG93biA9IHNlbGVjdGlvbi5vcmlnaW47XG4gICAgICAgIGlmIChtb3VzZURvd24ueCA9PT0gLTEpIHtcbiAgICAgICAgICAgIC8vbm8gc2VsZWN0ZWQgYXJlYSwgbGV0cyBleGl0XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdmlzaWJsZUNvbHVtbnMgPSB0aGlzLmdldFZpc2libGVDb2x1bW5zKCk7XG4gICAgICAgIHZhciB2aXNpYmxlUm93cyA9IHRoaXMuZ2V0VmlzaWJsZVJvd3MoKTtcbiAgICAgICAgdmFyIGxhc3RWaXNpYmxlQ29sdW1uID0gdmlzaWJsZUNvbHVtbnNbdmlzaWJsZUNvbHVtbnMubGVuZ3RoIC0gMV07XG4gICAgICAgIHZhciBsYXN0VmlzaWJsZVJvdyA9IHZpc2libGVSb3dzW3Zpc2libGVSb3dzLmxlbmd0aCAtIDFdO1xuXG4gICAgICAgIHZhciBleHRlbnQgPSBzZWxlY3Rpb24uZXh0ZW50O1xuXG4gICAgICAgIHZhciBkcE9YID0gTWF0aC5taW4obW91c2VEb3duLngsIG1vdXNlRG93bi54ICsgZXh0ZW50LngpO1xuICAgICAgICB2YXIgZHBPWSA9IE1hdGgubWluKG1vdXNlRG93bi55LCBtb3VzZURvd24ueSArIGV4dGVudC55KTtcblxuICAgICAgICAvL2xldHMgY2hlY2sgaWYgb3VyIHNlbGVjdGlvbiByZWN0YW5nbGUgaXMgc2Nyb2xsZWQgb3V0c2lkZSBvZiB0aGUgdmlzaWJsZSBhcmVhXG4gICAgICAgIGlmIChkcE9YID4gbGFzdFZpc2libGVDb2x1bW4pIHtcbiAgICAgICAgICAgIHJldHVybjsgLy90aGUgdG9wIG9mIG91ciByZWN0YW5nbGUgaXMgYmVsb3cgdmlzaWJsZVxuICAgICAgICB9XG4gICAgICAgIGlmIChkcE9ZID4gbGFzdFZpc2libGVSb3cpIHtcbiAgICAgICAgICAgIHJldHVybjsgLy90aGUgbGVmdCBvZiBvdXIgcmVjdGFuZ2xlIGlzIHRvIHRoZSByaWdodCBvZiBiZWluZyB2aXNpYmxlXG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZHBFWCA9IE1hdGgubWF4KG1vdXNlRG93bi54LCBtb3VzZURvd24ueCArIGV4dGVudC54KSArIDE7XG4gICAgICAgIGRwRVggPSBNYXRoLm1pbihkcEVYLCAxICsgbGFzdFZpc2libGVDb2x1bW4pO1xuXG4gICAgICAgIHZhciBkcEVZID0gTWF0aC5tYXgobW91c2VEb3duLnksIG1vdXNlRG93bi55ICsgZXh0ZW50LnkpICsgMTtcbiAgICAgICAgZHBFWSA9IE1hdGgubWluKGRwRVksIDEgKyBsYXN0VmlzaWJsZVJvdyk7XG5cbiAgICAgICAgdmFyIG8gPSB0aGlzLl9nZXRCb3VuZHNPZkNlbGwoZHBPWCwgZHBPWSk7XG4gICAgICAgIHZhciBveCA9IE1hdGgucm91bmQoKG8ueCA9PT0gdW5kZWZpbmVkKSA/IGdyaWQuZ2V0Rml4ZWRDb2x1bW5zV2lkdGgoKSA6IG8ueCk7XG4gICAgICAgIHZhciBveSA9IE1hdGgucm91bmQoKG8ueSA9PT0gdW5kZWZpbmVkKSA/IGdyaWQuZ2V0Rml4ZWRSb3dzSGVpZ2h0KCkgOiBvLnkpO1xuICAgICAgICAvLyB2YXIgb3cgPSBvLndpZHRoO1xuICAgICAgICAvLyB2YXIgb2ggPSBvLmhlaWdodDtcbiAgICAgICAgdmFyIGUgPSB0aGlzLl9nZXRCb3VuZHNPZkNlbGwoZHBFWCwgZHBFWSk7XG4gICAgICAgIHZhciBleCA9IE1hdGgucm91bmQoKGUueCA9PT0gdW5kZWZpbmVkKSA/IGdyaWQuZ2V0Rml4ZWRDb2x1bW5zV2lkdGgoKSA6IGUueCk7XG4gICAgICAgIHZhciBleSA9IE1hdGgucm91bmQoKGUueSA9PT0gdW5kZWZpbmVkKSA/IGdyaWQuZ2V0Rml4ZWRSb3dzSGVpZ2h0KCkgOiBlLnkpO1xuICAgICAgICAvLyB2YXIgZXcgPSBlLndpZHRoO1xuICAgICAgICAvLyB2YXIgZWggPSBlLmhlaWdodDtcbiAgICAgICAgdmFyIHggPSBNYXRoLm1pbihveCwgZXgpO1xuICAgICAgICB2YXIgeSA9IE1hdGgubWluKG95LCBleSk7XG4gICAgICAgIHZhciB3aWR0aCA9IDEgKyBleCAtIG94O1xuICAgICAgICB2YXIgaGVpZ2h0ID0gMSArIGV5IC0gb3k7XG4gICAgICAgIGlmICh4ID09PSBleCkge1xuICAgICAgICAgICAgd2lkdGggPSBveCAtIGV4O1xuICAgICAgICB9XG4gICAgICAgIGlmICh5ID09PSBleSkge1xuICAgICAgICAgICAgaGVpZ2h0ID0gb3kgLSBleTtcbiAgICAgICAgfVxuICAgICAgICBpZiAod2lkdGggKiBoZWlnaHQgPCAxKSB7XG4gICAgICAgICAgICAvL2lmIHdlIGFyZSBvbmx5IGEgc2tpbm55IGxpbmUsIGRvbid0IHJlbmRlciBhbnl0aGluZ1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgZ2MucmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgZ2MuZmlsbFN0eWxlID0gJ3JnYmEoMCwgMCwgMCwgMC4yKSc7XG4gICAgICAgIGdjLmZpbGwoKTtcbiAgICAgICAgZ2MubGluZVdpZHRoID0gMTtcbiAgICAgICAgZ2Muc3Ryb2tlU3R5bGUgPSAnYmxhY2snO1xuXG4gICAgICAgIC8vIGFuaW1hdGUgdGhlIGRhc2hlZCBsaW5lIGEgYml0IGhlcmUgZm9yIGZ1blxuXG4gICAgICAgIGdjLnN0cm9rZSgpO1xuXG4gICAgICAgIC8vZ2MucmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcblxuICAgICAgICAvL2djLnN0cm9rZVN0eWxlID0gJ3doaXRlJztcblxuICAgICAgICAvLyBhbmltYXRlIHRoZSBkYXNoZWQgbGluZSBhIGJpdCBoZXJlIGZvciBmdW5cbiAgICAgICAgLy9nYy5zZXRMaW5lRGFzaCh0aGlzLmZvY3VzTGluZVN0ZXBbTWF0aC5mbG9vcigxMCAqIChEYXRlLm5vdygpIC8gMzAwICUgMSkpICUgdGhpcy5mb2N1c0xpbmVTdGVwLmxlbmd0aF0pO1xuXG4gICAgICAgIGdjLnN0cm9rZSgpO1xuICAgIH0sXG5cblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSZW5kZXJlci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBQYWludCB0aGUgYmFja2dyb3VuZCBjb2xvciBvdmVyIHRoZSBvdmVyZmxvdyBmcm9tIHRoZSBmaW5hbCBjb2x1bW4gcGFpbnRcbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gZ2MgLSBbQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEKVxuICAgICAqL1xuICAgIGJsYW5rT3V0T3ZlcmZsb3c6IGZ1bmN0aW9uKGdjKSB7XG4gICAgICAgIHZhciBpc01heFggPSB0aGlzLmlzTGFzdENvbHVtblZpc2libGUoKTtcbiAgICAgICAgdmFyIGNob3AgPSBpc01heFggPyAxIDogMDtcbiAgICAgICAgdmFyIHggPSB0aGlzLmdldENvbHVtbkVkZ2VzKClbdGhpcy5nZXRDb2x1bW5FZGdlcygpLmxlbmd0aCAtIGNob3BdO1xuICAgICAgICB2YXIgYm91bmRzID0gdGhpcy5nZXRCb3VuZHMoKTtcbiAgICAgICAgdmFyIHdpZHRoID0gYm91bmRzLndpZHRoIC0gMjAwIC0geDtcbiAgICAgICAgdmFyIGhlaWdodCA9IGJvdW5kcy5oZWlnaHQ7XG4gICAgICAgIGdjLmZpbGxTdHlsZSA9IHRoaXMucmVzb2x2ZVByb3BlcnR5KCdiYWNrZ3JvdW5kQ29sb3IyJyk7XG4gICAgICAgIGdjLmZpbGxSZWN0KHggKyAxLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJlbmRlcmVyLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGl0ZXJhdGUgdGhlIHJlbmRlcmVyaW5nIG92ZXJyaWRlcyBhbmQgbWFuaWZlc3QgZWFjaFxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBnYyAtIFtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkRdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQpXG4gICAgICovXG4gICAgcmVuZGVyT3ZlcnJpZGVzOiBmdW5jdGlvbihnYykge1xuICAgICAgICB2YXIgZ3JpZCA9IHRoaXMuZ2V0R3JpZCgpO1xuICAgICAgICB2YXIgY2FjaGUgPSBncmlkLnJlbmRlck92ZXJyaWRlc0NhY2hlO1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gY2FjaGUpIHtcbiAgICAgICAgICAgIGlmIChjYWNoZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgdmFyIG92ZXJyaWRlID0gY2FjaGVba2V5XTtcbiAgICAgICAgICAgICAgICBpZiAob3ZlcnJpZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJPdmVycmlkZShnYywgb3ZlcnJpZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUmVuZGVyZXIucHJvdG90eXBlXG4gICAgICogQGRlc2MgY29weSBlYWNoIG92ZXJyaWRlcyBzcGVjaWZpZWQgYXJlYSB0byBpdCdzIHRhcmdldCBhbmQgYmxhbmsgb3V0IHRoZSBzb3VyY2UgYXJlYVxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBnYyAtIFtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkRdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQpXG4gICAgICogQHBhcmFtIHtPdmVycmlkZU9iamVjdH0gb3ZlcnJpZGUgLSBhbiBvYmplY3Qgd2l0aCBkZXRhaWxzIGNvbnRhaW4gYW4gYXJlYSBhbmQgYSB0YXJnZXQgY29udGV4dFxuICAgICAqL1xuICAgIHJlbmRlck92ZXJyaWRlOiBmdW5jdGlvbihnYywgb3ZlcnJpZGUpIHtcbiAgICAgICAgLy9sZXRzIGJsYW5rIG91dCB0aGUgZHJhZyByb3dcbiAgICAgICAgdmFyIGhkcGlSYXRpbyA9IG92ZXJyaWRlLmhkcGlyYXRpbztcbiAgICAgICAgLy92YXIgZWRnZXMgPSB0aGlzLmdldENvbHVtbkVkZ2VzKCk7XG4gICAgICAgIHZhciBzdGFydFggPSBvdmVycmlkZS5zdGFydFg7IC8vaGRwaVJhdGlvICogZWRnZXNbb3ZlcnJpZGUuY29sdW1uSW5kZXhdO1xuICAgICAgICB2YXIgd2lkdGggPSBvdmVycmlkZS53aWR0aCArIDE7XG4gICAgICAgIHZhciBoZWlnaHQgPSBvdmVycmlkZS5oZWlnaHQ7XG4gICAgICAgIHZhciB0YXJnZXRDVFggPSBvdmVycmlkZS5jdHg7XG4gICAgICAgIHZhciBpbWdEYXRhID0gZ2MuZ2V0SW1hZ2VEYXRhKHN0YXJ0WCwgMCwgTWF0aC5yb3VuZCh3aWR0aCAqIGhkcGlSYXRpbyksIE1hdGgucm91bmQoaGVpZ2h0ICogaGRwaVJhdGlvKSk7XG4gICAgICAgIHRhcmdldENUWC5wdXRJbWFnZURhdGEoaW1nRGF0YSwgMCwgMCk7XG4gICAgICAgIGdjLmZpbGxTdHlsZSA9IHRoaXMucmVzb2x2ZVByb3BlcnR5KCdiYWNrZ3JvdW5kQ29sb3IyJyk7XG4gICAgICAgIGdjLmZpbGxSZWN0KE1hdGgucm91bmQoc3RhcnRYIC8gaGRwaVJhdGlvKSwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSZW5kZXJlci5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gbW91c2UgaXMgY3VycmVudGx5IG92ZXIgY2VsbCB4LCB5XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFggLSB4IGNvb3JkaW5hdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0WSAtIHkgY29vcmRpbmF0ZVxuICAgICAqL1xuICAgIGlzSG92ZXJlZDogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRHcmlkKCkuaXNIb3ZlcmVkKHgsIHkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUmVuZGVyZXIucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IG1vdXNlIGlzIGN1cnJlbnRseSBvdmVyIHJvdyB5XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFkgLSB5IGNvb3JkaW5hdGVcbiAgICAgKi9cbiAgICBpc1Jvd0hvdmVyZWQ6IGZ1bmN0aW9uKHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0R3JpZCgpLmlzUm93SG92ZXJlZCh5KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJlbmRlcmVyLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBtb3VzZSBpcyBjdXJyZW50bHkgb3ZlciBjb2x1bW4geFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRYIC0geCBjb29yZGluYXRlXG4gICAgICovXG4gICAgaXNDb2x1bW5Ib3ZlcmVkOiBmdW5jdGlvbih4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEdyaWQoKS5pc0NvbHVtbkhvdmVyZWQoeCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSZW5kZXJlci5wcm90b3R5cGVcbiAgICAgKiBAc3VtbWFyeSBTbWFydCByZW5kZXIgdGhlIG1haW4gY2VsbHMuXG4gICAgICogQGRlc2MgV2Ugc25hcHNob3QgdGhlIGNvbnRleHQgdG8gaW5zdXJlIGFnYWluc3QgaXRzIHBvbGx1dGlvbi5cbiAgICAgKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRH0gZ2MgLSBbQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQ2FudmFzUmVuZGVyaW5nQ29udGV4dDJEKVxuICAgICAqL1xuICAgIHBhaW50Q2VsbHM6IGZ1bmN0aW9uKGdjKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBnYy5zYXZlKCk7XG4gICAgICAgICAgICB0aGlzLl9wYWludENlbGxzKGdjKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIGdjLnJlc3RvcmUoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUmVuZGVyZXIucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbEluZGV4XG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFRoZSBnaXZlbiBjb2x1bW4gd2l0aGluIHRoZSBmaXhlZCByb3cgYXJlYSBpcyBzZWxlY3RlZC5cbiAgICAgKi9cbiAgICBpc0NlbGxTZWxlY3RlZEluUm93OiBmdW5jdGlvbihjb2xJbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRHcmlkKCkuaXNDZWxsU2VsZWN0ZWRJblJvdyhjb2xJbmRleCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSZW5kZXJlci5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcm93SW5kZXhcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVGhlIGdpdmVuIHJvdyB3aXRoaW4gdGhlIGZpeGVkIGNvbHVtbiBhcmVhIGlzIHNlbGVjdGVkLlxuICAgICAqL1xuICAgIGlzQ2VsbFNlbGVjdGVkSW5Db2x1bW46IGZ1bmN0aW9uKHJvd0luZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEdyaWQoKS5pc0NlbGxTZWxlY3RlZEluQ29sdW1uKHJvd0luZGV4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJlbmRlcmVyLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IEN1cnJlbnQgdmVydGljYWwgc2Nyb2xsIHZhbHVlLlxuICAgICAqL1xuICAgIGdldFNjcm9sbFRvcDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzdCA9IHRoaXMuZ2V0R3JpZCgpLmdldFZTY3JvbGxWYWx1ZSgpO1xuICAgICAgICByZXR1cm4gc3Q7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSZW5kZXJlci5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBDdXJyZW50IGhvcml6b250YWwgc2Nyb2xsIHZhbHVlLlxuICAgICAqL1xuICAgIGdldFNjcm9sbExlZnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc3QgPSB0aGlzLmdldEdyaWQoKS5nZXRIU2Nyb2xsVmFsdWUoKTtcbiAgICAgICAgcmV0dXJuIHN0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUmVuZGVyZXIucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge0JlaGF2aW9yfVxuICAgICAqL1xuICAgIGdldEJlaGF2aW9yOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0R3JpZCgpLmdldEJlaGF2aW9yKCk7XG4gICAgfSxcblxuICAgIGdldENvbHVtbkVkZ2VzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29sdW1uRWRnZXM7XG4gICAgfSxcblxuICAgIGdldFJvd0VkZ2VzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucm93RWRnZXM7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUmVuZGVyZXIucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge251bWJlcn0gVGhlIHJvdyBoZWlnaHQgb2YgdGhlIHJvdyBhdCBpbmRleCByb3dJbmRleFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByb3dJbmRleFxuICAgICAqL1xuICAgIGdldFJvd0hlaWdodDogZnVuY3Rpb24ocm93SW5kZXgpIHtcbiAgICAgICAgdmFyIGhlaWdodCA9IHRoaXMuZ2V0QmVoYXZpb3IoKS5nZXRSb3dIZWlnaHQocm93SW5kZXgpO1xuICAgICAgICByZXR1cm4gaGVpZ2h0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUmVuZGVyZXIucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge251bWJlcn0gVGhlIGNvbHVtbldpZHRoIG9mIHRoZSBjb2x1bW4gYXQgaW5kZXggY29sdW1uSW5kZXhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY29sdW1uSW5kZXhcbiAgICAgKi9cbiAgICBnZXRDb2x1bW5XaWR0aDogZnVuY3Rpb24oY29sdW1uSW5kZXgpIHtcbiAgICAgICAgdmFyIHdpZHRoID0gdGhpcy5nZXRHcmlkKCkuZ2V0Q29sdW1uV2lkdGgoY29sdW1uSW5kZXgpO1xuICAgICAgICByZXR1cm4gd2lkdGg7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSZW5kZXJlci5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVGhlIGxhc3QgY29sIHdhcyByZW5kZXJlZCAoaXMgdmlzaWJsZSlcbiAgICAgKi9cbiAgICBpc0xhc3RDb2x1bW5WaXNpYmxlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGxhc3RDb2x1bW5JbmRleCA9IHRoaXMuZ2V0Q29sdW1uQ291bnQoKSAtIDE7XG4gICAgICAgIHZhciBpc01heCA9IHRoaXMudmlzaWJsZUNvbHVtbnMuaW5kZXhPZihsYXN0Q29sdW1uSW5kZXgpICE9PSAtMTtcbiAgICAgICAgcmV0dXJuIGlzTWF4O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUmVuZGVyZXIucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge251bWJlcn0gVGhlIHJlbmRlcmVkIGNvbHVtbiB3aWR0aCBhdCBpbmRleFxuICAgICAqL1xuICAgIGdldFJlbmRlcmVkV2lkdGg6IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldENvbHVtbkVkZ2VzKClbaW5kZXhdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUmVuZGVyZXIucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge251bWJlcn0gVGhlIHJlbmRlcmVkIHJvdyBoZWlnaHQgYXQgaW5kZXhcbiAgICAgKi9cbiAgICBnZXRSZW5kZXJlZEhlaWdodDogZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucm93RWRnZXNbaW5kZXhdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUmVuZGVyZXIucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge2Zpbi1jYW52YXN9IG15IFtmaW4tY2FudmFzXShodHRwczovL2dpdGh1Yi5jb20vc3RldmV3aXJ0cy9maW4tY2FudmFzKVxuICAgICAqL1xuICAgIGdldENhbnZhczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEdyaWQoKS5nZXRDYW52YXMoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJlbmRlcmVyLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBVc2VyIGlzIGN1cnJlbnRseSBkcmFnZ2luZyBhIGNvbHVtbiBmb3IgcmVvcmRlcmluZy5cbiAgICAgKi9cbiAgICBpc0RyYWdnaW5nQ29sdW1uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0R3JpZCgpLmlzRHJhZ2dpbmdDb2x1bW4oKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJlbmRlcmVyLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSByb3cgdG8gZ290byBmb3IgYSBwYWdlIHVwLlxuICAgICAqL1xuICAgIGdldFBhZ2VVcFJvdzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBiZWhhdmlvciA9IHRoaXMuZ2V0QmVoYXZpb3IoKTtcbiAgICAgICAgdmFyIHNjcm9sbEhlaWdodCA9IHRoaXMuZ2V0VmlzaWJsZVNjcm9sbEhlaWdodCgpO1xuICAgICAgICB2YXIgaGVhZGVyUm93cyA9IHRoaXMuZ2V0R3JpZCgpLmdldEZpeGVkUm93Q291bnQoKTtcbiAgICAgICAgdmFyIHRvcCA9IHRoaXMuZGF0YVdpbmRvdy5vcmlnaW4ueSAtIGhlYWRlclJvd3M7XG4gICAgICAgIHZhciBzY2FuSGVpZ2h0ID0gMDtcbiAgICAgICAgd2hpbGUgKHNjYW5IZWlnaHQgPCBzY3JvbGxIZWlnaHQgJiYgdG9wID4gLTEpIHtcbiAgICAgICAgICAgIHNjYW5IZWlnaHQgPSBzY2FuSGVpZ2h0ICsgYmVoYXZpb3IuZ2V0Um93SGVpZ2h0KHRvcCk7XG4gICAgICAgICAgICB0b3AtLTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9wICsgMTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJlbmRlcmVyLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSByb3cgdG8gZ290byBmb3IgYSBwYWdlIGRvd24uXG4gICAgICovXG4gICAgZ2V0UGFnZURvd25Sb3c6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaGVhZGVyUm93cyA9IHRoaXMuZ2V0R3JpZCgpLmdldEZpeGVkUm93Q291bnQoKTtcbiAgICAgICAgdmFyIHJvd051bSA9IHRoaXMuZGF0YVdpbmRvdy5jb3JuZXIueSAtIGhlYWRlclJvd3MgLSAxO1xuICAgICAgICByZXR1cm4gcm93TnVtO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUmVuZGVyZXIucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge251bWJlcn0gVGhlIG51bWJlciBvZiBjb2x1bW5zLlxuICAgICAqL1xuICAgIGdldENvbHVtbkNvdW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0R3JpZCgpLmdldENvbHVtbkNvdW50KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSZW5kZXJlci5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIHJvd3MuXG4gICAgICovXG4gICAgZ2V0Um93Q291bnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRHcmlkKCkuZ2V0Um93Q291bnQoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJlbmRlcmVyLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgZml4ZWQgY29sdW1ucy5cbiAgICAgKi9cbiAgICBnZXRGaXhlZENvbHVtbkNvdW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0R3JpZCgpLmdldEZpeGVkQ29sdW1uQ291bnQoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJlbmRlcmVyLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgZml4ZWQgcm93cy5cbiAgICAgKi9cbiAgICBnZXRGaXhlZFJvd0NvdW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0R3JpZCgpLmdldEZpeGVkUm93Q291bnQoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJlbmRlcmVyLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgaGVhZGVyIHJvd3MuXG4gICAgICovXG4gICAgZ2V0SGVhZGVyUm93Q291bnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRHcmlkKCkuZ2V0SGVhZGVyUm93Q291bnQoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJlbmRlcmVyLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgaGVhZGVyIGNvbHVtbnMuXG4gICAgICovXG4gICAgZ2V0SGVhZGVyQ29sdW1uQ291bnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRHcmlkKCkuZ2V0SGVhZGVyQ29sdW1uQ291bnQoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJlbmRlcmVyLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIER1bWIgcmVuZGVyIHRoZSBmaXhlZCBjb2x1bW5zIGFsb25nIHRoZSBsZWZ0IHNpZGUuXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGdjIC0gW0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyRClcbiAgICAgKi9cbiAgICBfcGFpbnRDZWxsczogZnVuY3Rpb24oZ2MpIHtcbiAgICAgICAgdmFyIHgsIHksIGMsIHIgPSAwO1xuXG4gICAgICAgIHZhciBjb2x1bW5FZGdlcyA9IHRoaXMuZ2V0Q29sdW1uRWRnZXMoKTtcbiAgICAgICAgdmFyIHJvd0VkZ2VzID0gdGhpcy5yb3dFZGdlcztcbiAgICAgICAgdGhpcy5idXR0b25DZWxscyA9IHt9O1xuICAgICAgICB2YXIgdmlzaWJsZUNvbHMgPSB0aGlzLmdldFZpc2libGVDb2x1bW5zKCk7XG4gICAgICAgIHZhciB2aXNpYmxlUm93cyA9IHRoaXMuZ2V0VmlzaWJsZVJvd3MoKTtcblxuICAgICAgICB2YXIgd2lkdGggPSBjb2x1bW5FZGdlc1tjb2x1bW5FZGdlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgdmFyIGhlaWdodCA9IHJvd0VkZ2VzW3Jvd0VkZ2VzLmxlbmd0aCAtIDFdO1xuXG4gICAgICAgIGdjLm1vdmVUbygwLCAwKTtcbiAgICAgICAgZ2MucmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgZ2Muc3Ryb2tlKCk7XG4gICAgICAgIGdjLmNsaXAoKTtcblxuICAgICAgICB2YXIgbG9vcExlbmd0aCA9IHZpc2libGVDb2xzLmxlbmd0aDtcbiAgICAgICAgdmFyIGxvb3BTdGFydCA9IDA7XG5cbiAgICAgICAgaWYgKHRoaXMuZ2V0R3JpZCgpLmlzU2hvd1Jvd051bWJlcnMoKSkge1xuICAgICAgICAgICAgLy9sb29wTGVuZ3RoKys7XG4gICAgICAgICAgICBsb29wU3RhcnQtLTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoeCA9IGxvb3BTdGFydDsgeCA8IGxvb3BMZW5ndGg7IHgrKykge1xuICAgICAgICAgICAgYyA9IHZpc2libGVDb2xzW3hdO1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlZENvbHVtbk1pbldpZHRoc1tjXSA9IDA7XG4gICAgICAgICAgICBmb3IgKHkgPSAwOyB5IDwgdmlzaWJsZVJvd3MubGVuZ3RoOyB5KyspIHtcbiAgICAgICAgICAgICAgICByID0gdmlzaWJsZVJvd3NbeV07XG4gICAgICAgICAgICAgICAgdGhpcy5fcGFpbnRDZWxsKGdjLCBjLCByKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHNldE51bWJlckNvbHVtbldpZHRoKGdjLCB0aGlzLmdldEJlaGF2aW9yKCksIHRoaXMuZ2V0R3JpZCgpLmdldFJvd0NvdW50KCkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUmVuZGVyZXIucHJvdG90eXBlXG4gICAgICogQGRlc2MgV2Ugb3B0ZWQgdG8gbm90IHBhaW50IGJvcmRlcnMgZm9yIGVhY2ggY2VsbCBhcyB0aGF0IHdhcyBleHRyZW1lbHkgZXhwZW5zaXZlLiBJbnN0ZWFkIHdlIGRyYXcgZ3JpZGxpbmVzIGhlcmUuIEFsc28gd2UgcmVjb3JkIHRoZSB3aWR0aHMgYW5kIGhlaWdodHMgZm9yIGxhdGVyLlxuICAgICAqIEBwYXJhbSB7Q2FudmFzUmVuZGVyaW5nQ29udGV4dDJEfSBnYyAtIFtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkRdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9DYW52YXNSZW5kZXJpbmdDb250ZXh0MkQpXG4gICAgICovXG4gICAgcGFpbnRHcmlkbGluZXM6IGZ1bmN0aW9uKGdjKSB7XG4gICAgICAgIHZhciB4LCB5LCBjLCByID0gMDtcblxuICAgICAgICB2YXIgY29sV2lkdGhzID0gdGhpcy5nZXRDb2x1bW5FZGdlcygpO1xuICAgICAgICB2YXIgcm93SGVpZ2h0cyA9IHRoaXMucm93RWRnZXM7XG5cbiAgICAgICAgdmFyIHZpZXdXaWR0aCA9IGNvbFdpZHRoc1tjb2xXaWR0aHMubGVuZ3RoIC0gMV07XG4gICAgICAgIHZhciB2aWV3SGVpZ2h0ID0gcm93SGVpZ2h0c1tyb3dIZWlnaHRzLmxlbmd0aCAtIDFdO1xuXG4gICAgICAgIHZhciBkcmF3VGhlbUggPSB0aGlzLnJlc29sdmVQcm9wZXJ0eSgnZ3JpZExpbmVzSCcpO1xuICAgICAgICB2YXIgZHJhd1RoZW1WID0gdGhpcy5yZXNvbHZlUHJvcGVydHkoJ2dyaWRMaW5lc1YnKTtcbiAgICAgICAgdmFyIGxpbmVDb2xvciA9IHRoaXMucmVzb2x2ZVByb3BlcnR5KCdsaW5lQ29sb3InKTtcblxuICAgICAgICBnYy5iZWdpblBhdGgoKTtcbiAgICAgICAgZ2Muc3Ryb2tlU3R5bGUgPSBsaW5lQ29sb3I7XG4gICAgICAgIGdjLmxpbmVXaWR0aCA9IHRoaXMucmVzb2x2ZVByb3BlcnR5KCdsaW5lV2lkdGgnKTtcbiAgICAgICAgZ2MubW92ZVRvKDAsIDApO1xuXG4gICAgICAgIGlmIChkcmF3VGhlbVYpIHtcbiAgICAgICAgICAgIGZvciAoYyA9IDA7IGMgPCBjb2xXaWR0aHMubGVuZ3RoICsgMTsgYysrKSB7XG4gICAgICAgICAgICAgICAgeCA9IGNvbFdpZHRoc1tjXSArIDAuNTtcbiAgICAgICAgICAgICAgICBnYy5tb3ZlVG8oeCwgMCk7XG4gICAgICAgICAgICAgICAgZ2MubGluZVRvKHgsIHZpZXdIZWlnaHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRyYXdUaGVtSCkge1xuICAgICAgICAgICAgZm9yIChyID0gMDsgciA8IHJvd0hlaWdodHMubGVuZ3RoOyByKyspIHtcbiAgICAgICAgICAgICAgICB5ID0gcm93SGVpZ2h0c1tyXSArIDAuNTtcbiAgICAgICAgICAgICAgICBnYy5tb3ZlVG8oMCwgeSk7XG4gICAgICAgICAgICAgICAgZ2MubGluZVRvKHZpZXdXaWR0aCwgeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZ2Muc3Ryb2tlKCk7XG4gICAgICAgIGdjLmNsb3NlUGF0aCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUmVuZGVyZXIucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IGdjXG4gICAgICogQHBhcmFtIHhcbiAgICAgKiBAcGFyYW0geVxuICAgICAqL1xuICAgIHBhaW50Q2VsbDogZnVuY3Rpb24oZ2MsIHgsIHkpIHtcbiAgICAgICAgZ2MubW92ZVRvKDAsIDApO1xuXG4gICAgICAgIHZhciBjID0gdGhpcy5nZXRWaXNpYmxlQ29sdW1ucygpW3hdLFxuICAgICAgICAgICAgciA9IHRoaXMuZ2V0VmlzaWJsZVJvd3MoKVt5XTtcblxuICAgICAgICBpZiAoYykgeyAvL3NvbWV0aGluZyBpcyBiZWluZyB2aWV3ZWQgYXQgYXQgdGhlIG1vbWVudCAob3RoZXJ3aXNlIHJldHVybnMgdW5kZWZpbmVkKVxuICAgICAgICAgICAgdGhpcy5fcGFpbnRDZWxsKGdjLCBjLCByKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBfcGFpbnRDZWxsOiBmdW5jdGlvbihnYywgYywgcikge1xuXG4gICAgICAgIHZhciBncmlkID0gdGhpcy5nZXRHcmlkKCk7XG4gICAgICAgIHZhciBiZWhhdmlvciA9IHRoaXMuZ2V0QmVoYXZpb3IoKTtcbiAgICAgICAgdmFyIGJhc2VQcm9wZXJ0aWVzID0gYmVoYXZpb3IuZ2V0Q29sdW1uUHJvcGVydGllcyhjKTtcblxuICAgICAgICBpZiAoYmFzZVByb3BlcnRpZXMuaXNOdWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY29sdW1uUHJvcGVydGllcyA9IGJhc2VQcm9wZXJ0aWVzO1xuICAgICAgICB2YXIgaGVhZGVyUm93Q291bnQgPSBiZWhhdmlvci5nZXRIZWFkZXJSb3dDb3VudCgpO1xuICAgICAgICAvL3ZhciBoZWFkZXJDb2x1bW5Db3VudCA9IGJlaGF2aW9yLmdldEhlYWRlckNvbHVtbkNvdW50KCk7XG5cbiAgICAgICAgdmFyIGlzU2hvd1Jvd051bWJlcnMgPSBncmlkLmlzU2hvd1Jvd051bWJlcnMoKTtcbiAgICAgICAgdmFyIGlzSGVhZGVyUm93ID0gciA8IGhlYWRlclJvd0NvdW50O1xuICAgICAgICAvL3ZhciBpc0hlYWRlckNvbHVtbiA9IGMgPCBoZWFkZXJDb2x1bW5Db3VudDtcbiAgICAgICAgdmFyIGlzRmlsdGVyUm93ID0gZ3JpZC5pc0ZpbHRlclJvdyhyKTtcbiAgICAgICAgdmFyIGlzSGllcmFyY2h5Q29sdW1uID0gZ3JpZC5pc0hpZXJhcmNoeUNvbHVtbihjKTtcbiAgICAgICAgdmFyIGlzUm93U2VsZWN0ZWQgPSBncmlkLmlzUm93U2VsZWN0ZWQocik7XG4gICAgICAgIHZhciBpc0NvbHVtblNlbGVjdGVkID0gZ3JpZC5pc0NvbHVtblNlbGVjdGVkKGMpO1xuICAgICAgICB2YXIgaXNDZWxsU2VsZWN0ZWQgPSBncmlkLmlzQ2VsbFNlbGVjdGVkKGMsIHIpO1xuICAgICAgICB2YXIgaXNDZWxsU2VsZWN0ZWRJbkNvbHVtbiA9IGdyaWQuaXNDZWxsU2VsZWN0ZWRJbkNvbHVtbihjKTtcbiAgICAgICAgdmFyIGlzQ2VsbFNlbGVjdGVkSW5Sb3cgPSBncmlkLmlzQ2VsbFNlbGVjdGVkSW5Sb3cocik7XG4gICAgICAgIHZhciBhcmVBbGxSb3dzU2VsZWN0ZWQgPSBncmlkLmFyZUFsbFJvd3NTZWxlY3RlZCgpO1xuXG4gICAgICAgIHZhciBjZWxsUHJvcGVydGllcztcblxuICAgICAgICBpZiAoKGlzU2hvd1Jvd051bWJlcnMgJiYgYyA9PT0gLTEpIHx8IGlzSGllcmFyY2h5Q29sdW1uKSB7XG4gICAgICAgICAgICBpZiAoaXNSb3dTZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgIGJhc2VQcm9wZXJ0aWVzID0gYmFzZVByb3BlcnRpZXMucm93SGVhZGVyUm93U2VsZWN0aW9uO1xuICAgICAgICAgICAgICAgIGNlbGxQcm9wZXJ0aWVzID0gT2JqZWN0LmNyZWF0ZShiYXNlUHJvcGVydGllcyk7XG4gICAgICAgICAgICAgICAgY2VsbFByb3BlcnRpZXMuaXNTZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGJhc2VQcm9wZXJ0aWVzID0gYmFzZVByb3BlcnRpZXMucm93SGVhZGVyO1xuICAgICAgICAgICAgICAgIGNlbGxQcm9wZXJ0aWVzID0gT2JqZWN0LmNyZWF0ZShiYXNlUHJvcGVydGllcyk7XG4gICAgICAgICAgICAgICAgY2VsbFByb3BlcnRpZXMuaXNTZWxlY3RlZCA9IGlzQ2VsbFNlbGVjdGVkSW5Sb3c7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjZWxsUHJvcGVydGllcy5pc1VzZXJEYXRhQXJlYSA9IGZhbHNlO1xuICAgICAgICB9IGVsc2UgaWYgKGlzSGVhZGVyUm93KSB7XG4gICAgICAgICAgICBpZiAoaXNGaWx0ZXJSb3cpIHtcbiAgICAgICAgICAgICAgICBiYXNlUHJvcGVydGllcyA9IGJhc2VQcm9wZXJ0aWVzLmZpbHRlclByb3BlcnRpZXM7XG4gICAgICAgICAgICAgICAgY2VsbFByb3BlcnRpZXMgPSBPYmplY3QuY3JlYXRlKGJhc2VQcm9wZXJ0aWVzKTtcbiAgICAgICAgICAgICAgICBjZWxsUHJvcGVydGllcy5pc1NlbGVjdGVkID0gZmFsc2U7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzQ29sdW1uU2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICBiYXNlUHJvcGVydGllcyA9IGJhc2VQcm9wZXJ0aWVzLmNvbHVtbkhlYWRlckNvbHVtblNlbGVjdGlvbjtcbiAgICAgICAgICAgICAgICBjZWxsUHJvcGVydGllcyA9IE9iamVjdC5jcmVhdGUoYmFzZVByb3BlcnRpZXMpO1xuICAgICAgICAgICAgICAgIGNlbGxQcm9wZXJ0aWVzLmlzU2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBiYXNlUHJvcGVydGllcyA9IGJhc2VQcm9wZXJ0aWVzLmNvbHVtbkhlYWRlcjtcbiAgICAgICAgICAgICAgICBjZWxsUHJvcGVydGllcyA9IE9iamVjdC5jcmVhdGUoYmFzZVByb3BlcnRpZXMpO1xuICAgICAgICAgICAgICAgIGNlbGxQcm9wZXJ0aWVzLmlzU2VsZWN0ZWQgPSBpc0NlbGxTZWxlY3RlZEluQ29sdW1uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2VsbFByb3BlcnRpZXMuaXNVc2VyRGF0YUFyZWEgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0hpZXJhcmNoeUNvbHVtbikge1xuICAgICAgICAgICAgYmFzZVByb3BlcnRpZXMgPSBiYXNlUHJvcGVydGllcy5yb3dIZWFkZXI7XG4gICAgICAgICAgICBjZWxsUHJvcGVydGllcyA9IE9iamVjdC5jcmVhdGUoYmFzZVByb3BlcnRpZXMpO1xuICAgICAgICAgICAgY2VsbFByb3BlcnRpZXMuaXNTZWxlY3RlZCA9IGlzQ2VsbFNlbGVjdGVkSW5Sb3c7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjZWxsUHJvcGVydGllcyA9IE9iamVjdC5jcmVhdGUoYmFzZVByb3BlcnRpZXMpO1xuICAgICAgICAgICAgY2VsbFByb3BlcnRpZXMuaXNTZWxlY3RlZCA9IGlzQ2VsbFNlbGVjdGVkIHx8IGlzUm93U2VsZWN0ZWQgfHwgaXNDb2x1bW5TZWxlY3RlZDtcbiAgICAgICAgICAgIGNlbGxQcm9wZXJ0aWVzLmlzVXNlckRhdGFBcmVhID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByb3dOdW0gPSByIC0gaGVhZGVyUm93Q291bnQgKyAxO1xuXG4gICAgICAgIGlmIChjID09PSAtMSkge1xuICAgICAgICAgICAgdmFyIGNoZWNrZWRJbWFnZSA9IGlzUm93U2VsZWN0ZWQgPyAnY2hlY2tlZCcgOiAndW5jaGVja2VkJztcbiAgICAgICAgICAgIGNlbGxQcm9wZXJ0aWVzLnZhbHVlID0gaXNIZWFkZXJSb3cgPyAnJyA6IFtiZWhhdmlvci5nZXRJbWFnZShjaGVja2VkSW1hZ2UpLCByb3dOdW0sIG51bGxdO1xuICAgICAgICAgICAgaWYgKHIgPT09IDApIHtcbiAgICAgICAgICAgICAgICBjaGVja2VkSW1hZ2UgPSBhcmVBbGxSb3dzU2VsZWN0ZWQgPyAnY2hlY2tlZCcgOiAndW5jaGVja2VkJztcbiAgICAgICAgICAgICAgICBjZWxsUHJvcGVydGllcy52YWx1ZSA9IFtiZWhhdmlvci5nZXRJbWFnZShjaGVja2VkSW1hZ2UpLCAnJywgbnVsbF07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGlzRmlsdGVyUm93KSB7XG4gICAgICAgICAgICAgICAgY2VsbFByb3BlcnRpZXMudmFsdWUgPSBbYmVoYXZpb3IuZ2V0SW1hZ2UoJ2ZpbHRlci1vZmYnKSwgJycsIG51bGxdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2VsbFByb3BlcnRpZXMuaGFsaWduID0gJ3JpZ2h0JztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNlbGxQcm9wZXJ0aWVzLnZhbHVlID0gZ3JpZC5nZXRWYWx1ZShjLCByKTtcbiAgICAgICAgICAgIGNlbGxQcm9wZXJ0aWVzLmhhbGlnbiA9IGdyaWQuZ2V0Q29sdW1uQWxpZ25tZW50KGMpO1xuICAgICAgICB9XG4gICAgICAgIGNlbGxQcm9wZXJ0aWVzLmlzQ29sdW1uSG92ZXJlZCA9IHRoaXMuaXNSb3dIb3ZlcmVkKGMsIHIpO1xuICAgICAgICBjZWxsUHJvcGVydGllcy5pc1Jvd0hvdmVyZWQgPSB0aGlzLmlzQ29sdW1uSG92ZXJlZChjLCByKTtcbiAgICAgICAgY2VsbFByb3BlcnRpZXMuYm91bmRzID0gdGhpcy5fZ2V0Qm91bmRzT2ZDZWxsKGMsIHIpO1xuICAgICAgICBjZWxsUHJvcGVydGllcy5pc0NlbGxTZWxlY3RlZCA9IGlzQ2VsbFNlbGVjdGVkO1xuICAgICAgICBjZWxsUHJvcGVydGllcy5pc1Jvd1NlbGVjdGVkID0gaXNSb3dTZWxlY3RlZDtcbiAgICAgICAgY2VsbFByb3BlcnRpZXMuaXNDb2x1bW5TZWxlY3RlZCA9IGlzQ29sdW1uU2VsZWN0ZWQ7XG4gICAgICAgIGNlbGxQcm9wZXJ0aWVzLmlzSW5DdXJyZW50U2VsZWN0aW9uUmVjdGFuZ2xlID0gZ3JpZC5pc0luQ3VycmVudFNlbGVjdGlvblJlY3RhbmdsZShjLCByKTtcblxuICAgICAgICB2YXIgbW91c2VEb3duU3RhdGUgPSBncmlkLm1vdXNlRG93blN0YXRlO1xuICAgICAgICBpZiAobW91c2VEb3duU3RhdGUpIHtcbiAgICAgICAgICAgIHZhciBwb2ludCA9IG1vdXNlRG93blN0YXRlLmdyaWRDZWxsO1xuICAgICAgICAgICAgY2VsbFByb3BlcnRpZXMubW91c2VEb3duID0gcG9pbnQueCA9PT0gYyAmJiBwb2ludC55ID09PSByO1xuICAgICAgICB9XG5cbiAgICAgICAgY2VsbFByb3BlcnRpZXMueCA9IGM7XG4gICAgICAgIGNlbGxQcm9wZXJ0aWVzLnkgPSByO1xuXG4gICAgICAgIGJlaGF2aW9yLmNlbGxQcm9wZXJ0aWVzUHJlUGFpbnROb3RpZmljYXRpb24oY2VsbFByb3BlcnRpZXMpO1xuXG4gICAgICAgIHZhciBjZWxsID0gYmVoYXZpb3IuZ2V0Q2VsbFJlbmRlcmVyKGNlbGxQcm9wZXJ0aWVzLCBjLCByKTtcbiAgICAgICAgdmFyIG92ZXJyaWRlcyA9IGJlaGF2aW9yLmdldENlbGxQcm9wZXJ0aWVzKGMsIHIpO1xuXG4gICAgICAgIC8vZGVjbGFyYXRpdmUgY2VsbCBwcm9wZXJ0aWVzXG4gICAgICAgIF8oY2VsbFByb3BlcnRpZXMpLmV4dGVuZE93bihvdmVycmlkZXMpO1xuXG4gICAgICAgIC8vYWxsb3cgdGhlIHJlbmRlcmVyIHRvIGlkZW50aWZ5IGl0c2VsZiBpZiBpdCdzIGEgYnV0dG9uXG4gICAgICAgIGNlbGxQcm9wZXJ0aWVzLmJ1dHRvbkNlbGxzID0gdGhpcy5idXR0b25DZWxscztcblxuICAgICAgICBjZWxsLnBhaW50KGdjLCBjZWxsUHJvcGVydGllcyk7XG5cbiAgICAgICAgdGhpcy5yZW5kZXJlZENvbHVtbk1pbldpZHRoc1tjXSA9IE1hdGgubWF4KGNlbGxQcm9wZXJ0aWVzLm1pbldpZHRoIHx8IDAsIHRoaXMucmVuZGVyZWRDb2x1bW5NaW5XaWR0aHNbY10pO1xuICAgICAgICBjb2x1bW5Qcm9wZXJ0aWVzLnByZWZlcnJlZFdpZHRoID0gdGhpcy5yZW5kZXJlZENvbHVtbk1pbldpZHRoc1tjXTtcbiAgICB9LFxuXG4gICAgaXNWaWV3YWJsZUJ1dHRvbjogZnVuY3Rpb24oYywgcikge1xuICAgICAgICB2YXIga2V5ID0gYyArICcsJyArIHI7XG4gICAgICAgIHJldHVybiB0aGlzLmJ1dHRvbkNlbGxzW2tleV0gPT09IHRydWU7XG4gICAgfSxcblxuICAgIGdldFJvd051bWJlcnNXaWR0aDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjb2xFZGdlcyA9IHRoaXMuZ2V0Q29sdW1uRWRnZXMoKTtcbiAgICAgICAgaWYgKGNvbEVkZ2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbEVkZ2VzWzBdO1xuICAgIH0sXG5cbiAgICBzdGFydEFuaW1hdG9yOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGFuaW1hdGU7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgYW5pbWF0ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgc2VsZi5hbmltYXRlKCk7XG4gICAgICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoYW5pbWF0ZSk7XG4gICAgICAgIH07XG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShhbmltYXRlKTtcbiAgICB9LFxuXG4gICAgYW5pbWF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBjdHggPSB0aGlzLmdldENhbnZhcygpLmNhbnZhc0NUWDtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICB0aGlzLnJlbmRlckZvY3VzQ2VsbChjdHgpO1xuICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgfSxcblxuICAgIGdldEJvdW5kczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmJvdW5kcztcbiAgICB9LFxuXG4gICAgc2V0Qm91bmRzOiBmdW5jdGlvbihib3VuZHMpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmJvdW5kcyA9IGJvdW5kcyk7XG4gICAgfVxuXG59KTtcblxuZnVuY3Rpb24gc2V0TnVtYmVyQ29sdW1uV2lkdGgoZ2MsIGJlaGF2aW9yLCBtYXhSb3cpIHtcbiAgICB2YXIgY29sdW1uUHJvcGVydGllcyA9IGJlaGF2aW9yLmdldENvbHVtblByb3BlcnRpZXMoLTEpLFxuICAgICAgICBjZWxsUHJvcGVydGllcyA9IGNvbHVtblByb3BlcnRpZXMucm93SGVhZGVyLFxuICAgICAgICBpY29uID0gYmVoYXZpb3IuZ2V0SW1hZ2UoJ2NoZWNrZWQnKTtcblxuICAgIGdjLmZvbnQgPSBjZWxsUHJvcGVydGllcy5mb250O1xuXG4gICAgY29sdW1uUHJvcGVydGllcy5wcmVmZXJyZWRXaWR0aCA9IGljb24ud2lkdGggKyA3ICsgY2VsbFByb3BlcnRpZXMuZ2V0VGV4dFdpZHRoKGdjLCBtYXhSb3cgKyAxKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSZW5kZXJlcjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFJhbmdlU2VsZWN0aW9uTW9kZWwgPSByZXF1aXJlKCdzcGFyc2UtYm9vbGVhbi1hcnJheScpO1xuXG4vKipcbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBkZXNjIFdlIHJlcHJlc2VudCBzZWxlY3Rpb25zIGFzIGEgbGlzdCBvZiByZWN0YW5nbGVzIGJlY2F1c2UgbGFyZ2UgYXJlYXMgY2FuIGJlIHJlcHJlc2VudGVkIGFuZCB0ZXN0ZWQgYWdhaW5zdCBxdWlja2x5IHdpdGggYSBtaW5pbWFsIGFtb3VudCBvZiBtZW1vcnkgdXNhZ2UuIEFsc28gd2UgbmVlZCB0byBtYWludGFpbiB0aGUgc2VsZWN0aW9uIHJlY3RhbmdsZXMgZmxhdHRlbmVkIGNvdW50ZXIgcGFydHMgc28gd2UgY2FuIHRlc3QgZm9yIHNpbmdsZSBkaW1lbnNpb24gY29udGFpbnMuIFRoaXMgaXMgaG93IHdlIGtub3cgdG8gaGlnaGxpZ2h0IHRoZSBmaXhlZCByZWdpb25zIG9uIHRoZSBlZGdlcyBvZiB0aGUgZ3JpZC5cbiAqL1xuXG5mdW5jdGlvbiBTZWxlY3Rpb25Nb2RlbCgpIHtcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIHNlbGVjdGlvbnNcbiAgICAgKiBAdHlwZSB7UmVjdGFuZ2xlW119XG4gICAgICogQHN1bW1hcnkgVGhlIHNlbGVjdGlvbiByZWN0YW5nbGVzLlxuICAgICAqIEBkZXNjIENyZWF0ZWQgYXMgYW4gZW1wdHkgYXJyYXkgdXBvbiBpbnN0YW50aWF0aW9uIGJ5IHRoZSB7QGxpbmsgU2VsZWN0aW9uTW9kZWx8Y29uc3RydWN0b3J9LlxuICAgICAqIEBtZW1iZXJPZiBTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGVcbiAgICAgKi9cbiAgICB0aGlzLnNlbGVjdGlvbnMgPSBbXTtcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIGZsYXR0ZW5lZFhcbiAgICAgKiBAdHlwZSB7UmVjdGFuZ2xlW119XG4gICAgICogQHN1bW1hcnkgVGhlIHNlbGVjdGlvbiByZWN0YW5nbGVzIGZsYXR0ZW5lZCBpbiB0aGUgaG9yaXpvbnRhbCBkaXJlY3Rpb24gKG5vIHdpZHRoKS5cbiAgICAgKiBAZGVzYyBDcmVhdGVkIGFzIGFuIGVtcHR5IGFycmF5IHVwb24gaW5zdGFudGlhdGlvbiBieSB0aGUge0BsaW5rIFNlbGVjdGlvbk1vZGVsfGNvbnN0cnVjdG9yfS5cbiAgICAgKiBAbWVtYmVyT2YgU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlXG4gICAgICovXG4gICAgdGhpcy5mbGF0dGVuZWRYID0gW107XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSBmbGF0dGVuZWRZXG4gICAgICogQHR5cGUge1JlY3RhbmdsZVtdfVxuICAgICAqIEBzdW1tYXJ5IFRoZSBzZWxlY3Rpb24gcmVjdGFuZ2xlcyBmbGF0dGVuZWQgaW4gdGhlIHZlcnRpY2FsIGRpcmVjdGlvbiAobm8gaGVpZ2h0KS5cbiAgICAgKiBAZGVzYyBDcmVhdGVkIGFzIGFuIGVtcHR5IGFycmF5IHVwb24gaW5zdGFudGlhdGlvbiBieSB0aGUge0BsaW5rIFNlbGVjdGlvbk1vZGVsfGNvbnN0cnVjdG9yfS5cbiAgICAgKiBAbWVtYmVyT2YgU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlXG4gICAgICovXG4gICAgdGhpcy5mbGF0dGVuZWRZID0gW107XG5cbiAgICAvKipcbiAgICAgKiBAbmFtZSByb3dTZWxlY3Rpb25Nb2RlbFxuICAgICAqIEB0eXBlIHtSYW5nZVNlbGVjdGlvbk1vZGVsfVxuICAgICAqIEBzdW1tYXJ5IFRoZSBzZWxlY3Rpb24gcmVjdGFuZ2xlcy5cbiAgICAgKiBAZGVzYyBDcmVhdGVkIGFzIGEgbmV3IFJhbmdlU2VsZWN0aW9uTW9kZWwgdXBvbiBpbnN0YW50aWF0aW9uIGJ5IHRoZSB7QGxpbmsgU2VsZWN0aW9uTW9kZWx8Y29uc3RydWN0b3J9LlxuICAgICAqIEBtZW1iZXJPZiBTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGVcbiAgICAgKi9cbiAgICB0aGlzLnJvd1NlbGVjdGlvbk1vZGVsID0gbmV3IFJhbmdlU2VsZWN0aW9uTW9kZWwoKTtcblxuICAgIC8qKlxuICAgICAqIEBuYW1lIGNvbHVtblNlbGVjdGlvbk1vZGVsXG4gICAgICogQHR5cGUge1JhbmdlU2VsZWN0aW9uTW9kZWx9XG4gICAgICogQHN1bW1hcnkgVGhlIHNlbGVjdGlvbiByZWN0YW5nbGVzLlxuICAgICAqIEBkZXNjIENyZWF0ZWQgYXMgYSBuZXcgUmFuZ2VTZWxlY3Rpb25Nb2RlbCB1cG9uIGluc3RhbnRpYXRpb24gYnkgdGhlIHtAbGluayBTZWxlY3Rpb25Nb2RlbHxjb25zdHJ1Y3Rvcn0uXG4gICAgICogQG1lbWJlck9mIFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHRoaXMuY29sdW1uU2VsZWN0aW9uTW9kZWwgPSBuZXcgUmFuZ2VTZWxlY3Rpb25Nb2RlbCgpO1xuXG4gICAgdGhpcy5zZXRMYXN0U2VsZWN0aW9uVHlwZSgnJyk7XG59XG5cblNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZSA9IHtcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBtZW1iZXJPZiBTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBhbGxSb3dzU2VsZWN0ZWQ6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGdldHRlciBmb3IgdGhlIFtmaW4taHlwZXJncmlkXShtb2R1bGUtLl9maW4taHlwZXJncmlkLmh0bWwpXG4gICAgICogIyMjIyByZXR1cm5zOiBmaW4taHlwZXJncmlkXG4gICAgICovXG4gICAgZ2V0R3JpZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgZ2V0TGFzdFNlbGVjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzZWxzID0gdGhpcy5zZWxlY3Rpb25zO1xuICAgICAgICB2YXIgc2VsID0gc2Vsc1tzZWxzLmxlbmd0aCAtIDFdO1xuICAgICAgICByZXR1cm4gc2VsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgZ2V0TGFzdFNlbGVjdGlvblR5cGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sYXN0U2VsZWN0aW9uVHlwZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHR5cGVcbiAgICAgKiBAbWVtYmVyT2YgU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlXG4gICAgICovXG4gICAgc2V0TGFzdFNlbGVjdGlvblR5cGU6IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgICAgdGhpcy5sYXN0U2VsZWN0aW9uVHlwZSA9IHR5cGU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGVcbiAgICAgKiBAZGVzY3JpcHRpb24gU2VsZWN0IHRoZSByZWdpb24gZGVzY3JpYmVkIGJ5IHRoZSBnaXZlbiBjb29yZGluYXRlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBveCAtIG9yaWdpbiB4IGNvb3JkaW5hdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb3kgLSBvcmlnaW4geSBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGV4IC0gZXh0ZW50IHggY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBleSAtIGV4dGVudCB5IGNvb3JkaW5hdGVcbiAgICAgKi9cbiAgICBzZWxlY3Q6IGZ1bmN0aW9uKG94LCBveSwgZXgsIGV5KSB7XG4gICAgICAgIHZhciBuZXdTZWxlY3Rpb24gPSB0aGlzLmdldEdyaWQoKS5uZXdSZWN0YW5nbGUob3gsIG95LCBleCwgZXkpO1xuICAgICAgICB0aGlzLnNlbGVjdGlvbnMucHVzaChuZXdTZWxlY3Rpb24pO1xuICAgICAgICB0aGlzLmZsYXR0ZW5lZFgucHVzaChuZXdTZWxlY3Rpb24uZmxhdHRlblhBdCgwKSk7XG4gICAgICAgIHRoaXMuZmxhdHRlbmVkWS5wdXNoKG5ld1NlbGVjdGlvbi5mbGF0dGVuWUF0KDApKTtcbiAgICAgICAgdGhpcy5zZXRMYXN0U2VsZWN0aW9uVHlwZSgnY2VsbCcpO1xuICAgICAgICB0aGlzLmdldEdyaWQoKS5zZWxlY3Rpb25DaGFuZ2VkKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb3ggLSBvcmlnaW4geCBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG95IC0gb3JpZ2luIHkgY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBleCAtIGV4dGVudCB4IGNvb3JkaW5hdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZXkgLSBleHRlbnQgeSBjb29yZGluYXRlXG4gICAgICovXG4gICAgdG9nZ2xlU2VsZWN0OiBmdW5jdGlvbihveCwgb3ksIGV4LCBleSkge1xuXG4gICAgICAgIHZhciBzZWxlY3RlZCwgaW5kZXg7XG5cbiAgICAgICAgc2VsZWN0ZWQgPSB0aGlzLnNlbGVjdGlvbnMuZmluZChmdW5jdGlvbihzZWxlY3Rpb24sIGlkeCkge1xuICAgICAgICAgICAgaW5kZXggPSBpZHg7XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIHNlbGVjdGlvbi5vcmlnaW4ueCA9PT0gb3ggJiYgc2VsZWN0aW9uLm9yaWdpbi55ID09PSBveSAmJlxuICAgICAgICAgICAgICAgIHNlbGVjdGlvbi5leHRlbnQueCA9PT0gZXggJiYgc2VsZWN0aW9uLmV4dGVudC55ID09PSBleVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKHNlbGVjdGVkKSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdGlvbnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgIHRoaXMuZmxhdHRlbmVkWC5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgdGhpcy5mbGF0dGVuZWRZLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICB0aGlzLmdldEdyaWQoKS5zZWxlY3Rpb25DaGFuZ2VkKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNlbGVjdChveCwgb3ksIGV4LCBleSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIFJlbW92ZSB0aGUgbGFzdCBzZWxlY3Rpb24gdGhhdCB3YXMgY3JlYXRlZC5cbiAgICAgKi9cbiAgICBjbGVhck1vc3RSZWNlbnRTZWxlY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmFsbFJvd3NTZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnNlbGVjdGlvbnMubGVuZ3RoID0gTWF0aC5tYXgoMCwgdGhpcy5zZWxlY3Rpb25zLmxlbmd0aCAtIDEpO1xuICAgICAgICB0aGlzLmZsYXR0ZW5lZFgubGVuZ3RoID0gTWF0aC5tYXgoMCwgdGhpcy5mbGF0dGVuZWRYLmxlbmd0aCAtIDEpO1xuICAgICAgICB0aGlzLmZsYXR0ZW5lZFkubGVuZ3RoID0gTWF0aC5tYXgoMCwgdGhpcy5mbGF0dGVuZWRZLmxlbmd0aCAtIDEpO1xuICAgICAgICAvL3RoaXMuZ2V0R3JpZCgpLnNlbGVjdGlvbkNoYW5nZWQoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGNsZWFyTW9zdFJlY2VudENvbHVtblNlbGVjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuY29sdW1uU2VsZWN0aW9uTW9kZWwuY2xlYXJNb3N0UmVjZW50U2VsZWN0aW9uKCk7XG4gICAgICAgIHRoaXMuc2V0TGFzdFNlbGVjdGlvblR5cGUoJ2NvbHVtbicpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlXG4gICAgICovXG4gICAgY2xlYXJNb3N0UmVjZW50Um93U2VsZWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5yb3dTZWxlY3Rpb25Nb2RlbC5jbGVhck1vc3RSZWNlbnRTZWxlY3Rpb24oKTtcbiAgICAgICAgdGhpcy5zZXRMYXN0U2VsZWN0aW9uVHlwZSgncm93Jyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBjbGVhclJvd1NlbGVjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMucm93U2VsZWN0aW9uTW9kZWwuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5zZXRMYXN0U2VsZWN0aW9uVHlwZSgncm93Jyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBnZXRTZWxlY3Rpb25zOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0aW9ucztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBUaGVyZSBhcmUgYWN0aXZlIHNlbGVjdGlvbihzKS5cbiAgICAgKi9cbiAgICBoYXNTZWxlY3Rpb25zOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0aW9ucy5sZW5ndGggIT09IDA7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBoYXNSb3dTZWxlY3Rpb25zOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLnJvd1NlbGVjdGlvbk1vZGVsLmlzRW1wdHkoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGhhc0NvbHVtblNlbGVjdGlvbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuY29sdW1uU2VsZWN0aW9uTW9kZWwuaXNFbXB0eSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gU2VsZWN0aW9uIGNvdmVycyBhIHNwZWNpZmljIGNvbHVtbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgICAqL1xuICAgIGlzQ2VsbFNlbGVjdGVkSW5Sb3c6IGZ1bmN0aW9uKHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lzQ2VsbFNlbGVjdGVkKHRoaXMuZmxhdHRlbmVkWCwgMCwgeSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyBTZWxlY3Rpb24gY292ZXJzIGEgc3BlY2lmaWMgcm93LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAgICovXG4gICAgaXNDZWxsU2VsZWN0ZWRJbkNvbHVtbjogZnVuY3Rpb24oeCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXNDZWxsU2VsZWN0ZWQodGhpcy5mbGF0dGVuZWRZLCB4LCAwKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZVxuICAgICAqIEBzdW1tYXJ5IFNlbGVjdGlvbiBxdWVyeSBmdW5jdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVGhlIGdpdmVuIGNlbGwgaXMgc2VsZWN0ZWQgKHBhcnQgb2YgYW4gYWN0aXZlIHNlbGVjdGlvbikuXG4gICAgICogQHBhcmFtIHtSZWN0YW5nbGVbXX0gc2VsZWN0aW9ucyAtIFNlbGVjdGlvbiByZWN0YW5nbGVzIHRvIHNlYXJjaCB0aHJvdWdoLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHlcbiAgICAgKi9cbiAgICBpc1NlbGVjdGVkOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICB0aGlzLmlzQ29sdW1uU2VsZWN0ZWQoeCkgfHxcbiAgICAgICAgICAgIHRoaXMuaXNSb3dTZWxlY3RlZCh5KSB8fFxuICAgICAgICAgICAgdGhpcy5faXNDZWxsU2VsZWN0ZWQodGhpcy5zZWxlY3Rpb25zLCB4LCB5KVxuICAgICAgICApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHhcbiAgICAgKiBAcGFyYW0geVxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGlzQ2VsbFNlbGVjdGVkOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pc0NlbGxTZWxlY3RlZCh0aGlzLnNlbGVjdGlvbnMsIHgsIHkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHNlbGVjdGlvbnNcbiAgICAgKiBAcGFyYW0geFxuICAgICAqIEBwYXJhbSB5XG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfaXNDZWxsU2VsZWN0ZWQ6IGZ1bmN0aW9uKHNlbGVjdGlvbnMsIHgsIHkpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICByZXR1cm4gISFzZWxlY3Rpb25zLmZpbmQoZnVuY3Rpb24oc2VsZWN0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VsZi5yZWN0YW5nbGVDb250YWlucyhzZWxlY3Rpb24sIHgsIHkpO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGVtcHR5IG91dCBhbGwgb3VyIHN0YXRlXG4gICAgICpcbiAgICAgKi9cbiAgICBjbGVhcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuYWxsUm93c1NlbGVjdGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuc2VsZWN0aW9ucy5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLmZsYXR0ZW5lZFgubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5mbGF0dGVuZWRZLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXMucm93U2VsZWN0aW9uTW9kZWwuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5jb2x1bW5TZWxlY3Rpb25Nb2RlbC5jbGVhcigpO1xuICAgICAgICAvL3RoaXMuZ2V0R3JpZCgpLnNlbGVjdGlvbkNoYW5nZWQoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBveCAtIG9yaWdpbiB4IGNvb3JkaW5hdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb3kgLSBvcmlnaW4geSBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGV4IC0gZXh0ZW50IHggY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBleSAtIGV4dGVudCB5IGNvb3JkaW5hdGVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBpc1JlY3RhbmdsZVNlbGVjdGVkOiBmdW5jdGlvbihveCwgb3ksIGV4LCBleSkge1xuICAgICAgICByZXR1cm4gISF0aGlzLnNlbGVjdGlvbnMuZmluZChmdW5jdGlvbihzZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uLm9yaWdpbi54ID09PSBveCAmJiBzZWxlY3Rpb24ub3JpZ2luLnkgPT09IG95ICYmXG4gICAgICAgICAgICAgICAgc2VsZWN0aW9uLmV4dGVudC54ID09PSBleCAmJiBzZWxlY3Rpb24uZXh0ZW50LnkgPT09IGV5XG4gICAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB4XG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgaXNDb2x1bW5TZWxlY3RlZDogZnVuY3Rpb24oeCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb2x1bW5TZWxlY3Rpb25Nb2RlbC5pc1NlbGVjdGVkKHgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHlcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbnwqfVxuICAgICAqL1xuICAgIGlzUm93U2VsZWN0ZWQ6IGZ1bmN0aW9uKHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWxsUm93c1NlbGVjdGVkIHx8IHRoaXMucm93U2VsZWN0aW9uTW9kZWwuaXNTZWxlY3RlZCh5KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB4MVxuICAgICAqIEBwYXJhbSB4MlxuICAgICAqL1xuICAgIHNlbGVjdENvbHVtbjogZnVuY3Rpb24oeDEsIHgyKSB7XG4gICAgICAgIHRoaXMuY29sdW1uU2VsZWN0aW9uTW9kZWwuc2VsZWN0KHgxLCB4Mik7XG4gICAgICAgIHRoaXMuc2V0TGFzdFNlbGVjdGlvblR5cGUoJ2NvbHVtbicpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlXG4gICAgICovXG4gICAgc2VsZWN0QWxsUm93czogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5hbGxSb3dzU2VsZWN0ZWQgPSB0cnVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgYXJlQWxsUm93c1NlbGVjdGVkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWxsUm93c1NlbGVjdGVkO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHkxXG4gICAgICogQHBhcmFtIHkyXG4gICAgICovXG4gICAgc2VsZWN0Um93OiBmdW5jdGlvbih5MSwgeTIpIHtcbiAgICAgICAgdGhpcy5yb3dTZWxlY3Rpb25Nb2RlbC5zZWxlY3QoeTEsIHkyKTtcbiAgICAgICAgdGhpcy5zZXRMYXN0U2VsZWN0aW9uVHlwZSgncm93Jyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0geDFcbiAgICAgKiBAcGFyYW0geDJcbiAgICAgKi9cbiAgICBkZXNlbGVjdENvbHVtbjogZnVuY3Rpb24oeDEsIHgyKSB7XG4gICAgICAgIHRoaXMuY29sdW1uU2VsZWN0aW9uTW9kZWwuZGVzZWxlY3QoeDEsIHgyKTtcbiAgICAgICAgdGhpcy5zZXRMYXN0U2VsZWN0aW9uVHlwZSgnY29sdW1uJyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0geTFcbiAgICAgKiBAcGFyYW0geTJcbiAgICAgKi9cbiAgICBkZXNlbGVjdFJvdzogZnVuY3Rpb24oeTEsIHkyKSB7XG4gICAgICAgIHRoaXMucm93U2VsZWN0aW9uTW9kZWwuZGVzZWxlY3QoeTEsIHkyKTtcbiAgICAgICAgdGhpcy5zZXRMYXN0U2VsZWN0aW9uVHlwZSgncm93Jyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBnZXRTZWxlY3RlZFJvd3M6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5hcmVBbGxSb3dzU2VsZWN0ZWQoKSkge1xuICAgICAgICAgICAgdmFyIGdyaWQgPSB0aGlzLmdldEdyaWQoKTtcbiAgICAgICAgICAgIHZhciBoZWFkZXJSb3dzID0gZ3JpZC5nZXRIZWFkZXJSb3dDb3VudCgpO1xuICAgICAgICAgICAgdmFyIHJvd0NvdW50ID0gZ3JpZC5nZXRSb3dDb3VudCgpIC0gaGVhZGVyUm93cztcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBuZXcgQXJyYXkocm93Q291bnQpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByb3dDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0W2ldID0gaSArIGhlYWRlclJvd3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnJvd1NlbGVjdGlvbk1vZGVsLmdldFNlbGVjdGlvbnMoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFNlbGVjdGlvbk1vZGVsLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHsqfEFycmF5LkFycmF5Lm51bWJlcn1cbiAgICAgKi9cbiAgICBnZXRTZWxlY3RlZENvbHVtbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb2x1bW5TZWxlY3Rpb25Nb2RlbC5nZXRTZWxlY3Rpb25zKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICAgaXNDb2x1bW5PclJvd1NlbGVjdGVkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLmNvbHVtblNlbGVjdGlvbk1vZGVsLmlzRW1wdHkoKSB8fCAhdGhpcy5yb3dTZWxlY3Rpb25Nb2RlbC5pc0VtcHR5KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9XG4gICAgICovXG4gICAgZ2V0RmxhdHRlbmVkWXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgIHZhciBzZXQgPSB7fTtcbiAgICAgICAgdGhpcy5zZWxlY3Rpb25zLmZvckVhY2goZnVuY3Rpb24oc2VsZWN0aW9uKSB7XG4gICAgICAgICAgICB2YXIgdG9wID0gc2VsZWN0aW9uLm9yaWdpbi55O1xuICAgICAgICAgICAgdmFyIHNpemUgPSBzZWxlY3Rpb24uZXh0ZW50LnkgKyAxO1xuICAgICAgICAgICAgZm9yICh2YXIgciA9IDA7IHIgPCBzaXplOyByKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgdGkgPSByICsgdG9wO1xuICAgICAgICAgICAgICAgIGlmICghc2V0W3RpXSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh0aSk7XG4gICAgICAgICAgICAgICAgICAgIHNldFt0aV0gPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJlc3VsdC5zb3J0KGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgICAgIHJldHVybiB4IC0geTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0gb2Zmc2V0XG4gICAgICovXG4gICAgc2VsZWN0Um93c0Zyb21DZWxsczogZnVuY3Rpb24ob2Zmc2V0KSB7XG4gICAgICAgIG9mZnNldCA9IG9mZnNldCB8fCAwO1xuXG4gICAgICAgIHZhciBzbSA9IHRoaXMucm93U2VsZWN0aW9uTW9kZWw7XG4gICAgICAgIHRoaXMuYWxsUm93c1NlbGVjdGVkID0gZmFsc2U7XG4gICAgICAgIHNtLmNsZWFyKCk7XG5cbiAgICAgICAgdGhpcy5zZWxlY3Rpb25zLmZvckVhY2goZnVuY3Rpb24oc2VsZWN0aW9uKSB7XG4gICAgICAgICAgICB2YXIgdG9wID0gc2VsZWN0aW9uLm9yaWdpbi55LFxuICAgICAgICAgICAgICAgIHNpemUgPSBzZWxlY3Rpb24uZXh0ZW50Lnk7XG4gICAgICAgICAgICBzbS5zZWxlY3QodG9wICsgb2Zmc2V0LCB0b3AgKyBzaXplICsgb2Zmc2V0KTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0gb2Zmc2V0XG4gICAgICovXG4gICAgc2VsZWN0Q29sdW1uc0Zyb21DZWxsczogZnVuY3Rpb24ob2Zmc2V0KSB7XG4gICAgICAgIG9mZnNldCA9IG9mZnNldCB8fCAwO1xuXG4gICAgICAgIHZhciBzbSA9IHRoaXMuY29sdW1uU2VsZWN0aW9uTW9kZWw7XG4gICAgICAgIHNtLmNsZWFyKCk7XG5cbiAgICAgICAgdGhpcy5zZWxlY3Rpb25zLmZvckVhY2goZnVuY3Rpb24oc2VsZWN0aW9uKSB7XG4gICAgICAgICAgICB2YXIgbGVmdCA9IHNlbGVjdGlvbi5vcmlnaW4ueDtcbiAgICAgICAgICAgIHZhciBzaXplID0gc2VsZWN0aW9uLmV4dGVudC54O1xuICAgICAgICAgICAgc20uc2VsZWN0KGxlZnQgKyBvZmZzZXQsIGxlZnQgKyBzaXplICsgb2Zmc2V0KTtcbiAgICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBTZWxlY3Rpb25Nb2RlbC5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0geFxuICAgICAqIEBwYXJhbSB5XG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgaXNJbkN1cnJlbnRTZWxlY3Rpb25SZWN0YW5nbGU6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgdmFyIGxhc3QgPSB0aGlzLnNlbGVjdGlvbnNbdGhpcy5zZWxlY3Rpb25zLmxlbmd0aCAtIDFdO1xuICAgICAgICByZXR1cm4gbGFzdCAmJiB0aGlzLnJlY3RhbmdsZUNvbnRhaW5zKGxhc3QsIHgsIHkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgU2VsZWN0aW9uTW9kZWwucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHJlY3RcbiAgICAgKiBAcGFyYW0geFxuICAgICAqIEBwYXJhbSB5XG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgcmVjdGFuZ2xlQ29udGFpbnM6IGZ1bmN0aW9uKHJlY3QsIHgsIHkpIHsgLy9UT0RPOiBleHBsb3JlIHdoeSB0aGlzIHdvcmtzIGFuZCBjb250YWlucyBvbiByZWN0YW5nbHVsYXIgZG9lcyBub3RcbiAgICAgICAgdmFyIG1pblggPSByZWN0Lm9yaWdpbi54O1xuICAgICAgICB2YXIgbWluWSA9IHJlY3Qub3JpZ2luLnk7XG4gICAgICAgIHZhciBtYXhYID0gbWluWCArIHJlY3QuZXh0ZW50Lng7XG4gICAgICAgIHZhciBtYXhZID0gbWluWSArIHJlY3QuZXh0ZW50Lnk7XG5cbiAgICAgICAgaWYgKHJlY3QuZXh0ZW50LnggPCAwKSB7XG4gICAgICAgICAgICBtaW5YID0gbWF4WDtcbiAgICAgICAgICAgIG1heFggPSByZWN0Lm9yaWdpbi54O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlY3QuZXh0ZW50LnkgPCAwKSB7XG4gICAgICAgICAgICBtaW5ZID0gbWF4WTtcbiAgICAgICAgICAgIG1heFkgPSByZWN0Lm9yaWdpbi55O1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlc3VsdCA9XG4gICAgICAgICAgICB4ID49IG1pblggJiZcbiAgICAgICAgICAgIHkgPj0gbWluWSAmJlxuICAgICAgICAgICAgeCA8PSBtYXhYICYmXG4gICAgICAgICAgICB5IDw9IG1heFk7XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNlbGVjdGlvbk1vZGVsO1xuIiwiLyogZXNsaW50LWVudiBicm93c2VyICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIF8gPSByZXF1aXJlKCdvYmplY3QtaXRlcmF0b3JzJyk7XG52YXIgQmFzZSA9IHJlcXVpcmUoJ2V4dGVuZC1tZScpLkJhc2U7XG5cbnZhciBDb2x1bW4gPSByZXF1aXJlKCcuL0NvbHVtbicpO1xudmFyIGltYWdlcyA9IHJlcXVpcmUoJy4vaW1hZ2VzJyk7XG52YXIgQ2VsbFByb3ZpZGVyID0gcmVxdWlyZSgnLi4vQ2VsbFByb3ZpZGVyJyk7XG5cbnZhciBub0V4cG9ydFByb3BlcnRpZXMgPSBbXG4gICAgJ2NvbHVtbkhlYWRlcicsXG4gICAgJ2NvbHVtbkhlYWRlckNvbHVtblNlbGVjdGlvbicsXG4gICAgJ2ZpbHRlclByb3BlcnRpZXMnLFxuICAgICdyb3dIZWFkZXInLFxuICAgICdyb3dIZWFkZXJSb3dTZWxlY3Rpb24nLFxuICAgICdyb3dOdW1iZXJzUHJvcGVydGllcycsXG4gICAgJ3RyZWVDb2x1bW5Qcm9wZXJ0aWVzJyxcbiAgICAndHJlZUNvbHVtblByb3BlcnRpZXNDb2x1bW5TZWxlY3Rpb24nLFxuXTtcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBkZXNjIFRoaXMgaXMgdGhlIGJhc2UgY2xhc3MgZm9yIGNyZWF0aW5nIGJlaGF2aW9ycy4gIGEgYmVoYXZpb3IgY2FuIGJlIHRob3VnaHQgb2YgYXMgYSBtb2RlbCsrLlxuaXQgY29udGFpbnMgYWxsIGNvZGUvZGF0YSB0aGF0J3MgbmVjZXNzYXJ5IGZvciBlYXNpbHkgaW1wbGVtZW50aW5nIGEgdmlydHVhbCBkYXRhIHNvdXJjZSBhbmQgaXQncyBtYW5pcHVsYXRpb24vYW5hbHl0aWNzXG4gKi9cbnZhciBCZWhhdmlvciA9IEJhc2UuZXh0ZW5kKCdCZWhhdmlvcicsIHtcblxuICAgIC8qKlxuICAgICAqIEBkZXNjIHRoaXMgaXMgdGhlIGNhbGxiYWNrIGZvciB0aGUgcGx1Z2luIHBhdHRlcm4gb2YgbmVzdGVkIHRhZ3NcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihncmlkKSB7IC8vZm9ybWVybHkgaW5zdGFsbE9uXG4gICAgICAgIGdyaWQuc2V0QmVoYXZpb3IodGhpcyk7XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZUZlYXR1cmVDaGFpbihncmlkKTtcblxuICAgICAgICB0aGlzLmdldERhdGFNb2RlbCgpO1xuICAgICAgICB0aGlzLmNlbGxQcm92aWRlciA9IHRoaXMuY3JlYXRlQ2VsbFByb3ZpZGVyKCk7XG4gICAgICAgIHRoaXMucmVuZGVyZWRDb2x1bW5Db3VudCA9IDMwO1xuICAgICAgICB0aGlzLnJlbmRlcmVkUm93Q291bnQgPSA2MDtcbiAgICAgICAgdGhpcy5kYXRhVXBkYXRlcyA9IHt9OyAvL2ZvciBvdmVycmlkaW5nIHdpdGggZWRpdCB2YWx1ZXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBkZXNjIGNyZWF0ZSB0aGUgZmVhdHVyZSBjaGFpbiAtIHRoaXMgaXMgdGhlIFtjaGFpbiBvZiByZXNwb25zaWJpbGl0eV0oaHR0cDovL2MyLmNvbS9jZ2kvd2lraT9DaGFpbk9mUmVzcG9uc2liaWxpdHlQYXR0ZXJuKSBwYXR0ZXJuLlxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGluaXRpYWxpemVGZWF0dXJlQ2hhaW46IGZ1bmN0aW9uKGdyaWQpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB0aGlzLmZlYXR1cmVzLmZvckVhY2goZnVuY3Rpb24oRmVhdHVyZUNvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICBzZWxmLnNldE5leHRGZWF0dXJlKG5ldyBGZWF0dXJlQ29uc3RydWN0b3IpO1xuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmZlYXR1cmVDaGFpbi5pbml0aWFsaXplT24oZ3JpZCk7XG4gICAgfSxcblxuICAgIGZlYXR1cmVzOiBbXSwgLy8gaW4gY2FzZSBpbXBsZW1lbnRpbmcgY2xhc3MgaGFzIG5vIGZlYXR1cmVzIFRPRE86IFdpbGwgdGhpcyBldmVyIGhhcHBlbj9cblxuICAgIC8qKlxuICAgICAqIG1lbWVudG8gZm9yIHRoZSB1c2VyIGNvbmZpZ3VyZWQgdmlzdWFsIHByb3BlcnRpZXMgb2YgdGhlIHRhYmxlXG4gICAgICogQHR5cGUge29iamVjdH1cbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICovXG4gICAgdGFibGVTdGF0ZTogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIEB0eXBlIHtIeXBlcmdyaWR9XG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGdyaWQ6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBsaXN0IG9mIGRlZmF1bHQgY2VsbCBlZGl0b3IgbmFtZXNcbiAgICAgKiBAdHlwZSB7c3RyaW5nW119XG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGVkaXRvclR5cGVzOiBbJ2Nob2ljZScsICd0ZXh0ZmllbGQnLCAnY29sb3InLCAnc2xpZGVyJywgJ3NwaW5uZXInLCAnZGF0ZSddLFxuXG4gICAgLyoqXG4gICAgICogY29udHJvbGxlciBjaGFpbiBvZiBjb21tYW5kXG4gICAgICogQHR5cGUge29iamVjdH1cbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICovXG4gICAgZmVhdHVyZUNoYWluOiBudWxsLFxuXG4gICAgZGF0YU1vZGVsOiBudWxsLFxuICAgIGJhc2VNb2RlbDogbnVsbCxcblxuICAgIHNjcm9sbFBvc2l0aW9uWDogMCxcbiAgICBzY3JvbGxQb3NpdGlvblk6IDAsXG5cbiAgICBmZWF0dXJlTWFwOiB7fSxcbiAgICBhbGxDb2x1bW5zOiBbXSxcbiAgICBjb2x1bW5zOiBbXSxcblxuICAgIHJlc2V0OiBmdW5jdGlvbigpIHtcblxuICAgICAgICB0aGlzLmNlbGxQcm92aWRlciA9IHRoaXMuY3JlYXRlQ2VsbFByb3ZpZGVyKCk7XG4gICAgICAgIHRoaXMucmVuZGVyZWRDb2x1bW5Db3VudCA9IDMwO1xuICAgICAgICB0aGlzLnJlbmRlcmVkUm93Q291bnQgPSA2MDtcbiAgICAgICAgdGhpcy5kYXRhVXBkYXRlcyA9IHt9OyAvL2ZvciBvdmVycmlkaW5nIHdpdGggZWRpdCB2YWx1ZXM7XG4gICAgICAgIHRoaXMuY2xlYXJDb2x1bW5zKCk7XG4gICAgICAgIHRoaXMuY2xlYXJTdGF0ZSgpO1xuICAgICAgICB0aGlzLmdldERhdGFNb2RlbCgpLnJlc2V0KCk7XG4gICAgICAgIHRoaXMuY3JlYXRlQ29sdW1ucygpO1xuICAgIH0sXG5cbiAgICBjbGVhckNvbHVtbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmNvbHVtbnMgPSBbXTtcbiAgICAgICAgdGhpcy5hbGxDb2x1bW5zID0gW107XG4gICAgICAgIHRoaXMuY29sdW1uc1stMV0gPSB0aGlzLm5ld0NvbHVtbigtMSwgJycpO1xuICAgICAgICB0aGlzLmNvbHVtbnNbLTJdID0gdGhpcy5uZXdDb2x1bW4oLTIsICdUcmVlJyk7XG4gICAgICAgIHRoaXMuYWxsQ29sdW1uc1stMV0gPSB0aGlzLmNvbHVtbnNbLTFdO1xuICAgICAgICB0aGlzLmFsbENvbHVtbnNbLTJdID0gdGhpcy5jb2x1bW5zWy0yXTtcbiAgICB9LFxuXG4gICAgZ2V0Q29sdW1uOiBmdW5jdGlvbih4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbHVtbnNbeF07XG4gICAgfSxcblxuICAgIGdldENvbHVtbklkOiBmdW5jdGlvbih4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldENvbHVtbih4KS5sYWJlbDtcbiAgICB9LFxuXG4gICAgbmV3Q29sdW1uOiBmdW5jdGlvbihpbmRleCwgbGFiZWwpIHtcbiAgICAgICAgdmFyIHByb3BlcnRpZXMgPSB0aGlzLmNyZWF0ZUNvbHVtblByb3BlcnRpZXMoKTtcbiAgICAgICAgdGhpcy5nZXRQcml2YXRlU3RhdGUoKS5jb2x1bW5Qcm9wZXJ0aWVzW2luZGV4XSA9IHByb3BlcnRpZXM7XG4gICAgICAgIHJldHVybiBuZXcgQ29sdW1uKHRoaXMsIGluZGV4LCBsYWJlbCk7XG4gICAgfSxcblxuICAgIGFkZENvbHVtbjogZnVuY3Rpb24oaW5kZXgsIGxhYmVsKSB7XG4gICAgICAgIHZhciBjb2x1bW4gPSB0aGlzLm5ld0NvbHVtbihpbmRleCwgbGFiZWwpO1xuICAgICAgICB0aGlzLmNvbHVtbnMucHVzaChjb2x1bW4pO1xuICAgICAgICB0aGlzLmFsbENvbHVtbnMucHVzaChjb2x1bW4pO1xuICAgICAgICByZXR1cm4gY29sdW1uO1xuICAgIH0sXG5cbiAgICBjcmVhdGVDb2x1bW5zOiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy9jb25jcmV0ZSBpbXBsZW1lbnRhdGlvbiBoZXJlXG4gICAgfSxcblxuICAgIGNyZWF0ZUNvbHVtblByb3BlcnRpZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdGFibGVTdGF0ZSA9IHRoaXMuZ2V0UHJpdmF0ZVN0YXRlKCk7XG4gICAgICAgIHZhciBwcm9wZXJ0aWVzID0gT2JqZWN0LmNyZWF0ZSh0YWJsZVN0YXRlKTtcblxuICAgICAgICBwcm9wZXJ0aWVzLnJvd051bWJlcnNQcm9wZXJ0aWVzID0gT2JqZWN0LmNyZWF0ZShwcm9wZXJ0aWVzLCB7XG4gICAgICAgICAgICBmb3JlZ3JvdW5kU2VsZWN0aW9uQ29sb3I6IHtcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29sdW1uSGVhZGVyRm9yZWdyb3VuZFNlbGVjdGlvbkNvbG9yO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbHVtbkhlYWRlckZvcmVncm91bmRTZWxlY3Rpb25Db2xvciA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBiYWNrZ3JvdW5kU2VsZWN0aW9uQ29sb3I6IHtcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29sdW1uSGVhZGVyQmFja2dyb3VuZFNlbGVjdGlvbkNvbG9yO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbHVtbkhlYWRlckJhY2tncm91bmRTZWxlY3Rpb25Db2xvciA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcHJvcGVydGllcy5yb3dIZWFkZXIgPSBPYmplY3QuY3JlYXRlKHByb3BlcnRpZXMsIHtcbiAgICAgICAgICAgIGZvbnQ6IHtcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucm93SGVhZGVyRm9udDtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yb3dIZWFkZXJGb250ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbG9yOiB7XG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJvd0hlYWRlckNvbG9yO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJvd0hlYWRlckNvbG9yID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjoge1xuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yb3dIZWFkZXJCYWNrZ3JvdW5kQ29sb3I7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucm93SGVhZGVyQmFja2dyb3VuZENvbG9yID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZvcmVncm91bmRTZWxlY3Rpb25Db2xvcjoge1xuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yb3dIZWFkZXJGb3JlZ3JvdW5kU2VsZWN0aW9uQ29sb3I7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucm93SGVhZGVyRm9yZWdyb3VuZFNlbGVjdGlvbkNvbG9yID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGJhY2tncm91bmRTZWxlY3Rpb25Db2xvcjoge1xuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yb3dIZWFkZXJCYWNrZ3JvdW5kU2VsZWN0aW9uQ29sb3I7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucm93SGVhZGVyQmFja2dyb3VuZFNlbGVjdGlvbkNvbG9yID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBwcm9wZXJ0aWVzLmNvbHVtbkhlYWRlciA9IE9iamVjdC5jcmVhdGUocHJvcGVydGllcywge1xuICAgICAgICAgICAgZm9udDoge1xuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb2x1bW5IZWFkZXJGb250O1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNvbHVtbkhlYWRlckZvbnQgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29sb3I6IHtcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29sdW1uSGVhZGVyQ29sb3I7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29sdW1uSGVhZGVyQ29sb3IgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiB7XG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbHVtbkhlYWRlckJhY2tncm91bmRDb2xvcjtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb2x1bW5IZWFkZXJCYWNrZ3JvdW5kQ29sb3IgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZm9yZWdyb3VuZFNlbGVjdGlvbkNvbG9yOiB7XG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbHVtbkhlYWRlckZvcmVncm91bmRTZWxlY3Rpb25Db2xvcjtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb2x1bW5IZWFkZXJGb3JlZ3JvdW5kU2VsZWN0aW9uQ29sb3IgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYmFja2dyb3VuZFNlbGVjdGlvbkNvbG9yOiB7XG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbHVtbkhlYWRlckJhY2tncm91bmRTZWxlY3Rpb25Db2xvcjtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb2x1bW5IZWFkZXJCYWNrZ3JvdW5kU2VsZWN0aW9uQ29sb3IgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHByb3BlcnRpZXMuY29sdW1uSGVhZGVyQ29sdW1uU2VsZWN0aW9uID0gT2JqZWN0LmNyZWF0ZShwcm9wZXJ0aWVzLmNvbHVtbkhlYWRlciwge1xuICAgICAgICAgICAgZm9yZWdyb3VuZFNlbGVjdGlvbkNvbG9yOiB7XG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbHVtbkhlYWRlckZvcmVncm91bmRDb2x1bW5TZWxlY3Rpb25Db2xvcjtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb2x1bW5IZWFkZXJGb3JlZ3JvdW5kQ29sdW1uU2VsZWN0aW9uQ29sb3IgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYmFja2dyb3VuZFNlbGVjdGlvbkNvbG9yOiB7XG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbHVtbkhlYWRlckJhY2tncm91bmRDb2x1bW5TZWxlY3Rpb25Db2xvcjtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb2x1bW5IZWFkZXJCYWNrZ3JvdW5kQ29sdW1uU2VsZWN0aW9uQ29sb3IgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHByb3BlcnRpZXMucm93SGVhZGVyUm93U2VsZWN0aW9uID0gT2JqZWN0LmNyZWF0ZShwcm9wZXJ0aWVzLnJvd0hlYWRlciwge1xuICAgICAgICAgICAgZm9yZWdyb3VuZFNlbGVjdGlvbkNvbG9yOiB7XG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJvd0hlYWRlckZvcmVncm91bmRSb3dTZWxlY3Rpb25Db2xvcjtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yb3dIZWFkZXJGb3JlZ3JvdW5kUm93U2VsZWN0aW9uQ29sb3IgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYmFja2dyb3VuZFNlbGVjdGlvbkNvbG9yOiB7XG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnJvd0hlYWRlckJhY2tncm91bmRSb3dTZWxlY3Rpb25Db2xvcjtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yb3dIZWFkZXJCYWNrZ3JvdW5kUm93U2VsZWN0aW9uQ29sb3IgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHByb3BlcnRpZXMuZmlsdGVyUHJvcGVydGllcyA9IE9iamVjdC5jcmVhdGUocHJvcGVydGllcywge1xuICAgICAgICAgICAgZm9udDoge1xuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5maWx0ZXJGb250O1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpbHRlckZvbnQgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29sb3I6IHtcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyQ29sb3I7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmlsdGVyQ29sb3IgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiB7XG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbHRlckJhY2tncm91bmRDb2xvcjtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maWx0ZXJCYWNrZ3JvdW5kQ29sb3IgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZm9yZWdyb3VuZFNlbGVjdGlvbkNvbG9yOiB7XG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbHRlckZvcmVncm91bmRTZWxlY3Rpb25Db2xvcjtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maWx0ZXJGb3JlZ3JvdW5kU2VsZWN0aW9uQ29sb3IgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYmFja2dyb3VuZFNlbGVjdGlvbkNvbG9yOiB7XG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbHRlckJhY2tncm91bmRTZWxlY3Rpb25Db2xvcjtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maWx0ZXJCYWNrZ3JvdW5kU2VsZWN0aW9uQ29sb3IgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2VsbEJvcmRlclN0eWxlOiB7XG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbHRlckNlbGxCb3JkZXJTdHlsZTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5maWx0ZXJDZWxsQm9yZGVyU3R5bGUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2VsbEJvcmRlclRoaWNrbmVzczoge1xuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5maWx0ZXJDZWxsQm9yZGVyVGhpY2tuZXNzO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpbHRlckNlbGxCb3JkZXJUaGlja25lc3MgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHByb3BlcnRpZXMudHJlZUNvbHVtblByb3BlcnRpZXMgPSBPYmplY3QuY3JlYXRlKHByb3BlcnRpZXMsIHtcbiAgICAgICAgICAgIGZvbnQ6IHtcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudHJlZUNvbHVtbkZvbnQ7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJlZUNvbHVtbkZvbnQgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY29sb3I6IHtcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudHJlZUNvbHVtbkNvbG9yO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyZWVDb2x1bW5Db2xvciA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IHtcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudHJlZUNvbHVtbkJhY2tncm91bmRDb2xvcjtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmVlQ29sdW1uQmFja2dyb3VuZENvbG9yID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZvcmVncm91bmRTZWxlY3Rpb25Db2xvcjoge1xuICAgICAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy50cmVlQ29sdW1uRm9yZWdyb3VuZFNlbGVjdGlvbkNvbG9yO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyZWVDb2x1bW5Gb3JlZ3JvdW5kU2VsZWN0aW9uQ29sb3IgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYmFja2dyb3VuZFNlbGVjdGlvbkNvbG9yOiB7XG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRyZWVDb2x1bW5CYWNrZ3JvdW5kU2VsZWN0aW9uQ29sb3I7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJlZUNvbHVtbkJhY2tncm91bmRTZWxlY3Rpb25Db2xvciA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcHJvcGVydGllcy50cmVlQ29sdW1uUHJvcGVydGllc0NvbHVtblNlbGVjdGlvbiA9IE9iamVjdC5jcmVhdGUocHJvcGVydGllcy50cmVlQ29sdW1uUHJvcGVydGllcywge1xuICAgICAgICAgICAgZm9yZWdyb3VuZFNlbGVjdGlvbkNvbG9yOiB7XG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnRyZWVDb2x1bW5Gb3JlZ3JvdW5kQ29sdW1uU2VsZWN0aW9uQ29sb3I7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudHJlZUNvbHVtbkZvcmVncm91bmRDb2x1bW5TZWxlY3Rpb25Db2xvciA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBiYWNrZ3JvdW5kU2VsZWN0aW9uQ29sb3I6IHtcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMudHJlZUNvbHVtbkJhY2tncm91bmRDb2x1bW5TZWxlY3Rpb25Db2xvcjtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy50cmVlQ29sdW1uQmFja2dyb3VuZENvbHVtblNlbGVjdGlvbkNvbG9yID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gcHJvcGVydGllcztcbiAgICB9LFxuXG4gICAgZ2V0Q29sdW1uV2lkdGg6IGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgdmFyIGNvbCA9IHRoaXMuZ2V0Q29sdW1uKHgpO1xuICAgICAgICBpZiAoIWNvbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVzb2x2ZVByb3BlcnR5KCdkZWZhdWx0Q29sdW1uV2lkdGgnKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgd2lkdGggPSBjb2wuZ2V0V2lkdGgoKTtcbiAgICAgICAgcmV0dXJuIHdpZHRoO1xuICAgIH0sXG5cbiAgICBzZXRDb2x1bW5XaWR0aDogZnVuY3Rpb24oeCwgd2lkdGgpIHtcbiAgICAgICAgdGhpcy5nZXRDb2x1bW4oeCkuc2V0V2lkdGgod2lkdGgpO1xuICAgICAgICB0aGlzLnN0YXRlQ2hhbmdlZCgpO1xuICAgIH0sXG5cbiAgICBnZXREYXRhTW9kZWw6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5kYXRhTW9kZWwgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBkYXRhTW9kZWwgPSB0aGlzLmdldERlZmF1bHREYXRhTW9kZWwoKTtcbiAgICAgICAgICAgIHRoaXMuc2V0RGF0YU1vZGVsKGRhdGFNb2RlbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YU1vZGVsO1xuICAgIH0sXG5cbiAgICBnZXRDZWxsUmVuZGVyZXI6IGZ1bmN0aW9uKGNvbmZpZywgeCwgeSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRDb2x1bW4oeCkuZ2V0Q2VsbFJlbmRlcmVyKGNvbmZpZywgeSk7XG4gICAgfSxcblxuICAgIHNldERhdGFNb2RlbDogZnVuY3Rpb24obmV3RGF0YU1vZGVsKSB7XG4gICAgICAgIHRoaXMuZGF0YU1vZGVsID0gbmV3RGF0YU1vZGVsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICogQGRlc2MgdXRpbGl0eSBmdW5jdGlvbiB0byBlbXB0eSBhbiBvYmplY3Qgb2YgaXRzIG1lbWJlcnNcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gb2JqIC0gdGhlIG9iamVjdCB0byBlbXB0eVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2V4cG9ydFByb3BzXVxuICAgICAqICogYHVuZGVmaW5lZGAgKG9taXR0ZWQpIC0gZGVsZXRlICphbGwqIHByb3BlcnRpZXNcbiAgICAgKiAqICoqZmFsc3kqKiAtIGRlbGV0ZSAqb25seSogdGhlIGV4cG9ydCBwcm9wZXJ0aWVzXG4gICAgICogKiAqKnRydXRoeSoqIC0gZGVsZXRlIGFsbCBwcm9wZXJ0aWVzICpleGNlcHQqIHRoZSBleHBvcnQgcHJvcGVydGllc1xuICAgICAqL1xuICAgIGNsZWFyT2JqZWN0UHJvcGVydGllczogZnVuY3Rpb24ob2JqLCBleHBvcnRQcm9wcykge1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICAgICAgICBpZiAoXG4gICAgICAgICAgICAgICAgb2JqLmhhc093blByb3BlcnR5KGtleSkgJiYgKFxuICAgICAgICAgICAgICAgICAgICBleHBvcnRQcm9wcyA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgICAgICAgICAgICFleHBvcnRQcm9wcyAmJiBub0V4cG9ydFByb3BlcnRpZXMuaW5kZXhPZihrZXkpID49IDAgfHxcbiAgICAgICAgICAgICAgICAgICAgZXhwb3J0UHJvcHMgJiYgbm9FeHBvcnRQcm9wZXJ0aWVzLmluZGV4T2Yoa2V5KSA8IDBcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgb2JqW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGdldHRlciBmb3IgYSBbTWVtZW50b10oaHR0cDovL2MyLmNvbS9jZ2kvd2lraT9NZW1lbnRvUGF0dGVybikgT2JqZWN0XG4gICAgICogQHJldHVybnMge29iamVjdH1cbiAgICAgKi9cbiAgICBnZXRQcml2YXRlU3RhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMudGFibGVTdGF0ZSkge1xuICAgICAgICAgICAgdGhpcy50YWJsZVN0YXRlID0gdGhpcy5nZXREZWZhdWx0U3RhdGUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy50YWJsZVN0YXRlO1xuICAgIH0sXG5cbiAgICAvL3RoaXMgaXMgZWZmZWN0aXZlbHkgYSBjbG9uZSwgd2l0aCBjZXJ0YWluIHRoaW5ncyByZW1vdmVkLi4uLlxuICAgIGdldFN0YXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGNvcHkgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHRoaXMuZ2V0UHJpdmF0ZVN0YXRlKCkpKTtcbiAgICAgICAgdGhpcy5jbGVhck9iamVjdFByb3BlcnRpZXMoY29weS5jb2x1bW5Qcm9wZXJ0aWVzLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIGNvcHk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICogQGRlc2MgY2xlYXIgYWxsIHRhYmxlIHN0YXRlXG4gICAgICovXG4gICAgY2xlYXJTdGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMudGFibGVTdGF0ZSA9IG51bGw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJuIHtvYmplY3R9IE5ld2x5IGNyZWF0ZWQgZGVmYXVsdCBlbXB0eSB0YWJsZXN0YXRlLlxuICAgICAqL1xuICAgIGdldERlZmF1bHRTdGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB0YWJsZVByb3BlcnRpZXMgPSB0aGlzLmdldEdyaWQoKS5fZ2V0UHJvcGVydGllcygpO1xuICAgICAgICB2YXIgc3RhdGUgPSBPYmplY3QuY3JlYXRlKHRhYmxlUHJvcGVydGllcyk7XG5cbiAgICAgICAgXyhzdGF0ZSkuZXh0ZW5kT3duKHtcbiAgICAgICAgICAgIHJvd0hlaWdodHM6IHt9LFxuICAgICAgICAgICAgY2VsbFByb3BlcnRpZXM6IHt9LFxuICAgICAgICAgICAgY29sdW1uUHJvcGVydGllczogW11cbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICogQGRlc2MgUmVzdG9yZSB0aGlzIHRhYmxlIHRvIGEgcHJldmlvdXMgc3RhdGUuXG4gICAgICogU2VlIHRoZSBbbWVtZW50byBwYXR0ZXJuXShodHRwOi8vYzIuY29tL2NnaS93aWtpP01lbWVudG9QYXR0ZXJuKS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbWVtZW50byAtIGFuIGVuY2Fwc3VsYXRlZCByZXByZXNlbnRhdGlvbiBvZiB0YWJsZSBzdGF0ZVxuICAgICAqL1xuICAgIHNldFN0YXRlOiBmdW5jdGlvbihtZW1lbnRvKSB7XG5cbiAgICAgICAgLy93ZSBkb24ndCB3YW50IHRvIGNsb2JiZXIgdGhlIGNvbHVtbiBwcm9wZXJ0aWVzIGNvbXBsZXRlbHlcbiAgICAgICAgaWYgKCFtZW1lbnRvLmNvbHVtbkluZGV4ZXMpIHtcbiAgICAgICAgICAgIHZhciBmaWVsZHMgPSB0aGlzLmdldEZpZWxkcygpO1xuICAgICAgICAgICAgbWVtZW50by5jb2x1bW5JbmRleGVzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZpZWxkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIG1lbWVudG8uY29sdW1uSW5kZXhlc1tpXSA9IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNvbFByb3BlcnRpZXMgPSBtZW1lbnRvLmNvbHVtblByb3BlcnRpZXM7XG4gICAgICAgIGRlbGV0ZSBtZW1lbnRvLmNvbHVtblByb3BlcnRpZXM7XG4gICAgICAgIHRoaXMudGFibGVTdGF0ZSA9IG51bGw7XG4gICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuZ2V0UHJpdmF0ZVN0YXRlKCk7XG4gICAgICAgIHRoaXMuY3JlYXRlQ29sdW1ucygpO1xuICAgICAgICB0aGlzLnNldENvbHVtbk9yZGVyKG1lbWVudG8uY29sdW1uSW5kZXhlcyk7XG4gICAgICAgIF8oc3RhdGUpLmV4dGVuZE93bihtZW1lbnRvKTtcbiAgICAgICAgdGhpcy5zZXRBbGxDb2x1bW5Qcm9wZXJ0aWVzKGNvbFByb3BlcnRpZXMpO1xuICAgICAgICBtZW1lbnRvLmNvbHVtblByb3BlcnRpZXMgPSBjb2xQcm9wZXJ0aWVzO1xuICAgICAgICAvL21lbWVudG8uY29sdW1uUHJvcGVydGllcyA9IGNvbFByb3BlcnRpZXM7XG5cbiAgICAgICAgLy8gdGhpcy5nZXREYXRhTW9kZWwoKS5zZXRTdGF0ZShtZW1lbnRvKTtcbiAgICAgICAgLy8gdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAvLyByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vICAgICBzZWxmLmFwcGx5U29ydHMoKTtcbiAgICAgICAgLy8gICAgIHNlbGYuY2hhbmdlZCgpO1xuICAgICAgICAvLyAgICAgc2VsZi5zdGF0ZUNoYW5nZWQoKTtcbiAgICAgICAgLy8gfSk7XG5cbiAgICAgICAgLy9qdXN0IHRvIGJlIGNsb3NlLyBpdCdzIGVhc2llciBvbiB0aGUgZXllc1xuICAgICAgICB0aGlzLnNldENvbHVtbldpZHRoKC0xLCAyNC4xOTMzNTkzNzUpO1xuICAgICAgICB0aGlzLmdldERhdGFNb2RlbCgpLmFwcGx5U3RhdGUoKTtcbiAgICB9LFxuXG4gICAgc2V0QWxsQ29sdW1uUHJvcGVydGllczogZnVuY3Rpb24ocHJvcGVydGllcykge1xuICAgICAgICBwcm9wZXJ0aWVzID0gcHJvcGVydGllcyB8fCBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wZXJ0aWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgY3VycmVudCA9IHRoaXMuZ2V0UHJpdmF0ZVN0YXRlKCkuY29sdW1uUHJvcGVydGllc1tpXTtcbiAgICAgICAgICAgIHRoaXMuY2xlYXJPYmplY3RQcm9wZXJ0aWVzKGN1cnJlbnQsIGZhbHNlKTtcbiAgICAgICAgICAgIF8oY3VycmVudCkuZXh0ZW5kT3duKHByb3BlcnRpZXNbaV0pO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHNldENvbHVtbk9yZGVyOiBmdW5jdGlvbihpbmRleGVzKSB7XG4gICAgICAgIGlmICghaW5kZXhlcykge1xuICAgICAgICAgICAgdGhpcy5jb2x1bW5zLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb2x1bW5zLmxlbmd0aCA9IGluZGV4ZXMubGVuZ3RoO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGluZGV4ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuY29sdW1uc1tpXSA9IHRoaXMuYWxsQ29sdW1uc1tpbmRleGVzW2ldXTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBhcHBseVNvcnRzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy9pZiBJIGhhdmUgc29ydHMsIGFwcGx5IHRoZW0gbm93Ly9cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGZldGNoIHRoZSB2YWx1ZSBmb3IgYSBwcm9wZXJ0eSBrZXlcbiAgICAgKiBAcmV0dXJucyB7Kn0gVGhlIHZhbHVlIG9mIHRoZSBnaXZlbiBwcm9wZXJ0eS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IC0gYSBwcm9wZXJ0eSBuYW1lXG4gICAgICovXG4gICAgcmVzb2x2ZVByb3BlcnR5OiBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JpZC5yZXNvbHZlUHJvcGVydHkoa2V5KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIEEgc3BlY2lmaWMgY2VsbCB3YXMgY2xpY2tlZDsgeW91J3ZlIGJlZW4gbm90aWZpZWQuXG4gICAgICogQHBhcmFtIHtQb2ludH0gY2VsbCAtIHBvaW50IG9mIGNlbGwgY29vcmRpbmF0ZXNcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSBhbGwgZXZlbnQgaW5mb3JtYXRpb25cbiAgICAgKi9cbiAgICBjZWxsQ2xpY2tlZDogZnVuY3Rpb24oY2VsbCwgZXZlbnQpIHtcbiAgICAgICAgdGhpcy5nZXREYXRhTW9kZWwoKS5jZWxsQ2xpY2tlZChjZWxsLCBldmVudCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBBIHNwZWNpZmljIGNlbGwgd2FzIGxlIGRvdWJsZS1jbGlja2VkOyB5b3UndmUgYmVlbiBub3RpZmllZC5cbiAgICAgKiBAcGFyYW0ge1BvaW50fSBjZWxsIC0gcG9pbnQgb2YgY2VsbCBjb29yZGluYXRlc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIGFsbCBldmVudCBpbmZvcm1hdGlvblxuICAgICAqL1xuICAgIGNlbGxEb3VibGVDbGlja2VkOiBmdW5jdGlvbihjZWxsLCBldmVudCkge1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBhZGQgbmV4dEZlYXR1cmUgdG8gbWUgSWYgSSBkb24ndCBoYXZlIGEgbmV4dCBub2RlLCBvdGhlcndpc2UgcGFzcyBpdCBhbG9uZ1xuICAgICAqIEBwYXJhbSB7RmVhdHVyZX1cbiAgICAgKi9cbiAgICBzZXROZXh0RmVhdHVyZTogZnVuY3Rpb24obmV4dEZlYXR1cmUpIHtcbiAgICAgICAgdGhpcy5mZWF0dXJlTWFwW25leHRGZWF0dXJlLmFsaWFzXSA9IG5leHRGZWF0dXJlO1xuICAgICAgICBpZiAodGhpcy5mZWF0dXJlQ2hhaW4pIHtcbiAgICAgICAgICAgIHRoaXMuZmVhdHVyZUNoYWluLnNldE5leHQobmV4dEZlYXR1cmUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5mZWF0dXJlQ2hhaW4gPSBuZXh0RmVhdHVyZTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBsb29rdXBGZWF0dXJlOiBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmVhdHVyZU1hcFtrZXldO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICogQGRlc2MgZ2V0dGVyIGZvciB0aGUgY2VsbCBwcm92aWRlclxuICAgICAqIEByZXR1cm4ge0NlbGxQcm92aWRlcn1cbiAgICAgKi9cbiAgICBnZXRDZWxsUHJvdmlkZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jZWxsUHJvdmlkZXI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBzZXR0ZXIgZm9yIHRoZSBoeXBlcmdyaWRcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqL1xuICAgIHNldEdyaWQ6IGZ1bmN0aW9uKGZpbkdyaWQpIHtcbiAgICAgICAgdGhpcy5ncmlkID0gZmluR3JpZDtcbiAgICAgICAgdGhpcy5nZXREYXRhTW9kZWwoKS5zZXRHcmlkKGZpbkdyaWQpO1xuICAgICAgICB0aGlzLmNsZWFyQ29sdW1ucygpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICogQHJldHVybnM6IHtIeXBlcmdyaWR9IFRoZSBoeXBlcmdyaWQgdG8gd2hpY2ggdGhpcyBiZWhhdmlvciBpcyBhdHRhY2hlZC5cbiAgICAgKiBAcGFyYW0ge3R5cGV9IHZhcm5hbWUgLSBkZXNjcmlwdG9uXG4gICAgICovXG4gICAgZ2V0R3JpZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdyaWQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBZb3UgY2FuIG92ZXJyaWRlIHRoaXMgZnVuY3Rpb24gYW5kIHN1YnN0aXR1dGUgeW91ciBvd24gY2VsbCBwcm92aWRlci5cbiAgICAgKiBAcmV0dXJuIHtDZWxsUHJvdmlkZXJ9XG4gICAgICovXG4gICAgY3JlYXRlQ2VsbFByb3ZpZGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBDZWxsUHJvdmlkZXIoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIEZpcnN0IGNoZWNrIHRvIHNlZSBpZiBzb21ldGhpbmcgd2FzIG92ZXJyaWRkZW4uXG4gICAgICogQHJldHVybiB7Kn0gVGhlIHZhbHVlIGF0IGB4LHlgIGZvciB0aGUgdG9wIGxlZnQgc2VjdGlvbiBvZiB0aGUgaHlwZXJncmlkLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IC0geCBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgLSB5IGNvb3JkaW5hdGVcbiAgICAgKi9cbiAgICBnZXRWYWx1ZTogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICB2YXIgY29sdW1uID0gdGhpcy5nZXRDb2x1bW4oeCk7XG4gICAgICAgIGlmICghY29sdW1uKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb2x1bW4uZ2V0VmFsdWUoeSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyB1cGRhdGUgdGhlIGRhdGEgYXQgcG9pbnQgeCwgeSB3aXRoIHZhbHVlXG4gICAgICogQHJldHVybiBUaGUgZGF0YS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCAtIHggY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IC0geSBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHZhbHVlIC0gdGhlIHZhbHVlIHRvIHVzZVxuICAgICAqL1xuICAgIHNldFZhbHVlOiBmdW5jdGlvbih4LCB5LCB2YWx1ZSkge1xuICAgICAgICB2YXIgY29sdW1uID0gdGhpcy5nZXRDb2x1bW4oeCk7XG4gICAgICAgIGlmICghY29sdW1uKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbHVtbi5zZXRWYWx1ZSh5LCB2YWx1ZSk7XG4gICAgfSxcblxuICAgIGdldERhdGFWYWx1ZTogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXREYXRhTW9kZWwoKS5nZXRWYWx1ZSh4LCB5KTtcbiAgICB9LFxuXG4gICAgc2V0RGF0YVZhbHVlOiBmdW5jdGlvbih4LCB5LCB2YWx1ZSkge1xuICAgICAgICB0aGlzLmdldERhdGFNb2RlbCgpLnNldFZhbHVlKHgsIHksIHZhbHVlKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBGaXJzdCBjaGVja3MgdG8gc2VlIGlmIHNvbWV0aGluZyB3YXMgb3ZlcnJpZGRlbi5cbiAgICAgKiBAcmV0dXJuIHsqfSBUaGUgdmFsdWUgYXQgeCx5IGZvciB0aGUgdG9wIGxlZnQgc2VjdGlvbiBvZiB0aGUgaHlwZXJncmlkLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IC0geCBjb29yZGluYXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgLSB5IGNvb3JkaW5hdGVcbiAgICAgKi9cbiAgICBnZXRDZWxsUHJvcGVydGllczogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICB2YXIgY29sID0gdGhpcy5nZXRDb2x1bW4oeCk7XG4gICAgICAgIHJldHVybiBjb2wuZ2V0Q2VsbFByb3BlcnRpZXMoeSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyB1cGRhdGUgdGhlIGRhdGEgYXQgcG9pbnQgeCwgeSB3aXRoIHZhbHVlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggLSB4IGNvb3JkaW5hdGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSAtIHkgY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZSAtIHRoZSB2YWx1ZSB0byB1c2VcbiAgICAgKi9cbiAgICBzZXRDZWxsUHJvcGVydGllczogZnVuY3Rpb24oeCwgeSwgdmFsdWUpIHtcbiAgICAgICAgdmFyIGNvbCA9IHRoaXMuZ2V0Q29sdW1uKHgpO1xuICAgICAgICBpZiAoY29sKSB7XG4gICAgICAgICAgICBjb2wuc2V0Q2VsbFByb3BlcnRpZXMoeSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgbnVtYmVyIG9mIHJvd3MgaW4gdGhlIGh5cGVyZ3JpZC5cbiAgICAgKi9cbiAgICBnZXRSb3dDb3VudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldERhdGFNb2RlbCgpLmdldFJvd0NvdW50KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBoZWlnaHQgaW4gcGl4ZWxzIG9mIHRoZSBmaXhlZCByb3dzIGFyZWEgIG9mIHRoZSBoeXBlcmdyaWQuXG4gICAgICovXG4gICAgZ2V0Rml4ZWRSb3dzSGVpZ2h0OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGNvdW50ID0gdGhpcy5nZXRGaXhlZFJvd0NvdW50KCk7XG4gICAgICAgIHZhciB0b3RhbCA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuICAgICAgICAgICAgdG90YWwgPSB0b3RhbCArIHRoaXMuZ2V0Um93SGVpZ2h0KGkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b3RhbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm4ge251bWJlcn0gVGhlIGhlaWdodCBpbiBwaXhlbHMgb2YgYSBzcGVjaWZpYyByb3cgaW4gdGhlIGh5cGVyZ3JpZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gcm93TnVtIC0gcm93IGluZGV4IG9mIGludGVyZXN0XG4gICAgICovXG4gICAgZ2V0Um93SGVpZ2h0OiBmdW5jdGlvbihyb3dOdW0pIHtcbiAgICAgICAgdmFyIHRhYmxlU3RhdGUgPSB0aGlzLmdldFByaXZhdGVTdGF0ZSgpO1xuICAgICAgICBpZiAodGFibGVTdGF0ZS5yb3dIZWlnaHRzKSB7XG4gICAgICAgICAgICB2YXIgb3ZlcnJpZGUgPSB0YWJsZVN0YXRlLnJvd0hlaWdodHNbcm93TnVtXTtcbiAgICAgICAgICAgIGlmIChvdmVycmlkZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBvdmVycmlkZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5nZXREZWZhdWx0Um93SGVpZ2h0KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBUaGUgdmFsdWUgaXMgbGF6aWx5IGluaXRpYWxpemVkIGFuZCBjb21lcyBmcm9tIHRoZSBwcm9wZXJ0aWVzIG1lY2hhbmlzbSBmb3IgJ2BkZWZhdWx0Um93SGVpZ2h0YCcsIHdoaWNoIHNob3VsZCBiZSB+MjBweC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgcm93IGhlaWdodCBpbiBwaXhlbHMuXG4gICAgICovXG4gICAgZ2V0RGVmYXVsdFJvd0hlaWdodDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghdGhpcy5kZWZhdWx0Um93SGVpZ2h0KSB7XG4gICAgICAgICAgICB0aGlzLmRlZmF1bHRSb3dIZWlnaHQgPSB0aGlzLnJlc29sdmVQcm9wZXJ0eSgnZGVmYXVsdFJvd0hlaWdodCcpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmRlZmF1bHRSb3dIZWlnaHQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBzZXQgdGhlIHBpeGVsIGhlaWdodCBvZiBhIHNwZWNpZmljIHJvd1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSByb3dOdW0gLSB0aGUgcm93IGluZGV4IG9mIGludGVyZXN0XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGhlaWdodCAtIHBpeGVsIGhlaWdodFxuICAgICAqL1xuICAgIHNldFJvd0hlaWdodDogZnVuY3Rpb24ocm93TnVtLCBoZWlnaHQpIHtcbiAgICAgICAgdmFyIHRhYmxlU3RhdGUgPSB0aGlzLmdldFByaXZhdGVTdGF0ZSgpO1xuICAgICAgICB0YWJsZVN0YXRlLnJvd0hlaWdodHNbcm93TnVtXSA9IE1hdGgubWF4KDUsIGhlaWdodCk7XG4gICAgICAgIHRoaXMuc3RhdGVDaGFuZ2VkKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBUaGlzIHdpbGwgYWxsb3cgJ2Zsb2F0aW5nJyBmaXhlZCByb3dzLlxuICAgICAqIEByZXR1cm4ge251bWJlcn0gVGhlIG1heGltdW0gaGVpZ2h0IG9mIHRoZSBmaXhlZCByb3dzIGFyZWEgaW4gdGhlIGh5cGVyZ3JpZC5cbiAgICAgKi9cbiAgICBnZXRGaXhlZFJvd3NNYXhIZWlnaHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRGaXhlZFJvd3NIZWlnaHQoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm4ge251bWJlcn0gVGhlIHdpZHRoIG9mIHRoZSBmaXhlZCBjb2x1bW4gYXJlYSBpbiB0aGUgaHlwZXJncmlkLlxuICAgICAqL1xuICAgIGdldEZpeGVkQ29sdW1uc1dpZHRoOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGNvdW50ID0gdGhpcy5nZXRGaXhlZENvbHVtbkNvdW50KCk7XG4gICAgICAgIHZhciB0b3RhbCA9IDA7XG4gICAgICAgIGlmICh0aGlzLmdldEdyaWQoKS5pc1Nob3dSb3dOdW1iZXJzKCkpIHtcbiAgICAgICAgICAgIHRvdGFsID0gdGhpcy5nZXRDb2x1bW5XaWR0aCgtMSk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgICAgICB0b3RhbCA9IHRvdGFsICsgdGhpcy5nZXRDb2x1bW5XaWR0aChpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG90YWw7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBUaGlzIGV4aXN0cyB0byBzdXBwb3J0IFwiZmxvYXRpbmdcIiBjb2x1bW5zLlxuICAgICAqIEByZXR1cm4ge251bWJlcn0gVGhlIHRvdGFsIHdpZHRoIG9mIHRoZSBmaXhlZCBjb2x1bW5zIGFyZWEuXG4gICAgICovXG4gICAgZ2V0Rml4ZWRDb2x1bW5zTWF4V2lkdGg6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgd2lkdGggPSB0aGlzLmdldEZpeGVkQ29sdW1uc1dpZHRoKCk7XG4gICAgICAgIHJldHVybiB3aWR0aDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIFNldCB0aGUgc2Nyb2xsIHBvc2l0aW9uIGluIHZlcnRpY2FsIGRpbWVuc2lvbiBhbmQgbm90aWZ5IGxpc3RlbmVycy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSAtIHRoZSBuZXcgeSB2YWx1ZVxuICAgICAqL1xuICAgIF9zZXRTY3JvbGxQb3NpdGlvblk6IGZ1bmN0aW9uKHkpIHtcbiAgICAgICAgdGhpcy5zZXRTY3JvbGxQb3NpdGlvblkoeSk7XG4gICAgICAgIHRoaXMuY2hhbmdlZCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICogQGRlc2MgU2V0IHRoZSBzY3JvbGwgcG9zaXRpb24gaW4gaG9yaXpvbnRhbCBkaW1lbnNpb24gYW5kIG5vdGlmeSBsaXN0ZW5lcnMuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggLSB0aGUgbmV3IHggdmFsdWVcbiAgICAgKi9cbiAgICBfc2V0U2Nyb2xsUG9zaXRpb25YOiBmdW5jdGlvbih4KSB7XG4gICAgICAgIHRoaXMuc2V0U2Nyb2xsUG9zaXRpb25YKHgpO1xuICAgICAgICB0aGlzLmNoYW5nZWQoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIFNldCB0aGUgbnVtYmVyIG9mIGNvbHVtbnMganVzdCByZW5kZXJlZCwgaW5jbHVkaW5nIHBhcnRpYWxseSByZW5kZXJlZCBjb2x1bW5zLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb3VudCAtIGhvdyBtYW55IGNvbHVtbnMgd2VyZSBqdXN0IHJlbmRlcmVkXG4gICAgICovXG4gICAgc2V0UmVuZGVyZWRDb2x1bW5Db3VudDogZnVuY3Rpb24oY291bnQpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJlZENvbHVtbkNvdW50ID0gY291bnQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBTZXQgdGhlIG51bWJlciBvZiByb3dzIGp1c3QgcmVuZGVyZWQsIGluY2x1ZGluZyBwYXJ0aWFsbHkgcmVuZGVyZWQgcm93cy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY291bnQgLSBob3cgbWFueSByb3dzIHdlcmUganVzdCByZW5kZXJlZFxuICAgICAqL1xuICAgIHNldFJlbmRlcmVkUm93Q291bnQ6IGZ1bmN0aW9uKGNvdW50KSB7XG4gICAgICAgIHRoaXMucmVuZGVyZWRSb3dDb3VudCA9IGNvdW50O1xuICAgIH0sXG5cblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBUaGUgZml4ZWQgcm93IGFyZWEgaGFzIGJlZW4gY2xpY2tlZCwgbWFzc2FnZSB0aGUgZGV0YWlscyBhbmQgY2FsbCB0aGUgcmVhbCBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtb3VzZSAtIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBfZml4ZWRSb3dDbGlja2VkOiBmdW5jdGlvbihncmlkLCBtb3VzZSkge1xuICAgICAgICB2YXIgeCA9IHRoaXMudHJhbnNsYXRlQ29sdW1uSW5kZXgodGhpcy5nZXRTY3JvbGxQb3NpdGlvblgoKSArIG1vdXNlLmdyaWRDZWxsLnggLSB0aGlzLmdldEZpeGVkQ29sdW1uQ291bnQoKSk7XG4gICAgICAgIHZhciB0cmFuc2xhdGVkUG9pbnQgPSB0aGlzLmdyaWQubmV3UG9pbnQoeCwgbW91c2UuZ3JpZENlbGwueSk7XG4gICAgICAgIG1vdXNlLmdyaWRDZWxsID0gdHJhbnNsYXRlZFBvaW50O1xuICAgICAgICB0aGlzLmZpeGVkUm93Q2xpY2tlZChncmlkLCBtb3VzZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBUaGUgZml4ZWQgY29sdW1uIGFyZWEgaGFzIGJlZW4gY2xpY2tlZCwgbWFzc2FnZSB0aGUgZGV0YWlscyBhbmQgY2FsbCB0aGUgcmVhbCBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtb3VzZSAtIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBfZml4ZWRDb2x1bW5DbGlja2VkOiBmdW5jdGlvbihncmlkLCBtb3VzZSkge1xuICAgICAgICB2YXIgdHJhbnNsYXRlZFBvaW50ID0gdGhpcy5ncmlkLm5ld1BvaW50KG1vdXNlLmdyaWRDZWxsLngsIHRoaXMuZ2V0U2Nyb2xsUG9zaXRpb25ZKCkgKyBtb3VzZS5ncmlkQ2VsbC55IC0gdGhpcy5nZXRGaXhlZFJvd0NvdW50KCkpO1xuICAgICAgICBtb3VzZS5ncmlkQ2VsbCA9IHRyYW5zbGF0ZWRQb2ludDtcbiAgICAgICAgdGhpcy5maXhlZENvbHVtbkNsaWNrZWQoZ3JpZCwgbW91c2UpO1xuICAgIH0sXG5cbiAgICBtb3ZlU2luZ2xlU2VsZWN0OiBmdW5jdGlvbihncmlkLCB4LCB5KSB7XG4gICAgICAgIGlmICh0aGlzLmZlYXR1cmVDaGFpbikge1xuICAgICAgICAgICAgdGhpcy5mZWF0dXJlQ2hhaW4ubW92ZVNpbmdsZVNlbGVjdChncmlkLCB4LCB5KTtcbiAgICAgICAgICAgIHRoaXMuc2V0Q3Vyc29yKGdyaWQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBkZWxlZ2F0ZSBzZXR0aW5nIHRoZSBjdXJzb3IgdXAgdGhlIGZlYXR1cmUgY2hhaW4gb2YgcmVzcG9uc2liaWxpdHlcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqL1xuICAgIHNldEN1cnNvcjogZnVuY3Rpb24oZ3JpZCkge1xuICAgICAgICBncmlkLnVwZGF0ZUN1cnNvcigpO1xuICAgICAgICB0aGlzLmZlYXR1cmVDaGFpbi5zZXRDdXJzb3IoZ3JpZCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBkZWxlZ2F0ZSBoYW5kbGluZyBtb3VzZSBtb3ZlIHRvIHRoZSBmZWF0dXJlIGNoYWluIG9mIHJlc3BvbnNpYmlsaXR5XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIG9uTW91c2VNb3ZlOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICBpZiAodGhpcy5mZWF0dXJlQ2hhaW4pIHtcbiAgICAgICAgICAgIHRoaXMuZmVhdHVyZUNoYWluLmhhbmRsZU1vdXNlTW92ZShncmlkLCBldmVudCk7XG4gICAgICAgICAgICB0aGlzLnNldEN1cnNvcihncmlkKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICogQGRlc2MgZGVsZWdhdGUgaGFuZGxpbmcgdGFwIHRvIHRoZSBmZWF0dXJlIGNoYWluIG9mIHJlc3BvbnNpYmlsaXR5XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIG9uVGFwOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuXG4gICAgICAgIGlmICh0aGlzLmZlYXR1cmVDaGFpbikge1xuICAgICAgICAgICAgdGhpcy5mZWF0dXJlQ2hhaW4uaGFuZGxlVGFwKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgICAgIHRoaXMuc2V0Q3Vyc29yKGdyaWQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBkZWxlZ2F0ZSBoYW5kbGluZyB0YXAgdG8gdGhlIGZlYXR1cmUgY2hhaW4gb2YgcmVzcG9uc2liaWxpdHlcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgb25Db250ZXh0TWVudTogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgdmFyIHByb2NlZWQgPSBncmlkLmZpcmVTeW50aGV0aWNDb250ZXh0TWVudUV2ZW50KGV2ZW50KTtcbiAgICAgICAgaWYgKHByb2NlZWQgJiYgdGhpcy5mZWF0dXJlQ2hhaW4pIHtcbiAgICAgICAgICAgIHRoaXMuZmVhdHVyZUNoYWluLmhhbmRsZUNvbnRleHRNZW51KGdyaWQsIGV2ZW50KTtcbiAgICAgICAgICAgIHRoaXMuc2V0Q3Vyc29yKGdyaWQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBkZWxlZ2F0ZSBoYW5kbGluZyB3aGVlbCBtb3ZlZCB0byB0aGUgZmVhdHVyZSBjaGFpbiBvZiByZXNwb25zaWJpbGl0eVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBvbldoZWVsTW92ZWQ6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLmZlYXR1cmVDaGFpbikge1xuICAgICAgICAgICAgdGhpcy5mZWF0dXJlQ2hhaW4uaGFuZGxlV2hlZWxNb3ZlZChncmlkLCBldmVudCk7XG4gICAgICAgICAgICB0aGlzLnNldEN1cnNvcihncmlkKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICogQGRlc2MgZGVsZWdhdGUgaGFuZGxpbmcgbW91c2UgdXAgdG8gdGhlIGZlYXR1cmUgY2hhaW4gb2YgcmVzcG9uc2liaWxpdHlcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgb25Nb3VzZVVwOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICBpZiAodGhpcy5mZWF0dXJlQ2hhaW4pIHtcbiAgICAgICAgICAgIHRoaXMuZmVhdHVyZUNoYWluLmhhbmRsZU1vdXNlVXAoZ3JpZCwgZXZlbnQpO1xuICAgICAgICAgICAgdGhpcy5zZXRDdXJzb3IoZ3JpZCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGRlbGVnYXRlIGhhbmRsaW5nIG1vdXNlIGRyYWcgdG8gdGhlIGZlYXR1cmUgY2hhaW4gb2YgcmVzcG9uc2liaWxpdHlcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgb25Nb3VzZURyYWc6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLmZlYXR1cmVDaGFpbikge1xuICAgICAgICAgICAgdGhpcy5mZWF0dXJlQ2hhaW4uaGFuZGxlTW91c2VEcmFnKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgICAgIHRoaXMuc2V0Q3Vyc29yKGdyaWQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBkZWxlZ2F0ZSBoYW5kbGluZyBrZXkgZG93biB0byB0aGUgZmVhdHVyZSBjaGFpbiBvZiByZXNwb25zaWJpbGl0eVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBvbktleURvd246IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLmZlYXR1cmVDaGFpbikge1xuICAgICAgICAgICAgdGhpcy5mZWF0dXJlQ2hhaW4uaGFuZGxlS2V5RG93bihncmlkLCBldmVudCk7XG4gICAgICAgICAgICB0aGlzLnNldEN1cnNvcihncmlkKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICogQGRlc2MgZGVsZWdhdGUgaGFuZGxpbmcga2V5IHVwIHRvIHRoZSBmZWF0dXJlIGNoYWluIG9mIHJlc3BvbnNpYmlsaXR5XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIG9uS2V5VXA6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLmZlYXR1cmVDaGFpbikge1xuICAgICAgICAgICAgdGhpcy5mZWF0dXJlQ2hhaW4uaGFuZGxlS2V5VXAoZ3JpZCwgZXZlbnQpO1xuICAgICAgICAgICAgdGhpcy5zZXRDdXJzb3IoZ3JpZCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGRlbGVnYXRlIGhhbmRsaW5nIGRvdWJsZSBjbGljayB0byB0aGUgZmVhdHVyZSBjaGFpbiBvZiByZXNwb25zaWJpbGl0eVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBvbkRvdWJsZUNsaWNrOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICBpZiAodGhpcy5mZWF0dXJlQ2hhaW4pIHtcbiAgICAgICAgICAgIHRoaXMuZmVhdHVyZUNoYWluLmhhbmRsZURvdWJsZUNsaWNrKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgICAgIHRoaXMuc2V0Q3Vyc29yKGdyaWQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBkZWxlZ2F0ZSBoYW5kbGluZyBob2xkIHB1bHNlIHRvIHRoZSBmZWF0dXJlIGNoYWluIG9mIHJlc3BvbnNpYmlsaXR5XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIG9uSG9sZFB1bHNlOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICBpZiAodGhpcy5mZWF0dXJlQ2hhaW4pIHtcbiAgICAgICAgICAgIHRoaXMuZmVhdHVyZUNoYWluLmhhbmRsZUhvbGRQdWxzZShncmlkLCBldmVudCk7XG4gICAgICAgICAgICB0aGlzLnNldEN1cnNvcihncmlkKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICogQGRlc2MgZGVsZWdhdGUgaGFuZGxpbmcgZG91YmxlIGNsaWNrIHRvIHRoZSBmZWF0dXJlIGNoYWluIG9mIHJlc3BvbnNpYmlsaXR5XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIHRvZ2dsZUNvbHVtblBpY2tlcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLmZlYXR1cmVDaGFpbikge1xuICAgICAgICAgICAgdGhpcy5mZWF0dXJlQ2hhaW4udG9nZ2xlQ29sdW1uUGlja2VyKHRoaXMuZ2V0R3JpZCgpKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICogQGRlc2MgZGVsZWdhdGUgaGFuZGxpbmcgbW91c2UgZG93biB0byB0aGUgZmVhdHVyZSBjaGFpbiBvZiByZXNwb25zaWJpbGl0eVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVNb3VzZURvd246IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLmZlYXR1cmVDaGFpbikge1xuICAgICAgICAgICAgdGhpcy5mZWF0dXJlQ2hhaW4uaGFuZGxlTW91c2VEb3duKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgICAgIHRoaXMuc2V0Q3Vyc29yKGdyaWQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBkZWxlZ2F0ZSBoYW5kbGluZyBtb3VzZSBleGl0IHRvIHRoZSBmZWF0dXJlIGNoYWluIG9mIHJlc3BvbnNpYmlsaXR5XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZU1vdXNlRXhpdDogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuZmVhdHVyZUNoYWluKSB7XG4gICAgICAgICAgICB0aGlzLmZlYXR1cmVDaGFpbi5oYW5kbGVNb3VzZUV4aXQoZ3JpZCwgZXZlbnQpO1xuICAgICAgICAgICAgdGhpcy5zZXRDdXJzb3IoZ3JpZCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIHRoaXMgZnVuY3Rpb24gaXMgcmVwbGFjZWQgYnkgdGhlIGdyaWQgb24gaW5pdGlhbGl6YXRpb24gYW5kIHNlcnZlcyBhcyB0aGUgY2FsbGJhY2tcbiAgICAgKi9cbiAgICBjaGFuZ2VkOiBmdW5jdGlvbigpIHt9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIHRoaXMgZnVuY3Rpb24gaXMgcmVwbGFjZWQgYnkgdGhlIGdyaWQgb24gaW5pdGlhbGl6YXRpb24gYW5kIHNlcnZlcyBhcyB0aGUgY2FsbGJhY2tcbiAgICAgKi9cbiAgICBzaGFwZUNoYW5nZWQ6IGZ1bmN0aW9uKCkge30sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gQ2FuIHJlLW9yZGVyIGNvbHVtbnMuXG4gICAgICovXG4gICAgaXNDb2x1bW5SZW9yZGVyYWJsZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgcHJvcGVydGllcyBmb3IgYSBzcGVjaWZpYyBjb2x1bW4uIFRoZXNlIGFyZSB1c2VkIGlmIG5vIGNlbGwgcHJvcGVydGllcyBhcmUgc3BlY2lmaWVkLlxuICAgICAqIEBwYXJhbSB7aW5kZXh9IGNvbHVtbkluZGV4IC0gdGhlIGNvbHVtbiBpbmRleCBvZiBpbnRlcmVzdFxuICAgICAqL1xuICAgIGdldENvbHVtblByb3BlcnRpZXM6IGZ1bmN0aW9uKGNvbHVtbkluZGV4KSB7XG4gICAgICAgIHZhciBjb2wgPSB0aGlzLmNvbHVtbnNbY29sdW1uSW5kZXhdO1xuICAgICAgICBpZiAoIWNvbCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBpc051bGw6IHRydWVcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHByb3BlcnRpZXMgPSBjb2wuZ2V0UHJvcGVydGllcygpOyAvL1RPRE86IHJldHVybnMgYG51bGxgIG9uIEh5cGVyZ3JpZC5yZXNldCgpO1xuICAgICAgICBpZiAoIXByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgaXNOdWxsOiB0cnVlXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwcm9wZXJ0aWVzO1xuICAgIH0sXG4gICAgc2V0Q29sdW1uUHJvcGVydGllczogZnVuY3Rpb24oY29sdW1uSW5kZXgsIHByb3BlcnRpZXMpIHtcbiAgICAgICAgdmFyIGNvbHVtblByb3BlcnRpZXMgPSB0aGlzLmdldENvbHVtblByb3BlcnRpZXMoY29sdW1uSW5kZXgpO1xuICAgICAgICBfKGNvbHVtblByb3BlcnRpZXMpLmV4dGVuZE93bihwcm9wZXJ0aWVzKTtcbiAgICAgICAgdGhpcy5jaGFuZ2VkKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmdzW119IExhYmVscyB0byB1c2UgZm9yIHRoZSBjb2x1bW4gcGlja2VyLlxuICAgICAqL1xuICAgIGdldENvbHVtbkRlc2NyaXB0b3JzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgLy9hc3N1bWVzIHRoZXJlIGlzIG9uZSByb3cuLi4uXG4gICAgICAgIHRoaXMuaW5zdXJlQ29sdW1uSW5kZXhlc0FyZUluaXRpYWxpemVkKCk7XG4gICAgICAgIHZhciB0YWJsZVN0YXRlID0gdGhpcy5nZXRQcml2YXRlU3RhdGUoKTtcbiAgICAgICAgdmFyIGNvbHVtbkNvdW50ID0gdGFibGVTdGF0ZS5jb2x1bW5JbmRleGVzLmxlbmd0aDtcbiAgICAgICAgdmFyIGxhYmVscyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbHVtbkNvdW50OyBpKyspIHtcbiAgICAgICAgICAgIHZhciBpZCA9IHRhYmxlU3RhdGUuY29sdW1uSW5kZXhlc1tpXTtcbiAgICAgICAgICAgIGxhYmVscy5wdXNoKHtcbiAgICAgICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICAgICAgbGFiZWw6IHRoaXMuZ2V0SGVhZGVyKGlkKSxcbiAgICAgICAgICAgICAgICBmaWVsZDogdGhpcy5nZXRGaWVsZChpZClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsYWJlbHM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBmaWVsZCBhdCBgY29sSW5kZXhgLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb2xJbmRleCAtIHRoZSBjb2x1bW4gaW5kZXggb2YgaW50ZXJlc3RcbiAgICAgKi9cbiAgICBnZXRGaWVsZDogZnVuY3Rpb24oY29sSW5kZXgpIHtcbiAgICAgICAgaWYgKGNvbEluZGV4ID09PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuICd0cmVlJztcbiAgICAgICAgfVxuICAgICAgICB2YXIgY29sID0gdGhpcy5nZXRDb2x1bW4oY29sSW5kZXgpO1xuICAgICAgICByZXR1cm4gY29sLmdldEZpZWxkKCk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgY29sdW1uIGhlYWRpbmcgYXQgYGNvbEluZGV4Jy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY29sSW5kZXggLSB0aGUgY29sdW1uIGluZGV4IG9mIGludGVyZXN0XG4gICAgICovXG4gICAgZ2V0SGVhZGVyOiBmdW5jdGlvbihjb2xJbmRleCkge1xuICAgICAgICBpZiAoY29sSW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm4gJ1RyZWUnO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjb2wgPSB0aGlzLmdldENvbHVtbihjb2xJbmRleCk7XG4gICAgICAgIHJldHVybiBjb2wuZ2V0SGVhZGVyKCk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICogQGRlc2MgdGhpcyBpcyBjYWxsZWQgYnkgdGhlIGNvbHVtbiBlZGl0b3IgcG9zdCBjbG9zaW5nOyByZWJ1aWxkIHRoZSBjb2x1bW4gb3JkZXIgaW5kZXhlc1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGxpc3QgLSBsaXN0IG9mIGNvbHVtbiBvYmplY3RzIGZyb20gdGhlIGNvbHVtbiBlZGl0b3JcbiAgICAgKi9cbiAgICBzZXRDb2x1bW5EZXNjcmlwdG9yczogZnVuY3Rpb24obGlzdHMpIHtcbiAgICAgICAgLy9hc3N1bWVzIHRoZXJlIGlzIG9uZSByb3cuLi4uXG4gICAgICAgIHZhciB2aXNpYmxlID0gbGlzdHMudmlzaWJsZTtcbiAgICAgICAgdmFyIHRhYmxlU3RhdGUgPSB0aGlzLmdldFByaXZhdGVTdGF0ZSgpO1xuXG4gICAgICAgIHZhciBjb2x1bW5Db3VudCA9IHZpc2libGUubGVuZ3RoO1xuICAgICAgICB2YXIgaW5kZXhlcyA9IFtdO1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGNvbHVtbkNvdW50OyBpKyspIHtcbiAgICAgICAgICAgIGluZGV4ZXMucHVzaCh2aXNpYmxlW2ldLmlkKTtcbiAgICAgICAgfVxuICAgICAgICB0YWJsZVN0YXRlLmNvbHVtbkluZGV4ZXMgPSBpbmRleGVzO1xuICAgICAgICB0aGlzLmNoYW5nZWQoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm4ge3N0cmluZ1tdfSBBbGwgdGhlIGN1cnJlbnRseSBoaWRkZW4gY29sdW1uIGhlYWRlciBsYWJlbHMuXG4gICAgICovXG4gICAgZ2V0SGlkZGVuQ29sdW1uRGVzY3JpcHRvcnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdGFibGVTdGF0ZSA9IHRoaXMuZ2V0UHJpdmF0ZVN0YXRlKCk7XG4gICAgICAgIHZhciBpbmRleGVzID0gdGFibGVTdGF0ZS5jb2x1bW5JbmRleGVzO1xuICAgICAgICB2YXIgbGFiZWxzID0gW107XG4gICAgICAgIHZhciBjb2x1bW5Db3VudCA9IHRoaXMuZ2V0Q29sdW1uQ291bnQoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb2x1bW5Db3VudDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaW5kZXhlcy5pbmRleE9mKGkpID09PSAtMSkge1xuICAgICAgICAgICAgICAgIGxhYmVscy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IGksXG4gICAgICAgICAgICAgICAgICAgIGxhYmVsOiB0aGlzLmdldEhlYWRlcihpKSxcbiAgICAgICAgICAgICAgICAgICAgZmllbGQ6IHRoaXMuZ2V0RmllbGQoaSlcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGFiZWxzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICogQGRlc2MgaGlkZSBjb2x1bW5zIHRoYXQgYXJlIHNwZWNpZmllZCBieSB0aGVpciBpbmRleGVzXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXlPZkluZGV4ZXMgLSBhbiBhcnJheSBvZiBjb2x1bW4gaW5kZXhlcyB0byBoaWRlXG4gICAgICovXG4gICAgaGlkZUNvbHVtbnM6IGZ1bmN0aW9uKGFycmF5T2ZJbmRleGVzKSB7XG4gICAgICAgIHZhciB0YWJsZVN0YXRlID0gdGhpcy5nZXRQcml2YXRlU3RhdGUoKTtcbiAgICAgICAgdmFyIG9yZGVyID0gdGFibGVTdGF0ZS5jb2x1bW5JbmRleGVzO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5T2ZJbmRleGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgZWFjaCA9IGFycmF5T2ZJbmRleGVzW2ldO1xuICAgICAgICAgICAgaWYgKG9yZGVyLmluZGV4T2YoZWFjaCkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgb3JkZXIuc3BsaWNlKG9yZGVyLmluZGV4T2YoZWFjaCksIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJuIHtpbnRlZ2VyfSBUaGUgbnVtYmVyIG9mIGZpeGVkIGNvbHVtbnMuXG4gICAgICovXG4gICAgZ2V0Rml4ZWRDb2x1bW5Db3VudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB0YWJsZVN0YXRlID0gdGhpcy5nZXRQcml2YXRlU3RhdGUoKTtcbiAgICAgICAgcmV0dXJuIHRhYmxlU3RhdGUuZml4ZWRDb2x1bW5Db3VudCB8fCAwO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICogQGRlc2Mgc2V0IHRoZSBudW1iZXIgb2YgZml4ZWQgY29sdW1uc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBudW1iZXJPZkZpeGVkQ29sdW1ucyAtIHRoZSBpbnRlZ2VyIGNvdW50IG9mIGhvdyBtYW55IGNvbHVtbnMgdG8gYmUgZml4ZWRcbiAgICAgKi9cbiAgICBzZXRGaXhlZENvbHVtbkNvdW50OiBmdW5jdGlvbihudW1iZXJPZkZpeGVkQ29sdW1ucykge1xuICAgICAgICB2YXIgdGFibGVTdGF0ZSA9IHRoaXMuZ2V0UHJpdmF0ZVN0YXRlKCk7XG4gICAgICAgIHRhYmxlU3RhdGUuZml4ZWRDb2x1bW5Db3VudCA9IG51bWJlck9mRml4ZWRDb2x1bW5zO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICogQHJldHVybiB7aW50ZWdlcn0gVGhlIG51bWJlciBvZiBmaXhlZCByb3dzLlxuICAgICAqL1xuICAgIGdldEZpeGVkUm93Q291bnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMudGFibGVTdGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHVzZXJzU2l6ZSA9IHRoaXMudGFibGVTdGF0ZS5maXhlZFJvd0NvdW50IHx8IDA7XG4gICAgICAgIHZhciBoZWFkZXJzID0gdGhpcy5nZXRHcmlkKCkuZ2V0SGVhZGVyUm93Q291bnQoKTtcbiAgICAgICAgdmFyIHRvdGFsID0gdXNlcnNTaXplICsgaGVhZGVycztcbiAgICAgICAgcmV0dXJuIHRvdGFsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICogQGRlc2Mgc2V0IHRoZSBudW1iZXIgb2Ygcm93cyB0aGF0IGFyZSBmaXhlZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBudW1iZXJPZkZpeGVkUm93cyAtIHRoZSBjb3VudCBvZiByb3dzIHRvIGJlIHNldCBmaXhlZFxuICAgICAqL1xuICAgIHNldEZpeGVkUm93Q291bnQ6IGZ1bmN0aW9uKG51bWJlck9mRml4ZWRSb3dzKSB7XG4gICAgICAgIHRoaXMudGFibGVTdGF0ZS5maXhlZFJvd0NvdW50ID0gbnVtYmVyT2ZGaXhlZFJvd3M7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgZml4ZWQgcm93cy5cbiAgICAgKi9cbiAgICBnZXRIZWFkZXJSb3dDb3VudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBncmlkID0gdGhpcy5nZXRHcmlkKCk7XG4gICAgICAgIHZhciBoZWFkZXIgPSBncmlkLmlzU2hvd0hlYWRlclJvdygpID8gMSA6IDA7XG4gICAgICAgIHZhciBmaWx0ZXIgPSBncmlkLmlzU2hvd0ZpbHRlclJvdygpID8gMSA6IDA7XG4gICAgICAgIHZhciB0b3RhbHMgPSB0aGlzLmdldFRvcFRvdGFscygpLmxlbmd0aDtcbiAgICAgICAgdmFyIGNvdW50ID0gaGVhZGVyICsgZmlsdGVyICsgdG90YWxzO1xuICAgICAgICByZXR1cm4gY291bnQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBzZXQgdGhlIG51bWJlciBvZiByb3dzIHRoYXQgYXJlIGZpeGVkXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG51bWJlck9mRml4ZWRSb3dzIC0gdGhlIGNvdW50IG9mIHJvd3MgdG8gYmUgc2V0IGZpeGVkXG4gICAgICovXG4gICAgc2V0SGVhZGVyUm93Q291bnQ6IGZ1bmN0aW9uKG51bWJlck9mSGVhZGVyUm93cykge1xuICAgICAgICB0aGlzLnRhYmxlU3RhdGUuaGVhZGVyUm93Q291bnQgPSBudW1iZXJPZkhlYWRlclJvd3M7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJuIHtudW1iZXJ9IFRoZSBudW1iZXIgb2YgZml4ZWQgcm93cy5cbiAgICAgKi9cbiAgICBnZXRIZWFkZXJDb2x1bW5Db3VudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBncmlkID0gdGhpcy5nZXRHcmlkKCk7XG4gICAgICAgIHZhciBjb3VudCA9IGdyaWQucmVzb2x2ZVByb3BlcnR5KCdoZWFkZXJDb2x1bW5Db3VudCcpO1xuICAgICAgICByZXR1cm4gY291bnQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gVGhlIG51bWJlciBvZiBmaXhlZCByb3dzLlxuICAgICAqL1xuICAgIHNldEhlYWRlckNvbHVtbkNvdW50OiBmdW5jdGlvbihudW1iZXJPZkhlYWRlckNvbHVtbnMpIHtcbiAgICAgICAgdGhpcy50YWJsZVN0YXRlLmhlYWRlckNvbHVtbkNvdW50ID0gbnVtYmVyT2ZIZWFkZXJDb2x1bW5zO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGJ1aWxkIGFuZCBvcGVuIHRoZSBlZGl0b3Igd2l0aGluIHRoZSBjb250YWluZXIgZGl2IGFyZ3VtZW50XG4gICAgICogQHJldHVybiB7Ym9vbGVhbn0gYGZhbHNlYCBwcmV2ZW50cyBlZGl0b3IgZnJvbSBvcGVuaW5nXG4gICAgICogQHBhcmFtIHtIVE1MRGl2RWxlbWVudH0gZGl2IC0gdGhlIGNvbnRhaW5pbmcgZGl2IGVsZW1lbnRcbiAgICAgKi9cbiAgICBvcGVuRWRpdG9yOiBmdW5jdGlvbihkaXYpIHtcbiAgICAgICAgdmFyIGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXG4gICAgICAgIHZhciBoaWRkZW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdmaW4taHlwZXJncmlkLWRuZC1saXN0Jyk7XG4gICAgICAgIHZhciB2aXNpYmxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZmluLWh5cGVyZ3JpZC1kbmQtbGlzdCcpO1xuXG4gICAgICAgIGNvbnRhaW5lci5hcHBlbmRDaGlsZChoaWRkZW4pO1xuICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQodmlzaWJsZSk7XG5cbiAgICAgICAgdGhpcy5iZUNvbHVtblN0eWxlKGhpZGRlbi5zdHlsZSk7XG4gICAgICAgIGhpZGRlbi50aXRsZSA9ICdoaWRkZW4gY29sdW1ucyc7XG4gICAgICAgIGhpZGRlbi5saXN0ID0gdGhpcy5nZXRIaWRkZW5Db2x1bW5EZXNjcmlwdG9ycygpO1xuXG4gICAgICAgIHRoaXMuYmVDb2x1bW5TdHlsZSh2aXNpYmxlLnN0eWxlKTtcbiAgICAgICAgdmlzaWJsZS5zdHlsZS5sZWZ0ID0gJzUwJSc7XG4gICAgICAgIHZpc2libGUudGl0bGUgPSAndmlzaWJsZSBjb2x1bW5zJztcbiAgICAgICAgdmlzaWJsZS5saXN0ID0gdGhpcy5nZXRDb2x1bW5EZXNjcmlwdG9ycygpO1xuXG4gICAgICAgIGRpdi5saXN0cyA9IHtcbiAgICAgICAgICAgIGhpZGRlbjogaGlkZGVuLmxpc3QsXG4gICAgICAgICAgICB2aXNpYmxlOiB2aXNpYmxlLmxpc3RcbiAgICAgICAgfTtcbiAgICAgICAgZGl2LmFwcGVuZENoaWxkKGNvbnRhaW5lcik7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICogQGRlc2MgdGhlIGVkaXRvciBpcyByZXF1ZXN0aW5nIGNsb3NlOyBkZWFsIHdpdGggdGhlIGVkaXRzXG4gICAgICogQHJldHVybiBgdHJ1ZWBcbiAgICAgKiBAcGFyYW0ge0hUTUxEaXZFbGVtZW50fSBkaXYgLSB0aGUgY29udGFpbmluZyBkaXYgZWxlbWVudFxuICAgICAqL1xuICAgIGNsb3NlRWRpdG9yOiBmdW5jdGlvbihkaXYpIHtcbiAgICAgICAgdmFyIGxpc3RzID0gZGl2Lmxpc3RzO1xuICAgICAgICB0aGlzLnNldENvbHVtbkRlc2NyaXB0b3JzKGxpc3RzKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBhIGRuZCBjb2x1bW4gaGFzIGp1c3QgYmVlbiBkcm9wcGVkLCB3ZSd2ZSBiZWVuIG5vdGlmaWVkXG4gICAgICovXG4gICAgZW5kRHJhZ0NvbHVtbk5vdGlmaWNhdGlvbjogZnVuY3Rpb24oKSB7fSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBiaW5kIGNvbHVtbiBlZGl0b3IgYXBwcm9wcmlhdGUgY3NzIHZhbHVlcyB0byBhcmcgc3R5bGVcbiAgICAgKiBAcGFyYW0ge0hUTUxTdHlsZUVsZW1lbnR9IHN0eWxlIC0gdGhlIHN0eWxlIG9iamVjdCB0byBlbmhhbmNlXG4gICAgICovXG4gICAgYmVDb2x1bW5TdHlsZTogZnVuY3Rpb24oc3R5bGUpIHtcbiAgICAgICAgc3R5bGUudG9wID0gJzUlJztcbiAgICAgICAgc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgICBzdHlsZS53aWR0aCA9ICc1MCUnO1xuICAgICAgICBzdHlsZS5oZWlnaHQgPSAnMTAwJSc7XG4gICAgICAgIHN0eWxlLndoaXRlU3BhY2UgPSAnbm93cmFwJztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm4ge251bGx9IHRoZSBjdXJzb3IgYXQgYSBzcGVjaWZpYyB4LHkgY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gdGhlIHggY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IC0gdGhlIHkgY29vcmRpbmF0ZVxuICAgICAqL1xuICAgIGdldEN1cnNvckF0OiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICogQHJldHVybiB7bnVtYmVyfSBUaGUgdG90YWwgbnVtYmVyIG9mIGNvbHVtbnMuXG4gICAgICovXG4gICAgZ2V0Q29sdW1uQ291bnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb2x1bW5zLmxlbmd0aDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm4ge3N0cmluZ30gLSBUaGUgY29sdW1uIGFsaWdubWVudCBhdCBjb2x1bW4gYHhgLCB3aGljaCBpcyBvbmUgb2YgYCdsZWZ0J2AsIGAnY2VudGVyJ2AgLCBvciBgJ3JpZ2h0J2AuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggLSB0aGUgY29sdW1uIGluZGV4IG9mIGludGVyZXN0XG4gICAgICovXG4gICAgZ2V0Q29sdW1uQWxpZ25tZW50OiBmdW5jdGlvbih4KSB7XG4gICAgICAgIHJldHVybiAnY2VudGVyJztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIHF1aWV0bHkgc2V0IHRoZSBzY3JvbGwgcG9zaXRpb24gaW4gdGhlIGhvcml6b250YWwgZGltZW5zaW9uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggLSB0aGUgcG9zaXRpb24gaW4gcGl4ZWxzXG4gICAgICovXG4gICAgc2V0U2Nyb2xsUG9zaXRpb25YOiBmdW5jdGlvbih4KSB7XG4gICAgICAgIHRoaXMuc2Nyb2xsUG9zaXRpb25YID0geDtcbiAgICB9LFxuXG4gICAgZ2V0U2Nyb2xsUG9zaXRpb25YOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2Nyb2xsUG9zaXRpb25YO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICogQGRlc2MgcXVpZXRseSBzZXQgdGhlIHNjcm9sbCBwb3NpdGlvbiBpbiB0aGUgaG9yaXpvbnRhbCBkaW1lbnNpb25cbiAgICAgKiBAcGFyYW0ge251bWJlcn0geSAtIHRoZSBwb3NpdGlvbiBpbiBwaXhlbHNcbiAgICAgKi9cbiAgICBzZXRTY3JvbGxQb3NpdGlvblk6IGZ1bmN0aW9uKHkpIHtcbiAgICAgICAgdGhpcy5zY3JvbGxQb3NpdGlvblkgPSB5O1xuICAgIH0sXG5cbiAgICBnZXRTY3JvbGxQb3NpdGlvblk6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zY3JvbGxQb3NpdGlvblk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJuIHtjZWxsRWRpdG9yfSBDZWxsIGVkaXRvciBmb3IgY29vcmRpbmF0ZSBgeCx5YC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCAtIHggY29vcmRpbmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5IC0geSBjb29yZGluYXRlXG4gICAgICovXG4gICAgZ2V0Q2VsbEVkaXRvckF0OiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldENvbHVtbih4KS5nZXRDZWxsRWRpdG9yQXQoeCwgeSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBmaXhlZCByb3cgaGFzIGJlZW4gY2xpY2tlZCwgeW91J3ZlIGJlZW4gbm90aWZpZWRcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtb3VzZSAtIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICB0b2dnbGVTb3J0OiBmdW5jdGlvbih4LCBrZXlzKSB7XG4gICAgICAgIHRoaXMuZ2V0Q29sdW1uKHgpLnRvZ2dsZVNvcnQoa2V5cyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBgdHJ1ZWAgaWYgd2Ugc2hvdWxkIGhpZ2hsaWdodCBvbiBob3ZlclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNDb2x1bW5Ib3ZlcmVkIC0gdGhlIGNvbHVtbiBpcyBob3ZlcmVkIG9yIG5vdFxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNSb3dIb3ZlcmVkIC0gdGhlIHJvdyBpcyBob3ZlcmVkIG9yIG5vdFxuICAgICAqL1xuICAgIGhpZ2hsaWdodENlbGxPbkhvdmVyOiBmdW5jdGlvbihpc0NvbHVtbkhvdmVyZWQsIGlzUm93SG92ZXJlZCkge1xuICAgICAgICByZXR1cm4gaXNDb2x1bW5Ib3ZlcmVkICYmIGlzUm93SG92ZXJlZDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm4ge0hUTUxJbWFnZUVsZW1lbnR9XG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSAtIGFuIGltYWdlIGFsaWFzXG4gICAgICovXG4gICAgZ2V0SW1hZ2U6IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICByZXR1cm4gaW1hZ2VzW2tleV07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBzZXQgdGhlIGltYWdlIGZvciBhIHNwZWNpZmljIGFsaWFzXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSAtIGFuIGltYWdlIGFsaWFzXG4gICAgICogQHBhcmFtIHtIVE1MSW1hZ2VFbGVtZW50fSBpbWFnZSAtIHRoZSBpbWFnZSB0byBjYWNoZVxuICAgICAqL1xuICAgIHNldEltYWdlOiBmdW5jdGlvbihrZXksIGltYWdlKSB7XG4gICAgICAgIGltYWdlc1trZXldID0gaW1hZ2U7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyB0aGlzIGZ1bmN0aW9uIGlzIGEgaG9vayBhbmQgaXMgY2FsbGVkIGp1c3QgYmVmb3JlIHRoZSBwYWludGluZyBvZiBhIGNlbGwgb2NjdXJzXG4gICAgICogQHBhcmFtIHt3aW5kb3cuZmluLnJlY3Rhbmd1bGFyLlBvaW50fSBjZWxsXG4gICAgICovXG4gICAgY2VsbFByb3BlcnRpZXNQcmVQYWludE5vdGlmaWNhdGlvbjogZnVuY3Rpb24oY2VsbFByb3BlcnRpZXMpIHtcbiAgICAgICAgdmFyIHJvdyA9IHRoaXMuZ2V0Um93KGNlbGxQcm9wZXJ0aWVzLnkpO1xuICAgICAgICB2YXIgY29sdW1uSWQgPSB0aGlzLmdldEhlYWRlcihjZWxsUHJvcGVydGllcy54KTtcbiAgICAgICAgY2VsbFByb3BlcnRpZXMucm93ID0gcm93O1xuICAgICAgICBjZWxsUHJvcGVydGllcy5jb2x1bW5JZCA9IGNvbHVtbklkO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICogQGRlc2MgdGhpcyBmdW5jdGlvbiBpcyBhIGhvb2sgYW5kIGlzIGNhbGxlZCBqdXN0IGJlZm9yZSB0aGUgcGFpbnRpbmcgb2YgYSBmaXhlZCByb3cgY2VsbCBvY2N1cnNcbiAgICAgKiBAcGFyYW0ge3dpbmRvdy5maW4ucmVjdGFuZ3VsYXIuUG9pbnR9IGNlbGxcbiAgICAgKi9cbiAgICBjZWxsRml4ZWRSb3dQcmVQYWludE5vdGlmaWNhdGlvbjogZnVuY3Rpb24oY2VsbCkge1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBCZWhhdmlvci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyB0aGlzIGZ1bmN0aW9uIGlzIGEgaG9vayBhbmQgaXMgY2FsbGVkIGp1c3QgYmVmb3JlIHRoZSBwYWludGluZyBvZiBhIGZpeGVkIGNvbHVtbiBjZWxsIG9jY3Vyc1xuICAgICAqIEBwYXJhbSB7d2luZG93LmZpbi5yZWN0YW5ndWxhci5Qb2ludH0gY2VsbFxuICAgICAqL1xuICAgIGNlbGxGaXhlZENvbHVtblByZVBhaW50Tm90aWZpY2F0aW9uOiBmdW5jdGlvbihjZWxsKSB7XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIHRoaXMgZnVuY3Rpb24gaXMgYSBob29rIGFuZCBpcyBjYWxsZWQganVzdCBiZWZvcmUgdGhlIHBhaW50aW5nIG9mIGEgdG9wIGxlZnQgY2VsbCBvY2N1cnNcbiAgICAgKiBAcGFyYW0ge3dpbmRvdy5maW4ucmVjdGFuZ3VsYXIuUG9pbnR9IGNlbGxcbiAgICAgKi9cbiAgICBjZWxsVG9wTGVmdFByZVBhaW50Tm90aWZpY2F0aW9uOiBmdW5jdGlvbihjZWxsKSB7XG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIHRoaXMgZnVuY3Rpb24gZW5oYW5jZSB0aGUgZG91YmxlIGNsaWNrIGV2ZW50IGp1c3QgYmVmb3JlIGl0J3MgYnJvYWRjYXN0IHRvIGxpc3RlbmVyc1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIGV2ZW50IHRvIGVuaGFuY2VcbiAgICAgKi9cbiAgICBlbmhhbmNlRG91YmxlQ2xpY2tFdmVudDogZnVuY3Rpb24oZXZlbnQpIHt9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEJlaGF2aW9yLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIHN3YXAgc3JjIGFuZCB0YXIgY29sdW1uc1xuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzcmMgLSBjb2x1bW4gaW5kZXhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdGFyIC0gY29sdW1uIGluZGV4XG4gICAgICovXG4gICAgc3dhcENvbHVtbnM6IGZ1bmN0aW9uKHNvdXJjZSwgdGFyZ2V0KSB7XG4gICAgICAgIHZhciBjb2x1bW5zID0gdGhpcy5jb2x1bW5zO1xuICAgICAgICB2YXIgdG1wID0gY29sdW1uc1tzb3VyY2VdO1xuICAgICAgICBjb2x1bW5zW3NvdXJjZV0gPSBjb2x1bW5zW3RhcmdldF07XG4gICAgICAgIGNvbHVtbnNbdGFyZ2V0XSA9IHRtcDtcbiAgICAgICAgdGhpcy5jaGFuZ2VkKCk7XG4gICAgfSxcblxuICAgIGdldENvbHVtbkVkZ2U6IGZ1bmN0aW9uKGMsIHJlbmRlcmVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldERhdGFNb2RlbCgpLmdldENvbHVtbkVkZ2UoYywgcmVuZGVyZXIpO1xuICAgIH0sXG5cbiAgICBzZXRUb3RhbHNWYWx1ZTogZnVuY3Rpb24oeCwgeSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5nZXRHcmlkKCkuc2V0VG90YWxzVmFsdWVOb3RpZmljYXRpb24oeCwgeSwgdmFsdWUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQmVoYXZpb3IucHJvdG90eXBlXG4gICAgICogQHJldHVybiB7b2JqZWN0fSBUaGUgb2JqZWN0IGF0IHkgaW5kZXguXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHkgLSB0aGUgcm93IGluZGV4IG9mIGludGVyZXN0XG4gICAgICovXG4gICAgZ2V0Um93OiBmdW5jdGlvbih5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldERhdGFNb2RlbCgpLmdldFJvdyh5KTtcbiAgICB9LFxuXG4gICAgY29udmVydFZpZXdQb2ludFRvRGF0YVBvaW50OiBmdW5jdGlvbih2aWV3UG9pbnQpIHtcbiAgICAgICAgdmFyIG5ld1ggPSB0aGlzLmdldENvbHVtbih2aWV3UG9pbnQueCk7XG4gICAgICAgIHZhciBuZXdQb2ludCA9IHRoaXMuZ2V0R3JpZCgpLm5ld1BvaW50KG5ld1gsIHZpZXdQb2ludC55KTtcbiAgICAgICAgcmV0dXJuIG5ld1BvaW50O1xuICAgIH0sXG5cbiAgICBzZXRHcm91cHM6IGZ1bmN0aW9uKGFycmF5T2ZDb2x1bW5JbmRleGVzKSB7XG4gICAgICAgIHRoaXMuZ2V0RGF0YU1vZGVsKCkuc2V0R3JvdXBzKGFycmF5T2ZDb2x1bW5JbmRleGVzKTtcbiAgICAgICAgdGhpcy5jcmVhdGVDb2x1bW5zKCk7XG4gICAgICAgIHRoaXMuY2hhbmdlZCgpO1xuICAgIH0sXG5cbiAgICBzZXRBZ2dyZWdhdGVzOiBmdW5jdGlvbihtYXBPZktleXNUb0Z1bmN0aW9ucykge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHRoaXMuZ2V0RGF0YU1vZGVsKCkuc2V0QWdncmVnYXRlcyhtYXBPZktleXNUb0Z1bmN0aW9ucyk7XG4gICAgICAgIHRoaXMuY3JlYXRlQ29sdW1ucygpO1xuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgc2VsZi5jaGFuZ2VkKCk7XG4gICAgICAgIH0sIDEwMCk7XG4gICAgfSxcblxuICAgIGhhc0hpZXJhcmNoeUNvbHVtbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgZ2V0Um93Q29udGV4dEZ1bmN0aW9uOiBmdW5jdGlvbihzZWxlY3RlZFJvd3MpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIGdldFNlbGVjdGlvbk1hdHJpeEZ1bmN0aW9uOiBmdW5jdGlvbihzZWxlY3RlZFJvd3MpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIGdldEZpZWxkTmFtZTogZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RmllbGRzKClbaW5kZXhdO1xuICAgIH0sXG5cbiAgICBnZXRDb2x1bW5JbmRleDogZnVuY3Rpb24oZmllbGROYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEZpZWxkcygpLmluZGV4T2YoZmllbGROYW1lKTtcbiAgICB9LFxuXG4gICAgZ2V0Q29tcHV0ZWRSb3c6IGZ1bmN0aW9uKHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RGF0YU1vZGVsKCkuZ2V0Q29tcHV0ZWRSb3coeSk7XG4gICAgfSxcblxuICAgIGF1dG9zaXplQWxsQ29sdW1uczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuY2hlY2tDb2x1bW5BdXRvc2l6aW5nKHRydWUpO1xuICAgICAgICB0aGlzLmNoYW5nZWQoKTtcbiAgICB9LFxuXG4gICAgY2hlY2tDb2x1bW5BdXRvc2l6aW5nOiBmdW5jdGlvbihmb3JjZSkge1xuICAgICAgICBmb3JjZSA9IGZvcmNlID09PSB0cnVlO1xuICAgICAgICB0aGlzLmFsbENvbHVtbnNbLTFdLmNoZWNrQ29sdW1uQXV0b3NpemluZyh0cnVlKTtcbiAgICAgICAgdGhpcy5hbGxDb2x1bW5zWy0yXS5jaGVja0NvbHVtbkF1dG9zaXppbmcoZm9yY2UpO1xuICAgICAgICB0aGlzLmFsbENvbHVtbnMuZm9yRWFjaChmdW5jdGlvbihjb2x1bW4pIHtcbiAgICAgICAgICAgIGNvbHVtbi5jaGVja0NvbHVtbkF1dG9zaXppbmcoZm9yY2UpO1xuICAgICAgICB9KTtcbiAgICB9LFxuXG4gICAgYXV0b1NpemVSb3dOdW1iZXJDb2x1bW46IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmFsbENvbHVtbnNbLTFdLmNoZWNrQ29sdW1uQXV0b3NpemluZyh0cnVlKTtcbiAgICB9LFxuXG4gICAgc2V0R2xvYmFsRmlsdGVyOiBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgICAgdGhpcy5nZXREYXRhTW9kZWwoKS5zZXRHbG9iYWxGaWx0ZXIoc3RyaW5nKTtcbiAgICB9LFxuXG4gICAgZ2V0U2VsZWN0ZWRSb3dzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0R3JpZCgpLmdldFNlbGVjdGlvbk1vZGVsKCkuZ2V0U2VsZWN0ZWRSb3dzKCk7XG4gICAgfSxcblxuICAgIGdldFNlbGVjdGVkQ29sdW1uczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEdyaWQoKS5nZXRTZWxlY3Rpb25Nb2RlbCgpLmdldFNlbGVjdGVkQ29sdW1ucygpO1xuICAgIH0sXG5cbiAgICBnZXRTZWxlY3Rpb25zOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0R3JpZCgpLmdldFNlbGVjdGlvbk1vZGVsKCkuZ2V0U2VsZWN0aW9ucygpO1xuICAgIH1cblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gQmVoYXZpb3I7XG4iLCIvKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgXyA9IHJlcXVpcmUoJ29iamVjdC1pdGVyYXRvcnMnKTtcblxuZnVuY3Rpb24gQ29sdW1uKGJlaGF2aW9yLCBpbmRleCwgbGFiZWwpIHtcbiAgICB0aGlzLmJlaGF2aW9yID0gYmVoYXZpb3I7XG4gICAgdGhpcy5kYXRhTW9kZWwgPSBiZWhhdmlvci5nZXREYXRhTW9kZWwoKTtcbiAgICB0aGlzLmluZGV4ID0gaW5kZXg7XG4gICAgdGhpcy5sYWJlbCA9IGxhYmVsO1xufVxuXG5Db2x1bW4ucHJvdG90eXBlID0ge1xuICAgIGNvbnN0cnVjdG9yOiBDb2x1bW4ucHJvdG90eXBlLmNvbnN0cnVjdG9yLFxuXG4gICAgZ2V0VmFsdWU6IGZ1bmN0aW9uKHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YU1vZGVsLmdldFZhbHVlKHRoaXMuaW5kZXgsIHkpO1xuICAgIH0sXG5cbiAgICBzZXRWYWx1ZTogZnVuY3Rpb24oeSwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YU1vZGVsLnNldFZhbHVlKHRoaXMuaW5kZXgsIHksIHZhbHVlKTtcbiAgICB9LFxuXG4gICAgZ2V0V2lkdGg6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcHJvcGVydGllcyA9IHRoaXMuZ2V0UHJvcGVydGllcygpO1xuICAgICAgICBpZiAocHJvcGVydGllcykge1xuICAgICAgICAgICAgdmFyIG92ZXJyaWRlID0gcHJvcGVydGllcy53aWR0aDtcbiAgICAgICAgICAgIGlmIChvdmVycmlkZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBvdmVycmlkZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5iZWhhdmlvci5yZXNvbHZlUHJvcGVydHkoJ2RlZmF1bHRDb2x1bW5XaWR0aCcpO1xuICAgIH0sXG5cbiAgICBzZXRXaWR0aDogZnVuY3Rpb24od2lkdGgpIHtcbiAgICAgICAgdGhpcy5nZXRQcm9wZXJ0aWVzKCkud2lkdGggPSBNYXRoLm1heCg1LCB3aWR0aCk7XG4gICAgfSxcblxuICAgIGdldENlbGxSZW5kZXJlcjogZnVuY3Rpb24oY29uZmlnLCB5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRhdGFNb2RlbC5nZXRDZWxsUmVuZGVyZXIoY29uZmlnLCB0aGlzLmluZGV4LCB5KTtcbiAgICB9LFxuXG4gICAgZ2V0Q2VsbFByb3BlcnRpZXM6IGZ1bmN0aW9uKHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmVoYXZpb3IuZ2V0UHJpdmF0ZVN0YXRlKCkuY2VsbFByb3BlcnRpZXNbdGhpcy5pbmRleCArICcsJyArIHldO1xuICAgIH0sXG5cbiAgICBzZXRDZWxsUHJvcGVydGllczogZnVuY3Rpb24oeSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5iZWhhdmlvci5nZXRQcml2YXRlU3RhdGUoKS5jZWxsUHJvcGVydGllc1t0aGlzLmluZGV4ICsgJywnICsgeV0gPSB2YWx1ZTtcbiAgICB9LFxuXG4gICAgY2hlY2tDb2x1bW5BdXRvc2l6aW5nOiBmdW5jdGlvbihmb3JjZSkge1xuICAgICAgICB2YXIgcHJvcGVydGllcyA9IHRoaXMuZ2V0UHJvcGVydGllcygpO1xuICAgICAgICB2YXIgYSwgYiwgZDtcbiAgICAgICAgaWYgKHByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIGEgPSBwcm9wZXJ0aWVzLndpZHRoO1xuICAgICAgICAgICAgYiA9IHByb3BlcnRpZXMucHJlZmVycmVkV2lkdGggfHwgcHJvcGVydGllcy53aWR0aDtcbiAgICAgICAgICAgIGQgPSBwcm9wZXJ0aWVzLmNvbHVtbkF1dG9zaXplZCAmJiAhZm9yY2U7XG4gICAgICAgICAgICBpZiAoYSAhPT0gYiB8fCAhZCkge1xuICAgICAgICAgICAgICAgIHByb3BlcnRpZXMud2lkdGggPSAhZCA/IGIgOiBNYXRoLm1heChhLCBiKTtcbiAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzLmNvbHVtbkF1dG9zaXplZCA9ICFpc05hTihwcm9wZXJ0aWVzLndpZHRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICBnZXRQcm9wZXJ0aWVzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmVoYXZpb3IuZ2V0UHJpdmF0ZVN0YXRlKCkuY29sdW1uUHJvcGVydGllc1t0aGlzLmluZGV4XTtcbiAgICB9LFxuXG4gICAgc2V0UHJvcGVydGllczogZnVuY3Rpb24ocHJvcGVydGllcykge1xuICAgICAgICB2YXIgY3VycmVudCA9IHRoaXMuYmVoYXZpb3IuZ2V0UHJpdmF0ZVN0YXRlKCkuY29sdW1uUHJvcGVydGllc1t0aGlzLmluZGV4XTtcbiAgICAgICAgdGhpcy5jbGVhck9iamVjdFByb3BlcnRpZXMoY3VycmVudCwgZmFsc2UpO1xuICAgICAgICBfKGN1cnJlbnQpLmV4dGVuZE93bihwcm9wZXJ0aWVzKTtcbiAgICB9LFxuXG4gICAgdG9nZ2xlU29ydDogZnVuY3Rpb24oa2V5cykge1xuICAgICAgICB0aGlzLmRhdGFNb2RlbC50b2dnbGVTb3J0KHRoaXMuaW5kZXgsIGtleXMpO1xuICAgIH0sXG5cbiAgICBnZXRDZWxsRWRpdG9yQXQ6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YU1vZGVsLmdldENlbGxFZGl0b3JBdCh0aGlzLmluZGV4LCB5KTtcbiAgICB9LFxuXG4gICAgZ2V0SGVhZGVyOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGFiZWw7XG4gICAgfSxcblxuICAgIGdldEZpZWxkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YU1vZGVsLmdldEZpZWxkcygpW3RoaXMuaW5kZXhdO1xuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ29sdW1uO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBEYXRhTW9kZWxEZWNvcmF0b3IoZ3JpZCwgY29tcG9uZW50KSB7XG4gICAgdGhpcy5zZXRDb21wb25lbnQoY29tcG9uZW50KTtcbiAgICB0aGlzLnNldEdyaWQoZ3JpZCk7XG59XG5cbkRhdGFNb2RlbERlY29yYXRvci5wcm90b3R5cGUgPSB7XG4gICAgY29uc3RydWN0b3I6IERhdGFNb2RlbERlY29yYXRvci5wcm90b3R5cGUuY29uc3RydWN0b3IsXG5cbiAgICBjb21wb25lbnQ6IG51bGwsXG4gICAgZ3JpZDogbnVsbCxcblxuICAgIGdldEdyaWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ncmlkO1xuICAgIH0sXG5cbiAgICBzZXRHcmlkOiBmdW5jdGlvbihuZXdHcmlkKSB7XG4gICAgICAgIHRoaXMuZ3JpZCA9IG5ld0dyaWQ7XG4gICAgICAgIHRoaXMuZ2V0Q29tcG9uZW50KCkuc2V0R3JpZChuZXdHcmlkKTtcbiAgICB9LFxuXG4gICAgZ2V0QmVoYXZpb3I6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRHcmlkKCkuZ2V0QmVoYXZpb3IoKTtcbiAgICB9LFxuXG4gICAgY2hhbmdlZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuZ2V0QmVoYXZpb3IoKS5jaGFuZ2VkKCk7XG4gICAgfSxcblxuICAgIGdldFByaXZhdGVTdGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEdyaWQoKS5nZXRQcml2YXRlU3RhdGUoKTtcbiAgICB9LFxuXG4gICAgYXBwbHlTdGF0ZTogZnVuY3Rpb24oKSB7XG5cbiAgICB9LFxuXG4gICAgc2V0Q29tcG9uZW50OiBmdW5jdGlvbihuZXdDb21wb25lbnQpIHtcbiAgICAgICAgdGhpcy5jb21wb25lbnQgPSBuZXdDb21wb25lbnQ7XG4gICAgfSxcblxuICAgIGdldENvbXBvbmVudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBvbmVudDtcbiAgICB9LFxuXG4gICAgc2V0R2xvYmFsRmlsdGVyOiBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q29tcG9uZW50KCkuc2V0R2xvYmFsRmlsdGVyKHN0cmluZyk7XG4gICAgfSxcblxuICAgIGdldFZhbHVlOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldENvbXBvbmVudCgpLmdldFZhbHVlKHgsIHkpO1xuICAgIH0sXG5cbiAgICBzZXRWYWx1ZTogZnVuY3Rpb24oeCwgeSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5nZXRDb21wb25lbnQoKS5zZXRWYWx1ZSh4LCB5LCB2YWx1ZSk7XG4gICAgfSxcblxuICAgIGdldENvbHVtbkNvdW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q29tcG9uZW50KCkuZ2V0Q29sdW1uQ291bnQoKTtcbiAgICB9LFxuXG4gICAgZ2V0Um93Q291bnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRDb21wb25lbnQoKS5nZXRSb3dDb3VudCgpO1xuICAgIH0sXG5cbiAgICBnZXRDZWxsUmVuZGVyZXI6IGZ1bmN0aW9uKGNvbmZpZywgeCwgeSwgdW50cmFuc2xhdGVkWCwgdW50cmFuc2xhdGVkWSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRDb21wb25lbnQoKS5nZXRDZWxsUmVuZGVyZXIoY29uZmlnLCB4LCB5LCB1bnRyYW5zbGF0ZWRYLCB1bnRyYW5zbGF0ZWRZKTtcbiAgICB9LFxuXG4gICAgZ2V0Um93SGVpZ2h0OiBmdW5jdGlvbih5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldENvbXBvbmVudCgpLmdldFJvd0hlaWdodCh5KTtcbiAgICB9LFxuXG4gICAgZ2V0Q29sdW1uRWRnZTogZnVuY3Rpb24oeCwgcmVuZGVyZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q29tcG9uZW50KCkuZ2V0Q29sdW1uRWRnZSh4LCByZW5kZXJlcik7XG4gICAgfSxcblxuICAgIGdldENvbHVtbldpZHRoOiBmdW5jdGlvbih4KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldENvbXBvbmVudCgpLmdldENvbHVtbldpZHRoKHgpO1xuICAgIH0sXG5cbiAgICBzZXRDb2x1bW5XaWR0aDogZnVuY3Rpb24oeCwgd2lkdGgpIHtcbiAgICAgICAgdGhpcy5nZXRDb21wb25lbnQoKS5zZXRDb2x1bW5XaWR0aCh4LCB3aWR0aCk7XG4gICAgfSxcblxuICAgIHRvZ2dsZVNvcnQ6IGZ1bmN0aW9uKHgsIGtleXMpIHtcbiAgICAgICAgdGhpcy5nZXRDb21wb25lbnQoKS50b2dnbGVTb3J0KHgsIGtleXMpO1xuICAgIH0sXG5cbiAgICBnZXRDb2x1bW5Qcm9wZXJ0aWVzOiBmdW5jdGlvbihjb2x1bW5JbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRDb21wb25lbnQoKS5nZXRDb2x1bW5Qcm9wZXJ0aWVzKGNvbHVtbkluZGV4KTtcbiAgICB9LFxuXG4gICAgc2V0Q29sdW1uUHJvcGVydGllczogZnVuY3Rpb24oY29sdW1uSW5kZXgsIHByb3BlcnRpZXMpIHtcbiAgICAgICAgdGhpcy5nZXRDb21wb25lbnQoKS5zZXRDb2x1bW5Qcm9wZXJ0aWVzKGNvbHVtbkluZGV4LCBwcm9wZXJ0aWVzKTtcbiAgICB9LFxuXG4gICAgZ2V0SGVhZGVyczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldENvbXBvbmVudCgpLmdldEhlYWRlcnMoKTtcbiAgICB9LFxuXG4gICAgZ2V0RmllbGRzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q29tcG9uZW50KCkuZ2V0RmllbGRzKCk7XG4gICAgfSxcblxuICAgIHNldEZpZWxkczogZnVuY3Rpb24oZmllbGRzKSB7XG4gICAgICAgIHRoaXMuZ2V0Q29tcG9uZW50KCkuc2V0RmllbGRzKGZpZWxkcyk7XG4gICAgfSxcblxuICAgIGdldENlbGxQcm9wZXJ0aWVzOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldENvbXBvbmVudCgpLmdldENlbGxQcm9wZXJ0aWVzKHgsIHkpO1xuICAgIH0sXG5cbiAgICBzZXRDZWxsUHJvcGVydGllczogZnVuY3Rpb24oeCwgeSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5nZXRDb21wb25lbnQoKS5zZXRDZWxsUHJvcGVydGllcyh4LCB5LCB2YWx1ZSk7XG4gICAgfSxcblxuICAgIGdldFJvdzogZnVuY3Rpb24oeSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRDb21wb25lbnQoKS5nZXRSb3coeSk7XG4gICAgfSxcblxuICAgIHNldFRvcFRvdGFsczogZnVuY3Rpb24obmVzdGVkQXJyYXkpIHtcbiAgICAgICAgdGhpcy5nZXRDb21wb25lbnQoKS5zZXRUb3BUb3RhbHMobmVzdGVkQXJyYXkpO1xuICAgIH0sXG5cbiAgICBnZXRUb3BUb3RhbHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRDb21wb25lbnQoKS5nZXRUb3BUb3RhbHMoKTtcbiAgICB9LFxuXG4gICAgc2V0RGF0YTogZnVuY3Rpb24oeSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRDb21wb25lbnQoKS5zZXREYXRhKHkpO1xuICAgIH0sXG5cbiAgICBoYXNIaWVyYXJjaHlDb2x1bW46IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRDb21wb25lbnQoKS5oYXNIaWVyYXJjaHlDb2x1bW4oKTtcbiAgICB9LFxuXG4gICAgc2V0SGVhZGVyczogZnVuY3Rpb24oaGVhZGVyTGFiZWxzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldENvbXBvbmVudCgpLnNldEhlYWRlcnMoaGVhZGVyTGFiZWxzKTtcbiAgICB9LFxuXG4gICAgY2VsbENsaWNrZWQ6IGZ1bmN0aW9uKGNlbGwsIGV2ZW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldENvbXBvbmVudCgpLmNlbGxDbGlja2VkKGNlbGwsIGV2ZW50KTtcbiAgICB9LFxuXG4gICAgZ2V0QXZhaWxhYmxlR3JvdXBzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q29tcG9uZW50KCkuZ2V0QXZhaWxhYmxlR3JvdXBzKCk7XG4gICAgfSxcblxuICAgIGdldEdyb3VwczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldENvbXBvbmVudCgpLmdldEdyb3VwcygpO1xuICAgIH0sXG5cbiAgICBzZXRHcm91cHM6IGZ1bmN0aW9uKGdyb3Vwcykge1xuICAgICAgICB0aGlzLmdldENvbXBvbmVudCgpLnNldEdyb3Vwcyhncm91cHMpO1xuICAgIH0sXG5cbiAgICBnZXRIaWRkZW5Db2x1bW5zOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q29tcG9uZW50KCkuZ2V0SGlkZGVuQ29sdW1ucygpO1xuICAgIH0sXG5cbiAgICBnZXRWaXNpYmxlQ29sdW1uczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldENvbXBvbmVudCgpLmdldFZpc2libGVDb2x1bW5zKCk7XG4gICAgfSxcblxuICAgIHNldEFnZ3JlZ2F0ZXM6IGZ1bmN0aW9uKGFnZ3JlZ2F0ZXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0Q29tcG9uZW50KCkuc2V0QWdncmVnYXRlcyhhZ2dyZWdhdGVzKTtcbiAgICB9LFxuXG4gICAgcmVzZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmdldENvbXBvbmVudCgpLnJlc2V0KCk7XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBEYXRhTW9kZWxEZWNvcmF0b3I7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBMaXN0RHJhZ29uID0gcmVxdWlyZSgnbGlzdC1kcmFnb24nKTtcblxudmFyIEJlaGF2aW9yID0gcmVxdWlyZSgnLi9CZWhhdmlvcicpO1xudmFyIERhdGFNb2RlbERlY29yYXRvciA9IHJlcXVpcmUoJy4vRGF0YU1vZGVsRGVjb3JhdG9yJyk7XG52YXIgRGF0YU1vZGVsSlNPTiA9IHJlcXVpcmUoJy4uL2RhdGFNb2RlbHMvSlNPTicpO1xudmFyIGZlYXR1cmVzID0gcmVxdWlyZSgnLi4vZmVhdHVyZXMvaW5kZXgnKTtcbnZhciBhZGRTdHlsZXNoZWV0ID0gcmVxdWlyZSgnLi4vc3R5bGVzaGVldHMnKTtcbnZhciBhZ2dyZWdhdGlvbnMgPSByZXF1aXJlKCdoeXBlci1hbmFseXRpY3MnKS51dGlsLmFnZ3JlZ2F0aW9ucztcbi8vdmFyIGFnZ3JlZ2F0aW9ucyA9IHJlcXVpcmUoJy4uL2xvY2FsX25vZGVfbW9kdWxlcy9uZXdhbmFseXRpY3MnKS51dGlsLmFnZ3JlZ2F0aW9ucztcbi8vdmFyIGFnZ3JlZ2F0aW9ucyA9IHJlcXVpcmUoJy4uL2xvY2FsX25vZGVfbW9kdWxlcy9maW5hbmFseXRpY3MnKS5hZ2dyZWdhdGlvbnM7XG5cbi8qKlxuICogQG5hbWUgYmVoYXZpb3JzLkpTT05cbiAqIEBkZXNjID4gU2FtZSBwYXJhbWV0ZXJzIGFzIHtAbGluayBiZWhhdmlvcnMuSlNPTiNpbml0aWFsaXplfGluaXRpYWxpemV9LCB3aGljaCBpcyBjYWxsZWQgYnkgdGhpcyBjb25zdHJ1Y3Rvci5cbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgSlNPTiA9IEJlaGF2aW9yLmV4dGVuZCgnYmVoYXZpb3JzLkpTT04nLCB7XG5cbiAgICAvKipcbiAgICAgKiBAc3VtbWFyeSBDb25zdHJ1Y3RvciBsb2dpYywgY2FsbGVkIF9hZnRlcl97QGxpbmsgQmVoYXZpb3IjaW5pdGlhbGl6ZXxCZWhhdmlvci5pbml0aWFsaXplKCl9LlxuICAgICAqIEBkZXNjIFRoaXMgbWV0aG9kIHdpbGwgYmUgY2FsbGVkIHVwb24gaW5zdGFudGlhdGlvbiBvZiB0aGlzIGNsYXNzIG9yIG9mIGFueSBjbGFzcyB0aGF0IGV4dGVuZHMgZnJvbSB0aGlzIGNsYXNzLlxuICAgICAqID4gQWxsIGBpbml0aWFsaXplKClgIG1ldGhvZHMgaW4gdGhlIGluaGVyaXRhbmNlIGNoYWluIGFyZSBjYWxsZWQsIGluIHR1cm4sIGVhY2ggd2l0aCB0aGUgc2FtZSBwYXJhbWV0ZXJzIHRoYXQgd2VyZSBwYXNzZWQgdG8gdGhlIGNvbnN0cnVjdG9yLCBiZWdpbm5pbmcgd2l0aCB0aGF0IG9mIHRoZSBtb3N0IFwic2VuaW9yXCIgY2xhc3MgdGhyb3VnaCB0aGF0IG9mIHRoZSBjbGFzcyBvZiB0aGUgbmV3IGluc3RhbmNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIGdyaWQgLSB0aGUgaHlwZXJncmlkXG4gICAgICogQHBhcmFtIHtvYmplY3RbXX0gZGF0YVJvd3MgLSBhcnJheSBvZiB1bmlmb3JtIGRhdGEgb2JqZWN0c1xuICAgICAqIEBtZW1iZXJPZiBiZWhhdmlvcnMuSlNPTi5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBpbml0aWFsaXplOiBmdW5jdGlvbihncmlkLCBkYXRhUm93cykge1xuICAgICAgICB0aGlzLnNldERhdGEoZGF0YVJvd3MpO1xuICAgIH0sXG5cbiAgICBmZWF0dXJlczogW1xuICAgICAgICBmZWF0dXJlcy5DZWxsU2VsZWN0aW9uLFxuICAgICAgICBmZWF0dXJlcy5LZXlQYWdpbmcsXG4gICAgICAgIGZlYXR1cmVzLk92ZXJsYXksXG4gICAgICAgIGZlYXR1cmVzLkNvbHVtblJlc2l6aW5nLFxuICAgICAgICBmZWF0dXJlcy5Sb3dSZXNpemluZyxcbiAgICAgICAgZmVhdHVyZXMuRmlsdGVycyxcbiAgICAgICAgZmVhdHVyZXMuUm93U2VsZWN0aW9uLFxuICAgICAgICBmZWF0dXJlcy5Db2x1bW5TZWxlY3Rpb24sXG4gICAgICAgIGZlYXR1cmVzLkNvbHVtbk1vdmluZyxcbiAgICAgICAgZmVhdHVyZXMuQ29sdW1uU29ydGluZyxcbiAgICAgICAgZmVhdHVyZXMuQ2VsbEVkaXRpbmcsXG4gICAgICAgIGZlYXR1cmVzLkNlbGxDbGljayxcbiAgICAgICAgZmVhdHVyZXMuT25Ib3ZlclxuICAgIF0sXG5cbiAgICBhZ2dyZWdhdGlvbnM6IGFnZ3JlZ2F0aW9ucyxcblxuICAgIGNyZWF0ZUNvbHVtbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZGF0YU1vZGVsID0gdGhpcy5nZXREYXRhTW9kZWwoKTtcbiAgICAgICAgdmFyIGNvbHVtbkNvdW50ID0gZGF0YU1vZGVsLmdldENvbHVtbkNvdW50KCk7XG4gICAgICAgIHZhciBoZWFkZXJzID0gZGF0YU1vZGVsLmdldEhlYWRlcnMoKTtcbiAgICAgICAgdmFyIGZpZWxkcyA9IGRhdGFNb2RlbC5nZXRGaWVsZHMoKTtcbiAgICAgICAgdGhpcy5jbGVhckNvbHVtbnMoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb2x1bW5Db3VudDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgaGVhZGVyID0gaGVhZGVyc1tpXTtcbiAgICAgICAgICAgIHZhciBjb2x1bW4gPSB0aGlzLmFkZENvbHVtbihpLCBoZWFkZXIpO1xuICAgICAgICAgICAgdmFyIHByb3BlcnRpZXMgPSBjb2x1bW4uZ2V0UHJvcGVydGllcygpO1xuICAgICAgICAgICAgcHJvcGVydGllcy5maWVsZCA9IGZpZWxkc1tpXTtcbiAgICAgICAgICAgIHByb3BlcnRpZXMuaGVhZGVyID0gaGVhZGVyO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGdldERlZmF1bHREYXRhTW9kZWw6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgbW9kZWwgPSBuZXcgRGF0YU1vZGVsSlNPTigpO1xuICAgICAgICB2YXIgd3JhcHBlciA9IG5ldyBEYXRhTW9kZWxEZWNvcmF0b3IodGhpcy5nZXRHcmlkKCksIG1vZGVsKTtcbiAgICAgICAgd3JhcHBlci5zZXRDb21wb25lbnQobW9kZWwpO1xuICAgICAgICByZXR1cm4gd3JhcHBlcjtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIGJlaGF2aW9ycy5KU09OLnByb3RvdHlwZVxuICAgICAqIEBkZXNjcmlwdGlvbiBTZXQgdGhlIGhlYWRlciBsYWJlbHMuXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gaGVhZGVyTGFiZWxzIC0gVGhlIGhlYWRlciBsYWJlbHMuXG4gICAgICovXG4gICAgc2V0SGVhZGVyczogZnVuY3Rpb24oaGVhZGVyTGFiZWxzKSB7XG4gICAgICAgIHRoaXMuZ2V0RGF0YU1vZGVsKCkuc2V0SGVhZGVycyhoZWFkZXJMYWJlbHMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgYmVoYXZpb3JzLkpTT04ucHJvdG90eXBlXG4gICAgICogQGRlc2MgKiBAcmV0dXJucyB7c3RyaW5nW119IFRoZSBoZWFkZXIgbGFiZWxzLlxuICAgICAqL1xuICAgIGdldEhlYWRlcnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXREYXRhTW9kZWwoKS5nZXRIZWFkZXJzKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBiZWhhdmlvcnMuSlNPTi5wcm90b3R5cGVcbiAgICAgKiBAZGVzY3JpcHRpb24gU2V0IHRoZSBmaWVsZHMgYXJyYXkuXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gZmllbGROYW1lcyAtIFRoZSBmaWVsZCBuYW1lcy5cbiAgICAgKi9cbiAgICBzZXRGaWVsZHM6IGZ1bmN0aW9uKGZpZWxkTmFtZXMpIHtcbiAgICAgICAgLy93ZXJlIGRlZmluaW5nIHRoZSBjb2x1bW5zIGJhc2VkIG9uIGZpZWxkIG5hbWVzLi4uLlxuICAgICAgICAvL3dlIG11c3QgcmVidWlsZCB0aGUgY29sdW1uIGRlZmluaXRpb25zXG4gICAgICAgIHRoaXMuZ2V0RGF0YU1vZGVsKCkuc2V0RmllbGRzKGZpZWxkTmFtZXMpO1xuICAgICAgICB0aGlzLmNyZWF0ZUNvbHVtbnMoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIGJlaGF2aW9ycy5KU09OLnByb3RvdHlwZVxuICAgICAqIEBkZXNjcmlwdGlvbiBHZXQgdGhlIGZpZWxkIG5hbWVzLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmdbXX1cbiAgICAgKi9cbiAgICBnZXRGaWVsZHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXREYXRhTW9kZWwoKS5nZXRGaWVsZHMoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIGJlaGF2aW9ycy5KU09OLnByb3RvdHlwZVxuICAgICAqIEBkZXNjcmlwdGlvbiBTZXQgdGhlIGRhdGEgZmllbGQuXG4gICAgICogQHBhcmFtIHtvYmplY3RbXX0gb2JqZWN0cyAtIEFuIGFycmF5IG9mIHVuaWZvcm0gb2JqZWN0cywgZWFjaCBiZWluZyBhIHJvdyBpbiB0aGUgZ3JpZC5cbiAgICAgKi9cbiAgICBzZXREYXRhOiBmdW5jdGlvbihkYXRhUm93cykge1xuICAgICAgICB0aGlzLmdldERhdGFNb2RlbCgpLnNldERhdGEoZGF0YVJvd3MpO1xuICAgICAgICB0aGlzLmNyZWF0ZUNvbHVtbnMoKTtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICBpZiAodGhpcy5nZXRHcmlkKCkuaXNDb2x1bW5BdXRvc2l6aW5nKCkpIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5hdXRvc2l6ZUFsbENvbHVtbnMoKTtcbiAgICAgICAgICAgIH0sIDEwMCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHNlbGYuYWxsQ29sdW1uc1stMV0uY2hlY2tDb2x1bW5BdXRvc2l6aW5nKHRydWUpO1xuICAgICAgICAgICAgICAgIHNlbGYuY2hhbmdlZCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIGJlaGF2aW9ycy5KU09OLnByb3RvdHlwZVxuICAgICAqIEBkZXNjcmlwdGlvbiBHZXQgdGhlIGRhdGEgZmllbGQuXG4gICAgICovXG4gICAgZ2V0RGF0YTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldERhdGFNb2RlbCgpLmdldERhdGEoKTtcbiAgICB9LFxuXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgYmVoYXZpb3JzLkpTT04ucHJvdG90eXBlXG4gICAgICogQGRlc2NyaXB0aW9uIFNldCB0aGUgdG90YWxzIGZpZWxkLlxuICAgICAqIEBwYXJhbSB7YXJyYXl9IG5lc3RlZEFycmF5IC0gYXJyYXkyRCBvZiB0b3RhbHMgZGF0YVxuICAgICAqL1xuICAgIHNldFRvcFRvdGFsczogZnVuY3Rpb24obmVzdGVkQXJyYXkpIHtcbiAgICAgICAgdGhpcy5nZXREYXRhTW9kZWwoKS5zZXRUb3BUb3RhbHMobmVzdGVkQXJyYXkpO1xuICAgIH0sXG5cbiAgICBnZXRUb3BUb3RhbHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXREYXRhTW9kZWwoKS5nZXRUb3BUb3RhbHMoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIGJlaGF2aW9ycy5KU09OLnByb3RvdHlwZVxuICAgICAqIEBkZXNjcmlwdGlvbiBCdWlsZCB0aGUgZmllbGRzIGFuZCBoZWFkZXJzIGZyb20gdGhlIHN1cHBsaWVkIGNvbHVtbiBkZWZpbml0aW9ucy5cbiAgICAgKiBgYGBqYXZhc2NyaXB0XG4gICAgICogbXlKc29uQmVoYXZpb3Iuc2V0Q29sdW1ucyhbXG4gICAgICogICAgIHsgdGl0bGU6ICdTdG9jayBOYW1lJywgZmllbGQ6ICdzaG9ydF9kZXNjcmlwdGlvbicgfSxcbiAgICAgKiAgICAgeyB0aXRsZTogJ1N0YXR1cycsIGZpZWxkOiAndHJhZGluZ19waGFzZScgfSxcbiAgICAgKiAgICAgeyB0aXRsZTogJ1JlZmVyZW5jZSBQcmljZScsIGZpZWxkOiAncmVmZXJlbmNlX3ByaWNlJyB9XG4gICAgICogXSk7XG4gICAgICogYGBgXG4gICAgICogQHBhcmFtIHtBcnJheX0gY29sdW1uRGVmaW5pdGlvbnMgLSBhbiBhcnJheSBvZiBvYmplY3RzIHdpdGggZmllbGRzICd0aXRsZScsIGFuZCAnZmllbGQnXG4gICAgICovXG4gICAgc2V0Q29sdW1uczogZnVuY3Rpb24oY29sdW1uRGVmaW5pdGlvbnMpIHtcbiAgICAgICAgdGhpcy5nZXREYXRhTW9kZWwoKS5zZXRDb2x1bW5zKGNvbHVtbkRlZmluaXRpb25zKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIGJlaGF2aW9ycy5KU09OLnByb3RvdHlwZVxuICAgICAqIEBkZXNjcmlwdGlvbiBFbmhhbmNlIHRoZSBkb3VibGUtY2xpY2sgZXZlbnQganVzdCBiZWZvcmUgaXQncyBicm9hZGNhc3QgdG8gbGlzdGVuZXJzLlxuICAgICAqIEBwYXJhbSB7UG9pbnR9IGV2ZW50XG4gICAgICovXG4gICAgZW5oYW5jZURvdWJsZUNsaWNrRXZlbnQ6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIGV2ZW50LnJvdyA9IHRoaXMuZ2V0Um93KGV2ZW50LmdyaWRDZWxsLnkpO1xuICAgIH0sXG5cbiAgICBzZXREYXRhUHJvdmlkZXI6IGZ1bmN0aW9uKGRhdGFQcm92aWRlcikge1xuICAgICAgICB0aGlzLmdldERhdGFNb2RlbCgpLnNldERhdGFQcm92aWRlcihkYXRhUHJvdmlkZXIpO1xuICAgIH0sXG5cbiAgICBoYXNIaWVyYXJjaHlDb2x1bW46IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXREYXRhTW9kZWwoKS5oYXNIaWVyYXJjaHlDb2x1bW4oKTtcbiAgICB9LFxuXG4gICAgZ2V0Q29sdW1uQWxpZ25tZW50OiBmdW5jdGlvbih4KSB7XG4gICAgICAgIGlmICh4ID09PSAwICYmIHRoaXMuaGFzSGllcmFyY2h5Q29sdW1uKCkpIHtcbiAgICAgICAgICAgIHJldHVybiAnbGVmdCc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gJ2NlbnRlcic7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgZ2V0Um93U2VsZWN0aW9uTWF0cml4OiBmdW5jdGlvbihzZWxlY3RlZFJvd3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RGF0YU1vZGVsKCkuZ2V0Um93U2VsZWN0aW9uTWF0cml4KHNlbGVjdGVkUm93cyk7XG4gICAgfSxcblxuICAgIGdldENvbHVtblNlbGVjdGlvbk1hdHJpeDogZnVuY3Rpb24oc2VsZWN0ZWRDb2x1bW5zKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldERhdGFNb2RlbCgpLmdldENvbHVtblNlbGVjdGlvbk1hdHJpeChzZWxlY3RlZENvbHVtbnMpO1xuICAgIH0sXG5cbiAgICBnZXRTZWxlY3Rpb25NYXRyaXg6IGZ1bmN0aW9uKHNlbGVjdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RGF0YU1vZGVsKCkuZ2V0U2VsZWN0aW9uTWF0cml4KHNlbGVjdGlvbnMpO1xuICAgIH0sXG5cbiAgICBnZXRSb3dTZWxlY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2VsZWN0ZWRSb3dzID0gdGhpcy5nZXRTZWxlY3RlZFJvd3MoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RGF0YU1vZGVsKCkuZ2V0Um93U2VsZWN0aW9uKHNlbGVjdGVkUm93cyk7XG4gICAgfSxcblxuICAgIGdldENvbHVtblNlbGVjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzZWxlY3RlZENvbHVtbnMgPSB0aGlzLmdldFNlbGVjdGVkQ29sdW1ucygpO1xuICAgICAgICByZXR1cm4gdGhpcy5nZXREYXRhTW9kZWwoKS5nZXRDb2x1bW5TZWxlY3Rpb24oc2VsZWN0ZWRDb2x1bW5zKTtcbiAgICB9LFxuXG4gICAgZ2V0U2VsZWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNlbGVjdGlvbnMgPSB0aGlzLmdldFNlbGVjdGlvbnMoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RGF0YU1vZGVsKCkuZ2V0U2VsZWN0aW9uKHNlbGVjdGlvbnMpO1xuICAgIH0sXG5cbiAgICBvcGVuRWRpdG9yOiBmdW5jdGlvbihkaXYpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzQ29sdW1uUmVvcmRlcmFibGUoKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgYWRkU3R5bGVzaGVldCgnZG5kJywgbnVsbCk7XG5cbiAgICAgICAgdmFyIGdyb3VwcyA9IHsgbW9kZWxzOiB0aGlzLmdldEdyb3VwcygpLCB0aXRsZTogJ0dyb3VwcycgfSxcbiAgICAgICAgICAgIGF2YWlsYWJsZUdyb3VwcyA9IHsgbW9kZWxzOiB0aGlzLmdldEF2YWlsYWJsZUdyb3VwcygpLCB0aXRsZTogJ0F2YWlsYWJsZSBHcm91cHMnIH0sXG4gICAgICAgICAgICBoaWRkZW5Db2x1bW5zID0geyBtb2RlbHM6IHRoaXMuZ2V0SGlkZGVuQ29sdW1ucygpLCB0aXRsZTogJ0hpZGRlbiBDY29sdW1ucycgfSxcbiAgICAgICAgICAgIHZpc2libGVDb2x1bW5zID0geyBtb2RlbHM6IHRoaXMuZ2V0VmlzaWJsZUNvbHVtbnMoKSwgdGl0bGU6ICdWaXNpYmxlIENvbHVtbnMnfSxcbiAgICAgICAgICAgIGdyb3VwTGlzdHMgPSBuZXcgTGlzdERyYWdvbihbZ3JvdXBzLCBhdmFpbGFibGVHcm91cHNdKSxcbiAgICAgICAgICAgIGNvbHVtbkxpc3RzID0gbmV3IExpc3REcmFnb24oW2hpZGRlbkNvbHVtbnMsIHZpc2libGVDb2x1bW5zXSksXG4gICAgICAgICAgICBsaXN0U2V0cyA9IFtncm91cExpc3RzLCBjb2x1bW5MaXN0c107XG5cbiAgICAgICAgbGlzdFNldHMuZm9yRWFjaChmdW5jdGlvbihsaXN0U2V0KSB7XG4gICAgICAgICAgICBsaXN0U2V0Lm1vZGVsTGlzdHMuZm9yRWFjaChmdW5jdGlvbihsaXN0KSB7XG4gICAgICAgICAgICAgICAgZGl2LmFwcGVuZENoaWxkKGxpc3QuY29udGFpbmVyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICAvL2F0dGFjaCBmb3IgbGF0ZXIgcmV0cmlldmFsXG4gICAgICAgIGRpdi5saXN0cyA9IHtcbiAgICAgICAgICAgIGdyb3VwOiBncm91cHMubW9kZWxzLFxuICAgICAgICAgICAgYXZhaWxhYmxlR3JvdXBzOiBhdmFpbGFibGVHcm91cHMubW9kZWxzLFxuICAgICAgICAgICAgaGlkZGVuOiBoaWRkZW5Db2x1bW5zLm1vZGVscyxcbiAgICAgICAgICAgIHZpc2libGU6IHZpc2libGVDb2x1bW5zLm1vZGVsc1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG4gICAgZ2V0R3JvdXBzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RGF0YU1vZGVsKCkuZ2V0R3JvdXBzKCk7XG4gICAgfSxcbiAgICBnZXRBdmFpbGFibGVHcm91cHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXREYXRhTW9kZWwoKS5nZXRBdmFpbGFibGVHcm91cHMoKTtcbiAgICB9LFxuICAgIGdldEhpZGRlbkNvbHVtbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXREYXRhTW9kZWwoKS5nZXRIaWRkZW5Db2x1bW5zKCk7XG4gICAgfSxcbiAgICBnZXRWaXNpYmxlQ29sdW1uczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldERhdGFNb2RlbCgpLmdldFZpc2libGVDb2x1bW5zKCk7XG4gICAgfSxcbiAgICBzZXRDb2x1bW5EZXNjcmlwdG9yczogZnVuY3Rpb24obGlzdHMpIHtcbiAgICAgICAgLy9hc3N1bWVzIHRoZXJlIGlzIG9uZSByb3cuLi4uXG4gICAgICAgIHZhciB0cmVlID0gdGhpcy5jb2x1bW5zWzBdO1xuICAgICAgICB0aGlzLmNvbHVtbnMubGVuZ3RoID0gMDtcbiAgICAgICAgaWYgKHRyZWUgJiYgdHJlZS5sYWJlbCA9PT0gJ1RyZWUnKSB7XG4gICAgICAgICAgICB0aGlzLmNvbHVtbnMucHVzaCh0cmVlKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3RzLnZpc2libGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuY29sdW1ucy5wdXNoKGxpc3RzLnZpc2libGVbaV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGdyb3VwQnlzID0gbGlzdHMuZ3JvdXAubWFwKGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBlLmlkO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5nZXREYXRhTW9kZWwoKS5zZXRHcm91cHMoZ3JvdXBCeXMpO1xuXG4gICAgICAgIHRoaXMuY2hhbmdlZCgpO1xuICAgIH0sXG5cbiAgICBnZXRTZWxlY3RlZFJvd3M6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgb2Zmc2V0ID0gLXRoaXMuZ2V0R3JpZCgpLmdldEhlYWRlclJvd0NvdW50KCk7XG4gICAgICAgIHZhciBzZWxlY3Rpb25zID0gdGhpcy5nZXRHcmlkKCkuZ2V0U2VsZWN0aW9uTW9kZWwoKS5nZXRTZWxlY3RlZFJvd3MoKTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHNlbGVjdGlvbnMubWFwKGZ1bmN0aW9uKGVhY2gpIHtcbiAgICAgICAgICAgIHJldHVybiBlYWNoICsgb2Zmc2V0O1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgZ2V0U2VsZWN0ZWRDb2x1bW5zOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0R3JpZCgpLmdldFNlbGVjdGlvbk1vZGVsKCkuZ2V0U2VsZWN0ZWRDb2x1bW5zKCk7XG4gICAgfSxcblxuICAgIGdldFNlbGVjdGlvbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRHcmlkKCkuZ2V0U2VsZWN0aW9uTW9kZWwoKS5nZXRTZWxlY3Rpb25zKCk7XG4gICAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBKU09OO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQmVoYXZpb3IgPSByZXF1aXJlKCcuL0JlaGF2aW9yJyk7XG5cbnZhciBub29wID0gZnVuY3Rpb24oKSB7fSxcbiAgICBuMDBwID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgTnVsbCA9IEJlaGF2aW9yLmV4dGVuZCgnTnVsbCcsIHtcblxuICAgIC8vaW5pdGFsaXplOiBmdW5jdGlvbihncmlkLCBjb21wb25lbnQpIHt9LFxuXG4gICAgc2V0U2Nyb2xsUG9zaXRpb25ZOiBub29wLFxuICAgIHNldFNjcm9sbFBvc2l0aW9uWDogbm9vcCxcbiAgICBnZXRDb2x1bW5Db3VudDogbjAwcCxcbiAgICBnZXRGaXhlZENvbHVtbkNvdW50OiBuMDBwLFxuICAgIGdldEZpeGVkQ29sdW1uc1dpZHRoOiBuMDBwLFxuICAgIGdldEZpeGVkQ29sdW1uc01heFdpZHRoOiBuMDBwLFxuICAgIHNldFJlbmRlcmVkV2lkdGg6IG4wMHAsXG4gICAgZ2V0Um93Q291bnQ6IG4wMHAsXG4gICAgZ2V0Rml4ZWRSb3dDb3VudDogbjAwcCxcbiAgICBnZXRGaXhlZFJvd3NIZWlnaHQ6IG4wMHAsXG4gICAgZ2V0Rml4ZWRSb3dzTWF4SGVpZ2h0OiBuMDBwLFxuICAgIHNldFJlbmRlcmVkSGVpZ2h0OiBuMDBwLFxuICAgIGdldENlbGxQcm92aWRlcjogbm9vcCxcbiAgICBjbGljazogbm9vcCxcbiAgICBkb3VibGVDbGljazogbm9vcFxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gTnVsbDtcbiIsIi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBfID0gcmVxdWlyZSgnb2JqZWN0LWl0ZXJhdG9ycycpO1xuXG52YXIgaW1hZ2VzID0gcmVxdWlyZSgnLi4vLi4vaW1hZ2VzJyk7IC8vIHRoaXMgaW5kZXguanMgaXMgZ2VuZXJhdGVkIGJ5IGd1bHAgYW5kIGlnbm9yZWQgYnkgZ2l0XG5cbl8oaW1hZ2VzKS5lYWNoKGZ1bmN0aW9uKGltYWdlLCBrZXkpIHtcbiAgICB2YXIgZWxlbWVudCA9IG5ldyBJbWFnZSgpO1xuICAgIGVsZW1lbnQuc3JjID0gJ2RhdGE6JyArIGltYWdlLnR5cGUgKyAnO2Jhc2U2NCwnICsgaW1hZ2UuZGF0YTtcbiAgICBpbWFnZXNba2V5XSA9IGVsZW1lbnQ7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBpbWFnZXM7XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIEJlaGF2aW9yOiByZXF1aXJlKCcuL0JlaGF2aW9yJyksIC8vIGFic3RyYWN0IGJhc2UgY2xhc3NcbiAgICBKU09OOiByZXF1aXJlKCcuL0pTT04nKSxcbiAgICBOdWxsOiByZXF1aXJlKCcuL051bGwnKVxufTsiLCIvKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgbXVzdGFjaGUgPSByZXF1aXJlKCdtdXN0YWNoZScpO1xudmFyIEJhc2UgPSByZXF1aXJlKCdleHRlbmQtbWUnKS5CYXNlO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgQ2VsbEVkaXRvciA9IEJhc2UuZXh0ZW5kKCdDZWxsRWRpdG9yJywge1xuXG4gICAgYWxpYXM6ICdiYXNlJyxcblxuICAgIC8qKlxuICAgICAqIGFtIEkgY3VycmVudGx5IGVkaXRpbmcgKGkuZS4sIGJldHdlZW4gY2FsbHMgdG8gYGJlZ2luRWRpdEF0YCBhbmQgZWl0aGVyIGBzdG9wRWRpdGluZ2Agb3IgYGNhbmNlbEVkaXRpbmdgKVxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICogQG1lbWJlck9mIENlbGxFZGl0b3IucHJvdG90eXBlXG4gICAgICovXG4gICAgaXNFZGl0aW5nOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIHRoZSBwb2ludCB0aGF0IEkgYW0gZWRpdGluZyBhdCByaWdodCBub3dcbiAgICAgKiBAdHlwZSB7UG9pbnR9XG4gICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAqIEBtZW1iZXJPZiBDZWxsRWRpdG9yLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGVkaXRvclBvaW50OiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogaWYgdHJ1ZSwgY2hlY2sgdGhhdCB0aGUgZWRpdG9yIGlzIGluIHRoZSByaWdodCBsb2NhdGlvblxuICAgICAqIEB0eXBlIHtib29sZWFufVxuICAgICAqIEBkZWZhdWx0IGZhbHNlXG4gICAgICogQG1lbWJlck9mIENlbGxFZGl0b3IucHJvdG90eXBlXG4gICAgICovXG4gICAgY2hlY2tFZGl0b3JQb3NpdGlvbkZsYWc6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogbXkgbWFpbiBpbnB1dCBjb250cm9sXG4gICAgICogQHR5cGUge0VsZW1lbnR9XG4gICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAqIEBtZW1iZXJPZiBDZWxsRWRpdG9yLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGlucHV0OiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogbXkgaW5zdGFuY2Ugb2YgaHlwZXJncmlkXG4gICAgICogQHR5cGUge0h5cGVyZ3JpZH1cbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICogQG1lbWJlck9mIENlbGxFZGl0b3IucHJvdG90eXBlXG4gICAgICovXG4gICAgZ3JpZDogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIHRoZSB2YWx1ZSBiZWZvcmUgZWRpdGluZ1xuICAgICAqIEB0eXBlIHt0eXBlfVxuICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbEVkaXRvci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBpbml0aWFsVmFsdWU6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbEVkaXRvci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyByZXR1cm4gdGhlIGJlaGF2aW9yIChtb2RlbClcbiAgICAgKiBAcmV0dXJucyB7QmVoYXZpb3J9IFRoZSBiZWhhdmlvciAobW9kZWwpLlxuICAgICAqL1xuICAgIGdldEJlaGF2aW9yOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ3JpZC5nZXRCZWhhdmlvcigpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbEVkaXRvci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBUaGlzIGZ1bmN0aW9uIGlzIGEgY2FsbGJhY2sgZnJvbSB0aGUgZmluLWh5cGVyZ3JpZC4gICBJdCBpcyBjYWxsZWQgYWZ0ZXIgZWFjaCBwYWludCBvZiB0aGUgY2FudmFzLlxuICAgICAqL1xuICAgIGdyaWRSZW5kZXJlZE5vdGlmaWNhdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuY2hlY2tFZGl0b3IoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENlbGxFZGl0b3IucHJvdG90eXBlXG4gICAgICogQGRlc2Mgc2Nyb2xsIHZhbHVlcyBoYXZlIGNoYW5nZWQsIHdlJ3ZlIGJlZW4gbm90aWZpZWRcbiAgICAgKi9cbiAgICBzY3JvbGxWYWx1ZUNoYW5nZWROb3RpZmljYXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnNldENoZWNrRWRpdG9yUG9zaXRpb25GbGFnKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsRWRpdG9yLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIHR1cm4gb24gY2hlY2tFZGl0b3JQb3NpdGlvbkZsYWcgYm9vbGVhbiBmaWVsZFxuICAgICAqL1xuICAgIHNldENoZWNrRWRpdG9yUG9zaXRpb25GbGFnOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5jaGVja0VkaXRvclBvc2l0aW9uRmxhZyA9IHRydWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsRWRpdG9yLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGJlZ2luIGVkaXRpbmcgYXQgbG9jYXRpb24gcG9pbnRcbiAgICAgKiBAcGFyYW0ge1BvaW50fSBwb2ludCAtIHRoZSBsb2NhdGlvbiB0byBzdGFydCBlZGl0aW5nIGF0XG4gICAgICovXG4gICAgYmVnaW5FZGl0QXQ6IGZ1bmN0aW9uKHBvaW50KSB7XG4gICAgICAgIHRoaXMuc2V0RWRpdG9yUG9pbnQocG9pbnQpO1xuICAgICAgICB2YXIgbW9kZWwgPSB0aGlzLmdldEJlaGF2aW9yKCk7XG4gICAgICAgIHZhciB2YWx1ZSA9IG1vZGVsLmdldFZhbHVlKHBvaW50LngsIHBvaW50LnkpO1xuICAgICAgICBpZiAodmFsdWUuY29uc3RydWN0b3IubmFtZSA9PT0gJ0FycmF5Jykge1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZVsxXTsgLy9pdCdzIGEgbmVzdGVkIG9iamVjdFxuICAgICAgICB9XG4gICAgICAgIHZhciBwcm9jZWVkID0gdGhpcy5ncmlkLmZpcmVSZXF1ZXN0Q2VsbEVkaXQocG9pbnQsIHZhbHVlKTtcbiAgICAgICAgaWYgKCFwcm9jZWVkKSB7XG4gICAgICAgICAgICAvL3dlIHdlcmUgY2FuY2VsbGVkXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbml0aWFsVmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5zZXRFZGl0b3JWYWx1ZSh2YWx1ZSk7XG4gICAgICAgIHRoaXMuaXNFZGl0aW5nID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5zZXRDaGVja0VkaXRvclBvc2l0aW9uRmxhZygpO1xuICAgICAgICB0aGlzLmNoZWNrRWRpdG9yKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsRWRpdG9yLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIHB1dCB2YWx1ZSBpbnRvIG91ciBlZGl0b3JcbiAgICAgKiBAcGFyYW0ge29iamVjdH0gdmFsdWUgLSB3aGF0ZXZlciB2YWx1ZSB3ZSB3YW50IHRvIGVkaXRcbiAgICAgKi9cbiAgICBzZXRFZGl0b3JWYWx1ZTogZnVuY3Rpb24odmFsdWUpIHt9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENlbGxFZGl0b3IucHJvdG90eXBlXG4gICAgICogQGRlc2MgcmV0dXJucyB0aGUgcG9pbnQgYXQgd2hpY2ggd2UgYXJlIGN1cnJlbnRseSBlZGl0aW5nXG4gICAgICogQHJldHVybnMge1BvaW50fVxuICAgICAqL1xuICAgIGdldEVkaXRvclBvaW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZWRpdG9yUG9pbnQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsRWRpdG9yLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIHNldCB0aGUgY3VycmVudCBlZGl0b3IgbG9jYXRpb25cbiAgICAgKiBAcGFyYW0ge1BvaW50fSBwb2ludCAtIHRoZSBkYXRhIGxvY2F0aW9uIG9mIHRoZSBjdXJyZW50IGVkaXRvclxuICAgICAqL1xuICAgIHNldEVkaXRvclBvaW50OiBmdW5jdGlvbihwb2ludCkge1xuICAgICAgICB0aGlzLmVkaXRvclBvaW50ID0gcG9pbnQ7XG4gICAgICAgIHRoaXMubW9kZWxQb2ludCA9IHRoaXMuZ2V0R3JpZCgpLmNvbnZlcnRWaWV3UG9pbnRUb0RhdGFQb2ludChwb2ludCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsRWRpdG9yLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGRpc3BsYXkgdGhlIGVkaXRvclxuICAgICAqL1xuICAgIHNob3dFZGl0b3I6IGZ1bmN0aW9uKCkge30sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbEVkaXRvci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBoaWRlIHRoZSBlZGl0b3JcbiAgICAgKi9cbiAgICBoaWRlRWRpdG9yOiBmdW5jdGlvbigpIHt9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENlbGxFZGl0b3IucHJvdG90eXBlXG4gICAgICogQGRlc2Mgc3RvcCBlZGl0aW5nXG4gICAgICovXG4gICAgc3RvcEVkaXRpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNFZGl0aW5nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHByb2NlZWQgPSB0aGlzLmdldEdyaWQoKS5maXJlU3ludGhldGljRWRpdG9yRGF0YUNoYW5nZUV2ZW50KHRoaXMsIHRoaXMuaW5pdGlhbFZhbHVlLCB0aGlzLmdldEVkaXRvclZhbHVlLCB0aGlzKTtcbiAgICAgICAgaWYgKCFwcm9jZWVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zYXZlRWRpdG9yVmFsdWUoKTtcbiAgICAgICAgdGhpcy5pc0VkaXRpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5oaWRlRWRpdG9yKCk7XG4gICAgfSxcblxuICAgIGNhbmNlbEVkaXRpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNFZGl0aW5nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pc0VkaXRpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5oaWRlRWRpdG9yKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsRWRpdG9yLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIHNhdmUgdGhlIG5ldyB2YWx1ZSBpbnRvIHRoZSBiZWhhdmlvcihtb2RlbClcbiAgICAgKi9cbiAgICBzYXZlRWRpdG9yVmFsdWU6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgcG9pbnQgPSB0aGlzLmdldEVkaXRvclBvaW50KCk7XG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuZ2V0RWRpdG9yVmFsdWUoKTtcbiAgICAgICAgaWYgKHZhbHVlID09PSB0aGlzLmluaXRpYWxWYWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuOyAvL2RhdGEgZGlkbid0IGNoYW5nZSBkbyBub3RoaW5nXG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNvbnRpbnVlZCA9IHRoaXMuZ2V0R3JpZCgpLmZpcmVCZWZvcmVDZWxsRWRpdChwb2ludCwgdGhpcy5pbml0aWFsVmFsdWUsIHZhbHVlLCB0aGlzKTtcbiAgICAgICAgaWYgKCFjb250aW51ZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmdldEJlaGF2aW9yKCkuc2V0VmFsdWUocG9pbnQueCwgcG9pbnQueSwgdmFsdWUpO1xuICAgICAgICB0aGlzLmdldEdyaWQoKS5maXJlQWZ0ZXJDZWxsRWRpdChwb2ludCwgdGhpcy5pbml0aWFsVmFsdWUsIHZhbHVlLCB0aGlzKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENlbGxFZGl0b3IucHJvdG90eXBlXG4gICAgICogQGRlc2MgcmV0dXJuIHRoZSBjdXJyZW50IGVkaXRvcidzIHZhbHVlXG4gICAgICovXG4gICAgZ2V0RWRpdG9yVmFsdWU6IGZ1bmN0aW9uKCkge30sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbEVkaXRvci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyByZXF1ZXN0IGZvY3VzIGZvciBteSBpbnB1dCBjb250cm9sXG4gICAgICovXG4gICAgdGFrZUZvY3VzOiBmdW5jdGlvbigpIHt9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENlbGxFZGl0b3IucHJvdG90eXBlXG4gICAgICogQGRlc2MgbW92ZSB0aGUgZWRpdG9yIHRvIHRoZSBjdXJyZW50IGVkaXRvciBwb2ludFxuICAgICAqL1xuICAgIF9tb3ZlRWRpdG9yOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGdyaWQgPSB0aGlzLmdldEdyaWQoKTtcbiAgICAgICAgdmFyIGVkaXRvclBvaW50ID0gdGhpcy5nZXRFZGl0b3JQb2ludCgpO1xuICAgICAgICB2YXIgY2VsbEJvdW5kcyA9IGdyaWQuX2dldEJvdW5kc09mQ2VsbChlZGl0b3JQb2ludC54LCBlZGl0b3JQb2ludC55KTtcblxuICAgICAgICAvL2hhY2sgdG8gYWNjb21vZGF0ZSBib290c3RyYXAgbWFyZ2luIGlzc3Vlcy4uLlxuICAgICAgICB2YXIgeE9mZnNldCA9IGdyaWQuZGl2LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQgLSBncmlkLmRpdkNhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0O1xuICAgICAgICBjZWxsQm91bmRzLnggPSBjZWxsQm91bmRzLnggLSB4T2Zmc2V0O1xuXG4gICAgICAgIHRoaXMuc2V0Qm91bmRzKGNlbGxCb3VuZHMpO1xuICAgIH0sXG5cbiAgICBtb3ZlRWRpdG9yOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5fbW92ZUVkaXRvcigpO1xuICAgICAgICB0aGlzLnRha2VGb2N1cygpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbEVkaXRvci5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBzZXQgdGhlIGJvdW5kcyBvZiBteSBpbnB1dCBjb250cm9sXG4gICAgICogQHBhcmFtIHtSZWN0YW5nbGV9IHRoZSBib3VuZHMgdG8gbW92ZSB0b1xuICAgICAqL1xuICAgIHNldEJvdW5kczogZnVuY3Rpb24ocmVjdGFuZ2xlKSB7fSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsRWRpdG9yLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGNoZWNrIHRoYXQgdGhlIGVkaXRvciBpcyBpbiB0aGUgY29ycmVjdCBsb2NhdGlvbiwgYW5kIGlzIHNob3dpbmcvaGlkZGVuIGFwcHJvcHJpYXRlbHlcbiAgICAgKi9cbiAgICBjaGVja0VkaXRvcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghdGhpcy5jaGVja0VkaXRvclBvc2l0aW9uRmxhZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jaGVja0VkaXRvclBvc2l0aW9uRmxhZyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5pc0VkaXRpbmcpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZWRpdG9yUG9pbnQgPSB0aGlzLmdldEVkaXRvclBvaW50KCk7XG4gICAgICAgIGlmICh0aGlzLmdyaWQuaXNEYXRhVmlzaWJsZShlZGl0b3JQb2ludC54LCBlZGl0b3JQb2ludC55KSkge1xuICAgICAgICAgICAgdGhpcy5tb3ZlRWRpdG9yKCk7XG4gICAgICAgICAgICB0aGlzLnNob3dFZGl0b3IoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaGlkZUVkaXRvcigpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIGdldEdyaWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5ncmlkO1xuICAgIH0sXG5cbiAgICB0ZW1wbGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIC8qXG5cbiAgICAgICAgICovXG4gICAgfSxcblxuICAgIGdldEhUTUw6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc3RyaW5nID0gdGhpcy50ZW1wbGF0ZS50b1N0cmluZygpLnNwbGl0KCdcXG4nKTtcbiAgICAgICAgc3RyaW5nLnNoaWZ0KCk7XG4gICAgICAgIHN0cmluZy5zaGlmdCgpO1xuICAgICAgICBzdHJpbmcubGVuZ3RoID0gc3RyaW5nLmxlbmd0aCAtIDI7XG4gICAgICAgIHN0cmluZyA9IHN0cmluZy5qb2luKCdcXG4nKS50cmltKCk7XG4gICAgICAgIHJldHVybiBtdXN0YWNoZS5yZW5kZXIoc3RyaW5nLCB0aGlzKTtcbiAgICB9LFxuXG4gICAgZ2V0SW5wdXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMuaW5wdXQpIHtcbiAgICAgICAgICAgIHRoaXMuaW5wdXQgPSB0aGlzLmdldERlZmF1bHRJbnB1dCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmlucHV0O1xuICAgIH0sXG5cbiAgICBnZXREZWZhdWx0SW5wdXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnRElWJyk7XG4gICAgICAgIGRpdi5pbm5lckhUTUwgPSB0aGlzLmdldEhUTUwoKTtcbiAgICAgICAgdmFyIGlucHV0ID0gZGl2LmZpcnN0Q2hpbGQ7XG4gICAgICAgIHRoaXMuaW5pdGlhbGl6ZUlucHV0KGlucHV0KTtcbiAgICAgICAgcmV0dXJuIGlucHV0O1xuICAgIH0sXG5cbiAgICB1cGRhdGVWaWV3OiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG9sZEd1eSA9IHRoaXMuZ2V0SW5wdXQoKTtcbiAgICAgICAgdmFyIHBhcmVudCA9IG9sZEd1eS5wYXJlbnROb2RlO1xuICAgICAgICB2YXIgbmV3R3V5ID0gdGhpcy5nZXREZWZhdWx0SW5wdXQoKTtcbiAgICAgICAgdGhpcy5pbnB1dCA9IG5ld0d1eTtcbiAgICAgICAgcGFyZW50LnJlcGxhY2VDaGlsZChuZXdHdXksIG9sZEd1eSk7XG4gICAgfSxcblxuICAgIGluaXRpYWxpemVJbnB1dDogZnVuY3Rpb24oaW5wdXQpIHt9LFxuXG4gICAgc2hvd0Ryb3Bkb3duOiBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgIHZhciBldmVudDtcbiAgICAgICAgZXZlbnQgPSBkb2N1bWVudC5jcmVhdGVFdmVudCgnTW91c2VFdmVudHMnKTtcbiAgICAgICAgZXZlbnQuaW5pdE1vdXNlRXZlbnQoJ21vdXNlZG93bicsIHRydWUsIHRydWUsIHdpbmRvdyk7XG4gICAgICAgIGVsZW1lbnQuZGlzcGF0Y2hFdmVudChldmVudCk7XG4gICAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBDZWxsRWRpdG9yO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgU2ltcGxlID0gcmVxdWlyZSgnLi9TaW1wbGUnKTtcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIENob2ljZSA9IFNpbXBsZS5leHRlbmQoJ0Nob2ljZScsIHtcblxuICAgIC8qKlxuICAgICAqIG15IGxvb2t1cCBhbGlhc1xuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQG1lbWJlck9mIENob2ljZS5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBhbGlhczogJ2Nob2ljZScsXG5cbiAgICAvKipcbiAgICAgKiB0aGUgbGlzdCBvZiBpdGVtcyB0byBwaWNrIGZyb21cbiAgICAgKiBAdHlwZSB7QXJyYXl9XG4gICAgICogQG1lbWJlck9mIENob2ljZS5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBpdGVtczogWydhJywgJ2InLCAnYyddLFxuXG4gICAgdGVtcGxhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvKlxuICAgICAgICAgICAgICAgIDxzZWxlY3QgaWQ9XCJlZGl0b3JcIj5cbiAgICAgICAgICAgICAgICAgICAge3sjaXRlbXN9fVxuICAgICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cInt7Ln19XCI+e3sufX08L29wdGlvbj5cbiAgICAgICAgICAgICAgICAgICAge3svaXRlbXN9fVxuICAgICAgICAgICAgICAgIDwvc2VsZWN0PlxuICAgICAgICAgICAgKi9cbiAgICB9LFxuXG4gICAgLy9ubyBldmVudHMgYXJlIGZpcmVkIHdoaWxlIHRoZSBkcm9wZG93biBpcyBvcGVuXG4gICAgLy9zZWUgaHR0cDovL2pzZmlkZGxlLm5ldC9tNHRuZHR1NC82L1xuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENob2ljZS5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBzaG93RWRpdG9yOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB0aGlzLmlucHV0LnN0eWxlLmRpc3BsYXkgPSAnaW5saW5lJztcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHNlbGYuc2hvd0Ryb3Bkb3duKHNlbGYuaW5wdXQpO1xuICAgICAgICB9LCA1MCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDaG9pY2UucHJvdG90eXBlXG4gICAgICogQHBhcmFtIGl0ZW1zXG4gICAgICovXG4gICAgc2V0SXRlbXM6IGZ1bmN0aW9uKGl0ZW1zKSB7XG4gICAgICAgIHRoaXMuaXRlbXMgPSBpdGVtcztcbiAgICAgICAgdGhpcy51cGRhdGVWaWV3KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDaG9pY2UucHJvdG90eXBlXG4gICAgICogQHBhcmFtIGlucHV0XG4gICAgICovXG4gICAgaW5pdGlhbGl6ZUlucHV0OiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIFNpbXBsZS5wcm90b3R5cGUuaW5pdGlhbGl6ZUlucHV0KGlucHV0KTtcbiAgICAgICAgaW5wdXQub25jaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHNlbGYuc3RvcEVkaXRpbmcoKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENob2ljZTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFNpbXBsZSA9IHJlcXVpcmUoJy4vU2ltcGxlJyk7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBDb2xvciA9IFNpbXBsZS5leHRlbmQoJ0NvbG9yJywge1xuXG4gICAgLyoqXG4gICAgICogbXkgbG9va3VwIGFsaWFzXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAbWVtYmVyT2YgQ29sb3IucHJvdG90eXBlXG4gICAgICovXG4gICAgYWxpYXM6ICdjb2xvcicsXG5cbiAgICB0ZW1wbGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIC8qXG4gICAgICAgICAgICA8aW5wdXQgaWQ9XCJlZGl0b3JcIiB0eXBlPVwiY29sb3JcIj5cbiAgICAgICAgKi9cbiAgICB9XG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbG9yO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgU2ltcGxlID0gcmVxdWlyZSgnLi9TaW1wbGUnKTtcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIERhdGUgPSBTaW1wbGUuZXh0ZW5kKCdEYXRlJywge1xuXG4gICAgLyoqXG4gICAgICogbXkgbG9va3VwIGFsaWFzXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAbWVtYmVyT2YgRGF0ZS5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBhbGlhczogJ2RhdGUnLFxuXG4gICAgdGVtcGxhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvKlxuICAgICAgICAgICAgPGlucHV0IGlkPVwiZWRpdG9yXCIgdHlwZT1cImRhdGVcIj5cbiAgICAgICAgKi9cbiAgICB9XG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IERhdGU7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBDZWxsRWRpdG9yID0gcmVxdWlyZSgnLi9DZWxsRWRpdG9yLmpzJyk7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBTaW1wbGUgPSBDZWxsRWRpdG9yLmV4dGVuZCgnU2ltcGxlJywge1xuXG4gICAgLyoqXG4gICAgICogbXkgbG9va3VwIGFsaWFzXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAbWVtYmVyT2YgU2ltcGxlLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGFsaWFzOiAnc2ltcGxlJyxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBTaW1wbGUucHJvdG90eXBlXG4gICAgICovXG4gICAgaW5pdGlhbGl6ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuZWRpdG9yUG9pbnQgPSB7XG4gICAgICAgICAgICB4OiAwLFxuICAgICAgICAgICAgeTogMFxuICAgICAgICB9O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgU2ltcGxlLnByb3RvdHlwZVxuICAgICAqIEBkZXNjICB0aGUgZnVuY3Rpb24gdG8gb3ZlcnJpZGUgZm9yIGluaXRpYWxpemF0aW9uXG4gICAgICovXG4gICAgaW5pdGlhbGl6ZUlucHV0OiBmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2tleXVwJywgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgaWYgKGUgJiYgKGUua2V5Q29kZSA9PT0gMTMgfHwgZS5rZXlDb2RlID09PSAyNyB8fCBlLmtleUNvZGUgPT09IDgpKSB7XG4gICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIGlmIChlLmtleUNvZGUgPT09IDgpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5jbGVhclN0b3BFZGl0aW5nKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChlLmtleUNvZGUgPT09IDI3KSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuY2FuY2VsRWRpdGluZygpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuc3RvcEVkaXRpbmcoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2VsZi5nZXRHcmlkKCkucmVwYWludCgpO1xuICAgICAgICAgICAgICAgIHNlbGYuZ2V0R3JpZCgpLnRha2VGb2N1cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2VsZi5nZXRHcmlkKCkuZmlyZVN5bnRoZXRpY0VkaXRvcktleVVwRXZlbnQoc2VsZiwgZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpbnB1dC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgc2VsZi5nZXRHcmlkKCkuZmlyZVN5bnRoZXRpY0VkaXRvcktleURvd25FdmVudChzZWxmLCBlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2tleXByZXNzJywgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ2tleXByZXNzJywgZS5rZXlDb2RlKTtcbiAgICAgICAgICAgIHNlbGYuZ2V0R3JpZCgpLmZpcmVTeW50aGV0aWNFZGl0b3JLZXlQcmVzc0V2ZW50KHNlbGYsIGUpO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXNvdXQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gICAgIHNlbGYuc3RvcEVkaXRpbmcoKTtcbiAgICAgICAgLy8gfSk7XG4gICAgICAgIC8vIGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoJ2JsdXInLCBmdW5jdGlvbigpIHtcbiAgICAgICAgLy8gICAgIHNlbGYuc3RvcEVkaXRpbmcoKTtcbiAgICAgICAgLy8gfSk7XG4gICAgICAgIGlucHV0LnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgICAgaW5wdXQuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgaW5wdXQuc3R5bGUuYm9yZGVyID0gJ3NvbGlkIDJweCBibGFjayc7XG4gICAgICAgIGlucHV0LnN0eWxlLm91dGxpbmUgPSAwO1xuICAgICAgICBpbnB1dC5zdHlsZS5wYWRkaW5nID0gMDtcbiAgICAgICAgaW5wdXQuc3R5bGUuekluZGV4ID0gMTAwMDtcbiAgICAgICAgaW5wdXQuc3R5bGUuZm9udFNpemUgPSAnOHB0JztcbiAgICAgICAgaW5wdXQuc3R5bGUuYm94U2hhZG93ID0gJ3doaXRlIDBweCAwcHggMXB4IDFweCc7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBTaW1wbGUucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge29iamVjdH0gdGhlIGN1cnJlbnQgZWRpdG9yJ3MgdmFsdWVcbiAgICAgKi9cbiAgICBnZXRFZGl0b3JWYWx1ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuZ2V0SW5wdXQoKS52YWx1ZTtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgU2ltcGxlLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIHNhdmUgdGhlIG5ldyB2YWx1ZSBpbnRvIHRoZSBiZWhhdmlvcihtb2RlbClcbiAgICAgKi9cbiAgICBzZXRFZGl0b3JWYWx1ZTogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgdGhpcy5nZXRJbnB1dCgpLnZhbHVlID0gdmFsdWUgKyAnJztcbiAgICB9LFxuXG4gICAgY2xlYXJTdG9wRWRpdGluZzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuc2V0RWRpdG9yVmFsdWUoJycpO1xuICAgICAgICB0aGlzLnN0b3BFZGl0aW5nKCk7XG4gICAgfSxcblxuICAgIGNhbmNlbEVkaXRpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNFZGl0aW5nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5nZXRJbnB1dCgpLnZhbHVlID0gbnVsbDtcbiAgICAgICAgdGhpcy5pc0VkaXRpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5oaWRlRWRpdG9yKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBTaW1wbGUucHJvdG90eXBlXG4gICAgICogQGRlc2MgZGlzcGxheSB0aGUgZWRpdG9yXG4gICAgICovXG4gICAgc2hvd0VkaXRvcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuZ2V0SW5wdXQoKS5zdHlsZS5kaXNwbGF5ID0gJ2lubGluZSc7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBTaW1wbGUucHJvdG90eXBlXG4gICAgICogQGRlc2MgaGlkZSB0aGUgZWRpdG9yXG4gICAgICovXG4gICAgaGlkZUVkaXRvcjogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuZ2V0SW5wdXQoKS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgU2ltcGxlLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIHJlcXVlc3QgZm9jdXMgZm9yIG15IGlucHV0IGNvbnRyb2xcbiAgICAgKi9cbiAgICB0YWtlRm9jdXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBzZWxmLmlucHV0LmZvY3VzKCk7XG4gICAgICAgICAgICBzZWxmLnNlbGVjdEFsbCgpO1xuICAgICAgICB9LCAzMDApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgU2ltcGxlLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIHNlbGVjdCBldmVyeXRoaW5nXG4gICAgICovXG4gICAgc2VsZWN0QWxsOiBmdW5jdGlvbigpIHtcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgU2ltcGxlLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGhvdyBtdWNoIHNob3VsZCBJIG9mZnNldCBteSBib3VuZHMgZnJvbSAwLDBcbiAgICAgKi9cbiAgICBvcmlnaW5PZmZzZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gWzAsIDBdO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgU2ltcGxlLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIHNldCB0aGUgYm91bmRzIG9mIG15IGlucHV0IGNvbnRyb2xcbiAgICAgKiBAcGFyYW0ge3JlY3RhbmdsZX0gcmVjdGFuZ2xlIC0gdGhlIGJvdW5kcyB0byBtb3ZlIHRvXG4gICAgICovXG4gICAgc2V0Qm91bmRzOiBmdW5jdGlvbihjZWxsQm91bmRzKSB7XG4gICAgICAgIHZhciBvcmlnaW5PZmZzZXQgPSB0aGlzLm9yaWdpbk9mZnNldCgpO1xuICAgICAgICB2YXIgdHJhbnNsYXRpb24gPSAndHJhbnNsYXRlKCdcbiAgICAgICAgICAgICsgKGNlbGxCb3VuZHMueCAtIDEgKyBvcmlnaW5PZmZzZXRbMF0pICsgJ3B4LCdcbiAgICAgICAgICAgICsgKGNlbGxCb3VuZHMueSAtIDEgKyBvcmlnaW5PZmZzZXRbMV0pICsgJ3B4KSc7XG5cbiAgICAgICAgdGhpcy5nZXRJbnB1dCgpLnN0eWxlLndlYmtpdFRyYW5zZm9ybSA9IHRyYW5zbGF0aW9uO1xuICAgICAgICB0aGlzLmdldElucHV0KCkuc3R5bGUuTW96VHJhbnNmb3JtID0gdHJhbnNsYXRpb247XG4gICAgICAgIHRoaXMuZ2V0SW5wdXQoKS5zdHlsZS5tc1RyYW5zZm9ybSA9IHRyYW5zbGF0aW9uO1xuICAgICAgICB0aGlzLmdldElucHV0KCkuc3R5bGUuT1RyYW5zZm9ybSA9IHRyYW5zbGF0aW9uO1xuXG4gICAgICAgIC8vIHRoaXMuZ2V0SW5wdXQoKS5zdHlsZS5sZWZ0ID0gY2VsbEJvdW5kcy54ICsgb3JpZ2luT2Zmc2V0WzBdICsgJ3B4JztcbiAgICAgICAgLy8gdGhpcy5nZXRJbnB1dCgpLnN0eWxlLnRvcCA9IGNlbGxCb3VuZHMueSArIG9yaWdpbk9mZnNldFsxXSArICdweCc7XG5cbiAgICAgICAgdGhpcy5nZXRJbnB1dCgpLnN0eWxlLndpZHRoID0gKGNlbGxCb3VuZHMud2lkdGggKyAyKSArICdweCc7XG4gICAgICAgIHRoaXMuZ2V0SW5wdXQoKS5zdHlsZS5oZWlnaHQgPSAoY2VsbEJvdW5kcy5oZWlnaHQgKyAyKSArICdweCc7XG4gICAgICAgIC8vdmFyIHhPZmZzZXQgPSB0aGlzLmdyaWQuY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQ7XG4gICAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBTaW1wbGU7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBTaW1wbGUgPSByZXF1aXJlKCcuL1NpbXBsZScpO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgU2xpZGVyID0gU2ltcGxlLmV4dGVuZCgnU2xpZGVyJywge1xuXG4gICAgLyoqXG4gICAgICogbXkgbG9va3VwIGFsaWFzXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAbWVtYmVyT2YgU2xpZGVyLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGFsaWFzOiAnc2xpZGVyJyxcblxuICAgIHRlbXBsYXRlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgLypcbiAgICAgICAgICAgIDxpbnB1dCBpZD1cImVkaXRvclwiIHR5cGU9XCJyYW5nZVwiPlxuICAgICAgICAqL1xuICAgIH1cblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gU2xpZGVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgU2ltcGxlID0gcmVxdWlyZSgnLi9TaW1wbGUnKTtcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIFNwaW5uZXIgPSBTaW1wbGUuZXh0ZW5kKCdTcGlubmVyJywge1xuXG4gICAgLyoqXG4gICAgICogbXkgbG9va3VwIGFsaWFzXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKiBAbWVtYmVyT2YgU3Bpbm5lci5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBhbGlhczogJ3NwaW5uZXInLFxuXG4gICAgdGVtcGxhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvKlxuICAgICAgICAgICAgPGlucHV0IGlkPVwiZWRpdG9yXCIgdHlwZT1cIm51bWJlclwiPlxuICAgICAgICAqL1xuICAgIH1cblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gU3Bpbm5lcjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIFNpbXBsZSA9IHJlcXVpcmUoJy4vU2ltcGxlJyk7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBUZXh0ZmllbGQgPSBTaW1wbGUuZXh0ZW5kKCdUZXh0ZmllbGQnLCB7XG5cbiAgICAvKipcbiAgICAgKiBteSBsb29rdXAgYWxpYXNcbiAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAqIEBtZW1iZXJPZiBUZXh0ZmllbGQucHJvdG90eXBlXG4gICAgICovXG4gICAgYWxpYXM6ICd0ZXh0ZmllbGQnLFxuXG4gICAgdGVtcGxhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAvKlxuICAgICAgICAgICAgPGlucHV0IGlkPVwiZWRpdG9yXCI+XG4gICAgICAgICovXG4gICAgfSxcblxuICAgIHNlbGVjdEFsbDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuaW5wdXQuc2V0U2VsZWN0aW9uUmFuZ2UoMCwgdGhpcy5pbnB1dC52YWx1ZS5sZW5ndGgpO1xuICAgIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRleHRmaWVsZDtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgQ2VsbEVkaXRvcjogcmVxdWlyZSgnLi9DZWxsRWRpdG9yJyksIC8vIGFic3RyYWN0IGJhc2UgY2xhc3NcbiAgICBUZXh0ZmllbGQ6IHJlcXVpcmUoJy4vVGV4dGZpZWxkJyksXG4gICAgQ2hvaWNlOiByZXF1aXJlKCcuL0Nob2ljZScpLFxuICAgIC8vQ29tYm86IHJlcXVpcmUoJy4vQ29tYm8nKSxcbiAgICBDb2xvcjogcmVxdWlyZSgnLi9Db2xvcicpLFxuICAgIERhdGU6IHJlcXVpcmUoJy4vRGF0ZScpLFxuICAgIFNsaWRlcjogcmVxdWlyZSgnLi9TbGlkZXInKSxcbiAgICBTcGlubmVyOiByZXF1aXJlKCcuL1NwaW5uZXInKVxufTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciBCYXNlID0gcmVxdWlyZSgnZXh0ZW5kLW1lJykuQmFzZTtcblxudmFyIEEgPSAnQScuY2hhckNvZGVBdCgwKTtcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIERhdGFNb2RlbCA9IEJhc2UuZXh0ZW5kKCdEYXRhTW9kZWwnLCB7XG5cbiAgICBuZXh0OiBudWxsLFxuXG4gICAgZ3JpZDogbnVsbCxcblxuICAgIHNldEdyaWQ6IGZ1bmN0aW9uKG5ld0dyaWQpIHtcbiAgICAgICAgdGhpcy5ncmlkID0gbmV3R3JpZDtcbiAgICB9LFxuXG4gICAgZ2V0R3JpZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdyaWQ7XG4gICAgfSxcblxuICAgIGdldEJlaGF2aW9yOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0R3JpZCgpLmdldEJlaGF2aW9yKCk7XG4gICAgfSxcblxuICAgIGNoYW5nZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmdldEJlaGF2aW9yKCkuY2hhbmdlZCgpO1xuICAgIH0sXG5cbiAgICBnZXRQcml2YXRlU3RhdGU6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRHcmlkKCkuZ2V0UHJpdmF0ZVN0YXRlKCk7XG4gICAgfSxcblxuICAgIGFwcGx5U3RhdGU6IGZ1bmN0aW9uKCkge1xuXG4gICAgfSxcblxuICAgIGFscGhhRm9yOiBmdW5jdGlvbihpKSB7XG4gICAgICAgIC8vIE5hbWUgdGhlIGNvbHVtbiBoZWFkZXJzIGluIEEsIC4uLCBBQSwgQUIsIEFDLCAuLiwgQVogZm9ybWF0XG4gICAgICAgIC8vIHF1b3RpZW50L3JlbWFpbmRlclxuICAgICAgICAvL3ZhciBxdW8gPSBNYXRoLmZsb29yKGNvbC8yNyk7XG4gICAgICAgIHZhciBxdW8gPSBNYXRoLmZsb29yKGkgLyAyNik7XG4gICAgICAgIHZhciByZW0gPSBpICUgMjY7XG4gICAgICAgIHZhciBjb2RlID0gJyc7XG4gICAgICAgIGlmIChxdW8gPiAwKSB7XG4gICAgICAgICAgICBjb2RlICs9IHRoaXMuYWxwaGEocXVvIC0gMSk7XG4gICAgICAgIH1cbiAgICAgICAgY29kZSArPSB0aGlzLmFscGhhKHJlbSk7XG4gICAgICAgIHJldHVybiBjb2RlO1xuICAgIH0sXG5cbiAgICBhbHBoYTogZnVuY3Rpb24oaSkge1xuICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShBICsgaSk7XG4gICAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBEYXRhTW9kZWw7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBhbmFseXRpY3MgPSByZXF1aXJlKCdoeXBlci1hbmFseXRpY3MnKTtcbi8vdmFyIGFuYWx5dGljcyA9IHJlcXVpcmUoJy4uL2xvY2FsX25vZGVfbW9kdWxlcy9uZXdhbmFseXRpY3MnKTtcbi8vdmFyIGFuYWx5dGljcyA9IHJlcXVpcmUoJy4uL2xvY2FsX25vZGVfbW9kdWxlcy9maW5hbmFseXRpY3MnKTtcbnZhciBEYXRhTW9kZWwgPSByZXF1aXJlKCcuL0RhdGFNb2RlbCcpO1xuXG52YXIgVVBXQVJEU19CTEFDS19BUlJPVyA9ICdcXHUyYjA2JyxcbiAgICBET1dOV0FSRFNfQkxBQ0tfQVJST1cgPSAnXFx1MmIwNyc7XG5cbnZhciBudWxsRGF0YVNvdXJjZSA9IHtcbiAgICBpc051bGxPYmplY3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuICAgIGdldEZpZWxkczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9LFxuICAgIGdldEhlYWRlcnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfSxcbiAgICBnZXRDb2x1bW5Db3VudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH0sXG4gICAgZ2V0Um93Q291bnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICB9LFxuICAgIGdldEdyYW5kVG90YWxzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgIH0sXG4gICAgaGFzQWdncmVnYXRlczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuICAgIGhhc0dyb3VwczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuICAgIGdldFJvdzogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn07XG5cbi8qKlxuICogQG5hbWUgZGF0YU1vZGVscy5KU09OXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIEpTT04gPSBEYXRhTW9kZWwuZXh0ZW5kKCdkYXRhTW9kZWxzLkpTT04nLCB7XG5cbiAgICAvL251bGwgb2JqZWN0IHBhdHRlcm4gZm9yIHRoZSBzb3VyY2Ugb2JqZWN0XG4gICAgc291cmNlOiBudWxsRGF0YVNvdXJjZSxcblxuICAgIHByZWdsb2JhbGZpbHRlcjogbnVsbERhdGFTb3VyY2UsXG4gICAgcHJlZmlsdGVyOiBudWxsRGF0YVNvdXJjZSxcblxuICAgIHByZXNvcnRlcjogbnVsbERhdGFTb3VyY2UsXG4gICAgYW5hbHl0aWNzOiBudWxsRGF0YVNvdXJjZSxcbiAgICBwb3N0ZmlsdGVyOiBudWxsRGF0YVNvdXJjZSxcbiAgICBwb3N0c29ydGVyOiBudWxsRGF0YVNvdXJjZSxcblxuICAgIHRvcFRvdGFsczogW10sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgZGF0YU1vZGVscy5KU09OLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGhhc0FnZ3JlZ2F0ZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hbmFseXRpY3MuaGFzQWdncmVnYXRlcygpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgZGF0YU1vZGVscy5KU09OLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGhhc0dyb3VwczogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFuYWx5dGljcy5oYXNHcm91cHMoKTtcbiAgICB9LFxuXG4gICAgZ2V0RGF0YVNvdXJjZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFuYWx5dGljczsgLy90aGlzLmhhc0FnZ3JlZ2F0ZXMoKSA/IHRoaXMuYW5hbHl0aWNzIDogdGhpcy5wcmVzb3J0ZXI7XG4gICAgfSxcblxuICAgIGdldEZpbHRlclNvdXJjZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByZWZpbHRlcjsgLy90aGlzLmhhc0FnZ3JlZ2F0ZXMoKSA/IHRoaXMucG9zdGZpbHRlciA6IHRoaXMucHJlZmlsdGVyO1xuICAgIH0sXG5cbiAgICBnZXRTb3J0aW5nU291cmNlOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJlc29ydGVyOyAvL3RoaXMuaGFzQWdncmVnYXRlcygpID8gdGhpcy5wb3N0c29ydGVyIDogdGhpcy5wcmVzb3J0ZXI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBkYXRhTW9kZWxzLkpTT04ucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geVxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGdldFZhbHVlOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgIHZhciBoYXNIaWVyYXJjaHlDb2x1bW4gPSB0aGlzLmhhc0hpZXJhcmNoeUNvbHVtbigpO1xuICAgICAgICB2YXIgZ3JpZCA9IHRoaXMuZ2V0R3JpZCgpO1xuICAgICAgICB2YXIgaGVhZGVyUm93Q291bnQgPSBncmlkLmdldEhlYWRlclJvd0NvdW50KCk7XG4gICAgICAgIHZhciB2YWx1ZTtcbiAgICAgICAgaWYgKGhhc0hpZXJhcmNoeUNvbHVtbiAmJiB4ID09PSAtMikge1xuICAgICAgICAgICAgeCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHkgPCBoZWFkZXJSb3dDb3VudCkge1xuICAgICAgICAgICAgdmFsdWUgPSB0aGlzLmdldEhlYWRlclJvd1ZhbHVlKHgsIHkpO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoYXNIaWVyYXJjaHlDb2x1bW4pIHtcbiAgICAgICAgICAgIHkgKz0gMTtcbiAgICAgICAgfVxuICAgICAgICB2YWx1ZSA9IHRoaXMuZ2V0RGF0YVNvdXJjZSgpLmdldFZhbHVlKHgsIHkgLSBoZWFkZXJSb3dDb3VudCk7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIGRhdGFNb2RlbHMuSlNPTi5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgZ2V0SGVhZGVyUm93VmFsdWU6IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgaWYgKHkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0SGVhZGVycygpW01hdGgubWF4KHgsIDApXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZ3JpZCA9IHRoaXMuZ2V0R3JpZCgpO1xuICAgICAgICB2YXIgYmVoYXZpb3IgPSBncmlkLmdldEJlaGF2aW9yKCk7XG4gICAgICAgIHZhciBpc0ZpbHRlclJvdyA9IGdyaWQuaXNTaG93RmlsdGVyUm93KCk7XG4gICAgICAgIHZhciBpc0hlYWRlclJvdyA9IGdyaWQuaXNTaG93SGVhZGVyUm93KCk7XG4gICAgICAgIHZhciBpc0JvdGggPSBpc0ZpbHRlclJvdyAmJiBpc0hlYWRlclJvdztcbiAgICAgICAgdmFyIHRvcFRvdGFsc09mZnNldCA9IChpc0ZpbHRlclJvdyA/IDEgOiAwKSArIChpc0hlYWRlclJvdyA/IDEgOiAwKTtcbiAgICAgICAgaWYgKHkgPj0gdG9wVG90YWxzT2Zmc2V0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXRUb3BUb3RhbHMoKVt5IC0gdG9wVG90YWxzT2Zmc2V0XVt4XTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZmlsdGVyID0gdGhpcy5nZXRGaWx0ZXIoeCk7XG4gICAgICAgIHZhciBpbWFnZSA9IGZpbHRlci5sZW5ndGggPT09IDAgPyAnZmlsdGVyLW9mZicgOiAnZmlsdGVyLW9uJztcbiAgICAgICAgdmFyIGhlYWRlciwgc29ydFN0cmluZztcbiAgICAgICAgaWYgKGlzQm90aCkge1xuICAgICAgICAgICAgaWYgKHkgPT09IDApIHtcbiAgICAgICAgICAgICAgICBoZWFkZXIgPSB0aGlzLmdldEhlYWRlcnMoKVt4XTtcbiAgICAgICAgICAgICAgICBzb3J0U3RyaW5nID0gdGhpcy5nZXRTb3J0SW1hZ2VGb3JDb2x1bW4oeCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgaWYgKHNvcnRTdHJpbmcpIHsgaGVhZGVyID0gc29ydFN0cmluZyArIGhlYWRlcjsgfVxuICAgICAgICAgICAgICAgIHJldHVybiBbbnVsbCwgaGVhZGVyLCBudWxsXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtudWxsLCBmaWx0ZXIsIGJlaGF2aW9yLmdldEltYWdlKGltYWdlKV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoaXNGaWx0ZXJSb3cpIHtcbiAgICAgICAgICAgIHJldHVybiBbbnVsbCwgZmlsdGVyLCBiZWhhdmlvci5nZXRJbWFnZShpbWFnZSldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaGVhZGVyID0gdGhpcy5nZXRIZWFkZXJzKClbeF07XG4gICAgICAgICAgICBzb3J0U3RyaW5nID0gdGhpcy5nZXRTb3J0SW1hZ2VGb3JDb2x1bW4oeCwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAoc29ydFN0cmluZykgeyBoZWFkZXIgPSBzb3J0U3RyaW5nICsgaGVhZGVyOyB9XG4gICAgICAgICAgICByZXR1cm4gW251bGwsIGhlYWRlciwgbnVsbF07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgZGF0YU1vZGVscy5KU09OLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHlcbiAgICAgKiBAcGFyYW0gdmFsdWVcbiAgICAgKi9cbiAgICBzZXRWYWx1ZTogZnVuY3Rpb24oeCwgeSwgdmFsdWUpIHtcbiAgICAgICAgdmFyIGhhc0hpZXJhcmNoeUNvbHVtbiA9IHRoaXMuaGFzSGllcmFyY2h5Q29sdW1uKCk7XG4gICAgICAgIHZhciBncmlkID0gdGhpcy5nZXRHcmlkKCk7XG4gICAgICAgIHZhciBoZWFkZXJSb3dDb3VudCA9IGdyaWQuZ2V0SGVhZGVyUm93Q291bnQoKTtcbiAgICAgICAgaWYgKGhhc0hpZXJhcmNoeUNvbHVtbikge1xuICAgICAgICAgICAgaWYgKHggPT09IC0yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB4ICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHkgPCBoZWFkZXJSb3dDb3VudCkge1xuICAgICAgICAgICAgdGhpcy5zZXRIZWFkZXJSb3dWYWx1ZSh4LCB5LCB2YWx1ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaGFzSGllcmFyY2h5Q29sdW1uKSB7XG4gICAgICAgICAgICB5ICs9IDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmdldERhdGFTb3VyY2UoKS5zZXRWYWx1ZSh4LCB5IC0gaGVhZGVyUm93Q291bnQsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNoYW5nZWQoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIGRhdGFNb2RlbHMuSlNPTi5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAgICogQHBhcmFtIHZhbHVlXG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgc2V0SGVhZGVyUm93VmFsdWU6IGZ1bmN0aW9uKHgsIHksIHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fc2V0SGVhZGVyKHgsIHkpOyAvLyB5IGlzIHJlYWxseSB0aGUgdmFsdWVcbiAgICAgICAgfVxuICAgICAgICB2YXIgZ3JpZCA9IHRoaXMuZ2V0R3JpZCgpO1xuICAgICAgICB2YXIgaXNGaWx0ZXJSb3cgPSBncmlkLmlzU2hvd0ZpbHRlclJvdygpO1xuICAgICAgICB2YXIgaXNIZWFkZXJSb3cgPSBncmlkLmlzU2hvd0hlYWRlclJvdygpO1xuICAgICAgICB2YXIgaXNCb3RoID0gaXNGaWx0ZXJSb3cgJiYgaXNIZWFkZXJSb3c7XG4gICAgICAgIHZhciB0b3BUb3RhbHNPZmZzZXQgPSAoaXNGaWx0ZXJSb3cgPyAxIDogMCkgKyAoaXNIZWFkZXJSb3cgPyAxIDogMCk7XG4gICAgICAgIGlmICh5ID49IHRvcFRvdGFsc09mZnNldCkge1xuICAgICAgICAgICAgdGhpcy5nZXRUb3BUb3RhbHMoKVt5IC0gdG9wVG90YWxzT2Zmc2V0XVt4XSA9IHZhbHVlO1xuICAgICAgICB9IGVsc2UgaWYgKHggPT09IC0xKSB7XG4gICAgICAgICAgICByZXR1cm47IC8vIGNhbid0IGNoYW5nZSB0aGUgcm93IG51bWJlcnNcbiAgICAgICAgfSBlbHNlIGlmIChpc0JvdGgpIHtcbiAgICAgICAgICAgIGlmICh5ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NldEhlYWRlcih4LCB2YWx1ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0RmlsdGVyKHgsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChpc0ZpbHRlclJvdykge1xuICAgICAgICAgICAgdGhpcy5zZXRGaWx0ZXIoeCwgdmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NldEhlYWRlcih4LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgZGF0YU1vZGVscy5KU09OLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb2xJbmRleFxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGdldENvbHVtblByb3BlcnRpZXM6IGZ1bmN0aW9uKGNvbEluZGV4KSB7XG4gICAgICAgIC8vYWNjZXNzIGRpcmVjdGx5IGJlY2F1c2Ugd2Ugd2FudCBpdCBvcmRlcmVkXG4gICAgICAgIHZhciBjb2x1bW4gPSB0aGlzLmdldEJlaGF2aW9yKCkuYWxsQ29sdW1uc1tjb2xJbmRleF07XG4gICAgICAgIGlmIChjb2x1bW4pIHtcbiAgICAgICAgICAgIHJldHVybiBjb2x1bW4uZ2V0UHJvcGVydGllcygpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBkYXRhTW9kZWxzLkpTT04ucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbEluZGV4XG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgZ2V0RmlsdGVyOiBmdW5jdGlvbihjb2xJbmRleCkge1xuICAgICAgICB2YXIgY29sdW1uUHJvcGVydGllcyA9IHRoaXMuZ2V0Q29sdW1uUHJvcGVydGllcyhjb2xJbmRleCk7XG4gICAgICAgIGlmICghY29sdW1uUHJvcGVydGllcykge1xuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb2x1bW5Qcm9wZXJ0aWVzLmZpbHRlciB8fCAnJztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIGRhdGFNb2RlbHMuSlNPTi5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY29sSW5kZXhcbiAgICAgKiBAcGFyYW0gdmFsdWVcbiAgICAgKi9cbiAgICBzZXRGaWx0ZXI6IGZ1bmN0aW9uKGNvbEluZGV4LCB2YWx1ZSkge1xuICAgICAgICB2YXIgY29sdW1uUHJvcGVydGllcyA9IHRoaXMuZ2V0Q29sdW1uUHJvcGVydGllcyhjb2xJbmRleCk7XG4gICAgICAgIGNvbHVtblByb3BlcnRpZXMuZmlsdGVyID0gdmFsdWU7XG4gICAgICAgIHRoaXMuYXBwbHlBbmFseXRpY3MoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIGRhdGFNb2RlbHMuSlNPTi5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqL1xuICAgIGdldENvbHVtbkNvdW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYW5hbHl0aWNzLmdldENvbHVtbkNvdW50KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBkYXRhTW9kZWxzLkpTT04ucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKi9cbiAgICBnZXRSb3dDb3VudDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBncmlkID0gdGhpcy5nZXRHcmlkKCk7XG4gICAgICAgIHZhciBjb3VudCA9IHRoaXMuZ2V0RGF0YVNvdXJjZSgpLmdldFJvd0NvdW50KCk7XG4gICAgICAgIGNvdW50ICs9IGdyaWQuZ2V0SGVhZGVyUm93Q291bnQoKTtcbiAgICAgICAgcmV0dXJuIGNvdW50O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgZGF0YU1vZGVscy5KU09OLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmdbXX1cbiAgICAgKi9cbiAgICBnZXRIZWFkZXJzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYW5hbHl0aWNzLmdldEhlYWRlcnMoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIGRhdGFNb2RlbHMuSlNPTi5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBoZWFkZXJzXG4gICAgICovXG4gICAgc2V0SGVhZGVyczogZnVuY3Rpb24oaGVhZGVycykge1xuICAgICAgICB0aGlzLmdldERhdGFTb3VyY2UoKS5zZXRIZWFkZXJzKGhlYWRlcnMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgZGF0YU1vZGVscy5KU09OLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IGZpZWxkc1xuICAgICAqL1xuICAgIHNldEZpZWxkczogZnVuY3Rpb24oZmllbGRzKSB7XG4gICAgICAgIHRoaXMuZ2V0RGF0YVNvdXJjZSgpLnNldEZpZWxkcyhmaWVsZHMpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgZGF0YU1vZGVscy5KU09OLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmdbXX1cbiAgICAgKi9cbiAgICBnZXRGaWVsZHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXREYXRhU291cmNlKCkuZ2V0RmllbGRzKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBkYXRhTW9kZWxzLkpTT04ucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtvYmplY3RbXX0gZGF0YVJvd3NcbiAgICAgKi9cbiAgICBzZXREYXRhOiBmdW5jdGlvbihkYXRhUm93cykge1xuICAgICAgICB0aGlzLnNvdXJjZSA9IG5ldyBhbmFseXRpY3MuSlNEYXRhU291cmNlKGRhdGFSb3dzKTtcbiAgICAgICAgdGhpcy5wcmVnbG9iYWxmaWx0ZXIgPSBuZXcgYW5hbHl0aWNzLkRhdGFTb3VyY2VHbG9iYWxGaWx0ZXIodGhpcy5zb3VyY2UpO1xuICAgICAgICB0aGlzLnByZWZpbHRlciA9IG5ldyBhbmFseXRpY3MuRGF0YVNvdXJjZUZpbHRlcih0aGlzLnByZWdsb2JhbGZpbHRlcik7XG4gICAgICAgIHRoaXMucHJlc29ydGVyID0gbmV3IGFuYWx5dGljcy5EYXRhU291cmNlU29ydGVyQ29tcG9zaXRlKHRoaXMucHJlZmlsdGVyKTtcbiAgICAgICAgdGhpcy5hbmFseXRpY3MgPSBuZXcgYW5hbHl0aWNzLkRhdGFTb3VyY2VBZ2dyZWdhdG9yKHRoaXMucHJlc29ydGVyKTtcblxuICAgICAgICB0aGlzLmFwcGx5QW5hbHl0aWNzKCk7XG5cbiAgICAgICAgLy90aGlzLnBvc3RmaWx0ZXIgPSBuZXcgYW5hbHl0aWNzLkRhdGFTb3VyY2VGaWx0ZXIodGhpcy5hbmFseXRpY3MpO1xuICAgICAgICAvL3RoaXMucG9zdHNvcnRlciA9IG5ldyBhbmFseXRpY3MuRGF0YVNvdXJjZVNvcnRlckNvbXBvc2l0ZSh0aGlzLnBvc3RmaWx0ZXIpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgZGF0YU1vZGVscy5KU09OLnByb3RvdHlwZVxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuICAgIGdldFRvcFRvdGFsczogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICghdGhpcy5oYXNBZ2dyZWdhdGVzKCkpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnRvcFRvdGFscztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5nZXREYXRhU291cmNlKCkuZ2V0R3JhbmRUb3RhbHMoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIGRhdGFNb2RlbHMuSlNPTi5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0gbmVzdGVkQXJyYXlcbiAgICAgKi9cbiAgICBzZXRUb3BUb3RhbHM6IGZ1bmN0aW9uKG5lc3RlZEFycmF5KSB7XG4gICAgICAgIHRoaXMudG9wVG90YWxzID0gbmVzdGVkQXJyYXk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBkYXRhTW9kZWxzLkpTT04ucHJvdG90eXBlXG4gICAgICogQHBhcmFtIGdyb3Vwc1xuICAgICAqL1xuICAgIHNldEdyb3VwczogZnVuY3Rpb24oZ3JvdXBzKSB7XG4gICAgICAgIHRoaXMuYW5hbHl0aWNzLnNldEdyb3VwQnlzKGdyb3Vwcyk7XG4gICAgICAgIHRoaXMuYXBwbHlBbmFseXRpY3MoKTtcbiAgICAgICAgdGhpcy5nZXRHcmlkKCkuZmlyZVN5bnRoZXRpY0dyb3Vwc0NoYW5nZWRFdmVudCh0aGlzLmdldEdyb3VwcygpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIGRhdGFNb2RlbHMuSlNPTi5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0W119XG4gICAgICovXG4gICAgZ2V0R3JvdXBzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGhlYWRlcnMgPSB0aGlzLmdldEhlYWRlcnMoKS5zbGljZSgwKTtcbiAgICAgICAgdmFyIGZpZWxkcyA9IHRoaXMuZ2V0RmllbGRzKCkuc2xpY2UoMCk7XG4gICAgICAgIHZhciBncm91cEJ5cyA9IHRoaXMuYW5hbHl0aWNzLmdyb3VwQnlzO1xuICAgICAgICB2YXIgZ3JvdXBzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ3JvdXBCeXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBmaWVsZCA9IGhlYWRlcnNbZ3JvdXBCeXNbaV1dO1xuICAgICAgICAgICAgZ3JvdXBzLnB1c2goe1xuICAgICAgICAgICAgICAgIGlkOiBncm91cEJ5c1tpXSxcbiAgICAgICAgICAgICAgICBsYWJlbDogZmllbGQsXG4gICAgICAgICAgICAgICAgZmllbGQ6IGZpZWxkc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGdyb3VwcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIGRhdGFNb2RlbHMuSlNPTi5wcm90b3R5cGVcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0W119XG4gICAgICovXG4gICAgZ2V0QXZhaWxhYmxlR3JvdXBzOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGhlYWRlcnMgPSB0aGlzLnNvdXJjZS5nZXRIZWFkZXJzKCkuc2xpY2UoMCk7XG4gICAgICAgIHZhciBncm91cEJ5cyA9IHRoaXMuYW5hbHl0aWNzLmdyb3VwQnlzO1xuICAgICAgICB2YXIgZ3JvdXBzID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGVhZGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGdyb3VwQnlzLmluZGV4T2YoaSkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgdmFyIGZpZWxkID0gaGVhZGVyc1tpXTtcbiAgICAgICAgICAgICAgICBncm91cHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGlkOiBpLFxuICAgICAgICAgICAgICAgICAgICBsYWJlbDogZmllbGQsXG4gICAgICAgICAgICAgICAgICAgIGZpZWxkOiBmaWVsZFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBncm91cHM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBkYXRhTW9kZWxzLkpTT04ucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge29iamVjdFtdfVxuICAgICAqL1xuICAgIGdldFZpc2libGVDb2x1bW5zOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGl0ZW1zID0gdGhpcy5nZXRCZWhhdmlvcigpLmNvbHVtbnM7XG4gICAgICAgIGl0ZW1zID0gaXRlbXMuZmlsdGVyKGZ1bmN0aW9uKGVhY2gpIHtcbiAgICAgICAgICAgIHJldHVybiBlYWNoLmxhYmVsICE9PSAnVHJlZSc7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gaXRlbXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBkYXRhTW9kZWxzLkpTT04ucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge29iamVjdFtdfVxuICAgICAqL1xuICAgIGdldEhpZGRlbkNvbHVtbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdmlzaWJsZSA9IHRoaXMuZ2V0QmVoYXZpb3IoKS5jb2x1bW5zO1xuICAgICAgICB2YXIgYWxsID0gdGhpcy5nZXRCZWhhdmlvcigpLmFsbENvbHVtbnM7XG4gICAgICAgIHZhciBoaWRkZW4gPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbGwubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh2aXNpYmxlLmluZGV4T2YoYWxsW2ldKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBoaWRkZW4ucHVzaChhbGxbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGhpZGRlbi5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcbiAgICAgICAgICAgIHJldHVybiBhLmxhYmVsIDwgYi5sYWJlbDtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBoaWRkZW47XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBkYXRhTW9kZWxzLkpTT04ucHJvdG90eXBlXG4gICAgICogQHBhcmFtIGFnZ3JlZ2F0aW9uc1xuICAgICAqL1xuICAgIHNldEFnZ3JlZ2F0ZXM6IGZ1bmN0aW9uKGFnZ3JlZ2F0aW9ucykge1xuICAgICAgICB0aGlzLnF1aWV0bHlTZXRBZ2dyZWdhdGVzKGFnZ3JlZ2F0aW9ucyk7XG4gICAgICAgIHRoaXMuYXBwbHlBbmFseXRpY3MoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIGRhdGFNb2RlbHMuSlNPTi5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0gYWdncmVnYXRpb25zXG4gICAgICovXG4gICAgcXVpZXRseVNldEFnZ3JlZ2F0ZXM6IGZ1bmN0aW9uKGFnZ3JlZ2F0aW9ucykge1xuICAgICAgICB0aGlzLmFuYWx5dGljcy5zZXRBZ2dyZWdhdGVzKGFnZ3JlZ2F0aW9ucyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBkYXRhTW9kZWxzLkpTT04ucHJvdG90eXBlXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgaGFzSGllcmFyY2h5Q29sdW1uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFzQWdncmVnYXRlcygpICYmIHRoaXMuaGFzR3JvdXBzKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBkYXRhTW9kZWxzLkpTT04ucHJvdG90eXBlXG4gICAgICovXG4gICAgYXBwbHlBbmFseXRpY3M6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmFwcGx5RmlsdGVycygpO1xuICAgICAgICB0aGlzLmFwcGx5U29ydHMoKTtcbiAgICAgICAgdGhpcy5hcHBseUdyb3VwQnlzQW5kQWdncmVnYXRpb25zKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBkYXRhTW9kZWxzLkpTT04ucHJvdG90eXBlXG4gICAgICovXG4gICAgYXBwbHlHcm91cEJ5c0FuZEFnZ3JlZ2F0aW9uczogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLmFuYWx5dGljcy5hZ2dyZWdhdGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5xdWlldGx5U2V0QWdncmVnYXRlcyh7fSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hbmFseXRpY3MuYXBwbHkoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIGRhdGFNb2RlbHMuSlNPTi5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBhcHBseUZpbHRlcnM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLnByZWdsb2JhbGZpbHRlci5hcHBseSgpO1xuICAgICAgICB2YXIgY29sQ291bnQgPSB0aGlzLmdldENvbHVtbkNvdW50KCk7XG4gICAgICAgIHZhciBmaWx0ZXJTb3VyY2UgPSB0aGlzLmdldEZpbHRlclNvdXJjZSgpO1xuICAgICAgICB2YXIgZ3JvdXBPZmZzZXQgPSB0aGlzLmhhc0FnZ3JlZ2F0ZXMoKSA/IDEgOiAwO1xuICAgICAgICBmaWx0ZXJTb3VyY2UuY2xlYXJBbGwoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb2xDb3VudDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgZmlsdGVyVGV4dCA9IHRoaXMuZ2V0RmlsdGVyKGkpO1xuICAgICAgICAgICAgaWYgKGZpbHRlclRleHQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGZpbHRlclNvdXJjZS5hZGQoaSAtIGdyb3VwT2Zmc2V0LCB0ZXh0TWF0Y2hGaWx0ZXIoZmlsdGVyVGV4dCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZpbHRlclNvdXJjZS5hcHBseUFsbCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgZGF0YU1vZGVscy5KU09OLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb2xJbmRleFxuICAgICAqIEBwYXJhbSBrZXlzXG4gICAgICovXG4gICAgdG9nZ2xlU29ydDogZnVuY3Rpb24oY29sSW5kZXgsIGtleXMpIHtcbiAgICAgICAgdGhpcy5pbmNyZW1lbnRTb3J0U3RhdGUoY29sSW5kZXgsIGtleXMpO1xuICAgICAgICB0aGlzLmFwcGx5QW5hbHl0aWNzKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBkYXRhTW9kZWxzLkpTT04ucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGNvbEluZGV4XG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0ga2V5c1xuICAgICAqL1xuICAgIGluY3JlbWVudFNvcnRTdGF0ZTogZnVuY3Rpb24oY29sSW5kZXgsIGtleXMpIHtcbiAgICAgICAgY29sSW5kZXgrKzsgLy9oYWNrIHRvIGdldCBhcm91bmQgMCBpbmRleFxuICAgICAgICB2YXIgc3RhdGUgPSB0aGlzLmdldFByaXZhdGVTdGF0ZSgpO1xuICAgICAgICB2YXIgaGFzQ1RSTCA9IGtleXMuaW5kZXhPZignQ1RSTCcpID4gLTE7XG4gICAgICAgIHN0YXRlLnNvcnRzID0gc3RhdGUuc29ydHMgfHwgW107XG4gICAgICAgIHZhciBhbHJlYWR5ID0gc3RhdGUuc29ydHMuaW5kZXhPZihjb2xJbmRleCk7XG4gICAgICAgIGlmIChhbHJlYWR5ID09PSAtMSkge1xuICAgICAgICAgICAgYWxyZWFkeSA9IHN0YXRlLnNvcnRzLmluZGV4T2YoLTEgKiBjb2xJbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFscmVhZHkgPiAtMSkge1xuICAgICAgICAgICAgaWYgKHN0YXRlLnNvcnRzW2FscmVhZHldID4gMCkge1xuICAgICAgICAgICAgICAgIHN0YXRlLnNvcnRzW2FscmVhZHldID0gLTEgKiBzdGF0ZS5zb3J0c1thbHJlYWR5XTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3RhdGUuc29ydHMuc3BsaWNlKGFscmVhZHksIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGhhc0NUUkwgfHwgc3RhdGUuc29ydHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBzdGF0ZS5zb3J0cy51bnNoaWZ0KGNvbEluZGV4KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0YXRlLnNvcnRzLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICBzdGF0ZS5zb3J0cy51bnNoaWZ0KGNvbEluZGV4KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUuc29ydHMubGVuZ3RoID4gMykge1xuICAgICAgICAgICAgc3RhdGUuc29ydHMubGVuZ3RoID0gMztcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgZGF0YU1vZGVscy5KU09OLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGFwcGx5U29ydHM6IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgc29ydGluZ1NvdXJjZSA9IHRoaXMuZ2V0U29ydGluZ1NvdXJjZSgpO1xuICAgICAgICB2YXIgc29ydHMgPSB0aGlzLmdldFByaXZhdGVTdGF0ZSgpLnNvcnRzO1xuICAgICAgICB2YXIgZ3JvdXBPZmZzZXQgPSB0aGlzLmhhc0FnZ3JlZ2F0ZXMoKSA/IDEgOiAwO1xuICAgICAgICBpZiAoIXNvcnRzIHx8IHNvcnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgc29ydGluZ1NvdXJjZS5jbGVhclNvcnRzKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNvcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbEluZGV4ID0gTWF0aC5hYnMoc29ydHNbaV0pIC0gMTtcbiAgICAgICAgICAgICAgICB2YXIgdHlwZSA9IHNvcnRzW2ldIDwgMCA/IC0xIDogMTtcbiAgICAgICAgICAgICAgICBzb3J0aW5nU291cmNlLnNvcnRPbihjb2xJbmRleCAtIGdyb3VwT2Zmc2V0LCB0eXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzb3J0aW5nU291cmNlLmFwcGx5U29ydHMoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIGRhdGFNb2RlbHMuSlNPTi5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0gaW5kZXhcbiAgICAgKiBAcGFyYW0gcmV0dXJuQXNTdHJpbmdcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBnZXRTb3J0SW1hZ2VGb3JDb2x1bW46IGZ1bmN0aW9uKGluZGV4LCByZXR1cm5Bc1N0cmluZykge1xuICAgICAgICBpbmRleCsrO1xuICAgICAgICB2YXIgdXAgPSB0cnVlO1xuICAgICAgICB2YXIgc29ydHMgPSB0aGlzLmdldFByaXZhdGVTdGF0ZSgpLnNvcnRzO1xuICAgICAgICBpZiAoIXNvcnRzKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcG9zaXRpb24gPSBzb3J0cy5pbmRleE9mKGluZGV4KTtcbiAgICAgICAgaWYgKHBvc2l0aW9uIDwgMCkge1xuICAgICAgICAgICAgcG9zaXRpb24gPSBzb3J0cy5pbmRleE9mKC0xICogaW5kZXgpO1xuICAgICAgICAgICAgdXAgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocG9zaXRpb24gPCAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByYW5rID0gc29ydHMubGVuZ3RoIC0gcG9zaXRpb247XG5cbiAgICAgICAgaWYgKHJldHVybkFzU3RyaW5nKSB7XG4gICAgICAgICAgICB2YXIgYXJyb3cgPSB1cCA/IFVQV0FSRFNfQkxBQ0tfQVJST1cgOiBET1dOV0FSRFNfQkxBQ0tfQVJST1c7XG4gICAgICAgICAgICByZXR1cm4gcmFuayArIGFycm93ICsgJyAnO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG5hbWUgPSByYW5rICsgKHVwID8gJy11cCcgOiAnLWRvd24nKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QmVoYXZpb3IoKS5nZXRJbWFnZShuYW1lKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIGRhdGFNb2RlbHMuSlNPTi5wcm90b3R5cGVcbiAgICAgKiBAcGFyYW0gY2VsbFxuICAgICAqIEBwYXJhbSBldmVudFxuICAgICAqL1xuICAgIGNlbGxDbGlja2VkOiBmdW5jdGlvbihjZWxsLCBldmVudCkge1xuICAgICAgICBpZiAoIXRoaXMuaGFzQWdncmVnYXRlcygpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV2ZW50LmdyaWRDZWxsLnggIT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjsgLy8gdGhpcyB3YXNuJ3QgYSBjbGljayBvbiB0aGUgaGllcmFyY2h5IGNvbHVtblxuICAgICAgICB9XG4gICAgICAgIHZhciBncmlkID0gdGhpcy5nZXRHcmlkKCk7XG4gICAgICAgIHZhciBoZWFkZXJSb3dDb3VudCA9IGdyaWQuZ2V0SGVhZGVyUm93Q291bnQoKTtcbiAgICAgICAgdmFyIHkgPSBldmVudC5ncmlkQ2VsbC55IC0gaGVhZGVyUm93Q291bnQgKyAxO1xuICAgICAgICB0aGlzLmFuYWx5dGljcy5jbGljayh5KTtcbiAgICAgICAgdGhpcy5jaGFuZ2VkKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBkYXRhTW9kZWxzLkpTT04ucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHlcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fVxuICAgICAqL1xuICAgIGdldFJvdzogZnVuY3Rpb24oeSkge1xuICAgICAgICB2YXIgZ3JpZCA9IHRoaXMuZ2V0R3JpZCgpO1xuICAgICAgICB2YXIgaGVhZGVyUm93Q291bnQgPSBncmlkLmdldEhlYWRlclJvd0NvdW50KCk7XG4gICAgICAgIGlmICh5IDwgaGVhZGVyUm93Q291bnQgJiYgIXRoaXMuaGFzQWdncmVnYXRlcygpKSB7XG4gICAgICAgICAgICB2YXIgdG9wVG90YWxzID0gdGhpcy5nZXRUb3BUb3RhbHMoKTtcbiAgICAgICAgICAgIHJldHVybiB0b3BUb3RhbHNbeSAtIChoZWFkZXJSb3dDb3VudCAtIHRvcFRvdGFscy5sZW5ndGgpXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5nZXREYXRhU291cmNlKCkuZ2V0Um93KHkgLSBoZWFkZXJSb3dDb3VudCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBkYXRhTW9kZWxzLkpTT04ucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHlcbiAgICAgKiBAcmV0dXJucyB7b2JqZWN0fVxuICAgICAqL1xuICAgIGJ1aWxkUm93OiBmdW5jdGlvbih5KSB7XG4gICAgICAgIHZhciBjb2xDb3VudCA9IHRoaXMuZ2V0Q29sdW1uQ291bnQoKTtcbiAgICAgICAgdmFyIGZpZWxkcyA9IFtdLmNvbmNhdCh0aGlzLmdldEZpZWxkcygpKTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgICBpZiAodGhpcy5oYXNBZ2dyZWdhdGVzKCkpIHtcbiAgICAgICAgICAgIHJlc3VsdC50cmVlID0gdGhpcy5nZXRWYWx1ZSgtMiwgeSk7XG4gICAgICAgICAgICBmaWVsZHMuc2hpZnQoKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbENvdW50OyBpKyspIHtcbiAgICAgICAgICAgIHJlc3VsdFtmaWVsZHNbaV1dID0gdGhpcy5nZXRWYWx1ZShpLCB5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgZGF0YU1vZGVscy5KU09OLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAgICogQHJldHVybnMge29iamVjdH1cbiAgICAgKi9cbiAgICBnZXRDb21wdXRlZFJvdzogZnVuY3Rpb24oeSkge1xuICAgICAgICB2YXIgcmNmID0gdGhpcy5nZXRSb3dDb250ZXh0RnVuY3Rpb24oW3ldKTtcbiAgICAgICAgdmFyIGZpZWxkcyA9IHRoaXMuZ2V0RmllbGRzKCk7XG4gICAgICAgIHZhciByb3cgPSB7fTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmaWVsZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBmaWVsZCA9IGZpZWxkc1tpXTtcbiAgICAgICAgICAgIHJvd1tmaWVsZF0gPSByY2YoZmllbGQpWzBdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByb3c7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBkYXRhTW9kZWxzLkpTT04ucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkTmFtZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAgICogQHJldHVybnMgeyp9XG4gICAgICovXG4gICAgZ2V0VmFsdWVCeUZpZWxkOiBmdW5jdGlvbihmaWVsZE5hbWUsIHkpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gdGhpcy5nZXRGaWVsZHMoKS5pbmRleE9mKGZpZWxkTmFtZSk7XG4gICAgICAgIGlmICh0aGlzLmhhc0FnZ3JlZ2F0ZXMoKSkge1xuICAgICAgICAgICAgeSArPSAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmdldERhdGFTb3VyY2UoKS5nZXRWYWx1ZShpbmRleCwgeSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBkYXRhTW9kZWxzLkpTT04ucHJvdG90eXBlXG4gICAgICogQHBhcmFtIHtzcmluZ30gc3RyaW5nXG4gICAgICovXG4gICAgc2V0R2xvYmFsRmlsdGVyOiBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgICAgaWYgKCFzdHJpbmcgfHwgc3RyaW5nLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5wcmVnbG9iYWxmaWx0ZXIuY2xlYXIoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucHJlZ2xvYmFsZmlsdGVyLnNldCh0ZXh0TWF0Y2hGaWx0ZXIoc3RyaW5nKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hcHBseUFuYWx5dGljcygpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgZGF0YU1vZGVscy5KU09OLnByb3RvdHlwZVxuICAgICAqIEBwYXJhbSB7b2JqZWN0fSBjb25maWdcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB5XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHVudHJhbnNsYXRlZFhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdW50cmFuc2xhdGVkWVxuICAgICAqIEByZXR1cm5zIHtvYmplY3R9XG4gICAgICovXG4gICAgZ2V0Q2VsbFJlbmRlcmVyOiBmdW5jdGlvbihjb25maWcsIHgsIHksIHVudHJhbnNsYXRlZFgsIHVudHJhbnNsYXRlZFkpIHtcbiAgICAgICAgdmFyIHJlbmRlcmVyO1xuICAgICAgICB2YXIgcHJvdmlkZXIgPSB0aGlzLmdldEdyaWQoKS5nZXRDZWxsUHJvdmlkZXIoKTtcblxuICAgICAgICBjb25maWcueCA9IHg7XG4gICAgICAgIGNvbmZpZy55ID0geTtcbiAgICAgICAgY29uZmlnLnVudHJhbnNsYXRlZFggPSB1bnRyYW5zbGF0ZWRYO1xuICAgICAgICBjb25maWcudW50cmFuc2xhdGVkWSA9IHVudHJhbnNsYXRlZFk7XG5cbiAgICAgICAgcmVuZGVyZXIgPSBwcm92aWRlci5nZXRDZWxsKGNvbmZpZyk7XG4gICAgICAgIHJlbmRlcmVyLmNvbmZpZyA9IGNvbmZpZztcblxuICAgICAgICByZXR1cm4gcmVuZGVyZXI7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBkYXRhTW9kZWxzLkpTT04ucHJvdG90eXBlXG4gICAgICovXG4gICAgYXBwbHlTdGF0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuYXBwbHlBbmFseXRpY3MoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIGRhdGFNb2RlbHMuSlNPTi5wcm90b3R5cGVcbiAgICAgKi9cbiAgICByZXNldDogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuc2V0RGF0YShbXSk7XG4gICAgfVxuXG59KTtcblxuZnVuY3Rpb24gdmFsdWVPckZ1bmN0aW9uRXhlY3V0ZSh2YWx1ZU9yRnVuY3Rpb24pIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlT3JGdW5jdGlvbiA9PT0gJ2Z1bmN0aW9uJyA/IHZhbHVlT3JGdW5jdGlvbigpIDogdmFsdWVPckZ1bmN0aW9uO1xufVxuXG5mdW5jdGlvbiB0ZXh0TWF0Y2hGaWx0ZXIoc3RyaW5nKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGVhY2gpIHtcbiAgICAgICAgZWFjaCA9IHZhbHVlT3JGdW5jdGlvbkV4ZWN1dGUoZWFjaCk7XG4gICAgICAgIHJldHVybiAoZWFjaCArICcnKS50b0xvd2VyQ2FzZSgpLnNlYXJjaChzdHJpbmcudG9Mb3dlckNhc2UoKSkgPiAtMTtcbiAgICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEpTT047XG4iLCIvKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgSHlwZXJncmlkID0gcmVxdWlyZSgnLi9IeXBlcmdyaWQnKTtcblxuSHlwZXJncmlkLmJlaGF2aW9ycyA9IHJlcXVpcmUoJy4vYmVoYXZpb3JzL2luZGV4Jyk7XG5IeXBlcmdyaWQuY2VsbEVkaXRvcnMgPSByZXF1aXJlKCcuL2NlbGxFZGl0b3JzL2luZGV4Jyk7XG5IeXBlcmdyaWQuZmVhdHVyZXMgPSByZXF1aXJlKCcuL2ZlYXR1cmVzL2luZGV4Jyk7XG5cbndpbmRvdy5maW4gPSB7XG4gICAgSHlwZXJncmlkOiBIeXBlcmdyaWRcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBGZWF0dXJlID0gcmVxdWlyZSgnLi9GZWF0dXJlLmpzJyk7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBDZWxsQ2xpY2sgPSBGZWF0dXJlLmV4dGVuZCgnQ2VsbENsaWNrJywge1xuXG4gICAgYWxpYXM6ICdDZWxsQ2xpY2snLFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENlbGxDbGljay5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBIYW5kbGUgdGhpcyBldmVudCBkb3duIHRoZSBmZWF0dXJlIGNoYWluIG9mIHJlc3BvbnNpYmlsaXR5XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZVRhcDogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgdmFyIGdyaWRDZWxsID0gZXZlbnQuZ3JpZENlbGw7XG4gICAgICAgIHZhciBiZWhhdmlvciA9IGdyaWQuZ2V0QmVoYXZpb3IoKTtcbiAgICAgICAgdmFyIGhlYWRlclJvd0NvdW50ID0gYmVoYXZpb3IuZ2V0SGVhZGVyUm93Q291bnQoKTtcbiAgICAgICAgdmFyIGhlYWRlckNvbHVtbkNvdW50ID0gYmVoYXZpb3IuZ2V0SGVhZGVyQ29sdW1uQ291bnQoKTtcbiAgICAgICAgaWYgKChncmlkQ2VsbC55ID49IGhlYWRlclJvd0NvdW50KSAmJlxuICAgICAgICAgICAgKGdyaWRDZWxsLnggPj0gaGVhZGVyQ29sdW1uQ291bnQpKSB7XG4gICAgICAgICAgICBncmlkLmNlbGxDbGlja2VkKGV2ZW50KTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dC5oYW5kbGVUYXAoZ3JpZCwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gQ2VsbENsaWNrO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgRmVhdHVyZSA9IHJlcXVpcmUoJy4vRmVhdHVyZS5qcycpO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgQ2VsbEVkaXRpbmcgPSBGZWF0dXJlLmV4dGVuZCgnQ2VsbEVkaXRpbmcnLCB7XG5cbiAgICBhbGlhczogJ0NlbGxFZGl0aW5nJyxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsRWRpdGluZy5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBoYW5kbGUgdGhpcyBldmVudCBkb3duIHRoZSBmZWF0dXJlIGNoYWluIG9mIHJlc3BvbnNpYmlsaXR5XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZURvdWJsZUNsaWNrOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICB2YXIgYmVoYXZpb3IgPSBncmlkLmdldEJlaGF2aW9yKCk7XG4gICAgICAgIHZhciBoZWFkZXJSb3dDb3VudCA9IGJlaGF2aW9yLmdldEhlYWRlclJvd0NvdW50KCk7XG4gICAgICAgIHZhciBoZWFkZXJDb2x1bW5Db3VudCA9IGJlaGF2aW9yLmdldEhlYWRlckNvbHVtbkNvdW50KCk7XG4gICAgICAgIHZhciBncmlkQ2VsbCA9IGV2ZW50LmdyaWRDZWxsO1xuICAgICAgICBpZiAoZ3JpZENlbGwueCA+PSBoZWFkZXJDb2x1bW5Db3VudCAmJiBncmlkQ2VsbC55ID49IGhlYWRlclJvd0NvdW50KSB7XG4gICAgICAgICAgICBncmlkLl9hY3RpdmF0ZUVkaXRvcihldmVudCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQuaGFuZGxlRG91YmxlQ2xpY2soZ3JpZCwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsRWRpdGluZy5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBoYW5kbGUgdGhpcyBldmVudCBkb3duIHRoZSBmZWF0dXJlIGNoYWluIG9mIHJlc3BvbnNpYmlsaXR5XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZUhvbGRQdWxzZTogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgdmFyIGJlaGF2aW9yID0gZ3JpZC5nZXRCZWhhdmlvcigpO1xuICAgICAgICB2YXIgaGVhZGVyUm93Q291bnQgPSBiZWhhdmlvci5nZXRIZWFkZXJSb3dDb3VudCgpO1xuICAgICAgICB2YXIgaGVhZGVyQ29sdW1uQ291bnQgPSBiZWhhdmlvci5nZXRIZWFkZXJDb2x1bW5Db3VudCgpO1xuICAgICAgICB2YXIgZ3JpZENlbGwgPSBldmVudC5ncmlkQ2VsbDtcbiAgICAgICAgaWYgKGdyaWRDZWxsLnggPj0gaGVhZGVyQ29sdW1uQ291bnQgJiYgZ3JpZENlbGwueSA+PSBoZWFkZXJSb3dDb3VudCkge1xuICAgICAgICAgICAgZ3JpZC5fYWN0aXZhdGVFZGl0b3IoZXZlbnQpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMubmV4dCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0LmhhbmRsZUhvbGRQdWxzZShncmlkLCBldmVudCk7XG4gICAgICAgIH1cbiAgICB9XG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENlbGxFZGl0aW5nO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgRmVhdHVyZSA9IHJlcXVpcmUoJy4vRmVhdHVyZS5qcycpO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgQ2VsbFNlbGVjdGlvbiA9IEZlYXR1cmUuZXh0ZW5kKCdDZWxsU2VsZWN0aW9uJywge1xuXG4gICAgYWxpYXM6ICdDZWxsU2VsZWN0aW9uJyxcblxuICAgIC8qKlxuICAgICAqIFRoZSBwaXhlbCBsb2NhdGlvbiBvZiB0aGUgbW91c2UgcG9pbnRlciBkdXJpbmcgYSBkcmFnIG9wZXJhdGlvbi5cbiAgICAgKiBAdHlwZSB7d2luZG93LmZpbi5yZWN0YW5ndWxhci5Qb2ludH1cbiAgICAgKiBAbWVtYmVyT2YgQ2VsbFNlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBjdXJyZW50RHJhZzogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIHRoZSBjZWxsIGNvb3JkaW5hdGVzIG9mIHRoZSB3aGVyZSB0aGUgbW91c2UgcG9pbnRlciBpcyBkdXJpbmcgYSBkcmFnIG9wZXJhdGlvblxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICogQG1lbWJlck9mIENlbGxTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICovXG4gICAgbGFzdERyYWdDZWxsOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogYSBtaWxsaXNlY29uZCB2YWx1ZSByZXByZXNlbnRpbmcgdGhlIHByZXZpb3VzIHRpbWUgYW4gYXV0b3Njcm9sbCBzdGFydGVkXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICogQG1lbWJlck9mIENlbGxTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICovXG4gICAgc2JMYXN0QXV0bzogMCxcblxuICAgIC8qKlxuICAgICAqIGEgbWlsbGlzZWNvbmQgdmFsdWUgcmVwcmVzZW50aW5nIHRoZSB0aW1lIHRoZSBjdXJyZW50IGF1dG9zY3JvbGwgc3RhcnRlZFxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQGRlZmF1bHQgMFxuICAgICAqIEBtZW1iZXJPZiBDZWxsU2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHNiQXV0b1N0YXJ0OiAwLFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENlbGxTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2MgSGFuZGxlIHRoaXMgZXZlbnQgZG93biB0aGUgZmVhdHVyZSBjaGFpbiBvZiByZXNwb25zaWJpbGl0eS5cbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlTW91c2VVcDogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuZHJhZ2dpbmcpIHtcbiAgICAgICAgICAgIHRoaXMuZHJhZ2dpbmcgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQuaGFuZGxlTW91c2VVcChncmlkLCBldmVudCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENlbGxTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2MgSGFuZGxlIHRoaXMgZXZlbnQgZG93biB0aGUgZmVhdHVyZSBjaGFpbiBvZiByZXNwb25zaWJpbGl0eS5cbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlTW91c2VEb3duOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICB2YXIgaXNSaWdodENsaWNrID0gZXZlbnQucHJpbWl0aXZlRXZlbnQuZGV0YWlsLmlzUmlnaHRDbGljaztcbiAgICAgICAgdmFyIGJlaGF2aW9yID0gZ3JpZC5nZXRCZWhhdmlvcigpO1xuICAgICAgICB2YXIgY2VsbCA9IGV2ZW50LmdyaWRDZWxsO1xuICAgICAgICB2YXIgdmlld0NlbGwgPSBldmVudC52aWV3UG9pbnQ7XG4gICAgICAgIHZhciBkeCA9IGNlbGwueDtcbiAgICAgICAgdmFyIGR5ID0gY2VsbC55O1xuICAgICAgICB2YXIgaGVhZGVyUm93Q291bnQgPSBiZWhhdmlvci5nZXRIZWFkZXJSb3dDb3VudCgpO1xuICAgICAgICB2YXIgaGVhZGVyQ29sdW1uQ291bnQgPSBiZWhhdmlvci5nZXRIZWFkZXJDb2x1bW5Db3VudCgpO1xuICAgICAgICB2YXIgY29sdW1uQ291bnQgPSBiZWhhdmlvci5nZXRDb2x1bW5Db3VudCgpO1xuICAgICAgICB2YXIgaXNPdXRzaWRlID0gdmlld0NlbGwueCA+PSBjb2x1bW5Db3VudDtcblxuICAgICAgICB2YXIgaXNIZWFkZXIgPSBkeSA8IGhlYWRlclJvd0NvdW50IHx8IGR4IDwgaGVhZGVyQ29sdW1uQ291bnQ7XG5cbiAgICAgICAgaWYgKCFncmlkLmlzQ2VsbFNlbGVjdGlvbigpIHx8IGlzUmlnaHRDbGljayB8fCBpc0hlYWRlciB8fCBpc091dHNpZGUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5leHQuaGFuZGxlTW91c2VEb3duKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgdmFyIG51bUZpeGVkQ29sdW1ucyA9IGdyaWQuZ2V0Rml4ZWRDb2x1bW5Db3VudCgpO1xuICAgICAgICAgICAgdmFyIG51bUZpeGVkUm93cyA9IGdyaWQuZ2V0Rml4ZWRSb3dDb3VudCgpO1xuXG4gICAgICAgICAgICAvL2lmIHdlIGFyZSBpbiB0aGUgZml4ZWQgYXJlYSBkbyBub3QgYXBwbHkgdGhlIHNjcm9sbCB2YWx1ZXNcbiAgICAgICAgICAgIC8vY2hlY2sgYm90aCB4IGFuZCB5IHZhbHVlcyBpbmRlcGVuZGVudGx5XG4gICAgICAgICAgICBpZiAodmlld0NlbGwueCA8IG51bUZpeGVkQ29sdW1ucykge1xuICAgICAgICAgICAgICAgIGR4ID0gdmlld0NlbGwueDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHZpZXdDZWxsLnkgPCBudW1GaXhlZFJvd3MpIHtcbiAgICAgICAgICAgICAgICBkeSA9IHZpZXdDZWxsLnk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBkQ2VsbCA9IGdyaWQubmV3UG9pbnQoZHgsIGR5KTtcblxuICAgICAgICAgICAgdmFyIHByaW1FdmVudCA9IGV2ZW50LnByaW1pdGl2ZUV2ZW50O1xuICAgICAgICAgICAgdmFyIGtleXMgPSBwcmltRXZlbnQuZGV0YWlsLmtleXM7XG4gICAgICAgICAgICB0aGlzLmRyYWdnaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuZXh0ZW5kU2VsZWN0aW9uKGdyaWQsIGRDZWxsLCBrZXlzKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbFNlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBIYW5kbGUgdGhpcyBldmVudCBkb3duIHRoZSBmZWF0dXJlIGNoYWluIG9mIHJlc3BvbnNpYmlsaXR5LlxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVNb3VzZURyYWc6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIHZhciBpc1JpZ2h0Q2xpY2sgPSBldmVudC5wcmltaXRpdmVFdmVudC5kZXRhaWwuaXNSaWdodENsaWNrO1xuXG4gICAgICAgIGlmICghZ3JpZC5pc0NlbGxTZWxlY3Rpb24oKSB8fCBpc1JpZ2h0Q2xpY2sgfHwgIXRoaXMuZHJhZ2dpbmcpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5leHQuaGFuZGxlTW91c2VEcmFnKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgdmFyIG51bUZpeGVkQ29sdW1ucyA9IGdyaWQuZ2V0Rml4ZWRDb2x1bW5Db3VudCgpO1xuICAgICAgICAgICAgdmFyIG51bUZpeGVkUm93cyA9IGdyaWQuZ2V0Rml4ZWRSb3dDb3VudCgpO1xuXG4gICAgICAgICAgICB2YXIgY2VsbCA9IGV2ZW50LmdyaWRDZWxsO1xuICAgICAgICAgICAgdmFyIHZpZXdDZWxsID0gZXZlbnQudmlld1BvaW50O1xuICAgICAgICAgICAgdmFyIGR4ID0gY2VsbC54O1xuICAgICAgICAgICAgdmFyIGR5ID0gY2VsbC55O1xuXG4gICAgICAgICAgICAvL2lmIHdlIGFyZSBpbiB0aGUgZml4ZWQgYXJlYSBkbyBub3QgYXBwbHkgdGhlIHNjcm9sbCB2YWx1ZXNcbiAgICAgICAgICAgIC8vY2hlY2sgYm90aCB4IGFuZCB5IHZhbHVlcyBpbmRlcGVuZGVudGx5XG4gICAgICAgICAgICBpZiAodmlld0NlbGwueCA8IG51bUZpeGVkQ29sdW1ucykge1xuICAgICAgICAgICAgICAgIGR4ID0gdmlld0NlbGwueDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHZpZXdDZWxsLnkgPCBudW1GaXhlZFJvd3MpIHtcbiAgICAgICAgICAgICAgICBkeSA9IHZpZXdDZWxsLnk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBkQ2VsbCA9IGdyaWQubmV3UG9pbnQoZHgsIGR5KTtcblxuICAgICAgICAgICAgdmFyIHByaW1FdmVudCA9IGV2ZW50LnByaW1pdGl2ZUV2ZW50O1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50RHJhZyA9IHByaW1FdmVudC5kZXRhaWwubW91c2U7XG4gICAgICAgICAgICB0aGlzLmxhc3REcmFnQ2VsbCA9IGRDZWxsO1xuXG4gICAgICAgICAgICB0aGlzLmNoZWNrRHJhZ1Njcm9sbChncmlkLCB0aGlzLmN1cnJlbnREcmFnKTtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlTW91c2VEcmFnQ2VsbFNlbGVjdGlvbihncmlkLCBkQ2VsbCwgcHJpbUV2ZW50LmRldGFpbC5rZXlzKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbFNlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBIYW5kbGUgdGhpcyBldmVudCBkb3duIHRoZSBmZWF0dXJlIGNoYWluIG9mIHJlc3BvbnNpYmlsaXR5LlxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVLZXlEb3duOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICB2YXIgY29tbWFuZCA9ICdoYW5kbGUnICsgZXZlbnQuZGV0YWlsLmNoYXI7XG4gICAgICAgIGlmICh0aGlzW2NvbW1hbmRdKSB7XG4gICAgICAgICAgICB0aGlzW2NvbW1hbmRdLmNhbGwodGhpcywgZ3JpZCwgZXZlbnQuZGV0YWlsKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbFNlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBIYW5kbGUgYSBtb3VzZWRyYWcgc2VsZWN0aW9uLlxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG1vdXNlIC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBrZXlzIC0gYXJyYXkgb2YgdGhlIGtleXMgdGhhdCBhcmUgY3VycmVudGx5IHByZXNzZWQgZG93blxuICAgICAqL1xuICAgIGhhbmRsZU1vdXNlRHJhZ0NlbGxTZWxlY3Rpb246IGZ1bmN0aW9uKGdyaWQsIGdyaWRDZWxsLCBrZXlzKSB7XG5cbiAgICAgICAgdmFyIGJlaGF2aW9yID0gZ3JpZC5nZXRCZWhhdmlvcigpO1xuICAgICAgICB2YXIgaGVhZGVyUm93Q291bnQgPSBiZWhhdmlvci5nZXRIZWFkZXJSb3dDb3VudCgpO1xuICAgICAgICB2YXIgaGVhZGVyQ29sdW1uQ291bnQgPSBiZWhhdmlvci5nZXRIZWFkZXJDb2x1bW5Db3VudCgpO1xuICAgICAgICB2YXIgeCA9IGdyaWRDZWxsLng7XG4gICAgICAgIHZhciB5ID0gZ3JpZENlbGwueTtcbiAgICAgICAgeCA9IE1hdGgubWF4KGhlYWRlckNvbHVtbkNvdW50LCB4KTtcbiAgICAgICAgeSA9IE1hdGgubWF4KGhlYWRlclJvd0NvdW50LCB5KTtcblxuICAgICAgICB2YXIgcHJldmlvdXNEcmFnRXh0ZW50ID0gZ3JpZC5nZXREcmFnRXh0ZW50KCk7XG4gICAgICAgIHZhciBtb3VzZURvd24gPSBncmlkLmdldE1vdXNlRG93bigpO1xuXG4gICAgICAgIC8vdmFyIHNjcm9sbGluZ05vdyA9IGdyaWQuaXNTY3JvbGxpbmdOb3coKTtcblxuICAgICAgICB2YXIgbmV3WCA9IHggLSBtb3VzZURvd24ueDtcbiAgICAgICAgdmFyIG5ld1kgPSB5IC0gbW91c2VEb3duLnk7XG5cbiAgICAgICAgaWYgKHByZXZpb3VzRHJhZ0V4dGVudC54ID09PSBuZXdYICYmIHByZXZpb3VzRHJhZ0V4dGVudC55ID09PSBuZXdZKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBncmlkLmNsZWFyTW9zdFJlY2VudFNlbGVjdGlvbigpO1xuXG4gICAgICAgIGdyaWQuc2VsZWN0KG1vdXNlRG93bi54LCBtb3VzZURvd24ueSwgbmV3WCwgbmV3WSk7XG4gICAgICAgIGdyaWQuc2V0RHJhZ0V4dGVudChncmlkLm5ld1BvaW50KG5ld1gsIG5ld1kpKTtcblxuICAgICAgICBncmlkLnJlcGFpbnQoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENlbGxTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2MgdGhpcyBjaGVja3Mgd2hpbGUgd2VyZSBkcmFnZ2luZyBpZiB3ZSBnbyBvdXRzaWRlIHRoZSB2aXNpYmxlIGJvdW5kcywgaWYgc28sIGtpY2sgb2ZmIHRoZSBleHRlcm5hbCBhdXRvc2Nyb2xsIGNoZWNrIGZ1bmN0aW9uIChhYm92ZSlcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtb3VzZSAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgY2hlY2tEcmFnU2Nyb2xsOiBmdW5jdGlvbihncmlkLCBtb3VzZSkge1xuICAgICAgICBpZiAoIWdyaWQucmVzb2x2ZVByb3BlcnR5KCdzY3JvbGxpbmdFbmFibGVkJykpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYiA9IGdyaWQuZ2V0RGF0YUJvdW5kcygpO1xuICAgICAgICB2YXIgaW5zaWRlID0gYi5jb250YWlucyhtb3VzZSk7XG4gICAgICAgIGlmIChpbnNpZGUpIHtcbiAgICAgICAgICAgIGlmIChncmlkLmlzU2Nyb2xsaW5nTm93KCkpIHtcbiAgICAgICAgICAgICAgICBncmlkLnNldFNjcm9sbGluZ05vdyhmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoIWdyaWQuaXNTY3JvbGxpbmdOb3coKSkge1xuICAgICAgICAgICAgZ3JpZC5zZXRTY3JvbGxpbmdOb3codHJ1ZSk7XG4gICAgICAgICAgICB0aGlzLnNjcm9sbERyYWcoZ3JpZCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENlbGxTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2MgdGhpcyBmdW5jdGlvbiBtYWtlcyBzdXJlIHRoYXQgd2hpbGUgd2UgYXJlIGRyYWdnaW5nIG91dHNpZGUgb2YgdGhlIGdyaWQgdmlzaWJsZSBib3VuZHMsIHdlIHNyY3JvbGwgYWNjb3JkaW5nbHlcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqL1xuICAgIHNjcm9sbERyYWc6IGZ1bmN0aW9uKGdyaWQpIHtcblxuICAgICAgICBpZiAoIWdyaWQuaXNTY3JvbGxpbmdOb3coKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGRyYWdTdGFydGVkSW5IZWFkZXJBcmVhID0gZ3JpZC5pc01vdXNlRG93bkluSGVhZGVyQXJlYSgpO1xuICAgICAgICB2YXIgbGFzdERyYWdDZWxsID0gdGhpcy5sYXN0RHJhZ0NlbGw7XG4gICAgICAgIHZhciBiID0gZ3JpZC5nZXREYXRhQm91bmRzKCk7XG4gICAgICAgIHZhciB4T2Zmc2V0ID0gMDtcbiAgICAgICAgdmFyIHlPZmZzZXQgPSAwO1xuXG4gICAgICAgIHZhciBudW1GaXhlZENvbHVtbnMgPSBncmlkLmdldEZpeGVkQ29sdW1uQ291bnQoKTtcbiAgICAgICAgdmFyIG51bUZpeGVkUm93cyA9IGdyaWQuZ2V0Rml4ZWRSb3dDb3VudCgpO1xuXG4gICAgICAgIHZhciBkcmFnRW5kSW5GaXhlZEFyZWFYID0gbGFzdERyYWdDZWxsLnggPCBudW1GaXhlZENvbHVtbnM7XG4gICAgICAgIHZhciBkcmFnRW5kSW5GaXhlZEFyZWFZID0gbGFzdERyYWdDZWxsLnkgPCBudW1GaXhlZFJvd3M7XG5cbiAgICAgICAgaWYgKCFkcmFnU3RhcnRlZEluSGVhZGVyQXJlYSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudERyYWcueCA8IGIub3JpZ2luLngpIHtcbiAgICAgICAgICAgICAgICB4T2Zmc2V0ID0gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50RHJhZy55IDwgYi5vcmlnaW4ueSkge1xuICAgICAgICAgICAgICAgIHlPZmZzZXQgPSAtMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jdXJyZW50RHJhZy54ID4gYi5vcmlnaW4ueCArIGIuZXh0ZW50LngpIHtcbiAgICAgICAgICAgIHhPZmZzZXQgPSAxO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnREcmFnLnkgPiBiLm9yaWdpbi55ICsgYi5leHRlbnQueSkge1xuICAgICAgICAgICAgeU9mZnNldCA9IDE7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgZHJhZ0NlbGxPZmZzZXRYID0geE9mZnNldDtcbiAgICAgICAgdmFyIGRyYWdDZWxsT2Zmc2V0WSA9IHlPZmZzZXQ7XG5cbiAgICAgICAgaWYgKGRyYWdFbmRJbkZpeGVkQXJlYVgpIHtcbiAgICAgICAgICAgIGRyYWdDZWxsT2Zmc2V0WCA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZHJhZ0VuZEluRml4ZWRBcmVhWSkge1xuICAgICAgICAgICAgZHJhZ0NlbGxPZmZzZXRZID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMubGFzdERyYWdDZWxsID0gbGFzdERyYWdDZWxsLnBsdXNYWShkcmFnQ2VsbE9mZnNldFgsIGRyYWdDZWxsT2Zmc2V0WSk7XG4gICAgICAgIGdyaWQuc2Nyb2xsQnkoeE9mZnNldCwgeU9mZnNldCk7XG4gICAgICAgIHRoaXMuaGFuZGxlTW91c2VEcmFnQ2VsbFNlbGVjdGlvbihncmlkLCBsYXN0RHJhZ0NlbGwsIFtdKTsgLy8gdXBkYXRlIHRoZSBzZWxlY3Rpb25cbiAgICAgICAgZ3JpZC5yZXBhaW50KCk7XG4gICAgICAgIHNldFRpbWVvdXQodGhpcy5zY3JvbGxEcmFnLmJpbmQodGhpcywgZ3JpZCksIDI1KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENlbGxTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2MgZXh0ZW5kIGEgc2VsZWN0aW9uIG9yIGNyZWF0ZSBvbmUgaWYgdGhlcmUgaXNudCB5ZXRcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBncmlkQ2VsbCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICogQHBhcmFtIHtBcnJheX0ga2V5cyAtIGFycmF5IG9mIHRoZSBrZXlzIHRoYXQgYXJlIGN1cnJlbnRseSBwcmVzc2VkIGRvd25cbiAgICAgKi9cbiAgICBleHRlbmRTZWxlY3Rpb246IGZ1bmN0aW9uKGdyaWQsIGdyaWRDZWxsLCBrZXlzKSB7XG4gICAgICAgIHZhciBoYXNDVFJMID0ga2V5cy5pbmRleE9mKCdDVFJMJykgIT09IC0xO1xuICAgICAgICB2YXIgaGFzU0hJRlQgPSBrZXlzLmluZGV4T2YoJ1NISUZUJykgIT09IC0xO1xuICAgICAgICAvLyB2YXIgc2Nyb2xsVG9wID0gZ3JpZC5nZXRWU2Nyb2xsVmFsdWUoKTtcbiAgICAgICAgLy8gdmFyIHNjcm9sbExlZnQgPSBncmlkLmdldEhTY3JvbGxWYWx1ZSgpO1xuXG4gICAgICAgIC8vIHZhciBudW1GaXhlZENvbHVtbnMgPSAwOy8vZ3JpZC5nZXRGaXhlZENvbHVtbkNvdW50KCk7XG4gICAgICAgIC8vIHZhciBudW1GaXhlZFJvd3MgPSAwOy8vZ3JpZC5nZXRGaXhlZFJvd0NvdW50KCk7XG5cbiAgICAgICAgdmFyIG1vdXNlUG9pbnQgPSBncmlkLmdldE1vdXNlRG93bigpO1xuICAgICAgICB2YXIgeCA9IGdyaWRDZWxsLng7IC8vIC0gbnVtRml4ZWRDb2x1bW5zICsgc2Nyb2xsTGVmdDtcbiAgICAgICAgdmFyIHkgPSBncmlkQ2VsbC55OyAvLyAtIG51bUZpeGVkUm93cyArIHNjcm9sbFRvcDtcblxuICAgICAgICAvL3dlcmUgb3V0c2lkZSBvZiB0aGUgZ3JpZCBkbyBub3RoaW5nXG4gICAgICAgIGlmICh4IDwgMCB8fCB5IDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy93ZSBoYXZlIHJlcGVhdGVkIGEgY2xpY2sgaW4gdGhlIHNhbWUgc3BvdCBkZXNsZWN0IHRoZSB2YWx1ZSBmcm9tIGxhc3QgdGltZVxuICAgICAgICBpZiAoeCA9PT0gbW91c2VQb2ludC54ICYmIHkgPT09IG1vdXNlUG9pbnQueSkge1xuICAgICAgICAgICAgZ3JpZC5jbGVhck1vc3RSZWNlbnRTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgIGdyaWQucG9wTW91c2VEb3duKCk7XG4gICAgICAgICAgICBncmlkLnJlcGFpbnQoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaGFzQ1RSTCAmJiAhaGFzU0hJRlQpIHtcbiAgICAgICAgICAgIGdyaWQuY2xlYXJTZWxlY3Rpb25zKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaGFzU0hJRlQpIHtcbiAgICAgICAgICAgIGdyaWQuY2xlYXJNb3N0UmVjZW50U2VsZWN0aW9uKCk7XG4gICAgICAgICAgICBncmlkLnNlbGVjdChtb3VzZVBvaW50LngsIG1vdXNlUG9pbnQueSwgeCAtIG1vdXNlUG9pbnQueCArIDEsIHkgLSBtb3VzZVBvaW50LnkgKyAxKTtcbiAgICAgICAgICAgIGdyaWQuc2V0RHJhZ0V4dGVudChncmlkLm5ld1BvaW50KHggLSBtb3VzZVBvaW50LnggKyAxLCB5IC0gbW91c2VQb2ludC55KSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBncmlkLnNlbGVjdCh4LCB5LCAwLCAwKTtcbiAgICAgICAgICAgIGdyaWQuc2V0TW91c2VEb3duKGdyaWQubmV3UG9pbnQoeCwgeSkpO1xuICAgICAgICAgICAgZ3JpZC5zZXREcmFnRXh0ZW50KGdyaWQubmV3UG9pbnQoMCwgMCkpO1xuICAgICAgICB9XG4gICAgICAgIGdyaWQucmVwYWludCgpO1xuICAgIH0sXG5cblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsU2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGhhbmRsZSB0aGlzIGV2ZW50XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKi9cbiAgICBoYW5kbGVET1dOU0hJRlQ6IGZ1bmN0aW9uKGdyaWQpIHtcbiAgICAgICAgdGhpcy5tb3ZlU2hpZnRTZWxlY3QoZ3JpZCwgMCwgMSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsU2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGhhbmRsZSB0aGlzIGV2ZW50XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZVVQU0hJRlQ6IGZ1bmN0aW9uKGdyaWQpIHtcbiAgICAgICAgdGhpcy5tb3ZlU2hpZnRTZWxlY3QoZ3JpZCwgMCwgLTEpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbFNlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBoYW5kbGUgdGhpcyBldmVudFxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVMRUZUU0hJRlQ6IGZ1bmN0aW9uKGdyaWQpIHtcbiAgICAgICAgdGhpcy5tb3ZlU2hpZnRTZWxlY3QoZ3JpZCwgLTEsIDApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbFNlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBoYW5kbGUgdGhpcyBldmVudFxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVSSUdIVFNISUZUOiBmdW5jdGlvbihncmlkKSB7XG4gICAgICAgIHRoaXMubW92ZVNoaWZ0U2VsZWN0KGdyaWQsIDEsIDApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbFNlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBoYW5kbGUgdGhpcyBldmVudFxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVET1dOOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICAvL2tlZXAgdGhlIGJyb3dzZXIgdmlld3BvcnQgZnJvbSBhdXRvIHNjcm9sbGluZyBvbiBrZXkgZXZlbnRcbiAgICAgICAgZXZlbnQucHJpbWl0aXZlRXZlbnQucHJldmVudERlZmF1bHQoKTtcblxuICAgICAgICB2YXIgY291bnQgPSB0aGlzLmdldEF1dG9TY3JvbGxBY2NlbGVyYXRpb24oKTtcbiAgICAgICAgdGhpcy5tb3ZlU2luZ2xlU2VsZWN0KGdyaWQsIDAsIGNvdW50KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENlbGxTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2MgaGFuZGxlIHRoaXMgZXZlbnRcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlVVA6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIC8va2VlcCB0aGUgYnJvd3NlciB2aWV3cG9ydCBmcm9tIGF1dG8gc2Nyb2xsaW5nIG9uIGtleSBldmVudFxuICAgICAgICBldmVudC5wcmltaXRpdmVFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAgIHZhciBjb3VudCA9IHRoaXMuZ2V0QXV0b1Njcm9sbEFjY2VsZXJhdGlvbigpO1xuICAgICAgICB0aGlzLm1vdmVTaW5nbGVTZWxlY3QoZ3JpZCwgMCwgLWNvdW50KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENlbGxTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2MgaGFuZGxlIHRoaXMgZXZlbnRcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlTEVGVDogZnVuY3Rpb24oZ3JpZCkge1xuICAgICAgICB0aGlzLm1vdmVTaW5nbGVTZWxlY3QoZ3JpZCwgLTEsIDApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbFNlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBoYW5kbGUgdGhpcyBldmVudFxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVSSUdIVDogZnVuY3Rpb24oZ3JpZCkge1xuICAgICAgICB0aGlzLm1vdmVTaW5nbGVTZWxlY3QoZ3JpZCwgMSwgMCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsU2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIElmIHdlIGFyZSBob2xkaW5nIGRvd24gdGhlIHNhbWUgbmF2aWdhdGlvbiBrZXksIGFjY2VsZXJhdGUgdGhlIGluY3JlbWVudCB3ZSBzY3JvbGxcbiAgICAgKiAjIyMjIHJldHVybnM6IGludGVnZXJcbiAgICAgKi9cbiAgICBnZXRBdXRvU2Nyb2xsQWNjZWxlcmF0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGNvdW50ID0gMTtcbiAgICAgICAgdmFyIGVsYXBzZWQgPSB0aGlzLmdldEF1dG9TY3JvbGxEdXJhdGlvbigpIC8gMjAwMDtcbiAgICAgICAgY291bnQgPSBNYXRoLm1heCgxLCBNYXRoLmZsb29yKGVsYXBzZWQgKiBlbGFwc2VkICogZWxhcHNlZCAqIGVsYXBzZWQpKTtcbiAgICAgICAgcmV0dXJuIGNvdW50O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbFNlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBzZXQgdGhlIHN0YXJ0IHRpbWUgdG8gcmlnaHQgbm93IHdoZW4gd2UgaW5pdGlhdGUgYW4gYXV0byBzY3JvbGxcbiAgICAgKi9cbiAgICBzZXRBdXRvU2Nyb2xsU3RhcnRUaW1lOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5zYkF1dG9TdGFydCA9IERhdGUubm93KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsU2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIHVwZGF0ZSB0aGUgYXV0b3Njcm9sbCBzdGFydCB0aW1lIGlmIHdlIGhhdmVuJ3QgYXV0b3Njcm9sbGVkIHdpdGhpbiB0aGUgbGFzdCA1MDBtcyBvdGhlcndpc2UgdXBkYXRlIHRoZSBjdXJyZW50IGF1dG9zY3JvbGwgdGltZVxuICAgICAqL1xuICAgIHBpbmdBdXRvU2Nyb2xsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG5vdyA9IERhdGUubm93KCk7XG4gICAgICAgIGlmIChub3cgLSB0aGlzLnNiTGFzdEF1dG8gPiA1MDApIHtcbiAgICAgICAgICAgIHRoaXMuc2V0QXV0b1Njcm9sbFN0YXJ0VGltZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2JMYXN0QXV0byA9IERhdGUubm93KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsU2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGFuc3dlciBob3cgbG9uZyB3ZSBoYXZlIGJlZW4gYXV0byBzY3JvbGxpbmdcbiAgICAgKiAjIyMjIHJldHVybnM6IGludGVnZXJcbiAgICAgKi9cbiAgICBnZXRBdXRvU2Nyb2xsRHVyYXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoRGF0ZS5ub3coKSAtIHRoaXMuc2JMYXN0QXV0byA+IDUwMCkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIERhdGUubm93KCkgLSB0aGlzLnNiQXV0b1N0YXJ0O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbFNlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBBdWdtZW50IHRoZSBtb3N0IHJlY2VudCBzZWxlY3Rpb24gZXh0ZW50IGJ5IChvZmZzZXRYLG9mZnNldFkpIGFuZCBzY3JvbGwgaWYgbmVjZXNzYXJ5LlxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFggLSB4IGNvb3JkaW5hdGUgdG8gc3RhcnQgYXRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0WSAtIHkgY29vcmRpbmF0ZSB0byBzdGFydCBhdFxuICAgICAqL1xuICAgIG1vdmVTaGlmdFNlbGVjdDogZnVuY3Rpb24oZ3JpZCwgb2Zmc2V0WCwgb2Zmc2V0WSkge1xuXG4gICAgICAgIHZhciBtYXhDb2x1bW5zID0gZ3JpZC5nZXRDb2x1bW5Db3VudCgpIC0gMTtcbiAgICAgICAgdmFyIG1heFJvd3MgPSBncmlkLmdldFJvd0NvdW50KCkgLSAxO1xuXG4gICAgICAgIHZhciBtYXhWaWV3YWJsZUNvbHVtbnMgPSBncmlkLmdldFZpc2libGVDb2x1bW5zKCkgLSAxO1xuICAgICAgICB2YXIgbWF4Vmlld2FibGVSb3dzID0gZ3JpZC5nZXRWaXNpYmxlUm93cygpIC0gMTtcblxuICAgICAgICBpZiAoIWdyaWQucmVzb2x2ZVByb3BlcnR5KCdzY3JvbGxpbmdFbmFibGVkJykpIHtcbiAgICAgICAgICAgIG1heENvbHVtbnMgPSBNYXRoLm1pbihtYXhDb2x1bW5zLCBtYXhWaWV3YWJsZUNvbHVtbnMpO1xuICAgICAgICAgICAgbWF4Um93cyA9IE1hdGgubWluKG1heFJvd3MsIG1heFZpZXdhYmxlUm93cyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgb3JpZ2luID0gZ3JpZC5nZXRNb3VzZURvd24oKTtcbiAgICAgICAgdmFyIGV4dGVudCA9IGdyaWQuZ2V0RHJhZ0V4dGVudCgpO1xuXG4gICAgICAgIHZhciBuZXdYID0gZXh0ZW50LnggKyBvZmZzZXRYO1xuICAgICAgICB2YXIgbmV3WSA9IGV4dGVudC55ICsgb2Zmc2V0WTtcblxuICAgICAgICBuZXdYID0gTWF0aC5taW4obWF4Q29sdW1ucyAtIG9yaWdpbi54LCBNYXRoLm1heCgtb3JpZ2luLngsIG5ld1gpKTtcbiAgICAgICAgbmV3WSA9IE1hdGgubWluKG1heFJvd3MgLSBvcmlnaW4ueSwgTWF0aC5tYXgoLW9yaWdpbi55LCBuZXdZKSk7XG5cbiAgICAgICAgZ3JpZC5jbGVhck1vc3RSZWNlbnRTZWxlY3Rpb24oKTtcbiAgICAgICAgZ3JpZC5zZWxlY3Qob3JpZ2luLngsIG9yaWdpbi55LCBuZXdYLCBuZXdZKTtcblxuICAgICAgICBncmlkLnNldERyYWdFeHRlbnQoZ3JpZC5uZXdQb2ludChuZXdYLCBuZXdZKSk7XG5cbiAgICAgICAgaWYgKGdyaWQuaW5zdXJlTW9kZWxDb2xJc1Zpc2libGUobmV3WCArIG9yaWdpbi54LCBvZmZzZXRYKSkge1xuICAgICAgICAgICAgdGhpcy5waW5nQXV0b1Njcm9sbCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChncmlkLmluc3VyZU1vZGVsUm93SXNWaXNpYmxlKG5ld1kgKyBvcmlnaW4ueSwgb2Zmc2V0WSkpIHtcbiAgICAgICAgICAgIHRoaXMucGluZ0F1dG9TY3JvbGwoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGdyaWQucmVwYWludCgpO1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsU2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIFJlcGxhY2UgdGhlIG1vc3QgcmVjZW50IHNlbGVjdGlvbiB3aXRoIGEgc2luZ2xlIGNlbGwgc2VsZWN0aW9uIHRoYXQgaXMgbW92ZWQgKG9mZnNldFgsb2Zmc2V0WSkgZnJvbSB0aGUgcHJldmlvdXMgc2VsZWN0aW9uIGV4dGVudC5cbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRYIC0geCBjb29yZGluYXRlIHRvIHN0YXJ0IGF0XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFkgLSB5IGNvb3JkaW5hdGUgdG8gc3RhcnQgYXRcbiAgICAgKi9cbiAgICBtb3ZlU2luZ2xlU2VsZWN0OiBmdW5jdGlvbihncmlkLCBvZmZzZXRYLCBvZmZzZXRZKSB7XG5cbiAgICAgICAgdmFyIG1heENvbHVtbnMgPSBncmlkLmdldENvbHVtbkNvdW50KCkgLSAxO1xuICAgICAgICB2YXIgbWF4Um93cyA9IGdyaWQuZ2V0Um93Q291bnQoKSAtIDE7XG5cbiAgICAgICAgdmFyIG1heFZpZXdhYmxlQ29sdW1ucyA9IGdyaWQuZ2V0VmlzaWJsZUNvbHVtbnNDb3VudCgpIC0gMTtcbiAgICAgICAgdmFyIG1heFZpZXdhYmxlUm93cyA9IGdyaWQuZ2V0VmlzaWJsZVJvd3NDb3VudCgpIC0gMTtcblxuICAgICAgICB2YXIgbWluUm93cyA9IGdyaWQuZ2V0SGVhZGVyUm93Q291bnQoKTtcbiAgICAgICAgdmFyIG1pbkNvbHMgPSBncmlkLmdldEhlYWRlckNvbHVtbkNvdW50KCk7XG5cbiAgICAgICAgaWYgKCFncmlkLnJlc29sdmVQcm9wZXJ0eSgnc2Nyb2xsaW5nRW5hYmxlZCcpKSB7XG4gICAgICAgICAgICBtYXhDb2x1bW5zID0gTWF0aC5taW4obWF4Q29sdW1ucywgbWF4Vmlld2FibGVDb2x1bW5zKTtcbiAgICAgICAgICAgIG1heFJvd3MgPSBNYXRoLm1pbihtYXhSb3dzLCBtYXhWaWV3YWJsZVJvd3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG1vdXNlQ29ybmVyID0gZ3JpZC5nZXRNb3VzZURvd24oKS5wbHVzKGdyaWQuZ2V0RHJhZ0V4dGVudCgpKTtcblxuICAgICAgICB2YXIgbmV3WCA9IG1vdXNlQ29ybmVyLnggKyBvZmZzZXRYO1xuICAgICAgICB2YXIgbmV3WSA9IG1vdXNlQ29ybmVyLnkgKyBvZmZzZXRZO1xuXG4gICAgICAgIG5ld1ggPSBNYXRoLm1pbihtYXhDb2x1bW5zLCBNYXRoLm1heChtaW5Db2xzLCBuZXdYKSk7XG4gICAgICAgIG5ld1kgPSBNYXRoLm1pbihtYXhSb3dzLCBNYXRoLm1heChtaW5Sb3dzLCBuZXdZKSk7XG5cbiAgICAgICAgZ3JpZC5jbGVhclNlbGVjdGlvbnMoKTtcbiAgICAgICAgZ3JpZC5zZWxlY3QobmV3WCwgbmV3WSwgMCwgMCk7XG4gICAgICAgIGdyaWQuc2V0TW91c2VEb3duKGdyaWQubmV3UG9pbnQobmV3WCwgbmV3WSkpO1xuICAgICAgICBncmlkLnNldERyYWdFeHRlbnQoZ3JpZC5uZXdQb2ludCgwLCAwKSk7XG5cbiAgICAgICAgaWYgKGdyaWQuaW5zdXJlTW9kZWxDb2xJc1Zpc2libGUobmV3WCwgb2Zmc2V0WCkpIHtcbiAgICAgICAgICAgIHRoaXMucGluZ0F1dG9TY3JvbGwoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZ3JpZC5pbnN1cmVNb2RlbFJvd0lzVmlzaWJsZShuZXdZLCBvZmZzZXRZKSkge1xuICAgICAgICAgICAgdGhpcy5waW5nQXV0b1Njcm9sbCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgZ3JpZC5yZXBhaW50KCk7XG5cbiAgICB9XG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENlbGxTZWxlY3Rpb247XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBGZWF0dXJlID0gcmVxdWlyZSgnLi9GZWF0dXJlLmpzJyk7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBDb2x1bW5BdXRvc2l6aW5nID0gRmVhdHVyZS5leHRlbmQoJ0NvbHVtbkF1dG9zaXppbmcnLCB7XG5cbiAgICBhbGlhczogJ0NvbHVtbkF1dG9zaXppbmcnLFxuXG4gICAgLyoqXG4gICAgICogQGRlc2MgaGFuZGxlIHRoaXMgZXZlbnQgZG93biB0aGUgZmVhdHVyZSBjaGFpbiBvZiByZXNwb25zaWJpbGl0eVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uQXV0b3NpemluZy5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBoYW5kbGVEb3VibGVDbGljazogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgdmFyIGhlYWRlclJvd0NvdW50ID0gZ3JpZC5nZXRIZWFkZXJSb3dDb3VudCgpO1xuICAgICAgICAvL3ZhciBoZWFkZXJDb2xDb3VudCA9IGdyaWQuZ2V0SGVhZGVyQ29sdW1uQ291bnQoKTtcbiAgICAgICAgdmFyIGdyaWRDZWxsID0gZXZlbnQuZ3JpZENlbGw7XG4gICAgICAgIGlmIChncmlkQ2VsbC55IDw9IGhlYWRlclJvd0NvdW50KSB7XG4gICAgICAgICAgICBncmlkLmF1dG9zaXplQ29sdW1uKGdyaWRDZWxsLngpO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMubmV4dCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0LmhhbmRsZURvdWJsZUNsaWNrKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH1cblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gQ29sdW1uQXV0b3NpemluZztcbiIsIi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuLyogZ2xvYmFsIHJlcXVlc3RBbmltYXRpb25GcmFtZSAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8vIFRoaXMgZmVhdHVyZSBpcyByZXNwb25zaWJsZSBmb3IgY29sdW1uIGRyYWcgYW5kIGRyb3AgcmVvcmRlcmluZy5cbi8vIFRoaXMgb2JqZWN0IGlzIGEgbWVzcyBhbmQgZGVzcGVyYXRlbHkgbmVlZHMgYSBjb21wbGV0ZSByZXdyaXRlLi4uLi5cblxudmFyIEZlYXR1cmUgPSByZXF1aXJlKCcuL0ZlYXR1cmUuanMnKTtcblxudmFyIGNvbHVtbkFuaW1hdGlvblRpbWUgPSAxNTA7XG52YXIgZHJhZ2dlcjtcbnZhciBkcmFnZ2VyQ1RYO1xudmFyIGZsb2F0Q29sdW1uO1xudmFyIGZsb2F0Q29sdW1uQ1RYO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG52YXIgQ29sdW1uTW92aW5nID0gRmVhdHVyZS5leHRlbmQoJ0NvbHVtbk1vdmluZycsIHtcblxuICAgIGFsaWFzOiAnQ29sdW1uTW92aW5nJyxcblxuICAgIC8qKlxuICAgICAqIHF1ZXVlIHVwIHRoZSBhbmltYXRpb25zIHRoYXQgbmVlZCB0byBwbGF5IHNvIHRoZXkgYXJlIGRvbmUgc3luY2hyb25vdXNseVxuICAgICAqIEB0eXBlIHtBcnJheX1cbiAgICAgKiBAbWVtYmVyT2YgQ2VsbE1vdmluZy5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBmbG9hdGVyQW5pbWF0aW9uUXVldWU6IFtdLFxuXG4gICAgLyoqXG4gICAgICogYW0gSSBjdXJyZW50bHkgYXV0byBzY3JvbGxpbmcgcmlnaHRcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAbWVtYmVyT2YgQ2VsbE1vdmluZy5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBjb2x1bW5EcmFnQXV0b1Njcm9sbGluZ1JpZ2h0OiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIGFtIEkgY3VycmVudGx5IGF1dG8gc2Nyb2xsaW5nIGxlZnRcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAbWVtYmVyT2YgQ2VsbE1vdmluZy5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBjb2x1bW5EcmFnQXV0b1Njcm9sbGluZ0xlZnQ6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogaXMgdGhlIGRyYWcgbWVjaGFuaXNtIGN1cnJlbnRseSBlbmFibGVkIChcImFybWVkXCIpXG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQG1lbWJlck9mIENlbGxNb3ZpbmcucHJvdG90eXBlXG4gICAgICovXG4gICAgZHJhZ0FybWVkOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIGFtIEkgZHJhZ2dpbmcgcmlnaHQgbm93XG4gICAgICogQHR5cGUge2Jvb2xlYW59XG4gICAgICogQG1lbWJlck9mIENlbGxNb3ZpbmcucHJvdG90eXBlXG4gICAgICovXG4gICAgZHJhZ2dpbmc6IGZhbHNlLFxuXG4gICAgLyoqXG4gICAgICogdGhlIGNvbHVtbiBpbmRleCBvZiB0aGUgY3VycmVudGx5IGRyYWdnZWQgY29sdW1uXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAbWVtYmVyT2YgQ2VsbE1vdmluZy5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBkcmFnQ29sOiAtMSxcblxuICAgIC8qKlxuICAgICAqIGFuIG9mZnNldCB0byBwb3NpdGlvbiB0aGUgZHJhZ2dlZCBpdGVtIGZyb20gdGhlIGN1cnNvclxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQG1lbWJlck9mIENlbGxNb3ZpbmcucHJvdG90eXBlXG4gICAgICovXG4gICAgZHJhZ09mZnNldDogMCxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsTW92aW5nLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGdpdmUgbWUgYW4gb3Bwb3J0dW5pdHkgdG8gaW5pdGlhbGl6ZSBzdHVmZiBvbiB0aGUgZ3JpZFxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICovXG4gICAgaW5pdGlhbGl6ZU9uOiBmdW5jdGlvbihncmlkKSB7XG4gICAgICAgIHRoaXMuaXNGbG9hdGluZ05vdyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmluaXRpYWxpemVBbmltYXRpb25TdXBwb3J0KGdyaWQpO1xuICAgICAgICBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQuaW5pdGlhbGl6ZU9uKGdyaWQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsTW92aW5nLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGluaXRpYWxpemUgYW5pbWF0aW9uIHN1cHBvcnQgb24gdGhlIGdyaWRcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqL1xuICAgIGluaXRpYWxpemVBbmltYXRpb25TdXBwb3J0OiBmdW5jdGlvbihncmlkKSB7XG4gICAgICAgIGlmICghZHJhZ2dlcikge1xuICAgICAgICAgICAgZHJhZ2dlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuICAgICAgICAgICAgZHJhZ2dlci5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgJzBweCcpO1xuICAgICAgICAgICAgZHJhZ2dlci5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsICcwcHgnKTtcblxuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChkcmFnZ2VyKTtcbiAgICAgICAgICAgIGRyYWdnZXJDVFggPSBkcmFnZ2VyLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFmbG9hdENvbHVtbikge1xuICAgICAgICAgICAgZmxvYXRDb2x1bW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgICAgIGZsb2F0Q29sdW1uLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCAnMHB4Jyk7XG4gICAgICAgICAgICBmbG9hdENvbHVtbi5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsICcwcHgnKTtcblxuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChmbG9hdENvbHVtbik7XG4gICAgICAgICAgICBmbG9hdENvbHVtbkNUWCA9IGZsb2F0Q29sdW1uLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIH1cblxuICAgIH0sXG5cbiAgICBnZXRDYW5EcmFnQ3Vyc29yTmFtZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAnLXdlYmtpdC1ncmFiJztcbiAgICB9LFxuXG4gICAgZ2V0RHJhZ2dpbmdDdXJzb3JOYW1lOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICctd2Via2l0LWdyYWJiaW5nJztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENlbGxNb3ZpbmcucHJvdG90eXBlXG4gICAgICogQGRlc2MgaGFuZGxlIHRoaXMgZXZlbnRcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlTW91c2VEcmFnOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuXG4gICAgICAgIHZhciBncmlkQ2VsbCA9IGV2ZW50LmdyaWRDZWxsO1xuICAgICAgICB2YXIgeDtcbiAgICAgICAgLy92YXIgeTtcblxuICAgICAgICB2YXIgZGlzdGFuY2UgPSBNYXRoLmFicyhldmVudC5wcmltaXRpdmVFdmVudC5kZXRhaWwuZHJhZ3N0YXJ0LnggLSBldmVudC5wcmltaXRpdmVFdmVudC5kZXRhaWwubW91c2UueCk7XG5cbiAgICAgICAgaWYgKGRpc3RhbmNlIDwgMTApIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5leHQuaGFuZGxlTW91c2VEcmFnKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmlzSGVhZGVyUm93KGdyaWQsIGV2ZW50KSAmJiB0aGlzLmRyYWdBcm1lZCAmJiAhdGhpcy5kcmFnZ2luZykge1xuICAgICAgICAgICAgdGhpcy5kcmFnZ2luZyA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmRyYWdDb2wgPSBncmlkQ2VsbC54O1xuICAgICAgICAgICAgdGhpcy5kcmFnT2Zmc2V0ID0gZXZlbnQubW91c2VQb2ludC54O1xuICAgICAgICAgICAgdGhpcy5kZXRhY2hDaGFpbigpO1xuICAgICAgICAgICAgeCA9IGV2ZW50LnByaW1pdGl2ZUV2ZW50LmRldGFpbC5tb3VzZS54IC0gdGhpcy5kcmFnT2Zmc2V0O1xuICAgICAgICAgICAgLy95ID0gZXZlbnQucHJpbWl0aXZlRXZlbnQuZGV0YWlsLm1vdXNlLnk7XG4gICAgICAgICAgICB0aGlzLmNyZWF0ZURyYWdDb2x1bW4oZ3JpZCwgeCwgdGhpcy5kcmFnQ29sKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dC5oYW5kbGVNb3VzZURyYWcoZ3JpZCwgZXZlbnQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuZHJhZ2dpbmcpIHtcbiAgICAgICAgICAgIHggPSBldmVudC5wcmltaXRpdmVFdmVudC5kZXRhaWwubW91c2UueCAtIHRoaXMuZHJhZ09mZnNldDtcbiAgICAgICAgICAgIC8veSA9IGV2ZW50LnByaW1pdGl2ZUV2ZW50LmRldGFpbC5tb3VzZS55O1xuICAgICAgICAgICAgdGhpcy5kcmFnQ29sdW1uKGdyaWQsIHgpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsTW92aW5nLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGhhbmRsZSB0aGlzIGV2ZW50XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZU1vdXNlRG93bjogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgaWYgKGdyaWQuZ2V0QmVoYXZpb3IoKS5pc0NvbHVtblJlb3JkZXJhYmxlKCkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzSGVhZGVyUm93KGdyaWQsIGV2ZW50KSAmJiBldmVudC5ncmlkQ2VsbC54ICE9PSAtMSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZHJhZ0FybWVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnNvciA9IHRoaXMuZ2V0RHJhZ2dpbmdDdXJzb3JOYW1lKCk7XG4gICAgICAgICAgICAgICAgZ3JpZC5jbGVhclNlbGVjdGlvbnMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQuaGFuZGxlTW91c2VEb3duKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbE1vdmluZy5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBoYW5kbGUgdGhpcyBldmVudFxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVNb3VzZVVwOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICAvL3ZhciBjb2wgPSBldmVudC5ncmlkQ2VsbC54O1xuICAgICAgICBpZiAodGhpcy5kcmFnZ2luZykge1xuICAgICAgICAgICAgdGhpcy5jdXJzb3IgPSBudWxsO1xuICAgICAgICAgICAgLy9kZWxheSBoZXJlIHRvIGdpdmUgb3RoZXIgZXZlbnRzIGEgY2hhbmNlIHRvIGJlIGRyb3BwZWRcbiAgICAgICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgICAgIHRoaXMuZW5kRHJhZ0NvbHVtbihncmlkKTtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5hdHRhY2hDaGFpbigpO1xuICAgICAgICAgICAgfSwgMjAwKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRyYWdDb2wgPSAtMTtcbiAgICAgICAgdGhpcy5kcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRyYWdBcm1lZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmN1cnNvciA9IG51bGw7XG4gICAgICAgIGdyaWQucmVwYWludCgpO1xuXG4gICAgICAgIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dC5oYW5kbGVNb3VzZVVwKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsTW92aW5nLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGhhbmRsZSB0aGlzIGV2ZW50XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZU1vdXNlTW92ZTogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcblxuICAgICAgICBpZiAoIXRoaXMuZHJhZ2dpbmcgJiYgZXZlbnQubW91c2VQb2ludC55IDwgNSAmJiBldmVudC52aWV3UG9pbnQueSA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5jdXJzb3IgPSB0aGlzLmdldENhbkRyYWdDdXJzb3JOYW1lKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmN1cnNvciA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQuaGFuZGxlTW91c2VNb3ZlKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLmlzSGVhZGVyUm93KGdyaWQsIGV2ZW50KSAmJiB0aGlzLmRyYWdnaW5nKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnNvciA9IHRoaXMuZ2V0RHJhZ2dpbmdDdXJzb3JOYW1lKCk7IC8vbW92ZSc7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENlbGxNb3ZpbmcucHJvdG90eXBlXG4gICAgICogQGRlc2MgdGhpcyBpcyB0aGUgbWFpbiBldmVudCBoYW5kbGVyIHRoYXQgbWFuYWdlcyB0aGUgZHJhZ2dpbmcgb2YgdGhlIGNvbHVtblxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtib29sZWFufSBkcmFnZ2VkVG9UaGVSaWdodCAtIGFyZSB3ZSBtb3ZpbmcgdG8gdGhlIHJpZ2h0XG4gICAgICovXG4gICAgZmxvYXRDb2x1bW5UbzogZnVuY3Rpb24oZ3JpZCwgZHJhZ2dlZFRvVGhlUmlnaHQpIHtcbiAgICAgICAgdGhpcy5mbG9hdGluZ05vdyA9IHRydWU7XG5cbiAgICAgICAgdmFyIHJlbmRlcmVyID0gZ3JpZC5nZXRSZW5kZXJlcigpO1xuICAgICAgICB2YXIgY29sRWRnZXMgPSByZW5kZXJlci5nZXRDb2x1bW5FZGdlcygpO1xuICAgICAgICAvL3ZhciBiZWhhdmlvciA9IGdyaWQuZ2V0QmVoYXZpb3IoKTtcbiAgICAgICAgdmFyIHNjcm9sbExlZnQgPSBncmlkLmdldEhTY3JvbGxWYWx1ZSgpO1xuICAgICAgICB2YXIgZmxvYXRlckluZGV4ID0gZ3JpZC5yZW5kZXJPdmVycmlkZXNDYWNoZS5mbG9hdGVyLmNvbHVtbkluZGV4O1xuICAgICAgICB2YXIgZHJhZ2dlckluZGV4ID0gZ3JpZC5yZW5kZXJPdmVycmlkZXNDYWNoZS5kcmFnZ2VyLmNvbHVtbkluZGV4O1xuICAgICAgICB2YXIgaGRwaXJhdGlvID0gZ3JpZC5yZW5kZXJPdmVycmlkZXNDYWNoZS5kcmFnZ2VyLmhkcGlyYXRpbztcblxuICAgICAgICB2YXIgZHJhZ2dlclN0YXJ0WDtcbiAgICAgICAgdmFyIGZsb2F0ZXJTdGFydFg7XG4gICAgICAgIHZhciBmaXhlZENvbHVtbkNvdW50ID0gZ3JpZC5nZXRGaXhlZENvbHVtbkNvdW50KCk7XG4gICAgICAgIHZhciBkcmFnZ2VyV2lkdGggPSBncmlkLmdldENvbHVtbldpZHRoKGRyYWdnZXJJbmRleCk7XG4gICAgICAgIHZhciBmbG9hdGVyV2lkdGggPSBncmlkLmdldENvbHVtbldpZHRoKGZsb2F0ZXJJbmRleCk7XG5cbiAgICAgICAgdmFyIG1heCA9IGdyaWQuZ2V0VmlzaWJsZUNvbHVtbnNDb3VudCgpO1xuXG4gICAgICAgIHZhciBkb2Zmc2V0ID0gMDtcbiAgICAgICAgdmFyIGZvZmZzZXQgPSAwO1xuXG4gICAgICAgIGlmIChkcmFnZ2VySW5kZXggPj0gZml4ZWRDb2x1bW5Db3VudCkge1xuICAgICAgICAgICAgZG9mZnNldCA9IHNjcm9sbExlZnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZsb2F0ZXJJbmRleCA+PSBmaXhlZENvbHVtbkNvdW50KSB7XG4gICAgICAgICAgICBmb2Zmc2V0ID0gc2Nyb2xsTGVmdDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkcmFnZ2VkVG9UaGVSaWdodCkge1xuICAgICAgICAgICAgZHJhZ2dlclN0YXJ0WCA9IGNvbEVkZ2VzW01hdGgubWluKG1heCwgZHJhZ2dlckluZGV4IC0gZG9mZnNldCldO1xuICAgICAgICAgICAgZmxvYXRlclN0YXJ0WCA9IGNvbEVkZ2VzW01hdGgubWluKG1heCwgZmxvYXRlckluZGV4IC0gZm9mZnNldCldO1xuXG4gICAgICAgICAgICBncmlkLnJlbmRlck92ZXJyaWRlc0NhY2hlLmRyYWdnZXIuc3RhcnRYID0gKGRyYWdnZXJTdGFydFggKyBmbG9hdGVyV2lkdGgpICogaGRwaXJhdGlvO1xuICAgICAgICAgICAgZ3JpZC5yZW5kZXJPdmVycmlkZXNDYWNoZS5mbG9hdGVyLnN0YXJ0WCA9IGRyYWdnZXJTdGFydFggKiBoZHBpcmF0aW87XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZsb2F0ZXJTdGFydFggPSBjb2xFZGdlc1tNYXRoLm1pbihtYXgsIGZsb2F0ZXJJbmRleCAtIGZvZmZzZXQpXTtcbiAgICAgICAgICAgIGRyYWdnZXJTdGFydFggPSBmbG9hdGVyU3RhcnRYICsgZHJhZ2dlcldpZHRoO1xuXG4gICAgICAgICAgICBncmlkLnJlbmRlck92ZXJyaWRlc0NhY2hlLmRyYWdnZXIuc3RhcnRYID0gZmxvYXRlclN0YXJ0WCAqIGhkcGlyYXRpbztcbiAgICAgICAgICAgIGdyaWQucmVuZGVyT3ZlcnJpZGVzQ2FjaGUuZmxvYXRlci5zdGFydFggPSBkcmFnZ2VyU3RhcnRYICogaGRwaXJhdGlvO1xuICAgICAgICB9XG4gICAgICAgIGdyaWQuc3dhcENvbHVtbnMoZHJhZ2dlckluZGV4LCBmbG9hdGVySW5kZXgpO1xuICAgICAgICBncmlkLnJlbmRlck92ZXJyaWRlc0NhY2hlLmRyYWdnZXIuY29sdW1uSW5kZXggPSBmbG9hdGVySW5kZXg7XG4gICAgICAgIGdyaWQucmVuZGVyT3ZlcnJpZGVzQ2FjaGUuZmxvYXRlci5jb2x1bW5JbmRleCA9IGRyYWdnZXJJbmRleDtcblxuXG4gICAgICAgIHRoaXMuZmxvYXRlckFuaW1hdGlvblF1ZXVlLnVuc2hpZnQodGhpcy5kb0NvbHVtbk1vdmVBbmltYXRpb24oZ3JpZCwgZmxvYXRlclN0YXJ0WCwgZHJhZ2dlclN0YXJ0WCkpO1xuXG4gICAgICAgIHRoaXMuZG9GbG9hdGVyQW5pbWF0aW9uKGdyaWQpO1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsTW92aW5nLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIG1hbmlmZXN0IHRoZSBjb2x1bW4gZHJhZyBhbmQgZHJvcCBhbmltYXRpb25cbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBmbG9hdGVyU3RhcnRYIC0gdGhlIHggc3RhcnQgY29vcmRpbmF0ZSBvZiB0aGUgY29sdW1uIHVuZGVybmVhdGggdGhhdCBmbG9hdHMgYmVoaW5kIHRoZSBkcmFnZ2VkIGNvbHVtblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkcmFnZ2VyU3RhcnRYIC0gdGhlIHggc3RhcnQgY29vcmRpbmF0ZSBvZiB0aGUgZHJhZ2dlZCBjb2x1bW5cbiAgICAgKi9cbiAgICBkb0NvbHVtbk1vdmVBbmltYXRpb246IGZ1bmN0aW9uKGdyaWQsIGZsb2F0ZXJTdGFydFgsIGRyYWdnZXJTdGFydFgpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgZCA9IGZsb2F0Q29sdW1uO1xuICAgICAgICAgICAgZC5zdHlsZS5kaXNwbGF5ID0gJ2lubGluZSc7XG4gICAgICAgICAgICBzZWxmLnNldENyb3NzQnJvd3NlclByb3BlcnR5KGQsICd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyBmbG9hdGVyU3RhcnRYICsgJ3B4LCAnICsgMCArICdweCknKTtcblxuICAgICAgICAgICAgLy9kLnN0eWxlLndlYmtpdC13ZWJraXQtVHJhbnNmb3JtID0gJ3RyYW5zbGF0ZSgnICsgZmxvYXRlclN0YXJ0WCArICdweCwgJyArIDAgKyAncHgpJztcbiAgICAgICAgICAgIC8vZC5zdHlsZS53ZWJraXQtd2Via2l0LVRyYW5zZm9ybSA9ICd0cmFuc2xhdGUoJyArIGZsb2F0ZXJTdGFydFggKyAncHgsICcgKyAwICsgJ3B4KSc7XG5cbiAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBzZWxmLnNldENyb3NzQnJvd3NlclByb3BlcnR5KGQsICd0cmFuc2l0aW9uJywgKHNlbGYuaXNXZWJraXQgPyAnLXdlYmtpdC0nIDogJycpICsgJ3RyYW5zZm9ybSAnICsgY29sdW1uQW5pbWF0aW9uVGltZSArICdtcyBlYXNlJyk7XG4gICAgICAgICAgICAgICAgc2VsZi5zZXRDcm9zc0Jyb3dzZXJQcm9wZXJ0eShkLCAndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgZHJhZ2dlclN0YXJ0WCArICdweCwgJyArIC0yICsgJ3B4KScpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBncmlkLnJlcGFpbnQoKTtcbiAgICAgICAgICAgIC8vbmVlZCB0byBjaGFuZ2UgdGhpcyB0byBrZXkgZnJhbWVzXG5cbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5zZXRDcm9zc0Jyb3dzZXJQcm9wZXJ0eShkLCAndHJhbnNpdGlvbicsICcnKTtcbiAgICAgICAgICAgICAgICBncmlkLnJlbmRlck92ZXJyaWRlc0NhY2hlLmZsb2F0ZXIgPSBudWxsO1xuICAgICAgICAgICAgICAgIGdyaWQucmVwYWludCgpO1xuICAgICAgICAgICAgICAgIHNlbGYuZG9GbG9hdGVyQW5pbWF0aW9uKGdyaWQpO1xuICAgICAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgZC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmlzRmxvYXRpbmdOb3cgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sIGNvbHVtbkFuaW1hdGlvblRpbWUgKyA1MCk7XG4gICAgICAgIH07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsTW92aW5nLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIG1hbmlmZXN0IHRoZSBmbG9hdGVyIGFuaW1hdGlvblxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICovXG4gICAgZG9GbG9hdGVyQW5pbWF0aW9uOiBmdW5jdGlvbihncmlkKSB7XG4gICAgICAgIGlmICh0aGlzLmZsb2F0ZXJBbmltYXRpb25RdWV1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuZmxvYXRpbmdOb3cgPSBmYWxzZTtcbiAgICAgICAgICAgIGdyaWQucmVwYWludCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhbmltYXRpb24gPSB0aGlzLmZsb2F0ZXJBbmltYXRpb25RdWV1ZS5wb3AoKTtcbiAgICAgICAgYW5pbWF0aW9uKCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsTW92aW5nLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGNyZWF0ZSB0aGUgZmxvYXQgY29sdW1uIGF0IGNvbHVtbkluZGV4IHVuZGVybmVhdGggdGhlIGRyYWdnZWQgY29sdW1uXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gY29sdW1uSW5kZXggLSB0aGUgaW5kZXggb2YgdGhlIGNvbHVtbiB0aGF0IHdpbGwgYmUgZmxvYXRpbmdcbiAgICAgKi9cbiAgICBjcmVhdGVGbG9hdENvbHVtbjogZnVuY3Rpb24oZ3JpZCwgY29sdW1uSW5kZXgpIHtcblxuICAgICAgICB2YXIgZml4ZWRDb2x1bW5Db3VudCA9IGdyaWQuZ2V0Rml4ZWRDb2x1bW5Db3VudCgpO1xuICAgICAgICB2YXIgc2Nyb2xsTGVmdCA9IGdyaWQuZ2V0SFNjcm9sbFZhbHVlKCk7XG5cbiAgICAgICAgaWYgKGNvbHVtbkluZGV4IDwgZml4ZWRDb2x1bW5Db3VudCkge1xuICAgICAgICAgICAgc2Nyb2xsTGVmdCA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmVuZGVyZXIgPSBncmlkLmdldFJlbmRlcmVyKCk7XG4gICAgICAgIHZhciBjb2x1bW5FZGdlcyA9IHJlbmRlcmVyLmdldENvbHVtbkVkZ2VzKCk7XG5cbiAgICAgICAgdmFyIGNvbHVtbldpZHRoID0gZ3JpZC5nZXRDb2x1bW5XaWR0aChjb2x1bW5JbmRleCk7XG4gICAgICAgIHZhciBjb2xIZWlnaHQgPSBncmlkLmRpdi5jbGllbnRIZWlnaHQ7XG4gICAgICAgIHZhciBkID0gZmxvYXRDb2x1bW47XG4gICAgICAgIHZhciBzdHlsZSA9IGQuc3R5bGU7XG4gICAgICAgIHZhciBsb2NhdGlvbiA9IGdyaWQuZGl2LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgICAgIHN0eWxlLnRvcCA9IChsb2NhdGlvbi50b3AgLSAyKSArICdweCc7XG4gICAgICAgIHN0eWxlLmxlZnQgPSBsb2NhdGlvbi5sZWZ0ICsgJ3B4JztcbiAgICAgICAgc3R5bGUucG9zaXRpb24gPSAnZml4ZWQnO1xuXG4gICAgICAgIHZhciBoZHBpUmF0aW8gPSBncmlkLmdldEhpRFBJKGZsb2F0Q29sdW1uQ1RYKTtcblxuICAgICAgICBkLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCBNYXRoLnJvdW5kKGNvbHVtbldpZHRoICogaGRwaVJhdGlvKSArICdweCcpO1xuICAgICAgICBkLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgTWF0aC5yb3VuZChjb2xIZWlnaHQgKiBoZHBpUmF0aW8pICsgJ3B4Jyk7XG4gICAgICAgIHN0eWxlLmJveFNoYWRvdyA9ICcwIDEwcHggMjBweCByZ2JhKDAsMCwwLDAuMTkpLCAwIDZweCA2cHggcmdiYSgwLDAsMCwwLjIzKSc7XG4gICAgICAgIHN0eWxlLndpZHRoID0gY29sdW1uV2lkdGggKyAncHgnOyAvL01hdGgucm91bmQoY29sdW1uV2lkdGggLyBoZHBpUmF0aW8pICsgJ3B4JztcbiAgICAgICAgc3R5bGUuaGVpZ2h0ID0gY29sSGVpZ2h0ICsgJ3B4JzsgLy9NYXRoLnJvdW5kKGNvbEhlaWdodCAvIGhkcGlSYXRpbykgKyAncHgnO1xuICAgICAgICBzdHlsZS5ib3JkZXJUb3AgPSAnMXB4IHNvbGlkICcgKyByZW5kZXJlci5yZXNvbHZlUHJvcGVydHkoJ2xpbmVDb2xvcicpO1xuICAgICAgICBzdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSByZW5kZXJlci5yZXNvbHZlUHJvcGVydHkoJ2JhY2tncm91bmRDb2xvcicpO1xuXG4gICAgICAgIHZhciBzdGFydFggPSBjb2x1bW5FZGdlc1tjb2x1bW5JbmRleCAtIHNjcm9sbExlZnRdO1xuICAgICAgICBzdGFydFggPSBzdGFydFggKiBoZHBpUmF0aW87XG5cbiAgICAgICAgZmxvYXRDb2x1bW5DVFguc2NhbGUoaGRwaVJhdGlvLCBoZHBpUmF0aW8pO1xuXG4gICAgICAgIGdyaWQucmVuZGVyT3ZlcnJpZGVzQ2FjaGUuZmxvYXRlciA9IHtcbiAgICAgICAgICAgIGNvbHVtbkluZGV4OiBjb2x1bW5JbmRleCxcbiAgICAgICAgICAgIGN0eDogZmxvYXRDb2x1bW5DVFgsXG4gICAgICAgICAgICBzdGFydFg6IHN0YXJ0WCxcbiAgICAgICAgICAgIHdpZHRoOiBjb2x1bW5XaWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogY29sSGVpZ2h0LFxuICAgICAgICAgICAgaGRwaXJhdGlvOiBoZHBpUmF0aW9cbiAgICAgICAgfTtcblxuICAgICAgICBzdHlsZS56SW5kZXggPSAnNCc7XG4gICAgICAgIHRoaXMuc2V0Q3Jvc3NCcm93c2VyUHJvcGVydHkoZCwgJ3RyYW5zZm9ybScsICd0cmFuc2xhdGUoJyArIHN0YXJ0WCArICdweCwgJyArIC0yICsgJ3B4KScpO1xuICAgICAgICBzdHlsZS5jdXJzb3IgPSB0aGlzLmdldERyYWdnaW5nQ3Vyc29yTmFtZSgpO1xuICAgICAgICBncmlkLnJlcGFpbnQoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENlbGxNb3ZpbmcucHJvdG90eXBlXG4gICAgICogQGRlc2MgdXRpbGl0eSBmdW5jdGlvbiBmb3Igc2V0dGluZyBjcm9zcyBicm93c2VyIGNzcyBwcm9wZXJ0aWVzXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCAtIGRlc2NyaXB0b25cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgLSB0aGUgcHJvcGVydHlcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgLSB0aGUgdmFsdWUgdG8gYXNzaWduXG4gICAgICovXG4gICAgc2V0Q3Jvc3NCcm93c2VyUHJvcGVydHk6IGZ1bmN0aW9uKGVsZW1lbnQsIHByb3BlcnR5LCB2YWx1ZSkge1xuICAgICAgICB2YXIgdVByb3BlcnR5ID0gcHJvcGVydHlbMF0udG9VcHBlckNhc2UoKSArIHByb3BlcnR5LnN1YnN0cigxKTtcbiAgICAgICAgdGhpcy5zZXRQcm9wKGVsZW1lbnQsICd3ZWJraXQnICsgdVByb3BlcnR5LCB2YWx1ZSk7XG4gICAgICAgIHRoaXMuc2V0UHJvcChlbGVtZW50LCAnTW96JyArIHVQcm9wZXJ0eSwgdmFsdWUpO1xuICAgICAgICB0aGlzLnNldFByb3AoZWxlbWVudCwgJ21zJyArIHVQcm9wZXJ0eSwgdmFsdWUpO1xuICAgICAgICB0aGlzLnNldFByb3AoZWxlbWVudCwgJ08nICsgdVByb3BlcnR5LCB2YWx1ZSk7XG4gICAgICAgIHRoaXMuc2V0UHJvcChlbGVtZW50LCBwcm9wZXJ0eSwgdmFsdWUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbE1vdmluZy5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyB1dGlsaXR5IGZ1bmN0aW9uIGZvciBzZXR0aW5nIHByb3BlcnRpZXMgb24gSFRNTEVsZW1lbnRzXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCAtIGRlc2NyaXB0b25cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHkgLSB0aGUgcHJvcGVydHlcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdmFsdWUgLSB0aGUgdmFsdWUgdG8gYXNzaWduXG4gICAgICovXG4gICAgc2V0UHJvcDogZnVuY3Rpb24oZWxlbWVudCwgcHJvcGVydHksIHZhbHVlKSB7XG4gICAgICAgIGlmIChwcm9wZXJ0eSBpbiBlbGVtZW50LnN0eWxlKSB7XG4gICAgICAgICAgICBlbGVtZW50LnN0eWxlW3Byb3BlcnR5XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDZWxsTW92aW5nLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGNyZWF0ZSB0aGUgZHJhZ2dlZCBjb2x1bW4gYXQgY29sdW1uSW5kZXggYWJvdmUgdGhlIGZsb2F0ZWQgY29sdW1uXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCAtIHRoZSBzdGFydCBwb3NpdGlvblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb2x1bW5JbmRleCAtIHRoZSBpbmRleCBvZiB0aGUgY29sdW1uIHRoYXQgd2lsbCBiZSBmbG9hdGluZ1xuICAgICAqL1xuICAgIGNyZWF0ZURyYWdDb2x1bW46IGZ1bmN0aW9uKGdyaWQsIHgsIGNvbHVtbkluZGV4KSB7XG5cbiAgICAgICAgdmFyIGZpeGVkQ29sdW1uQ291bnQgPSBncmlkLmdldEZpeGVkQ29sdW1uQ291bnQoKTtcbiAgICAgICAgdmFyIHNjcm9sbExlZnQgPSBncmlkLmdldEhTY3JvbGxWYWx1ZSgpO1xuXG4gICAgICAgIGlmIChjb2x1bW5JbmRleCA8IGZpeGVkQ29sdW1uQ291bnQpIHtcbiAgICAgICAgICAgIHNjcm9sbExlZnQgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlbmRlcmVyID0gZ3JpZC5nZXRSZW5kZXJlcigpO1xuICAgICAgICB2YXIgY29sdW1uRWRnZXMgPSByZW5kZXJlci5nZXRDb2x1bW5FZGdlcygpO1xuICAgICAgICB2YXIgaGRwaVJhdGlvID0gZ3JpZC5nZXRIaURQSShkcmFnZ2VyQ1RYKTtcbiAgICAgICAgdmFyIGNvbHVtbldpZHRoID0gZ3JpZC5nZXRDb2x1bW5XaWR0aChjb2x1bW5JbmRleCk7XG4gICAgICAgIHZhciBjb2xIZWlnaHQgPSBncmlkLmRpdi5jbGllbnRIZWlnaHQ7XG4gICAgICAgIHZhciBkID0gZHJhZ2dlcjtcbiAgICAgICAgdmFyIGxvY2F0aW9uID0gZ3JpZC5kaXYuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIHZhciBzdHlsZSA9IGQuc3R5bGU7XG5cbiAgICAgICAgc3R5bGUudG9wID0gbG9jYXRpb24udG9wICsgJ3B4JztcbiAgICAgICAgc3R5bGUubGVmdCA9IGxvY2F0aW9uLmxlZnQgKyAncHgnO1xuICAgICAgICBzdHlsZS5wb3NpdGlvbiA9ICdmaXhlZCc7XG4gICAgICAgIHN0eWxlLm9wYWNpdHkgPSAwLjg1O1xuICAgICAgICBzdHlsZS5ib3hTaGFkb3cgPSAnMCAxOXB4IDM4cHggcmdiYSgwLDAsMCwwLjMwKSwgMCAxNXB4IDEycHggcmdiYSgwLDAsMCwwLjIyKSc7XG4gICAgICAgIC8vc3R5bGUuekluZGV4ID0gMTAwO1xuICAgICAgICBzdHlsZS5ib3JkZXJUb3AgPSAnMXB4IHNvbGlkICcgKyByZW5kZXJlci5yZXNvbHZlUHJvcGVydHkoJ2xpbmVDb2xvcicpO1xuICAgICAgICBzdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBncmlkLnJlbmRlcmVyLnJlc29sdmVQcm9wZXJ0eSgnYmFja2dyb3VuZENvbG9yJyk7XG5cbiAgICAgICAgZC5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgTWF0aC5yb3VuZChjb2x1bW5XaWR0aCAqIGhkcGlSYXRpbykgKyAncHgnKTtcbiAgICAgICAgZC5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIE1hdGgucm91bmQoY29sSGVpZ2h0ICogaGRwaVJhdGlvKSArICdweCcpO1xuXG4gICAgICAgIHN0eWxlLndpZHRoID0gY29sdW1uV2lkdGggKyAncHgnOyAvL01hdGgucm91bmQoY29sdW1uV2lkdGggLyBoZHBpUmF0aW8pICsgJ3B4JztcbiAgICAgICAgc3R5bGUuaGVpZ2h0ID0gY29sSGVpZ2h0ICsgJ3B4JzsgLy9NYXRoLnJvdW5kKGNvbEhlaWdodCAvIGhkcGlSYXRpbykgKyAncHgnO1xuXG4gICAgICAgIHZhciBzdGFydFggPSBjb2x1bW5FZGdlc1tjb2x1bW5JbmRleCAtIHNjcm9sbExlZnRdO1xuICAgICAgICBzdGFydFggPSBzdGFydFggKiBoZHBpUmF0aW87XG5cbiAgICAgICAgZHJhZ2dlckNUWC5zY2FsZShoZHBpUmF0aW8sIGhkcGlSYXRpbyk7XG5cbiAgICAgICAgZ3JpZC5yZW5kZXJPdmVycmlkZXNDYWNoZS5kcmFnZ2VyID0ge1xuICAgICAgICAgICAgY29sdW1uSW5kZXg6IGNvbHVtbkluZGV4LFxuICAgICAgICAgICAgY3R4OiBkcmFnZ2VyQ1RYLFxuICAgICAgICAgICAgc3RhcnRYOiBzdGFydFgsXG4gICAgICAgICAgICB3aWR0aDogY29sdW1uV2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IGNvbEhlaWdodCxcbiAgICAgICAgICAgIGhkcGlyYXRpbzogaGRwaVJhdGlvXG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5zZXRDcm9zc0Jyb3dzZXJQcm9wZXJ0eShkLCAndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgeCArICdweCwgLTVweCknKTtcbiAgICAgICAgc3R5bGUuekluZGV4ID0gJzUnO1xuICAgICAgICBzdHlsZS5jdXJzb3IgPSB0aGlzLmdldERyYWdnaW5nQ3Vyc29yTmFtZSgpO1xuICAgICAgICBncmlkLnJlcGFpbnQoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENlbGxNb3ZpbmcucHJvdG90eXBlXG4gICAgICogQGRlc2MgdGhpcyBmdW5jdGlvbiBpcyB0aGUgbWFpbiBkcmFnZ2luZyBsb2dpY1xuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHggLSB0aGUgc3RhcnQgcG9zaXRpb25cbiAgICAgKi9cbiAgICBkcmFnQ29sdW1uOiBmdW5jdGlvbihncmlkLCB4KSB7XG5cbiAgICAgICAgLy9UT0RPOiB0aGlzIGZ1bmN0aW9uIGlzIG92ZXJseSBjb21wbGV4LCByZWZhY3RvciB0aGlzIGluIHRvIHNvbWV0aGluZyBtb3JlIHJlYXNvbmFibGVcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICAvL3ZhciByZW5kZXJlciA9IGdyaWQuZ2V0UmVuZGVyZXIoKTtcbiAgICAgICAgLy92YXIgY29sdW1uRWRnZXMgPSByZW5kZXJlci5nZXRDb2x1bW5FZGdlcygpO1xuXG4gICAgICAgIHZhciBhdXRvU2Nyb2xsaW5nTm93ID0gdGhpcy5jb2x1bW5EcmFnQXV0b1Njcm9sbGluZ1JpZ2h0IHx8IHRoaXMuY29sdW1uRHJhZ0F1dG9TY3JvbGxpbmdMZWZ0O1xuXG4gICAgICAgIHZhciBoZHBpUmF0aW8gPSBncmlkLmdldEhpRFBJKGRyYWdnZXJDVFgpO1xuXG4gICAgICAgIHZhciBkcmFnQ29sdW1uSW5kZXggPSBncmlkLnJlbmRlck92ZXJyaWRlc0NhY2hlLmRyYWdnZXIuY29sdW1uSW5kZXg7XG4gICAgICAgIHZhciBjb2x1bW5XaWR0aCA9IGdyaWQucmVuZGVyT3ZlcnJpZGVzQ2FjaGUuZHJhZ2dlci53aWR0aDtcblxuICAgICAgICB2YXIgbWluWCA9IDA7IC8vZ3JpZC5nZXRGaXhlZENvbHVtbnNXaWR0aCgpO1xuICAgICAgICB2YXIgbWF4WCA9IGdyaWQucmVuZGVyZXIuZ2V0RmluYWxWaXNhYmxlQ29sdW1uQm91bmRyeSgpIC0gY29sdW1uV2lkdGg7XG4gICAgICAgIHggPSBNYXRoLm1pbih4LCBtYXhYICsgMTUpO1xuICAgICAgICB4ID0gTWF0aC5tYXgobWluWCAtIDE1LCB4KTtcblxuICAgICAgICAvL2FtIEkgYXQgbXkgbG93ZXIgYm91bmRcbiAgICAgICAgdmFyIGF0TWluID0geCA8IG1pblggJiYgZHJhZ0NvbHVtbkluZGV4ICE9PSAwO1xuXG4gICAgICAgIC8vYW0gSSBhdCBteSB1cHBlciBib3VuZFxuICAgICAgICB2YXIgYXRNYXggPSB4ID4gbWF4WDtcblxuICAgICAgICB2YXIgZCA9IGRyYWdnZXI7XG5cbiAgICAgICAgdGhpcy5zZXRDcm9zc0Jyb3dzZXJQcm9wZXJ0eShkLCAndHJhbnNpdGlvbicsIChzZWxmLmlzV2Via2l0ID8gJy13ZWJraXQtJyA6ICcnKSArICd0cmFuc2Zvcm0gJyArIDAgKyAnbXMgZWFzZSwgYm94LXNoYWRvdyAnICsgY29sdW1uQW5pbWF0aW9uVGltZSArICdtcyBlYXNlJyk7XG5cbiAgICAgICAgdGhpcy5zZXRDcm9zc0Jyb3dzZXJQcm9wZXJ0eShkLCAndHJhbnNmb3JtJywgJ3RyYW5zbGF0ZSgnICsgeCArICdweCwgJyArIC0xMCArICdweCknKTtcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgZC5zdHlsZS5kaXNwbGF5ID0gJ2lubGluZSc7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHZhciBvdmVyQ29sID0gZ3JpZC5yZW5kZXJlci5nZXRDb2x1bW5Gcm9tUGl4ZWxYKHggKyAoZC53aWR0aCAvIDIgLyBoZHBpUmF0aW8pKTtcblxuICAgICAgICBpZiAoYXRNaW4pIHtcbiAgICAgICAgICAgIG92ZXJDb2wgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGF0TWF4KSB7XG4gICAgICAgICAgICBvdmVyQ29sID0gZ3JpZC5nZXRDb2x1bW5Db3VudCgpIC0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkb0FGbG9hdCA9IGRyYWdDb2x1bW5JbmRleCA+IG92ZXJDb2w7XG4gICAgICAgIGRvQUZsb2F0ID0gZG9BRmxvYXQgfHwgKG92ZXJDb2wgLSBkcmFnQ29sdW1uSW5kZXggPj0gMSk7XG5cbiAgICAgICAgaWYgKGRvQUZsb2F0ICYmICFhdE1heCAmJiAhYXV0b1Njcm9sbGluZ05vdykge1xuICAgICAgICAgICAgdmFyIGRyYWdnZWRUb1RoZVJpZ2h0ID0gZHJhZ0NvbHVtbkluZGV4IDwgb3ZlckNvbDtcbiAgICAgICAgICAgIC8vIGlmIChkcmFnZ2VkVG9UaGVSaWdodCkge1xuICAgICAgICAgICAgLy8gICAgIG92ZXJDb2wgPSBvdmVyQ29sIC0gMTtcbiAgICAgICAgICAgIC8vIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmlzRmxvYXRpbmdOb3cpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuaXNGbG9hdGluZ05vdyA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmNyZWF0ZUZsb2F0Q29sdW1uKGdyaWQsIG92ZXJDb2wpO1xuICAgICAgICAgICAgdGhpcy5mbG9hdENvbHVtblRvKGdyaWQsIGRyYWdnZWRUb1RoZVJpZ2h0KTtcbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgaWYgKHggPCBtaW5YIC0gMTApIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNoZWNrQXV0b1Njcm9sbFRvTGVmdChncmlkLCB4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh4ID4gbWluWCAtIDEwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb2x1bW5EcmFnQXV0b1Njcm9sbGluZ0xlZnQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vbGV0cyBjaGVjayBmb3IgYXV0b3Njcm9sbCB0byByaWdodCBpZiB3ZXJlIHVwIGFnYWluc3QgaXRcbiAgICAgICAgICAgIGlmIChhdE1heCB8fCB4ID4gbWF4WCArIDEwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGVja0F1dG9TY3JvbGxUb1JpZ2h0KGdyaWQsIHgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh4IDwgbWF4WCArIDEwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb2x1bW5EcmFnQXV0b1Njcm9sbGluZ1JpZ2h0ID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENlbGxNb3ZpbmcucHJvdG90eXBlXG4gICAgICogQGRlc2MgYXV0b3Njcm9sbCB0byB0aGUgcmlnaHQgaWYgbmVjZXNzYXJ5XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0geCAtIHRoZSBzdGFydCBwb3NpdGlvblxuICAgICAqL1xuICAgIGNoZWNrQXV0b1Njcm9sbFRvUmlnaHQ6IGZ1bmN0aW9uKGdyaWQsIHgpIHtcbiAgICAgICAgaWYgKHRoaXMuY29sdW1uRHJhZ0F1dG9TY3JvbGxpbmdSaWdodCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29sdW1uRHJhZ0F1dG9TY3JvbGxpbmdSaWdodCA9IHRydWU7XG4gICAgICAgIHRoaXMuX2NoZWNrQXV0b1Njcm9sbFRvUmlnaHQoZ3JpZCwgeCk7XG4gICAgfSxcblxuICAgIF9jaGVja0F1dG9TY3JvbGxUb1JpZ2h0OiBmdW5jdGlvbihncmlkLCB4KSB7XG4gICAgICAgIGlmICghdGhpcy5jb2x1bW5EcmFnQXV0b1Njcm9sbGluZ1JpZ2h0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNjcm9sbExlZnQgPSBncmlkLmdldEhTY3JvbGxWYWx1ZSgpO1xuICAgICAgICBpZiAoIWdyaWQuZHJhZ2dpbmcgfHwgc2Nyb2xsTGVmdCA+IChncmlkLnNiSFNjcm9sbENvbmZpZy5yYW5nZVN0b3AgLSAyKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBkcmFnZ2VkSW5kZXggPSBncmlkLnJlbmRlck92ZXJyaWRlc0NhY2hlLmRyYWdnZXIuY29sdW1uSW5kZXg7XG4gICAgICAgIGdyaWQuc2Nyb2xsQnkoMSwgMCk7XG4gICAgICAgIHZhciBuZXdJbmRleCA9IGRyYWdnZWRJbmRleCArIDE7XG4gICAgICAgIGNvbnNvbGUubG9nKG5ld0luZGV4LCBkcmFnZ2VkSW5kZXgpO1xuICAgICAgICBncmlkLnN3YXBDb2x1bW5zKG5ld0luZGV4LCBkcmFnZ2VkSW5kZXgpO1xuICAgICAgICBncmlkLnJlbmRlck92ZXJyaWRlc0NhY2hlLmRyYWdnZXIuY29sdW1uSW5kZXggPSBuZXdJbmRleDtcblxuICAgICAgICBzZXRUaW1lb3V0KHRoaXMuX2NoZWNrQXV0b1Njcm9sbFRvUmlnaHQuYmluZCh0aGlzLCBncmlkLCB4KSwgMjUwKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENlbGxNb3ZpbmcucHJvdG90eXBlXG4gICAgICogQGRlc2MgYXV0b3Njcm9sbCB0byB0aGUgbGVmdCBpZiBuZWNlc3NhcnlcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gdGhlIHN0YXJ0IHBvc2l0aW9uXG4gICAgICovXG4gICAgY2hlY2tBdXRvU2Nyb2xsVG9MZWZ0OiBmdW5jdGlvbihncmlkLCB4KSB7XG4gICAgICAgIGlmICh0aGlzLmNvbHVtbkRyYWdBdXRvU2Nyb2xsaW5nTGVmdCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29sdW1uRHJhZ0F1dG9TY3JvbGxpbmdMZWZ0ID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fY2hlY2tBdXRvU2Nyb2xsVG9MZWZ0KGdyaWQsIHgpO1xuICAgIH0sXG5cbiAgICBfY2hlY2tBdXRvU2Nyb2xsVG9MZWZ0OiBmdW5jdGlvbihncmlkLCB4KSB7XG4gICAgICAgIGlmICghdGhpcy5jb2x1bW5EcmFnQXV0b1Njcm9sbGluZ0xlZnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBzY3JvbGxMZWZ0ID0gZ3JpZC5nZXRIU2Nyb2xsVmFsdWUoKTtcbiAgICAgICAgaWYgKCFncmlkLmRyYWdnaW5nIHx8IHNjcm9sbExlZnQgPCAxKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRyYWdnZWRJbmRleCA9IGdyaWQucmVuZGVyT3ZlcnJpZGVzQ2FjaGUuZHJhZ2dlci5jb2x1bW5JbmRleDtcbiAgICAgICAgZ3JpZC5zd2FwQ29sdW1ucyhkcmFnZ2VkSW5kZXggKyBzY3JvbGxMZWZ0LCBkcmFnZ2VkSW5kZXggKyBzY3JvbGxMZWZ0IC0gMSk7XG4gICAgICAgIGdyaWQuc2Nyb2xsQnkoLTEsIDApO1xuICAgICAgICBzZXRUaW1lb3V0KHRoaXMuX2NoZWNrQXV0b1Njcm9sbFRvTGVmdC5iaW5kKHRoaXMsIGdyaWQsIHgpLCAyNTApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbE1vdmluZy5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBhIGNvbHVtbiBkcmFnIGhhcyBjb21wbGV0ZWQsIHVwZGF0ZSBkYXRhIGFuZCBjbGVhbnVwXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKi9cbiAgICBlbmREcmFnQ29sdW1uOiBmdW5jdGlvbihncmlkKSB7XG5cbiAgICAgICAgdmFyIGZpeGVkQ29sdW1uQ291bnQgPSBncmlkLmdldEZpeGVkQ29sdW1uQ291bnQoKTtcbiAgICAgICAgdmFyIHNjcm9sbExlZnQgPSBncmlkLmdldEhTY3JvbGxWYWx1ZSgpO1xuXG4gICAgICAgIHZhciBjb2x1bW5JbmRleCA9IGdyaWQucmVuZGVyT3ZlcnJpZGVzQ2FjaGUuZHJhZ2dlci5jb2x1bW5JbmRleDtcblxuICAgICAgICBpZiAoY29sdW1uSW5kZXggPCBmaXhlZENvbHVtbkNvdW50KSB7XG4gICAgICAgICAgICBzY3JvbGxMZWZ0ID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByZW5kZXJlciA9IGdyaWQuZ2V0UmVuZGVyZXIoKTtcbiAgICAgICAgdmFyIGNvbHVtbkVkZ2VzID0gcmVuZGVyZXIuZ2V0Q29sdW1uRWRnZXMoKTtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgc3RhcnRYID0gY29sdW1uRWRnZXNbY29sdW1uSW5kZXggLSBzY3JvbGxMZWZ0XTtcbiAgICAgICAgdmFyIGQgPSBkcmFnZ2VyO1xuXG4gICAgICAgIHNlbGYuc2V0Q3Jvc3NCcm93c2VyUHJvcGVydHkoZCwgJ3RyYW5zaXRpb24nLCAoc2VsZi5pc1dlYmtpdCA/ICctd2Via2l0LScgOiAnJykgKyAndHJhbnNmb3JtICcgKyBjb2x1bW5BbmltYXRpb25UaW1lICsgJ21zIGVhc2UsIGJveC1zaGFkb3cgJyArIGNvbHVtbkFuaW1hdGlvblRpbWUgKyAnbXMgZWFzZScpO1xuICAgICAgICBzZWxmLnNldENyb3NzQnJvd3NlclByb3BlcnR5KGQsICd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyBzdGFydFggKyAncHgsICcgKyAtMSArICdweCknKTtcbiAgICAgICAgZC5zdHlsZS5ib3hTaGFkb3cgPSAnMHB4IDBweCAwcHggIzg4ODg4OCc7XG5cbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGdyaWQucmVuZGVyT3ZlcnJpZGVzQ2FjaGUuZHJhZ2dlciA9IG51bGw7XG4gICAgICAgICAgICBncmlkLnJlcGFpbnQoKTtcbiAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBkLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgICAgICAgZ3JpZC5lbmREcmFnQ29sdW1uTm90aWZpY2F0aW9uKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSwgY29sdW1uQW5pbWF0aW9uVGltZSArIDUwKTtcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ2VsbE1vdmluZy5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBoYW5kbGUgdGhpcyBldmVudCBkb3duIHRoZSBmZWF0dXJlIGNoYWluIG9mIHJlc3BvbnNpYmlsaXR5XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGlzSGVhZGVyUm93OiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICB2YXIgZ3JpZENlbGwgPSBldmVudC52aWV3UG9pbnQ7XG4gICAgICAgIHZhciBpc0ZpeGVkID0gZ3JpZENlbGwueSA9PT0gMDtcbiAgICAgICAgcmV0dXJuIGlzRml4ZWQ7XG4gICAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBDb2x1bW5Nb3Zpbmc7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBGZWF0dXJlID0gcmVxdWlyZSgnLi9GZWF0dXJlLmpzJyk7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBDb2x1bW5SZXNpemluZyA9IEZlYXR1cmUuZXh0ZW5kKCdDb2x1bW5SZXNpemluZycsIHtcblxuICAgIGFsaWFzOiAnQ29sdW1uUmVzaXppbmcnLFxuXG4gICAgLyoqXG4gICAgICogdGhlIGluZGV4IG9mIHRoZSBjb2x1bW4gd2FsbCB3ZXJlIGN1cnJlbnRseSBkcmFnZ2luZ1xuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQGRlZmF1bHQgLTJcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uUmVzaXppbmcucHJvdG90eXBlXG4gICAgICovXG4gICAgZHJhZ0luZGV4OiAtMixcblxuICAgIC8qKlxuICAgICAqIHRoZSBwaXhlbCBsb2NhdGlvbiBvZiB0aGUgd2hlcmUgdGhlIGRyYWcgd2FzIGluaXRpYXRlZFxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQGRlZmF1bHQgLTFcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uUmVzaXppbmcucHJvdG90eXBlXG4gICAgICovXG4gICAgZHJhZ1N0YXJ0OiAtMSxcblxuICAgIC8qKlxuICAgICAqIHRoZSBzdGFydGluZyB3aWR0aC9oZWlnaHQgb2YgdGhlIHJvdy9jb2x1bW4gd2UgYXJlIGRyYWdnaW5nXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAtMVxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5SZXNpemluZy5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBkcmFnSW5kZXhTdGFydGluZ1NpemU6IC0xLFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENvbHVtblJlc2l6aW5nLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGdldCB0aGUgbW91c2UgeCx5IGNvb3JkaW5hdGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqIEBwYXJhbSB7TW91c2VFdmVudH0gZXZlbnQgLSB0aGUgbW91c2UgZXZlbnQgdG8gcXVlcnlcbiAgICAgKi9cbiAgICBnZXRNb3VzZVZhbHVlOiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICByZXR1cm4gZXZlbnQucHJpbWl0aXZlRXZlbnQuZGV0YWlsLm1vdXNlLng7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5SZXNpemluZy5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBnZXQgdGhlIGdyaWQgY2VsbCB4LHkgY29vcmRpbmF0ZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICogQHBhcmFtIHt3aW5kb3cuZmluLnJlY3Rhbmd1bGFyLlBvaW50fSBncmlkQ2VsbFxuICAgICAqL1xuICAgIGdldEdyaWRDZWxsVmFsdWU6IGZ1bmN0aW9uKGdyaWRDZWxsKSB7XG4gICAgICAgIHJldHVybiBncmlkQ2VsbC55O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uUmVzaXppbmcucHJvdG90eXBlXG4gICAgICogQGRlc2MgcmV0dXJuIHRoZSBncmlkcyB4LHkgc2Nyb2xsIHZhbHVlXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqL1xuICAgIGdldFNjcm9sbFZhbHVlOiBmdW5jdGlvbihncmlkKSB7XG4gICAgICAgIHJldHVybiBncmlkLmdldEhTY3JvbGxWYWx1ZSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uUmVzaXppbmcucHJvdG90eXBlXG4gICAgICogQGRlc2MgcmV0dXJuIHRoZSB3aWR0aC9oZWlnaHQgb2YgdGhlIHJvdy9jb2x1bW4gb2YgaW50ZXJlc3RcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gdGhlIHJvdy9jb2x1bW4gaW5kZXggb2YgaW50ZXJlc3RcbiAgICAgKi9cbiAgICBnZXRBcmVhU2l6ZTogZnVuY3Rpb24oZ3JpZCwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGdyaWQuZ2V0Q29sdW1uV2lkdGgoaW5kZXgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uUmVzaXppbmcucHJvdG90eXBlXG4gICAgICogQGRlc2Mgc2V0IHRoZSB3aWR0aC9oZWlnaHQgb2YgdGhlIHJvdy9jb2x1bW4gYXQgaW5kZXhcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gdGhlIHJvdy9jb2x1bW4gaW5kZXggb2YgaW50ZXJlc3RcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgLSB0aGUgd2lkdGgvaGVpZ2h0IHRvIHNldCB0b1xuICAgICAqL1xuICAgIHNldEFyZWFTaXplOiBmdW5jdGlvbihncmlkLCBpbmRleCwgdmFsdWUpIHtcbiAgICAgICAgZ3JpZC5zZXRDb2x1bW5XaWR0aChpbmRleCwgdmFsdWUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uUmVzaXppbmcucHJvdG90eXBlXG4gICAgICogQGRlc2MgcmV0dXJuIHRoZSByZWNlbnRseSByZW5kZXJlZCBhcmVhJ3Mgd2lkdGgvaGVpZ2h0XG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCAtIHRoZSByb3cvY29sdW1uIGluZGV4IG9mIGludGVyZXN0XG4gICAgICovXG4gICAgZ2V0UHJldmlvdXNBYnNvbHV0ZVNpemU6IGZ1bmN0aW9uKGdyaWQsIGluZGV4KSB7XG4gICAgICAgIHJldHVybiBncmlkLmdldFJlbmRlcmVkV2lkdGgoaW5kZXgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uUmVzaXppbmcucHJvdG90eXBlXG4gICAgICogQGRlc2MgcmV0dXJucyB0aGUgaW5kZXggb2Ygd2hpY2ggZGl2aWRlciBJJ20gb3ZlclxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIG92ZXJBcmVhRGl2aWRlcjogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgcmV0dXJuIGdyaWQub3ZlckNvbHVtbkRpdmlkZXIoZXZlbnQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uUmVzaXppbmcucHJvdG90eXBlXG4gICAgICogQGRlc2MgYW0gSSBvdmVyIHRoZSBjb2x1bW4vcm93IGFyZWFcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaXNGaXJzdEZpeGVkT3RoZXJBcmVhOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pc0ZpcnN0Rml4ZWRSb3coZ3JpZCwgZXZlbnQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uUmVzaXppbmcucHJvdG90eXBlXG4gICAgICogQGRlc2MgcmV0dXJuIHRoZSBjdXJzb3IgbmFtZVxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgZ2V0Q3Vyc29yTmFtZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAnY29sLXJlc2l6ZSc7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5SZXNpemluZy5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBoYW5kbGUgdGhpcyBldmVudFxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVNb3VzZURyYWc6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLmRyYWdJbmRleCA+IC0yKSB7XG4gICAgICAgICAgICAvL3ZhciBmaXhlZEFyZWFDb3VudCA9IHRoaXMuZ2V0Rml4ZWRBcmVhQ291bnQoZ3JpZCk7XG4gICAgICAgICAgICAvL3ZhciBvZmZzZXQgPSB0aGlzLmdldEZpeGVkQXJlYVNpemUoZ3JpZCwgZml4ZWRBcmVhQ291bnQgKyBhcmVhSW5kZXgpO1xuICAgICAgICAgICAgdmFyIG1vdXNlID0gdGhpcy5nZXRNb3VzZVZhbHVlKGV2ZW50KTtcbiAgICAgICAgICAgIHZhciBzY3JvbGxWYWx1ZSA9IHRoaXMuZ2V0U2Nyb2xsVmFsdWUoZ3JpZCk7XG4gICAgICAgICAgICBpZiAodGhpcy5kcmFnSW5kZXggPCB0aGlzLmdldEZpeGVkQXJlYUNvdW50KGdyaWQpKSB7XG4gICAgICAgICAgICAgICAgc2Nyb2xsVmFsdWUgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIHByZXZpb3VzID0gdGhpcy5nZXRQcmV2aW91c0Fic29sdXRlU2l6ZShncmlkLCB0aGlzLmRyYWdJbmRleCAtIHNjcm9sbFZhbHVlKTtcbiAgICAgICAgICAgIHZhciBkaXN0YW5jZSA9IG1vdXNlIC0gcHJldmlvdXM7XG4gICAgICAgICAgICB0aGlzLnNldEFyZWFTaXplKGdyaWQsIHRoaXMuZHJhZ0luZGV4LCBkaXN0YW5jZSk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQuaGFuZGxlTW91c2VEcmFnKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uUmVzaXppbmcucHJvdG90eXBlXG4gICAgICogQGRlc2MgZ2V0IHRoZSB3aWR0aC9oZWlnaHQgb2YgYSBzcGVjaWZpYyByb3cvY29sdW1uXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYXJlYUluZGV4IC0gdGhlIHJvdy9jb2x1bW4gaW5kZXggb2YgaW50ZXJlc3RcbiAgICAgKi9cbiAgICBnZXRTaXplOiBmdW5jdGlvbihncmlkLCBhcmVhSW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QXJlYVNpemUoZ3JpZCwgYXJlYUluZGV4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENvbHVtblJlc2l6aW5nLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIHJldHVybiB0aGUgZml4ZWQgYXJlYSByb3dzL2NvbHVtbnMgY291bnRcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICovXG4gICAgZ2V0T3RoZXJGaXhlZEFyZWFDb3VudDogZnVuY3Rpb24oZ3JpZCkge1xuICAgICAgICByZXR1cm4gZ3JpZC5nZXRGaXhlZFJvd0NvdW50KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5SZXNpemluZy5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBoYW5kbGUgdGhpcyBldmVudCBkb3duIHRoZSBmZWF0dXJlIGNoYWluIG9mIHJlc3BvbnNpYmlsaXR5XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZU1vdXNlRG93bjogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgdmFyIGlzRW5hYmxlZCA9IHRoaXMuaXNFbmFibGVkKGdyaWQpO1xuICAgICAgICB2YXIgb3ZlckFyZWEgPSB0aGlzLm92ZXJBcmVhRGl2aWRlcihncmlkLCBldmVudCk7XG4gICAgICAgIGlmIChpc0VuYWJsZWQgJiYgb3ZlckFyZWEgPiAtMSAmJiB0aGlzLmlzRmlyc3RGaXhlZE90aGVyQXJlYShncmlkLCBldmVudCkpIHtcbiAgICAgICAgICAgIHZhciBzY3JvbGxWYWx1ZSA9IHRoaXMuZ2V0U2Nyb2xsVmFsdWUoZ3JpZCk7XG4gICAgICAgICAgICBpZiAob3ZlckFyZWEgPCB0aGlzLmdldEZpeGVkQXJlYUNvdW50KGdyaWQpKSB7XG4gICAgICAgICAgICAgICAgc2Nyb2xsVmFsdWUgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5kcmFnSW5kZXggPSBvdmVyQXJlYSAtIDEgKyBzY3JvbGxWYWx1ZTtcbiAgICAgICAgICAgIHRoaXMuZHJhZ1N0YXJ0ID0gdGhpcy5nZXRNb3VzZVZhbHVlKGV2ZW50KTtcbiAgICAgICAgICAgIHRoaXMuZHJhZ0luZGV4U3RhcnRpbmdTaXplID0gMDtcbiAgICAgICAgICAgIHRoaXMuZGV0YWNoQ2hhaW4oKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dC5oYW5kbGVNb3VzZURvd24oZ3JpZCwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5SZXNpemluZy5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBoYW5kbGUgdGhpcyBldmVudCBkb3duIHRoZSBmZWF0dXJlIGNoYWluIG9mIHJlc3BvbnNpYmlsaXR5XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZU1vdXNlVXA6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIHZhciBpc0VuYWJsZWQgPSB0aGlzLmlzRW5hYmxlZChncmlkKTtcbiAgICAgICAgaWYgKGlzRW5hYmxlZCAmJiB0aGlzLmRyYWdJbmRleCA+IC0yKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnNvciA9IG51bGw7XG4gICAgICAgICAgICB0aGlzLmRyYWdJbmRleCA9IC0yO1xuXG4gICAgICAgICAgICBldmVudC5wcmltaXRpdmVFdmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgIC8vZGVsYXkgaGVyZSB0byBnaXZlIG90aGVyIGV2ZW50cyBhIGNoYW5jZSB0byBiZSBkcm9wcGVkXG4gICAgICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgICAgICBncmlkLnN5bmNocm9uaXplU2Nyb2xsaW5nQm91bmRyaWVzKCk7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHNlbGYuYXR0YWNoQ2hhaW4oKTtcbiAgICAgICAgICAgIH0sIDIwMCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQuaGFuZGxlTW91c2VVcChncmlkLCBldmVudCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENvbHVtblJlc2l6aW5nLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGhhbmRsZSB0aGlzIGV2ZW50IGRvd24gdGhlIGZlYXR1cmUgY2hhaW4gb2YgcmVzcG9uc2liaWxpdHlcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlTW91c2VNb3ZlOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICBpZiAodGhpcy5kcmFnSW5kZXggPiAtMikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY3Vyc29yID0gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMubmV4dCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0LmhhbmRsZU1vdXNlTW92ZShncmlkLCBldmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jaGVja0ZvckFyZWFSZXNpemVDdXJzb3JDaGFuZ2UoZ3JpZCwgZXZlbnQpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uUmVzaXppbmcucHJvdG90eXBlXG4gICAgICogQGRlc2MgZmlsbCB0aGlzIGluXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGNoZWNrRm9yQXJlYVJlc2l6ZUN1cnNvckNoYW5nZTogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgdmFyIGlzRW5hYmxlZCA9IHRoaXMuaXNFbmFibGVkKGdyaWQpO1xuICAgICAgICBpZiAoaXNFbmFibGVkICYmIHRoaXMub3ZlckFyZWFEaXZpZGVyKGdyaWQsIGV2ZW50KSA+IC0xICYmIHRoaXMuaXNGaXJzdEZpeGVkT3RoZXJBcmVhKGdyaWQsIGV2ZW50KSkge1xuICAgICAgICAgICAgdGhpcy5jdXJzb3IgPSB0aGlzLmdldEN1cnNvck5hbWUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY3Vyc29yID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAtMlxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5SZXNpemluZy5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBnZXRGaXhlZEFyZWFDb3VudDogZnVuY3Rpb24oZ3JpZCkge1xuICAgICAgICB2YXIgY291bnQgPSBncmlkLmdldEZpeGVkQ29sdW1uQ291bnQoKSArIChncmlkLmlzU2hvd1Jvd051bWJlcnMoKSA/IDEgOiAwKSArIChncmlkLmhhc0hpZXJhcmNoeUNvbHVtbigpID8gMSA6IDApO1xuICAgICAgICByZXR1cm4gY291bnQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIGV2ZW50XG4gICAgICogQGRlZmF1bHQgLTJcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uUmVzaXppbmcucHJvdG90eXBlXG4gICAgICovXG4gICAgaGFuZGxlRG91YmxlQ2xpY2s6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIHZhciBpc0VuYWJsZWQgPSB0aGlzLmlzRW5hYmxlZChncmlkKTtcbiAgICAgICAgdmFyIGhhc0N1cnNvciA9IHRoaXMub3ZlckFyZWFEaXZpZGVyKGdyaWQsIGV2ZW50KSA+IC0xOyAvL3RoaXMuY3Vyc29yICE9PSBudWxsO1xuICAgICAgICB2YXIgaGVhZGVyUm93Q291bnQgPSBncmlkLmdldEhlYWRlclJvd0NvdW50KCk7XG4gICAgICAgIC8vdmFyIGhlYWRlckNvbENvdW50ID0gZ3JpZC5nZXRIZWFkZXJDb2x1bW5Db3VudCgpO1xuICAgICAgICB2YXIgZ3JpZENlbGwgPSBldmVudC5ncmlkQ2VsbDtcbiAgICAgICAgaWYgKGlzRW5hYmxlZCAmJiBoYXNDdXJzb3IgJiYgKGdyaWRDZWxsLnkgPD0gaGVhZGVyUm93Q291bnQpKSB7XG4gICAgICAgICAgICBncmlkLmF1dG9zaXplQ29sdW1uKGdyaWRDZWxsLnggLSAxKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dC5oYW5kbGVEb3VibGVDbGljayhncmlkLCBldmVudCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKiBAZGVmYXVsdCAtMlxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5SZXNpemluZy5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBpc0VuYWJsZWQ6IGZ1bmN0aW9uKGdyaWQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBDb2x1bW5SZXNpemluZztcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEZlYXR1cmUgPSByZXF1aXJlKCcuL0ZlYXR1cmUuanMnKTtcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIENvbHVtblNlbGVjdGlvbiA9IEZlYXR1cmUuZXh0ZW5kKCdDb2x1bW5TZWxlY3Rpb24nLCB7XG5cbiAgICBhbGlhczogJ0NvbHVtblNlbGVjdGlvbicsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgcGl4ZWwgbG9jYXRpb24gb2YgdGhlIG1vdXNlIHBvaW50ZXIgZHVyaW5nIGEgZHJhZyBvcGVyYXRpb24uXG4gICAgICogQHR5cGUge3dpbmRvdy5maW4ucmVjdGFuZ3VsYXIuUG9pbnR9XG4gICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5TZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICovXG4gICAgY3VycmVudERyYWc6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgY2VsbCBjb29yZGluYXRlcyBvZiB0aGUgd2hlcmUgdGhlIG1vdXNlIHBvaW50ZXIgaXMgZHVyaW5nIGEgZHJhZyBvcGVyYXRpb24uXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICogQG1lbWJlck9mIENvbHVtblNlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBsYXN0RHJhZ0NlbGw6IG51bGwsXG5cbiAgICAvKipcbiAgICAgKiBhIG1pbGxpc2Vjb25kIHZhbHVlIHJlcHJlc2VudGluZyB0aGUgcHJldmlvdXMgdGltZSBhbiBhdXRvc2Nyb2xsIHN0YXJ0ZWRcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IDBcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uU2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHNiTGFzdEF1dG86IDAsXG5cbiAgICAvKipcbiAgICAgKiBhIG1pbGxpc2Vjb25kIHZhbHVlIHJlcHJlc2VudGluZyB0aGUgdGltZSB0aGUgY3VycmVudCBhdXRvc2Nyb2xsIHN0YXJ0ZWRcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IDBcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uU2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqL1xuICAgIHNiQXV0b1N0YXJ0OiAwLFxuXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uU2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIEhhbmRsZSB0aGlzIGV2ZW50IGRvd24gdGhlIGZlYXR1cmUgY2hhaW4gb2YgcmVzcG9uc2liaWxpdHkuXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZU1vdXNlVXA6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLmRyYWdnaW5nKSB7XG4gICAgICAgICAgICB0aGlzLmRyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMubmV4dCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0LmhhbmRsZU1vdXNlVXAoZ3JpZCwgZXZlbnQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5TZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2MgKiBAZGVzYyBIYW5kbGUgdGhpcyBldmVudCBkb3duIHRoZSBmZWF0dXJlIGNoYWluIG9mIHJlc3BvbnNpYmlsaXR5LlxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVNb3VzZURvd246IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG5cbiAgICAgICAgaWYgKCghZ3JpZC5pc0NvbHVtblNlbGVjdGlvbigpIHx8IGV2ZW50Lm1vdXNlUG9pbnQueSA8IDUpICYmIHRoaXMubmV4dCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0LmhhbmRsZU1vdXNlRG93bihncmlkLCBldmVudCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaXNSaWdodENsaWNrID0gZXZlbnQucHJpbWl0aXZlRXZlbnQuZGV0YWlsLmlzUmlnaHRDbGljaztcbiAgICAgICAgdmFyIGNlbGwgPSBldmVudC5ncmlkQ2VsbDtcbiAgICAgICAgdmFyIHZpZXdDZWxsID0gZXZlbnQudmlld1BvaW50O1xuICAgICAgICB2YXIgZHggPSBjZWxsLng7XG4gICAgICAgIHZhciBkeSA9IGNlbGwueTtcblxuICAgICAgICB2YXIgaXNIZWFkZXIgPSBncmlkLmlzU2hvd0hlYWRlclJvdygpICYmIGR5ID09PSAwICYmIGR4ICE9PSAtMTtcblxuICAgICAgICBpZiAoaXNSaWdodENsaWNrIHx8ICFpc0hlYWRlcikge1xuICAgICAgICAgICAgaWYgKHRoaXMubmV4dCkge1xuICAgICAgICAgICAgICAgIHRoaXMubmV4dC5oYW5kbGVNb3VzZURvd24oZ3JpZCwgZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuXG4gICAgICAgICAgICB2YXIgbnVtRml4ZWRDb2x1bW5zID0gZ3JpZC5nZXRGaXhlZENvbHVtbkNvdW50KCk7XG5cbiAgICAgICAgICAgIC8vaWYgd2UgYXJlIGluIHRoZSBmaXhlZCBhcmVhIGRvIG5vdCBhcHBseSB0aGUgc2Nyb2xsIHZhbHVlc1xuICAgICAgICAgICAgLy9jaGVjayBib3RoIHggYW5kIHkgdmFsdWVzIGluZGVwZW5kZW50bHlcbiAgICAgICAgICAgIGlmICh2aWV3Q2VsbC54IDwgbnVtRml4ZWRDb2x1bW5zKSB7XG4gICAgICAgICAgICAgICAgZHggPSB2aWV3Q2VsbC54O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZENlbGwgPSBncmlkLm5ld1BvaW50KGR4LCAwKTtcblxuICAgICAgICAgICAgdmFyIHByaW1FdmVudCA9IGV2ZW50LnByaW1pdGl2ZUV2ZW50O1xuICAgICAgICAgICAgdmFyIGtleXMgPSBwcmltRXZlbnQuZGV0YWlsLmtleXM7XG4gICAgICAgICAgICB0aGlzLmRyYWdnaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuZXh0ZW5kU2VsZWN0aW9uKGdyaWQsIGRDZWxsLCBrZXlzKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uU2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGhhbmRsZSB0aGlzIGV2ZW50IGRvd24gdGhlIGZlYXR1cmUgY2hhaW4gb2YgcmVzcG9uc2liaWxpdHlcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlTW91c2VEcmFnOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuXG4gICAgICAgIGlmICgoIWdyaWQuaXNDb2x1bW5TZWxlY3Rpb24oKSB8fCB0aGlzLmlzQ29sdW1uRHJhZ2dpbmcoZ3JpZCkpICYmIHRoaXMubmV4dCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0LmhhbmRsZU1vdXNlRHJhZyhncmlkLCBldmVudCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgaXNSaWdodENsaWNrID0gZXZlbnQucHJpbWl0aXZlRXZlbnQuZGV0YWlsLmlzUmlnaHRDbGljaztcblxuICAgICAgICBpZiAoaXNSaWdodENsaWNrIHx8ICF0aGlzLmRyYWdnaW5nKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5uZXh0LmhhbmRsZU1vdXNlRHJhZyhncmlkLCBldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgIHZhciBudW1GaXhlZENvbHVtbnMgPSBncmlkLmdldEZpeGVkQ29sdW1uQ291bnQoKTtcblxuICAgICAgICAgICAgdmFyIGNlbGwgPSBldmVudC5ncmlkQ2VsbDtcbiAgICAgICAgICAgIHZhciB2aWV3Q2VsbCA9IGV2ZW50LnZpZXdQb2ludDtcbiAgICAgICAgICAgIHZhciBkeCA9IGNlbGwueDtcbiAgICAgICAgICAgIHZhciBkeSA9IGNlbGwueTtcblxuICAgICAgICAgICAgLy9pZiB3ZSBhcmUgaW4gdGhlIGZpeGVkIGFyZWEgZG8gbm90IGFwcGx5IHRoZSBzY3JvbGwgdmFsdWVzXG4gICAgICAgICAgICAvL2NoZWNrIGJvdGggeCBhbmQgeSB2YWx1ZXMgaW5kZXBlbmRlbnRseVxuICAgICAgICAgICAgaWYgKHZpZXdDZWxsLnggPCBudW1GaXhlZENvbHVtbnMpIHtcbiAgICAgICAgICAgICAgICBkeCA9IHZpZXdDZWxsLng7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBkQ2VsbCA9IGdyaWQubmV3UG9pbnQoZHgsIGR5KTtcblxuICAgICAgICAgICAgdmFyIHByaW1FdmVudCA9IGV2ZW50LnByaW1pdGl2ZUV2ZW50O1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50RHJhZyA9IHByaW1FdmVudC5kZXRhaWwubW91c2U7XG4gICAgICAgICAgICB0aGlzLmxhc3REcmFnQ2VsbCA9IGRDZWxsO1xuXG4gICAgICAgICAgICB0aGlzLmNoZWNrRHJhZ1Njcm9sbChncmlkLCB0aGlzLmN1cnJlbnREcmFnKTtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlTW91c2VEcmFnQ2VsbFNlbGVjdGlvbihncmlkLCBkQ2VsbCwgcHJpbUV2ZW50LmRldGFpbC5rZXlzKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uU2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGhhbmRsZSB0aGlzIGV2ZW50IGRvd24gdGhlIGZlYXR1cmUgY2hhaW4gb2YgcmVzcG9uc2liaWxpdHlcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlS2V5RG93bjogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgaWYgKGdyaWQuZ2V0TGFzdFNlbGVjdGlvblR5cGUoKSAhPT0gJ2NvbHVtbicpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5leHQuaGFuZGxlS2V5RG93bihncmlkLCBldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNvbW1hbmQgPSAnaGFuZGxlJyArIGV2ZW50LmRldGFpbC5jaGFyO1xuICAgICAgICBpZiAodGhpc1tjb21tYW5kXSkge1xuICAgICAgICAgICAgdGhpc1tjb21tYW5kXS5jYWxsKHRoaXMsIGdyaWQsIGV2ZW50LmRldGFpbCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENvbHVtblNlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBIYW5kbGUgYSBtb3VzZWRyYWcgc2VsZWN0aW9uXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbW91c2UgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGtleXMgLSBhcnJheSBvZiB0aGUga2V5cyB0aGF0IGFyZSBjdXJyZW50bHkgcHJlc3NlZCBkb3duXG4gICAgICovXG4gICAgaGFuZGxlTW91c2VEcmFnQ2VsbFNlbGVjdGlvbjogZnVuY3Rpb24oZ3JpZCwgZ3JpZENlbGwsIGtleXMpIHtcblxuICAgICAgICAvL3ZhciBiZWhhdmlvciA9IGdyaWQuZ2V0QmVoYXZpb3IoKTtcbiAgICAgICAgdmFyIHggPSBncmlkQ2VsbC54O1xuICAgICAgICAvLyAgICAgICAgICAgIHZhciBwcmV2aW91c0RyYWdFeHRlbnQgPSBncmlkLmdldERyYWdFeHRlbnQoKTtcbiAgICAgICAgdmFyIG1vdXNlRG93biA9IGdyaWQuZ2V0TW91c2VEb3duKCk7XG5cbiAgICAgICAgdmFyIG5ld1ggPSB4IC0gbW91c2VEb3duLng7XG4gICAgICAgIC8vdmFyIG5ld1kgPSB5IC0gbW91c2VEb3duLnk7XG5cbiAgICAgICAgLy8gaWYgKHByZXZpb3VzRHJhZ0V4dGVudC54ID09PSBuZXdYICYmIHByZXZpb3VzRHJhZ0V4dGVudC55ID09PSBuZXdZKSB7XG4gICAgICAgIC8vICAgICByZXR1cm47XG4gICAgICAgIC8vIH1cblxuICAgICAgICBncmlkLmNsZWFyTW9zdFJlY2VudENvbHVtblNlbGVjdGlvbigpO1xuXG4gICAgICAgIGdyaWQuc2VsZWN0Q29sdW1uKG1vdXNlRG93bi54LCB4KTtcbiAgICAgICAgZ3JpZC5zZXREcmFnRXh0ZW50KGdyaWQubmV3UG9pbnQobmV3WCwgMCkpO1xuXG4gICAgICAgIGdyaWQucmVwYWludCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uU2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIHRoaXMgY2hlY2tzIHdoaWxlIHdlcmUgZHJhZ2dpbmcgaWYgd2UgZ28gb3V0c2lkZSB0aGUgdmlzaWJsZSBib3VuZHMsIGlmIHNvLCBraWNrIG9mZiB0aGUgZXh0ZXJuYWwgYXV0b3Njcm9sbCBjaGVjayBmdW5jdGlvbiAoYWJvdmUpXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbW91c2UgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGNoZWNrRHJhZ1Njcm9sbDogZnVuY3Rpb24oZ3JpZCwgbW91c2UpIHtcbiAgICAgICAgaWYgKCFncmlkLnJlc29sdmVQcm9wZXJ0eSgnc2Nyb2xsaW5nRW5hYmxlZCcpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGIgPSBncmlkLmdldERhdGFCb3VuZHMoKTtcbiAgICAgICAgdmFyIGluc2lkZSA9IGIuY29udGFpbnMobW91c2UpO1xuICAgICAgICBpZiAoaW5zaWRlKSB7XG4gICAgICAgICAgICBpZiAoZ3JpZC5pc1Njcm9sbGluZ05vdygpKSB7XG4gICAgICAgICAgICAgICAgZ3JpZC5zZXRTY3JvbGxpbmdOb3coZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKCFncmlkLmlzU2Nyb2xsaW5nTm93KCkpIHtcbiAgICAgICAgICAgIGdyaWQuc2V0U2Nyb2xsaW5nTm93KHRydWUpO1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxEcmFnKGdyaWQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5TZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2MgdGhpcyBmdW5jdGlvbiBtYWtlcyBzdXJlIHRoYXQgd2hpbGUgd2UgYXJlIGRyYWdnaW5nIG91dHNpZGUgb2YgdGhlIGdyaWQgdmlzaWJsZSBib3VuZHMsIHdlIHNyY3JvbGwgYWNjb3JkaW5nbHlcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqL1xuICAgIHNjcm9sbERyYWc6IGZ1bmN0aW9uKGdyaWQpIHtcblxuICAgICAgICBpZiAoIWdyaWQuaXNTY3JvbGxpbmdOb3coKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxhc3REcmFnQ2VsbCA9IHRoaXMubGFzdERyYWdDZWxsO1xuICAgICAgICB2YXIgYiA9IGdyaWQuZ2V0RGF0YUJvdW5kcygpO1xuICAgICAgICB2YXIgeE9mZnNldCA9IDA7XG4gICAgICAgIHZhciB5T2Zmc2V0ID0gMDtcblxuICAgICAgICB2YXIgbnVtRml4ZWRDb2x1bW5zID0gZ3JpZC5nZXRGaXhlZENvbHVtbkNvdW50KCk7XG4gICAgICAgIHZhciBudW1GaXhlZFJvd3MgPSBncmlkLmdldEZpeGVkUm93Q291bnQoKTtcblxuICAgICAgICB2YXIgZHJhZ0VuZEluRml4ZWRBcmVhWCA9IGxhc3REcmFnQ2VsbC54IDwgbnVtRml4ZWRDb2x1bW5zO1xuICAgICAgICB2YXIgZHJhZ0VuZEluRml4ZWRBcmVhWSA9IGxhc3REcmFnQ2VsbC55IDwgbnVtRml4ZWRSb3dzO1xuXG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnREcmFnLnggPCBiLm9yaWdpbi54KSB7XG4gICAgICAgICAgICB4T2Zmc2V0ID0gLTE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5jdXJyZW50RHJhZy54ID4gYi5vcmlnaW4ueCArIGIuZXh0ZW50LngpIHtcbiAgICAgICAgICAgIHhPZmZzZXQgPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGRyYWdDZWxsT2Zmc2V0WCA9IHhPZmZzZXQ7XG4gICAgICAgIHZhciBkcmFnQ2VsbE9mZnNldFkgPSB5T2Zmc2V0O1xuXG4gICAgICAgIGlmIChkcmFnRW5kSW5GaXhlZEFyZWFYKSB7XG4gICAgICAgICAgICBkcmFnQ2VsbE9mZnNldFggPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRyYWdFbmRJbkZpeGVkQXJlYVkpIHtcbiAgICAgICAgICAgIGRyYWdDZWxsT2Zmc2V0WSA9IDA7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmxhc3REcmFnQ2VsbCA9IGxhc3REcmFnQ2VsbC5wbHVzWFkoZHJhZ0NlbGxPZmZzZXRYLCBkcmFnQ2VsbE9mZnNldFkpO1xuICAgICAgICBncmlkLnNjcm9sbEJ5KHhPZmZzZXQsIHlPZmZzZXQpO1xuICAgICAgICB0aGlzLmhhbmRsZU1vdXNlRHJhZ0NlbGxTZWxlY3Rpb24oZ3JpZCwgbGFzdERyYWdDZWxsLCBbXSk7IC8vIHVwZGF0ZSB0aGUgc2VsZWN0aW9uXG4gICAgICAgIGdyaWQucmVwYWludCgpO1xuICAgICAgICBzZXRUaW1lb3V0KHRoaXMuc2Nyb2xsRHJhZy5iaW5kKHRoaXMsIGdyaWQpLCAyNSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5TZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2MgZXh0ZW5kIGEgc2VsZWN0aW9uIG9yIGNyZWF0ZSBvbmUgaWYgdGhlcmUgaXNudCB5ZXRcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBncmlkQ2VsbCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICogQHBhcmFtIHtBcnJheX0ga2V5cyAtIGFycmF5IG9mIHRoZSBrZXlzIHRoYXQgYXJlIGN1cnJlbnRseSBwcmVzc2VkIGRvd25cbiAgICAgKi9cbiAgICBleHRlbmRTZWxlY3Rpb246IGZ1bmN0aW9uKGdyaWQsIGdyaWRDZWxsLCBrZXlzKSB7XG4gICAgICAgIGdyaWQuc3RvcEVkaXRpbmcoKTtcbiAgICAgICAgLy92YXIgaGFzQ1RSTCA9IGtleXMuaW5kZXhPZignQ1RSTCcpICE9PSAtMTtcbiAgICAgICAgdmFyIGhhc1NISUZUID0ga2V5cy5pbmRleE9mKCdTSElGVCcpICE9PSAtMTtcblxuICAgICAgICAvLyB2YXIgc2Nyb2xsVG9wID0gZ3JpZC5nZXRWU2Nyb2xsVmFsdWUoKTtcbiAgICAgICAgLy8gdmFyIHNjcm9sbExlZnQgPSBncmlkLmdldEhTY3JvbGxWYWx1ZSgpO1xuXG4gICAgICAgIC8vIHZhciBudW1GaXhlZENvbHVtbnMgPSAwOy8vZ3JpZC5nZXRGaXhlZENvbHVtbkNvdW50KCk7XG4gICAgICAgIC8vIHZhciBudW1GaXhlZFJvd3MgPSAwOy8vZ3JpZC5nZXRGaXhlZFJvd0NvdW50KCk7XG5cbiAgICAgICAgdmFyIG1vdXNlUG9pbnQgPSBncmlkLmdldE1vdXNlRG93bigpO1xuICAgICAgICB2YXIgeCA9IGdyaWRDZWxsLng7IC8vIC0gbnVtRml4ZWRDb2x1bW5zICsgc2Nyb2xsTGVmdDtcbiAgICAgICAgdmFyIHkgPSBncmlkQ2VsbC55OyAvLyAtIG51bUZpeGVkUm93cyArIHNjcm9sbFRvcDtcblxuICAgICAgICAvL3dlcmUgb3V0c2lkZSBvZiB0aGUgZ3JpZCBkbyBub3RoaW5nXG4gICAgICAgIGlmICh4IDwgMCB8fCB5IDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy93ZSBoYXZlIHJlcGVhdGVkIGEgY2xpY2sgaW4gdGhlIHNhbWUgc3BvdCBkZXNsZWN0IHRoZSB2YWx1ZSBmcm9tIGxhc3QgdGltZVxuICAgICAgICAvLyBpZiAobW91c2VQb2ludCAmJiB4ID09PSBtb3VzZVBvaW50LnggJiYgeSA9PT0gbW91c2VQb2ludC55KSB7XG4gICAgICAgIC8vICAgICBncmlkLmNsZWFyU2VsZWN0aW9ucygpO1xuICAgICAgICAvLyAgICAgZ3JpZC5wb3BNb3VzZURvd24oKTtcbiAgICAgICAgLy8gICAgIGdyaWQucmVwYWludCgpO1xuICAgICAgICAvLyAgICAgcmV0dXJuO1xuICAgICAgICAvLyB9XG5cbiAgICAgICAgLy8gaWYgKCFoYXNDVFJMICYmICFoYXNTSElGVCkge1xuICAgICAgICAvLyAgICAgZ3JpZC5jbGVhclNlbGVjdGlvbnMoKTtcbiAgICAgICAgLy8gfVxuXG4gICAgICAgIGlmIChoYXNTSElGVCkge1xuICAgICAgICAgICAgZ3JpZC5jbGVhck1vc3RSZWNlbnRDb2x1bW5TZWxlY3Rpb24oKTtcbiAgICAgICAgICAgIGdyaWQuc2VsZWN0Q29sdW1uKHgsIG1vdXNlUG9pbnQueCk7XG4gICAgICAgICAgICBncmlkLnNldERyYWdFeHRlbnQoZ3JpZC5uZXdQb2ludCh4IC0gbW91c2VQb2ludC54LCAwKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBncmlkLnRvZ2dsZVNlbGVjdENvbHVtbih4LCBrZXlzKTtcbiAgICAgICAgICAgIGdyaWQuc2V0TW91c2VEb3duKGdyaWQubmV3UG9pbnQoeCwgeSkpO1xuICAgICAgICAgICAgZ3JpZC5zZXREcmFnRXh0ZW50KGdyaWQubmV3UG9pbnQoMCwgMCkpO1xuICAgICAgICB9XG4gICAgICAgIGdyaWQucmVwYWludCgpO1xuICAgIH0sXG5cblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5TZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2MgaGFuZGxlIHRoaXMgZXZlbnRcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqL1xuICAgIGhhbmRsZURPV05TSElGVDogZnVuY3Rpb24oZ3JpZCkge30sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uU2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGhhbmRsZSB0aGlzIGV2ZW50XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZVVQU0hJRlQ6IGZ1bmN0aW9uKGdyaWQpIHt9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENvbHVtblNlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBoYW5kbGUgdGhpcyBldmVudFxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVMRUZUU0hJRlQ6IGZ1bmN0aW9uKGdyaWQpIHtcbiAgICAgICAgdGhpcy5tb3ZlU2hpZnRTZWxlY3QoZ3JpZCwgLTEpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uU2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGhhbmRsZSB0aGlzIGV2ZW50XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZVJJR0hUU0hJRlQ6IGZ1bmN0aW9uKGdyaWQpIHtcbiAgICAgICAgdGhpcy5tb3ZlU2hpZnRTZWxlY3QoZ3JpZCwgMSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5TZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2MgaGFuZGxlIHRoaXMgZXZlbnRcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlRE9XTjogZnVuY3Rpb24oZ3JpZCkge1xuXG4gICAgICAgIC8vIHZhciBtb3VzZUNvcm5lciA9IGdyaWQuZ2V0TW91c2VEb3duKCkucGx1cyhncmlkLmdldERyYWdFeHRlbnQoKSk7XG4gICAgICAgIC8vIHZhciBtYXhSb3dzID0gZ3JpZC5nZXRSb3dDb3VudCgpIC0gMTtcblxuICAgICAgICAvLyB2YXIgbmV3WCA9IG1vdXNlQ29ybmVyLng7XG4gICAgICAgIC8vIHZhciBuZXdZID0gZ3JpZC5nZXRIZWFkZXJSb3dDb3VudCgpICsgZ3JpZC5nZXRWU2Nyb2xsVmFsdWUoKTtcblxuICAgICAgICAvLyBuZXdZID0gTWF0aC5taW4obWF4Um93cywgbmV3WSk7XG5cbiAgICAgICAgLy8gZ3JpZC5jbGVhclNlbGVjdGlvbnMoKTtcbiAgICAgICAgLy8gZ3JpZC5zZWxlY3QobmV3WCwgbmV3WSwgMCwgMCk7XG4gICAgICAgIC8vIGdyaWQuc2V0TW91c2VEb3duKG5ldyBncmlkLnJlY3Rhbmd1bGFyLlBvaW50KG5ld1gsIG5ld1kpKTtcbiAgICAgICAgLy8gZ3JpZC5zZXREcmFnRXh0ZW50KG5ldyBncmlkLnJlY3Rhbmd1bGFyLlBvaW50KDAsIDApKTtcblxuICAgICAgICAvLyBncmlkLnJlcGFpbnQoKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENvbHVtblNlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBoYW5kbGUgdGhpcyBldmVudFxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVVUDogZnVuY3Rpb24oZ3JpZCkge30sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uU2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGhhbmRsZSB0aGlzIGV2ZW50XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZUxFRlQ6IGZ1bmN0aW9uKGdyaWQpIHtcbiAgICAgICAgdGhpcy5tb3ZlU2luZ2xlU2VsZWN0KGdyaWQsIC0xKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENvbHVtblNlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBoYW5kbGUgdGhpcyBldmVudFxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVSSUdIVDogZnVuY3Rpb24oZ3JpZCkge1xuICAgICAgICB0aGlzLm1vdmVTaW5nbGVTZWxlY3QoZ3JpZCwgMSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5TZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2MgSWYgd2UgYXJlIGhvbGRpbmcgZG93biB0aGUgc2FtZSBuYXZpZ2F0aW9uIGtleSwgYWNjZWxlcmF0ZSB0aGUgaW5jcmVtZW50IHdlIHNjcm9sbFxuICAgICAqICMjIyMgcmV0dXJuczogaW50ZWdlclxuICAgICAqL1xuICAgIGdldEF1dG9TY3JvbGxBY2NlbGVyYXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY291bnQgPSAxO1xuICAgICAgICB2YXIgZWxhcHNlZCA9IHRoaXMuZ2V0QXV0b1Njcm9sbER1cmF0aW9uKCkgLyAyMDAwO1xuICAgICAgICBjb3VudCA9IE1hdGgubWF4KDEsIE1hdGguZmxvb3IoZWxhcHNlZCAqIGVsYXBzZWQgKiBlbGFwc2VkICogZWxhcHNlZCkpO1xuICAgICAgICByZXR1cm4gY291bnQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5TZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2Mgc2V0IHRoZSBzdGFydCB0aW1lIHRvIHJpZ2h0IG5vdyB3aGVuIHdlIGluaXRpYXRlIGFuIGF1dG8gc2Nyb2xsXG4gICAgICovXG4gICAgc2V0QXV0b1Njcm9sbFN0YXJ0VGltZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuc2JBdXRvU3RhcnQgPSBEYXRlLm5vdygpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgQ29sdW1uU2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIHVwZGF0ZSB0aGUgYXV0b3Njcm9sbCBzdGFydCB0aW1lIGlmIHdlIGhhdmVuJ3QgYXV0b3Njcm9sbGVkIHdpdGhpbiB0aGUgbGFzdCA1MDBtcyBvdGhlcndpc2UgdXBkYXRlIHRoZSBjdXJyZW50IGF1dG9zY3JvbGwgdGltZVxuICAgICAqL1xuICAgIHBpbmdBdXRvU2Nyb2xsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG5vdyA9IERhdGUubm93KCk7XG4gICAgICAgIGlmIChub3cgLSB0aGlzLnNiTGFzdEF1dG8gPiA1MDApIHtcbiAgICAgICAgICAgIHRoaXMuc2V0QXV0b1Njcm9sbFN0YXJ0VGltZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2JMYXN0QXV0byA9IERhdGUubm93KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5TZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2MgYW5zd2VyIGhvdyBsb25nIHdlIGhhdmUgYmVlbiBhdXRvIHNjcm9sbGluZ1xuICAgICAqICMjIyMgcmV0dXJuczogaW50ZWdlclxuICAgICAqL1xuICAgIGdldEF1dG9TY3JvbGxEdXJhdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChEYXRlLm5vdygpIC0gdGhpcy5zYkxhc3RBdXRvID4gNTAwKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gRGF0ZS5ub3coKSAtIHRoaXMuc2JBdXRvU3RhcnQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5TZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2MgQXVnbWVudCB0aGUgbW9zdCByZWNlbnQgc2VsZWN0aW9uIGV4dGVudCBieSAob2Zmc2V0WCxvZmZzZXRZKSBhbmQgc2Nyb2xsIGlmIG5lY2Vzc2FyeS5cbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRYIC0geCBjb29yZGluYXRlIHRvIHN0YXJ0IGF0XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFkgLSB5IGNvb3JkaW5hdGUgdG8gc3RhcnQgYXRcbiAgICAgKi9cbiAgICBtb3ZlU2hpZnRTZWxlY3Q6IGZ1bmN0aW9uKGdyaWQsIG9mZnNldFgpIHtcblxuICAgICAgICB2YXIgbWF4Q29sdW1ucyA9IGdyaWQuZ2V0Q29sdW1uQ291bnQoKSAtIDE7XG5cbiAgICAgICAgdmFyIG1heFZpZXdhYmxlQ29sdW1ucyA9IGdyaWQuZ2V0VmlzaWJsZUNvbHVtbnMoKSAtIDE7XG5cbiAgICAgICAgaWYgKCFncmlkLnJlc29sdmVQcm9wZXJ0eSgnc2Nyb2xsaW5nRW5hYmxlZCcpKSB7XG4gICAgICAgICAgICBtYXhDb2x1bW5zID0gTWF0aC5taW4obWF4Q29sdW1ucywgbWF4Vmlld2FibGVDb2x1bW5zKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBvcmlnaW4gPSBncmlkLmdldE1vdXNlRG93bigpO1xuICAgICAgICB2YXIgZXh0ZW50ID0gZ3JpZC5nZXREcmFnRXh0ZW50KCk7XG5cbiAgICAgICAgdmFyIG5ld1ggPSBleHRlbnQueCArIG9mZnNldFg7XG4gICAgICAgIC8vdmFyIG5ld1kgPSBncmlkLmdldFJvd0NvdW50KCk7XG5cbiAgICAgICAgbmV3WCA9IE1hdGgubWluKG1heENvbHVtbnMgLSBvcmlnaW4ueCwgTWF0aC5tYXgoLW9yaWdpbi54LCBuZXdYKSk7XG5cbiAgICAgICAgZ3JpZC5jbGVhck1vc3RSZWNlbnRDb2x1bW5TZWxlY3Rpb24oKTtcbiAgICAgICAgZ3JpZC5zZWxlY3RDb2x1bW4ob3JpZ2luLngsIG9yaWdpbi54ICsgbmV3WCk7XG5cbiAgICAgICAgZ3JpZC5zZXREcmFnRXh0ZW50KGdyaWQubmV3UG9pbnQobmV3WCwgMCkpO1xuXG4gICAgICAgIGlmIChncmlkLmluc3VyZU1vZGVsQ29sSXNWaXNpYmxlKG5ld1ggKyBvcmlnaW4ueCwgb2Zmc2V0WCkpIHtcbiAgICAgICAgICAgIHRoaXMucGluZ0F1dG9TY3JvbGwoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGdyaWQucmVwYWludCgpO1xuXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5TZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2MgUmVwbGFjZSB0aGUgbW9zdCByZWNlbnQgc2VsZWN0aW9uIHdpdGggYSBzaW5nbGUgY2VsbCBzZWxlY3Rpb24gdGhhdCBpcyBtb3ZlZCAob2Zmc2V0WCxvZmZzZXRZKSBmcm9tIHRoZSBwcmV2aW91cyBzZWxlY3Rpb24gZXh0ZW50LlxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFggLSB4IGNvb3JkaW5hdGUgdG8gc3RhcnQgYXRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0WSAtIHkgY29vcmRpbmF0ZSB0byBzdGFydCBhdFxuICAgICAqL1xuICAgIG1vdmVTaW5nbGVTZWxlY3Q6IGZ1bmN0aW9uKGdyaWQsIG9mZnNldFgpIHtcblxuICAgICAgICB2YXIgbWF4Q29sdW1ucyA9IGdyaWQuZ2V0Q29sdW1uQ291bnQoKSAtIDE7XG5cbiAgICAgICAgdmFyIG1heFZpZXdhYmxlQ29sdW1ucyA9IGdyaWQuZ2V0VmlzaWJsZUNvbHVtbnNDb3VudCgpIC0gMTtcblxuICAgICAgICBpZiAoIWdyaWQucmVzb2x2ZVByb3BlcnR5KCdzY3JvbGxpbmdFbmFibGVkJykpIHtcbiAgICAgICAgICAgIG1heENvbHVtbnMgPSBNYXRoLm1pbihtYXhDb2x1bW5zLCBtYXhWaWV3YWJsZUNvbHVtbnMpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG1vdXNlQ29ybmVyID0gZ3JpZC5nZXRNb3VzZURvd24oKS5wbHVzKGdyaWQuZ2V0RHJhZ0V4dGVudCgpKTtcblxuICAgICAgICB2YXIgbmV3WCA9IG1vdXNlQ29ybmVyLnggKyBvZmZzZXRYO1xuICAgICAgICAvL3ZhciBuZXdZID0gZ3JpZC5nZXRSb3dDb3VudCgpO1xuXG4gICAgICAgIG5ld1ggPSBNYXRoLm1pbihtYXhDb2x1bW5zLCBNYXRoLm1heCgwLCBuZXdYKSk7XG5cbiAgICAgICAgZ3JpZC5jbGVhclNlbGVjdGlvbnMoKTtcbiAgICAgICAgZ3JpZC5zZWxlY3RDb2x1bW4obmV3WCk7XG4gICAgICAgIGdyaWQuc2V0TW91c2VEb3duKGdyaWQubmV3UG9pbnQobmV3WCwgMCkpO1xuICAgICAgICBncmlkLnNldERyYWdFeHRlbnQoZ3JpZC5uZXdQb2ludCgwLCAwKSk7XG5cbiAgICAgICAgaWYgKGdyaWQuaW5zdXJlTW9kZWxDb2xJc1Zpc2libGUobmV3WCwgb2Zmc2V0WCkpIHtcbiAgICAgICAgICAgIHRoaXMucGluZ0F1dG9TY3JvbGwoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGdyaWQucmVwYWludCgpO1xuXG4gICAgfSxcblxuICAgIGlzQ29sdW1uRHJhZ2dpbmc6IGZ1bmN0aW9uKGdyaWQpIHtcbiAgICAgICAgdmFyIGRyYWdnZXIgPSBncmlkLmxvb2t1cEZlYXR1cmUoJ0NvbHVtbk1vdmluZycpO1xuICAgICAgICBpZiAoIWRyYWdnZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaXNBY3RpdmF0ZWQgPSBkcmFnZ2VyLmRyYWdnaW5nICYmICF0aGlzLmRyYWdnaW5nO1xuICAgICAgICByZXR1cm4gaXNBY3RpdmF0ZWQ7XG4gICAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBDb2x1bW5TZWxlY3Rpb247XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBGZWF0dXJlID0gcmVxdWlyZSgnLi9GZWF0dXJlLmpzJyk7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBDb2x1bW5Tb3J0aW5nID0gRmVhdHVyZS5leHRlbmQoJ0NvbHVtblNvcnRpbmcnLCB7XG5cbiAgICBhbGlhczogJ0NvbHVtblNvcnRpbmcnLFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIENvbHVtblNvcnRpbmcucHJvdG90eXBlXG4gICAgICogQGRlc2MgSGFuZGxlIHRoaXMgZXZlbnQgZG93biB0aGUgZmVhdHVyZSBjaGFpbiBvZiByZXNwb25zaWJpbGl0eS5cbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG5cbiAgICBoYW5kbGVEb3VibGVDbGljazogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgdmFyIGdyaWRDZWxsID0gZXZlbnQuZ3JpZENlbGw7XG4gICAgICAgIGlmIChncmlkLmlzU2hvd0hlYWRlclJvdygpICYmIGdyaWRDZWxsLnkgPT09IDAgJiYgZ3JpZENlbGwueCAhPT0gLTEpIHtcbiAgICAgICAgICAgIHZhciBrZXlzID0gZXZlbnQucHJpbWl0aXZlRXZlbnQuZGV0YWlsLmtleXM7XG4gICAgICAgICAgICBncmlkLnRvZ2dsZVNvcnQoZ3JpZENlbGwueCwga2V5cyk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQuaGFuZGxlRG91YmxlQ2xpY2soZ3JpZCwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5Tb3J0aW5nLnByb3RvdHlwZVxuICAgICAqIEBkZXNjICogQGRlc2MgSGFuZGxlIHRoaXMgZXZlbnQgZG93biB0aGUgZmVhdHVyZSBjaGFpbiBvZiByZXNwb25zaWJpbGl0eS5cbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlTW91c2VNb3ZlOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICB2YXIgeSA9IGV2ZW50LmdyaWRDZWxsLnk7XG4gICAgICAgIGlmICh0aGlzLmlzRml4ZWRSb3coZ3JpZCwgZXZlbnQpICYmIHkgPCAxKSB7XG4gICAgICAgICAgICB0aGlzLmN1cnNvciA9ICdwb2ludGVyJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY3Vyc29yID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQuaGFuZGxlTW91c2VNb3ZlKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH1cblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gQ29sdW1uU29ydGluZztcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEJhc2UgPSByZXF1aXJlKCdleHRlbmQtbWUnKS5CYXNlO1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICogQGRlc2MgaW5zdGFuY2VzIG9mIGZlYXR1cmVzIGFyZSBjb25uZWN0ZWQgdG8gb25lIGFub3RoZXIgdG8gbWFrZSBhIGNoYWluIG9mIHJlc3BvbnNpYmlsaXR5IGZvciBoYW5kbGluZyBhbGwgdGhlIGlucHV0IHRvIHRoZSBoeXBlcmdyaWQuXG4gKi9cbnZhciBGZWF0dXJlID0gQmFzZS5leHRlbmQoJ0ZlYXR1cmUnLCB7XG5cbiAgICAvKipcbiAgICAgKiB0aGUgbmV4dCBmZWF0dXJlIHRvIGJlIGdpdmVuIGEgY2hhbmNlIHRvIGhhbmRsZSBpbmNvbWluZyBldmVudHNcbiAgICAgKiBAdHlwZSB7RmVhdHVyZX1cbiAgICAgKiBAZGVmYXVsdCBudWxsXG4gICAgICogQG1lbWJlck9mIEZlYXR1cmUucHJvdG90eXBlXG4gICAgICovXG4gICAgbmV4dDogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIGEgdGVtcG9yYXJ5IGhvbGRpbmcgZmllbGQgZm9yIG15IG5leHQgZmVhdHVyZSB3aGVuIEknbSBpbiBhIGRpc2Nvbm5lY3RlZCBzdGF0ZVxuICAgICAqIEB0eXBlIHtGZWF0dXJlfVxuICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgKiBAbWVtYmVyT2YgRmVhdHVyZS5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBkZXRhY2hlZDogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIHRoZSBjdXJzb3IgSSB3YW50IHRvIGJlIGRpc3BsYXllZFxuICAgICAqIEB0eXBlIHtzdHJpbmd9XG4gICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAqIEBtZW1iZXJPZiBGZWF0dXJlLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGN1cnNvcjogbnVsbCxcblxuICAgIC8qKlxuICAgICAqIHRoZSBjZWxsIGxvY2F0aW9uIHdoZXJlIHRoZSBjdXJzb3IgaXMgY3VycmVudGx5XG4gICAgICogQHR5cGUge1BvaW50fVxuICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgKiBAbWVtYmVyT2YgRmVhdHVyZS5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBjdXJyZW50SG92ZXJDZWxsOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEZlYXR1cmUucHJvdG90eXBlXG4gICAgICogQGRlc2Mgc2V0IG15IG5leHQgZmllbGQsIG9yIGlmIGl0J3MgcG9wdWxhdGVkIGRlbGVnYXRlIHRvIHRoZSBmZWF0dXJlIGluIG15IG5leHQgZmllbGRcbiAgICAgKiBAcGFyYW0ge0ZlYXR1cmV9IG5leHRGZWF0dXJlIC0gdGhpcyBpcyBob3cgd2UgYnVpbGQgdGhlIGNoYWluIG9mIHJlc3BvbnNpYmlsaXR5XG4gICAgICovXG4gICAgc2V0TmV4dDogZnVuY3Rpb24obmV4dEZlYXR1cmUpIHtcbiAgICAgICAgaWYgKHRoaXMubmV4dCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0LnNldE5leHQobmV4dEZlYXR1cmUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5uZXh0ID0gbmV4dEZlYXR1cmU7XG4gICAgICAgICAgICB0aGlzLmRldGFjaGVkID0gbmV4dEZlYXR1cmU7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEZlYXR1cmUucHJvdG90eXBlXG4gICAgICogQGRlc2MgZGlzY29ubmVjdCBteSBjaGlsZFxuICAgICAqL1xuICAgIGRldGFjaENoYWluOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5uZXh0ID0gbnVsbDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEZlYXR1cmUucHJvdG90eXBlXG4gICAgICogQGRlc2MgcmVhdHRhY2ggbXkgY2hpbGQgZnJvbSB0aGUgZGV0YWNoZWQgcmVmZXJlbmNlXG4gICAgICovXG4gICAgYXR0YWNoQ2hhaW46IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLm5leHQgPSB0aGlzLmRldGFjaGVkO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRmVhdHVyZS5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBoYW5kbGUgbW91c2UgbW92ZSBkb3duIHRoZSBmZWF0dXJlIGNoYWluIG9mIHJlc3BvbnNpYmlsaXR5XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZU1vdXNlTW92ZTogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMubmV4dCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0LmhhbmRsZU1vdXNlTW92ZShncmlkLCBldmVudCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEZlYXR1cmUucHJvdG90eXBlXG4gICAgICogQGRlc2MgaGFuZGxlIHRoaXMgZXZlbnQgZG93biB0aGUgZmVhdHVyZSBjaGFpbiBvZiByZXNwb25zaWJpbGl0eVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVNb3VzZUV4aXQ6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dC5oYW5kbGVNb3VzZUV4aXQoZ3JpZCwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBGZWF0dXJlLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGhhbmRsZSB0aGlzIGV2ZW50IGRvd24gdGhlIGZlYXR1cmUgY2hhaW4gb2YgcmVzcG9uc2liaWxpdHlcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlTW91c2VFbnRlcjogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMubmV4dCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0LmhhbmRsZU1vdXNlRW50ZXIoZ3JpZCwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBGZWF0dXJlLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGhhbmRsZSB0aGlzIGV2ZW50IGRvd24gdGhlIGZlYXR1cmUgY2hhaW4gb2YgcmVzcG9uc2liaWxpdHlcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlTW91c2VEb3duOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQuaGFuZGxlTW91c2VEb3duKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRmVhdHVyZS5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBoYW5kbGUgdGhpcyBldmVudCBkb3duIHRoZSBmZWF0dXJlIGNoYWluIG9mIHJlc3BvbnNpYmlsaXR5XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZU1vdXNlVXA6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dC5oYW5kbGVNb3VzZVVwKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRmVhdHVyZS5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBoYW5kbGUgdGhpcyBldmVudCBkb3duIHRoZSBmZWF0dXJlIGNoYWluIG9mIHJlc3BvbnNpYmlsaXR5XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZUtleURvd246IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dC5oYW5kbGVLZXlEb3duKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRmVhdHVyZS5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBoYW5kbGUgdGhpcyBldmVudCBkb3duIHRoZSBmZWF0dXJlIGNoYWluIG9mIHJlc3BvbnNpYmlsaXR5XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZUtleVVwOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQuaGFuZGxlS2V5VXAoZ3JpZCwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBGZWF0dXJlLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGhhbmRsZSB0aGlzIGV2ZW50IGRvd24gdGhlIGZlYXR1cmUgY2hhaW4gb2YgcmVzcG9uc2liaWxpdHlcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlV2hlZWxNb3ZlZDogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMubmV4dCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0LmhhbmRsZVdoZWVsTW92ZWQoZ3JpZCwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBGZWF0dXJlLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGhhbmRsZSB0aGlzIGV2ZW50IGRvd24gdGhlIGZlYXR1cmUgY2hhaW4gb2YgcmVzcG9uc2liaWxpdHlcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlRG91YmxlQ2xpY2s6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dC5oYW5kbGVEb3VibGVDbGljayhncmlkLCBldmVudCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEZlYXR1cmUucHJvdG90eXBlXG4gICAgICogQGRlc2MgaGFuZGxlIHRoaXMgZXZlbnQgZG93biB0aGUgZmVhdHVyZSBjaGFpbiBvZiByZXNwb25zaWJpbGl0eVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVIb2xkUHVsc2U6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dC5oYW5kbGVIb2xkUHVsc2UoZ3JpZCwgZXZlbnQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBGZWF0dXJlLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGhhbmRsZSB0aGlzIGV2ZW50IGRvd24gdGhlIGZlYXR1cmUgY2hhaW4gb2YgcmVzcG9uc2liaWxpdHlcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlVGFwOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQuaGFuZGxlVGFwKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRmVhdHVyZS5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBoYW5kbGUgdGhpcyBldmVudCBkb3duIHRoZSBmZWF0dXJlIGNoYWluIG9mIHJlc3BvbnNpYmlsaXR5XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZU1vdXNlRHJhZzogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMubmV4dCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0LmhhbmRsZU1vdXNlRHJhZyhncmlkLCBldmVudCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEZlYXR1cmUucHJvdG90eXBlXG4gICAgICogQGRlc2MgaGFuZGxlIHRoaXMgZXZlbnQgZG93biB0aGUgZmVhdHVyZSBjaGFpbiBvZiByZXNwb25zaWJpbGl0eVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVDb250ZXh0TWVudTogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMubmV4dCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0LmhhbmRsZUNvbnRleHRNZW51KGdyaWQsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRmVhdHVyZS5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyB0b2dnbGUgdGhlIGNvbHVtbiBwaWNrZXJcbiAgICAgKi9cblxuICAgIHRvZ2dsZUNvbHVtblBpY2tlcjogZnVuY3Rpb24oZ3JpZCkge1xuICAgICAgICBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQudG9nZ2xlQ29sdW1uUGlja2VyKGdyaWQpO1xuICAgICAgICB9XG4gICAgfSxcblxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEZlYXR1cmUucHJvdG90eXBlXG4gICAgICogQGRlc2MgdG9nZ2xlIHRoZSBjb2x1bW4gcGlja2VyXG4gICAgICovXG5cbiAgICBtb3ZlU2luZ2xlU2VsZWN0OiBmdW5jdGlvbihncmlkLCB4LCB5KSB7XG4gICAgICAgIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dC5tb3ZlU2luZ2xlU2VsZWN0KGdyaWQsIHgsIHkpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBGZWF0dXJlLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGhhbmRsZSB0aGlzIGV2ZW50IGRvd24gdGhlIGZlYXR1cmUgY2hhaW4gb2YgcmVzcG9uc2liaWxpdHlcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaXNGaXhlZFJvdzogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgdmFyIGdyaWRDZWxsID0gZXZlbnQudmlld1BvaW50O1xuICAgICAgICB2YXIgaXNGaXhlZCA9IGdyaWRDZWxsLnkgPCBncmlkLmdldEZpeGVkUm93Q291bnQoKTtcbiAgICAgICAgcmV0dXJuIGlzRml4ZWQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBGZWF0dXJlLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGhhbmRsZSB0aGlzIGV2ZW50IGRvd24gdGhlIGZlYXR1cmUgY2hhaW4gb2YgcmVzcG9uc2liaWxpdHlcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaXNGaXJzdEZpeGVkUm93OiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICB2YXIgZ3JpZENlbGwgPSBldmVudC52aWV3UG9pbnQ7XG4gICAgICAgIHZhciBpc0ZpeGVkID0gZ3JpZENlbGwueSA8IDE7XG4gICAgICAgIHJldHVybiBpc0ZpeGVkO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRmVhdHVyZS5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBoYW5kbGUgdGhpcyBldmVudCBkb3duIHRoZSBmZWF0dXJlIGNoYWluIG9mIHJlc3BvbnNpYmlsaXR5XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGlzRml4ZWRDb2x1bW46IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIHZhciBncmlkQ2VsbCA9IGV2ZW50LnZpZXdQb2ludDtcbiAgICAgICAgdmFyIGlzRml4ZWQgPSBncmlkQ2VsbC54IDwgZ3JpZC5nZXRGaXhlZENvbHVtbkNvdW50KCk7XG4gICAgICAgIHJldHVybiBpc0ZpeGVkO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRmVhdHVyZS5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBoYW5kbGUgdGhpcyBldmVudCBkb3duIHRoZSBmZWF0dXJlIGNoYWluIG9mIHJlc3BvbnNpYmlsaXR5XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGlzRmlyc3RGaXhlZENvbHVtbjogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgdmFyIGdyaWRDZWxsID0gZXZlbnQudmlld1BvaW50O1xuICAgICAgICB2YXIgZWRnZSA9IGdyaWQuaXNTaG93Um93TnVtYmVycygpID8gMCA6IDE7XG4gICAgICAgIHZhciBpc0ZpeGVkID0gZ3JpZENlbGwueCA8IGVkZ2U7XG4gICAgICAgIHJldHVybiBpc0ZpeGVkO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgRmVhdHVyZS5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBoYW5kbGUgdGhpcyBldmVudCBkb3duIHRoZSBmZWF0dXJlIGNoYWluIG9mIHJlc3BvbnNpYmlsaXR5XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGlzVG9wTGVmdDogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgdmFyIGlzVG9wTGVmdCA9IHRoaXMuaXNGaXhlZFJvdyhncmlkLCBldmVudCkgJiYgdGhpcy5pc0ZpeGVkQ29sdW1uKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgcmV0dXJuIGlzVG9wTGVmdDtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIEZlYXR1cmUucHJvdG90eXBlXG4gICAgICogQGRlc2MgaGFuZGxlIHRoaXMgZXZlbnQgZG93biB0aGUgZmVhdHVyZSBjaGFpbiBvZiByZXNwb25zaWJpbGl0eVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBzZXRDdXJzb3I6IGZ1bmN0aW9uKGdyaWQpIHtcbiAgICAgICAgaWYgKHRoaXMubmV4dCkge1xuICAgICAgICAgICAgdGhpcy5uZXh0LnNldEN1cnNvcihncmlkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jdXJzb3IpIHtcbiAgICAgICAgICAgIGdyaWQuYmVDdXJzb3IodGhpcy5jdXJzb3IpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBGZWF0dXJlLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGhhbmRsZSB0aGlzIGV2ZW50IGRvd24gdGhlIGZlYXR1cmUgY2hhaW4gb2YgcmVzcG9uc2liaWxpdHlcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaW5pdGlhbGl6ZU9uOiBmdW5jdGlvbihncmlkKSB7XG4gICAgICAgIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dC5pbml0aWFsaXplT24oZ3JpZCk7XG4gICAgICAgIH1cbiAgICB9XG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEZlYXR1cmU7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBGZWF0dXJlID0gcmVxdWlyZSgnLi9GZWF0dXJlLmpzJyk7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBGaWx0ZXJzID0gRmVhdHVyZS5leHRlbmQoJ0ZpbHRlcnMnLCB7XG5cbiAgICBhbGlhczogJ0ZpbHRlcnMnLFxuXG4gICAgaGFuZGxlVGFwOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICB2YXIgZ3JpZENlbGwgPSBldmVudC5ncmlkQ2VsbDtcbiAgICAgICAgaWYgKGdyaWQuaXNGaWx0ZXJSb3coZ3JpZENlbGwueSkgJiYgZ3JpZENlbGwueCAhPT0gLTEpIHtcbiAgICAgICAgICAgIGdyaWQuZmlsdGVyQ2xpY2tlZChldmVudCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQuaGFuZGxlVGFwKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH1cblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gRmlsdGVycztcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEZlYXR1cmUgPSByZXF1aXJlKCcuL0ZlYXR1cmUuanMnKTtcblxudmFyIGNvbW1hbmRzID0ge1xuICAgIFBBR0VET1dOOiBmdW5jdGlvbihncmlkKSB7IGdyaWQucGFnZURvd24oKTsgfSxcbiAgICBQQUdFVVA6IGZ1bmN0aW9uKGdyaWQpIHsgZ3JpZC5wYWdlVXAoKTsgfSxcbiAgICBQQUdFTEVGVDogZnVuY3Rpb24oZ3JpZCkgeyBncmlkLnBhZ2VMZWZ0KCk7IH0sXG4gICAgUEFHRVJJR0hUOiBmdW5jdGlvbihncmlkKSB7IGdyaWQucGFnZVJpZ2h0KCk7IH1cbn07XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBLZXlQYWdpbmcgPSBGZWF0dXJlLmV4dGVuZCgnS2V5UGFnaW5nJywge1xuXG4gICAgYWxpYXM6ICdLZXlQYWdpbmcnLFxuXG4gICAgLyoqXG4gICAgICogQGRlc2MgSGFuZGxlIHRoaXMgZXZlbnQgZG93biB0aGUgZmVhdHVyZSBjaGFpbiBvZiByZXNwb25zaWJpbGl0eS5cbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICogQG1lbWJlck9mIEtleVBhZ2luZy5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBoYW5kbGVLZXlEb3duOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICB2YXIgZGV0YWlsID0gZXZlbnQuZGV0YWlsLmNoYXI7XG4gICAgICAgIHZhciBmdW5jID0gY29tbWFuZHNbZGV0YWlsXTtcbiAgICAgICAgaWYgKGZ1bmMpIHtcbiAgICAgICAgICAgIGZ1bmMoZ3JpZCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5uZXh0KSB7XG4gICAgICAgICAgICB0aGlzLm5leHQuaGFuZGxlS2V5RG93bihncmlkLCBldmVudCk7XG4gICAgICAgIH1cbiAgICB9XG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEtleVBhZ2luZztcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEZlYXR1cmUgPSByZXF1aXJlKCcuL0ZlYXR1cmUuanMnKTtcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIE9uSG92ZXIgPSBGZWF0dXJlLmV4dGVuZCgnT25Ib3ZlcicsIHtcblxuICAgIGFsaWFzOiAnT25Ib3ZlcicsXG5cbiAgICAvKipcbiAgICAgKiBAZGVzYyBIaGFuZGxlIHRoaXMgZXZlbnQgZG93biB0aGUgZmVhdHVyZSBjaGFpbiBvZiByZXNwb25zaWJpbGl0eS5cbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICogQG1lbWJlck9mIE9uSG92ZXIucHJvdG90eXBlXG4gICAgICovXG4gICAgaGFuZGxlTW91c2VNb3ZlOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICB2YXIgY3VycmVudEhvdmVyQ2VsbCA9IGdyaWQuZ2V0SG92ZXJDZWxsKCk7XG4gICAgICAgIGlmICghZXZlbnQuZ3JpZENlbGwuZXF1YWxzKGN1cnJlbnRIb3ZlckNlbGwpKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudEhvdmVyQ2VsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlTW91c2VFeGl0KGdyaWQsIGN1cnJlbnRIb3ZlckNlbGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5oYW5kbGVNb3VzZUVudGVyKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgICAgIGdyaWQuc2V0SG92ZXJDZWxsKGV2ZW50LmdyaWRDZWxsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5leHQuaGFuZGxlTW91c2VNb3ZlKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0gT25Ib3ZlcjtcbiIsIi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuLyogZ2xvYmFsIHJlcXVlc3RBbmltYXRpb25GcmFtZSAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBGZWF0dXJlID0gcmVxdWlyZSgnLi9GZWF0dXJlLmpzJyk7XG5cbnZhciBBTklNQVRJT05fVElNRSA9IDIwMDtcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIE92ZXJsYXkgPSBGZWF0dXJlLmV4dGVuZCgnT3ZlcmxheScsIHtcblxuICAgIGFsaWFzOiAnT3ZlcmxheScsXG5cbiAgICAvKipcbiAgICAgKiBpcyB0aGUgZWRpdG9yIG9wZW5cbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKiBAbWVtYmVyT2YgT3ZlcmxheS5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBvcGVuRWRpdG9yOiBmYWxzZSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBPdmVybGF5LnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGhhbmRsZSB0aGlzIGV2ZW50IGRvd24gdGhlIGZlYXR1cmUgY2hhaW4gb2YgcmVzcG9uc2liaWxpdHlcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlS2V5VXA6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIHZhciBrZXkgPSBldmVudC5kZXRhaWwuY2hhci50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB2YXIga2V5cyA9IGdyaWQucmVzb2x2ZVByb3BlcnR5KCdlZGl0b3JBY3RpdmF0aW9uS2V5cycpO1xuICAgICAgICBpZiAoa2V5cy5pbmRleE9mKGtleSkgPiAtMSkge1xuICAgICAgICAgICAgdGhpcy50b2dnbGVDb2x1bW5QaWNrZXIoZ3JpZCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIE92ZXJsYXkucHJvdG90eXBlXG4gICAgICogQGRlc2MgdG9nZ2xlIHRoZSBjb2x1bW4gcGlja2VyIG9uL29mZlxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICovXG4gICAgdG9nZ2xlQ29sdW1uUGlja2VyOiBmdW5jdGlvbihncmlkKSB7XG4gICAgICAgIGlmICh0aGlzLmlzQ29sdW1uUGlja2VyT3BlbihncmlkKSkge1xuICAgICAgICAgICAgdGhpcy5jbG9zZUNvbHVtblBpY2tlcihncmlkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMub3BlbkNvbHVtblBpY2tlcihncmlkKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgT3ZlcmxheS5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyByZXR1cm5zIHRydWUgaWYgdGhlIGNvbHVtbiBwaWNrZXIgaXMgb3BlblxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICovXG4gICAgaXNDb2x1bW5QaWNrZXJPcGVuOiBmdW5jdGlvbihncmlkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm92ZXJsYXkuc3R5bGUuZGlzcGxheSAhPT0gJ25vbmUnO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgT3ZlcmxheS5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBvcGVuIHRoZSBjb2x1bW4gcGlja2VyXG4gICAgICogIyMjIyByZXR1cm5zOiB0eXBlXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKi9cbiAgICBvcGVuQ29sdW1uUGlja2VyOiBmdW5jdGlvbihncmlkKSB7XG4gICAgICAgIGlmICh0aGlzLmlzQ29sdW1uUGlja2VyT3BlbigpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vcGVuRWRpdG9yID0gdHJ1ZTtcbiAgICAgICAgaWYgKGdyaWQuZ2V0QmVoYXZpb3IoKS5vcGVuRWRpdG9yKHRoaXMub3ZlcmxheSkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIHRoaXMub3ZlcmxheS5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBncmlkLnJlc29sdmVQcm9wZXJ0eSgnYmFja2dyb3VuZENvbG9yJyk7XG5cbiAgICAgICAgdGhpcy5vdmVybGF5LnN0eWxlLnRvcCA9ICcwJSc7XG4gICAgICAgIHRoaXMub3ZlcmxheS5zdHlsZS5yaWdodCA9ICcwJSc7XG4gICAgICAgIHRoaXMub3ZlcmxheS5zdHlsZS5ib3R0b20gPSAnMCUnO1xuICAgICAgICB0aGlzLm92ZXJsYXkuc3R5bGUubGVmdCA9ICcwJSc7XG5cbiAgICAgICAgdGhpcy5vdmVybGF5LnN0eWxlLm1hcmdpblRvcCA9ICcxNXB4JztcbiAgICAgICAgdGhpcy5vdmVybGF5LnN0eWxlLm1hcmdpblJpZ2h0ID0gJzM1cHgnO1xuICAgICAgICB0aGlzLm92ZXJsYXkuc3R5bGUubWFyZ2luQm90dG9tID0gJzM1cHgnO1xuICAgICAgICB0aGlzLm92ZXJsYXkuc3R5bGUubWFyZ2luTGVmdCA9ICcxNXB4JztcblxuICAgICAgICBzZWxmLm92ZXJsYXkuc3R5bGUuZGlzcGxheSA9ICcnO1xuXG5cbiAgICAgICAgaWYgKCF0aGlzLl9jbG9zZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX2Nsb3NlciA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICB2YXIga2V5ID0gc2VsZi5nZXRDaGFyRm9yKGdyaWQsIGUua2V5Q29kZSkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICB2YXIga2V5cyA9IGdyaWQucmVzb2x2ZVByb3BlcnR5KCdlZGl0b3JBY3RpdmF0aW9uS2V5cycpO1xuICAgICAgICAgICAgICAgIGlmIChrZXlzLmluZGV4T2Yoa2V5KSA+IC0xIHx8IGUua2V5Q29kZSA9PT0gMjcpIHtcbiAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgICAgICBzZWxmLmNsb3NlQ29sdW1uUGlja2VyKGdyaWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICAvL2dyaWQuc2V0Rm9jdXNhYmxlKGZhbHNlKTtcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgc2VsZi5vdmVybGF5LnN0eWxlLm9wYWNpdHkgPSAwLjk1O1xuICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIHNlbGYuX2Nsb3NlciwgZmFsc2UpO1xuICAgICAgICB9KTtcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHNlbGYub3ZlcmxheS5mb2N1cygpO1xuICAgICAgICB9LCAxMDApO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgT3ZlcmxheS5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBjbG9zZSB0aGUgY29sdW1uIHBpY2tlclxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICovXG4gICAgY2xvc2VDb2x1bW5QaWNrZXI6IGZ1bmN0aW9uKGdyaWQpIHtcbiAgICAgICAgLy9ncmlkLnNldEZvY3VzYWJsZSh0cnVlKTtcblxuICAgICAgICBpZiAoIXRoaXMuaXNDb2x1bW5QaWNrZXJPcGVuKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcGVuRWRpdG9yKSB7XG4gICAgICAgICAgICB0aGlzLm9wZW5FZGl0b3IgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZ3JpZC5nZXRCZWhhdmlvcigpLmNsb3NlRWRpdG9yKHRoaXMub3ZlcmxheSkgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5fY2xvc2VyLCBmYWxzZSk7XG5cbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHNlbGYub3ZlcmxheS5zdHlsZS5vcGFjaXR5ID0gMDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHNlbGYub3ZlcmxheS5pbm5lckhUTUwgPSAnJztcbiAgICAgICAgICAgIHNlbGYub3ZlcmxheS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgICAgZ3JpZC50YWtlRm9jdXMoKTtcbiAgICAgICAgfSwgQU5JTUFUSU9OX1RJTUUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgT3ZlcmxheS5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBpbml0aWFsaXplIG15c2VsZiBpbnRvIHRoZSBncmlkXG4gICAgICogIyMjIyByZXR1cm5zOiB0eXBlXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKi9cbiAgICBpbml0aWFsaXplT246IGZ1bmN0aW9uKGdyaWQpIHtcbiAgICAgICAgdGhpcy5pbml0aWFsaXplT3ZlcmxheVN1cmZhY2UoZ3JpZCk7XG4gICAgICAgIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dC5pbml0aWFsaXplT24oZ3JpZCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIE92ZXJsYXkucHJvdG90eXBlXG4gICAgICogQGRlc2MgaW5pdGlhbGl6ZSB0aGUgb3ZlcmxheSBzdXJmYWNlIGludG8gdGhlIGdyaWRcbiAgICAgKiAjIyMjIHJldHVybnM6IHR5cGVcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqL1xuICAgIGluaXRpYWxpemVPdmVybGF5U3VyZmFjZTogZnVuY3Rpb24oZ3JpZCkge1xuICAgICAgICB0aGlzLm92ZXJsYXkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy5vdmVybGF5LnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCAwKTtcbiAgICAgICAgdGhpcy5vdmVybGF5LnN0eWxlLm91dGxpbmUgPSAnbm9uZSc7XG4gICAgICAgIHRoaXMub3ZlcmxheS5zdHlsZS5ib3hTaGFkb3cgPSAnMCAxOXB4IDM4cHggcmdiYSgwLDAsMCwwLjMwKSwgMCAxNXB4IDEycHggcmdiYSgwLDAsMCwwLjIyKSc7XG4gICAgICAgIHRoaXMub3ZlcmxheS5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICAgIHRoaXMub3ZlcmxheS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICB0aGlzLm92ZXJsYXkuc3R5bGUudHJhbnNpdGlvbiA9ICdvcGFjaXR5ICcgKyBBTklNQVRJT05fVElNRSArICdtcyBlYXNlLWluJztcbiAgICAgICAgdGhpcy5vdmVybGF5LnN0eWxlLm9wYWNpdHkgPSAwO1xuICAgICAgICB0aGlzLm92ZXJsYXkuc3R5bGUuekluZGV4ID0gMTA7XG4gICAgICAgIGdyaWQuZGl2LmFwcGVuZENoaWxkKHRoaXMub3ZlcmxheSk7XG4gICAgICAgIC8vZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0aGlzLm92ZXJsYXkpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgT3ZlcmxheS5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBnZXQgYSBodW1hbiByZWFkYWJsZSBkZXNjcmlwdGlvbiBvZiB0aGUga2V5IHByZXNzZWQgZnJvbSBpdCdzIGludGVnZXIgcmVwcmVzZW50YXRpb25cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGludGVnZXIgLSB0aGUgaW50ZWdlciB3ZSB3YW50IHRoZSBjaGFyIGZvclxuICAgICAqL1xuICAgIGdldENoYXJGb3I6IGZ1bmN0aW9uKGdyaWQsIGludGVnZXIpIHtcbiAgICAgICAgdmFyIGNoYXJNYXAgPSBncmlkLmdldENhbnZhcygpLmdldENoYXJNYXAoKTtcbiAgICAgICAgcmV0dXJuIGNoYXJNYXBbaW50ZWdlcl1bMF07XG4gICAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBPdmVybGF5O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQ29sdW1uUmVzaXppbmcgPSByZXF1aXJlKCcuL0NvbHVtblJlc2l6aW5nJyk7XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciBSb3dSZXNpemluZyA9IENvbHVtblJlc2l6aW5nLmV4dGVuZCgnUm93UmVzaXppbmcnLCB7XG5cbiAgICBhbGlhczogJ1Jvd1Jlc2l6aW5nJyxcblxuICAgIC8qKlxuICAgICAqIHRoZSBpbmRleCBvZiB0aGUgcm93L2NvbHVtbiB3ZSBhcmUgZHJhZ2dpbmdcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqIEBkZWZhdWx0IC0xXG4gICAgICogQG1lbWJlck9mIFJvd1Jlc2l6aW5nLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGRyYWdBcmVhOiAtMSxcblxuICAgIC8qKlxuICAgICAqIHRoZSBwaXhlbCBsb2NhdGlvbiBvZiB0aGUgd2hlcmUgdGhlIGRyYWcgd2FzIGluaXRpYXRlZFxuICAgICAqIEB0eXBlIHtudW1iZXJ9XG4gICAgICogQGRlZmF1bHQgLTFcbiAgICAgKiBAbWVtYmVyT2YgUm93UmVzaXppbmcucHJvdG90eXBlXG4gICAgICovXG4gICAgZHJhZ1N0YXJ0OiAtMSxcblxuICAgIC8qKlxuICAgICAqIHRoZSBzdGFydGluZyB3aWR0aC9oZWlnaHQgb2YgdGhlIHJvdy9jb2x1bW4gd2UgYXJlIGRyYWdnaW5nXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAtMVxuICAgICAqIEBtZW1iZXJPZiBSb3dSZXNpemluZy5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBkcmFnQXJlYVN0YXJ0aW5nU2l6ZTogLTEsXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUm93UmVzaXppbmcucHJvdG90eXBlXG4gICAgICogQGRlc2MgZ2V0IHRoZSBtb3VzZSB4LHkgY29vcmRpbmF0ZVxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICogQHBhcmFtIHtNb3VzZUV2ZW50fSBldmVudCAtIHRoZSBtb3VzZSBldmVudCB0byBxdWVyeVxuICAgICAqL1xuICAgIGdldE1vdXNlVmFsdWU6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgIHJldHVybiBldmVudC5wcmltaXRpdmVFdmVudC5kZXRhaWwubW91c2UueTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQG1lbWJlck9mIFJvd1Jlc2l6aW5nLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGdldCB0aGUgZ3JpZCBjZWxsIHgseSBjb29yZGluYXRlXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKiBAcGFyYW0ge1BvaW50fSBncmlkQ2VsbFxuICAgICAqL1xuICAgIGdldEdyaWRDZWxsVmFsdWU6IGZ1bmN0aW9uKGdyaWRDZWxsKSB7XG4gICAgICAgIHJldHVybiBncmlkQ2VsbC54O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyT2YgUm93UmVzaXppbmcucHJvdG90eXBlXG4gICAgICogQGRlc2MgcmV0dXJuIHRoZSBncmlkcyB4LHkgc2Nyb2xsIHZhbHVlXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqL1xuICAgIGdldFNjcm9sbFZhbHVlOiBmdW5jdGlvbihncmlkKSB7XG4gICAgICAgIHJldHVybiBncmlkLmdldFZTY3JvbGxWYWx1ZSgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAZnVuY3Rpb25cbiAgICAgKiBAbWVtYmVyT2YgUm93UmVzaXppbmcucHJvdG90eXBlXG4gICAgICogQGRlc2MgcmV0dXJuIHRoZSB3aWR0aC9oZWlnaHQgb2YgdGhlIHJvdy9jb2x1bW4gb2YgaW50ZXJlc3RcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gdGhlIHJvdy9jb2x1bW4gaW5kZXggb2YgaW50ZXJlc3RcbiAgICAgKi9cbiAgICBnZXRBcmVhU2l6ZTogZnVuY3Rpb24oZ3JpZCwgaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGdyaWQuZ2V0Um93SGVpZ2h0KGluZGV4KTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQG1lbWJlck9mIFJvd1Jlc2l6aW5nLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIHNldCB0aGUgd2lkdGgvaGVpZ2h0IG9mIHRoZSByb3cvY29sdW1uIGF0IGluZGV4XG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCAtIHRoZSByb3cvY29sdW1uIGluZGV4IG9mIGludGVyZXN0XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIC0gdGhlIHdpZHRoL2hlaWdodCB0byBzZXQgdG9cbiAgICAgKi9cbiAgICBzZXRBcmVhU2l6ZTogZnVuY3Rpb24oZ3JpZCwgaW5kZXgsIHZhbHVlKSB7XG4gICAgICAgIGdyaWQuc2V0Um93SGVpZ2h0KGluZGV4LCB2YWx1ZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBtZW1iZXJPZiBSb3dSZXNpemluZy5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyByZXR1cm5zIHRoZSBpbmRleCBvZiB3aGljaCBkaXZpZGVyIEknbSBvdmVyXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgb3ZlckFyZWFEaXZpZGVyOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuICAgICAgICByZXR1cm4gZ3JpZC5vdmVyUm93RGl2aWRlcihldmVudCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBtZW1iZXJPZiBSb3dSZXNpemluZy5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBhbSBJIG92ZXIgdGhlIGNvbHVtbi9yb3cgYXJlYVxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBpc0ZpcnN0Rml4ZWRPdGhlckFyZWE6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzRmlyc3RGaXhlZENvbHVtbihncmlkLCBldmVudCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBtZW1iZXJPZiBSb3dSZXNpemluZy5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyByZXR1cm4gdGhlIGN1cnNvciBuYW1lXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBnZXRDdXJzb3JOYW1lOiBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuICdyb3ctcmVzaXplJztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQGZ1bmN0aW9uXG4gICAgICogQG1lbWJlck9mIFJvd1Jlc2l6aW5nLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIHJldHVybiB0aGUgcmVjZW50bHkgcmVuZGVyZWQgYXJlYSdzIHdpZHRoL2hlaWdodFxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXggLSB0aGUgcm93L2NvbHVtbiBpbmRleCBvZiBpbnRlcmVzdFxuICAgICAqL1xuICAgIGdldFByZXZpb3VzQWJzb2x1dGVTaXplOiBmdW5jdGlvbihncmlkLCBpbmRleCkge1xuICAgICAgICByZXR1cm4gZ3JpZC5nZXRSZW5kZXJlZEhlaWdodChpbmRleCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBmdW5jdGlvblxuICAgICAqIEBtZW1iZXJPZiBSb3dSZXNpemluZy5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyByZXR1cm4gdGhlIGZpeGVkIGFyZWEgcm93cy9jb2x1bW5zIGNvdW50XG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqL1xuICAgIGdldE90aGVyRml4ZWRBcmVhQ291bnQ6IGZ1bmN0aW9uKGdyaWQpIHtcbiAgICAgICAgcmV0dXJuIGdyaWQuZ2V0Rml4ZWRDb2x1bW5Db3VudCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHJldHVybnMge251bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAtMlxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5SZXNpemluZy5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBnZXRGaXhlZEFyZWFDb3VudDogZnVuY3Rpb24oZ3JpZCkge1xuICAgICAgICByZXR1cm4gZ3JpZC5nZXRGaXhlZFJvd0NvdW50KCkgKyBncmlkLmdldEhlYWRlclJvd0NvdW50KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKiBAZGVmYXVsdCAtMlxuICAgICAqIEBtZW1iZXJPZiBDb2x1bW5SZXNpemluZy5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBpc0VuYWJsZWQ6IGZ1bmN0aW9uKGdyaWQpIHtcbiAgICAgICAgcmV0dXJuIGdyaWQuaXNSb3dSZXNpemVhYmxlKCk7XG4gICAgfVxuXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBSb3dSZXNpemluZztcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEZlYXR1cmUgPSByZXF1aXJlKCcuL0ZlYXR1cmUuanMnKTtcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIFJvd1NlbGVjdGlvbiA9IEZlYXR1cmUuZXh0ZW5kKCdSb3dTZWxlY3Rpb24nLCB7XG5cbiAgICBhbGlhczogJ1Jvd1NlbGVjdGlvbicsXG5cbiAgICAvKipcbiAgICAgKiBUaGUgcGl4ZWwgbG9jYXRpb24gb2YgdGhlIG1vdXNlIHBvaW50ZXIgZHVyaW5nIGEgZHJhZyBvcGVyYXRpb24uXG4gICAgICogQHR5cGUge1BvaW50fVxuICAgICAqIEBkZWZhdWx0IG51bGxcbiAgICAgKiBAbWVtYmVyT2YgUm93U2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqL1xuICAgIGN1cnJlbnREcmFnOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogVGhlIGNlbGwgY29vcmRpbmF0ZXMgb2YgdGhlIHdoZXJlIHRoZSBtb3VzZSBwb2ludGVyIGlzIGR1cmluZyBhIGRyYWcgb3BlcmF0aW9uLlxuICAgICAqIEB0eXBlIHtPYmplY3R9XG4gICAgICogQGRlZmF1bHQgbnVsbFxuICAgICAqIEBtZW1iZXJPZiBSb3dTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICovXG4gICAgbGFzdERyYWdDZWxsOiBudWxsLFxuXG4gICAgLyoqXG4gICAgICogYSBtaWxsaXNlY29uZCB2YWx1ZSByZXByZXNlbnRpbmcgdGhlIHByZXZpb3VzIHRpbWUgYW4gYXV0b3Njcm9sbCBzdGFydGVkXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICogQG1lbWJlck9mIFJvd1NlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBzYkxhc3RBdXRvOiAwLFxuXG4gICAgLyoqXG4gICAgICogYSBtaWxsaXNlY29uZCB2YWx1ZSByZXByZXNlbnRpbmcgdGhlIHRpbWUgdGhlIGN1cnJlbnQgYXV0b3Njcm9sbCBzdGFydGVkXG4gICAgICogQHR5cGUge251bWJlcn1cbiAgICAgKiBAZGVmYXVsdCAwXG4gICAgICogQG1lbWJlck9mIFJvd1NlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKi9cbiAgICBzYkF1dG9TdGFydDogMCxcblxuICAgIGRyYWdBcm1lZDogZmFsc2UsXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUm93U2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIEhhbmRsZSB0aGlzIGV2ZW50IGRvd24gdGhlIGZlYXR1cmUgY2hhaW4gb2YgcmVzcG9uc2liaWxpdHkuXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZU1vdXNlVXA6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIGlmICh0aGlzLmRyYWdBcm1lZCkge1xuICAgICAgICAgICAgdGhpcy5kcmFnQXJtZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIC8vZ2xvYmFsIHJvdyBzZWxlY3Rpb25cbiAgICAgICAgICAgIGlmIChldmVudC5ncmlkQ2VsbC54ID09PSAtMSAmJiBldmVudC5ncmlkQ2VsbC55ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgZ3JpZC50b2dnbGVTZWxlY3RBbGxSb3dzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBncmlkLmZpcmVTeW50aGV0aWNSb3dTZWxlY3Rpb25DaGFuZ2VkRXZlbnQoKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmRyYWdnaW5nKSB7XG4gICAgICAgICAgICB0aGlzLmRyYWdnaW5nID0gZmFsc2U7XG4gICAgICAgICAgICBncmlkLmZpcmVTeW50aGV0aWNSb3dTZWxlY3Rpb25DaGFuZ2VkRXZlbnQoKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgIHRoaXMubmV4dC5oYW5kbGVNb3VzZVVwKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUm93U2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBkZXNjICogQGRlc2MgSGFuZGxlIHRoaXMgZXZlbnQgZG93biB0aGUgZmVhdHVyZSBjaGFpbiBvZiByZXNwb25zaWJpbGl0eS5cbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlTW91c2VEb3duOiBmdW5jdGlvbihncmlkLCBldmVudCkge1xuXG4gICAgICAgIHZhciBpc1JpZ2h0Q2xpY2sgPSBldmVudC5wcmltaXRpdmVFdmVudC5kZXRhaWwuaXNSaWdodENsaWNrO1xuICAgICAgICB2YXIgY2VsbCA9IGV2ZW50LmdyaWRDZWxsO1xuICAgICAgICB2YXIgdmlld0NlbGwgPSBldmVudC52aWV3UG9pbnQ7XG4gICAgICAgIHZhciBkeCA9IGNlbGwueDtcbiAgICAgICAgdmFyIGR5ID0gY2VsbC55O1xuXG5cbiAgICAgICAgdmFyIGlzSGVhZGVyID0gZ3JpZC5pc1Nob3dSb3dOdW1iZXJzKCkgJiYgZHggPCAwO1xuXG4gICAgICAgIGlmICghZ3JpZC5pc1Jvd1NlbGVjdGlvbigpIHx8IGlzUmlnaHRDbGljayB8fCAhaXNIZWFkZXIpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5leHQuaGFuZGxlTW91c2VEb3duKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgdmFyIG51bUZpeGVkUm93cyA9IGdyaWQuZ2V0Rml4ZWRSb3dDb3VudCgpO1xuXG4gICAgICAgICAgICAvL2lmIHdlIGFyZSBpbiB0aGUgZml4ZWQgYXJlYSBkbyBub3QgYXBwbHkgdGhlIHNjcm9sbCB2YWx1ZXNcbiAgICAgICAgICAgIC8vY2hlY2sgYm90aCB4IGFuZCB5IHZhbHVlcyBpbmRlcGVuZGVudGx5XG4gICAgICAgICAgICBpZiAodmlld0NlbGwueSA8IG51bUZpeGVkUm93cykge1xuICAgICAgICAgICAgICAgIGR5ID0gdmlld0NlbGwueTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGRDZWxsID0gZ3JpZC5uZXdQb2ludCgwLCBkeSk7XG5cbiAgICAgICAgICAgIHZhciBwcmltRXZlbnQgPSBldmVudC5wcmltaXRpdmVFdmVudDtcbiAgICAgICAgICAgIHZhciBrZXlzID0gcHJpbUV2ZW50LmRldGFpbC5rZXlzO1xuICAgICAgICAgICAgdGhpcy5kcmFnQXJtZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5leHRlbmRTZWxlY3Rpb24oZ3JpZCwgZENlbGwsIGtleXMpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSb3dTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2MgaGFuZGxlIHRoaXMgZXZlbnQgZG93biB0aGUgZmVhdHVyZSBjaGFpbiBvZiByZXNwb25zaWJpbGl0eVxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVNb3VzZURyYWc6IGZ1bmN0aW9uKGdyaWQsIGV2ZW50KSB7XG4gICAgICAgIHZhciBpc1JpZ2h0Q2xpY2sgPSBldmVudC5wcmltaXRpdmVFdmVudC5kZXRhaWwuaXNSaWdodENsaWNrO1xuXG4gICAgICAgIGlmICghdGhpcy5kcmFnQXJtZWQgfHwgIWdyaWQuaXNSb3dTZWxlY3Rpb24oKSB8fCBpc1JpZ2h0Q2xpY2spIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5leHQuaGFuZGxlTW91c2VEcmFnKGdyaWQsIGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZHJhZ2dpbmcgPSB0cnVlO1xuICAgICAgICAgICAgdmFyIG51bUZpeGVkUm93cyA9IGdyaWQuZ2V0Rml4ZWRSb3dDb3VudCgpO1xuXG4gICAgICAgICAgICB2YXIgY2VsbCA9IGV2ZW50LmdyaWRDZWxsO1xuICAgICAgICAgICAgdmFyIHZpZXdDZWxsID0gZXZlbnQudmlld1BvaW50O1xuICAgICAgICAgICAgLy92YXIgZHggPSBjZWxsLng7XG4gICAgICAgICAgICB2YXIgZHkgPSBjZWxsLnk7XG5cbiAgICAgICAgICAgIC8vaWYgd2UgYXJlIGluIHRoZSBmaXhlZCBhcmVhIGRvIG5vdCBhcHBseSB0aGUgc2Nyb2xsIHZhbHVlc1xuICAgICAgICAgICAgLy9jaGVjayBib3RoIHggYW5kIHkgdmFsdWVzIGluZGVwZW5kZW50bHlcbiAgICAgICAgICAgIGlmICh2aWV3Q2VsbC55IDwgbnVtRml4ZWRSb3dzKSB7XG4gICAgICAgICAgICAgICAgZHkgPSB2aWV3Q2VsbC55O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgZENlbGwgPSBncmlkLm5ld1BvaW50KDAsIGR5KTtcblxuICAgICAgICAgICAgdmFyIHByaW1FdmVudCA9IGV2ZW50LnByaW1pdGl2ZUV2ZW50O1xuICAgICAgICAgICAgdGhpcy5jdXJyZW50RHJhZyA9IHByaW1FdmVudC5kZXRhaWwubW91c2U7XG4gICAgICAgICAgICB0aGlzLmxhc3REcmFnQ2VsbCA9IGRDZWxsO1xuXG4gICAgICAgICAgICB0aGlzLmNoZWNrRHJhZ1Njcm9sbChncmlkLCB0aGlzLmN1cnJlbnREcmFnKTtcbiAgICAgICAgICAgIHRoaXMuaGFuZGxlTW91c2VEcmFnQ2VsbFNlbGVjdGlvbihncmlkLCBkQ2VsbCwgcHJpbUV2ZW50LmRldGFpbC5rZXlzKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUm93U2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGhhbmRsZSB0aGlzIGV2ZW50IGRvd24gdGhlIGZlYXR1cmUgY2hhaW4gb2YgcmVzcG9uc2liaWxpdHlcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIHRoZSBldmVudCBkZXRhaWxzXG4gICAgICovXG4gICAgaGFuZGxlS2V5RG93bjogZnVuY3Rpb24oZ3JpZCwgZXZlbnQpIHtcbiAgICAgICAgaWYgKGdyaWQuZ2V0TGFzdFNlbGVjdGlvblR5cGUoKSAhPT0gJ3JvdycpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm5leHQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5leHQuaGFuZGxlS2V5RG93bihncmlkLCBldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNvbW1hbmQgPSAnaGFuZGxlJyArIGV2ZW50LmRldGFpbC5jaGFyO1xuICAgICAgICBpZiAodGhpc1tjb21tYW5kXSkge1xuICAgICAgICAgICAgdGhpc1tjb21tYW5kXS5jYWxsKHRoaXMsIGdyaWQsIGV2ZW50LmRldGFpbCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJvd1NlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBIYW5kbGUgYSBtb3VzZWRyYWcgc2VsZWN0aW9uXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbW91c2UgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGtleXMgLSBhcnJheSBvZiB0aGUga2V5cyB0aGF0IGFyZSBjdXJyZW50bHkgcHJlc3NlZCBkb3duXG4gICAgICovXG4gICAgaGFuZGxlTW91c2VEcmFnQ2VsbFNlbGVjdGlvbjogZnVuY3Rpb24oZ3JpZCwgZ3JpZENlbGwsIGtleXMpIHtcblxuICAgICAgICAvL3ZhciBiZWhhdmlvciA9IGdyaWQuZ2V0QmVoYXZpb3IoKTtcbiAgICAgICAgdmFyIHkgPSBncmlkQ2VsbC55O1xuICAgICAgICAvLyAgICAgICAgICAgIHZhciBwcmV2aW91c0RyYWdFeHRlbnQgPSBncmlkLmdldERyYWdFeHRlbnQoKTtcbiAgICAgICAgdmFyIG1vdXNlRG93biA9IGdyaWQuZ2V0TW91c2VEb3duKCk7XG5cbiAgICAgICAgdmFyIG5ld1kgPSB5IC0gbW91c2VEb3duLnk7XG4gICAgICAgIC8vdmFyIG5ld1kgPSB5IC0gbW91c2VEb3duLnk7XG5cbiAgICAgICAgLy8gaWYgKHByZXZpb3VzRHJhZ0V4dGVudC54ID09PSBuZXdYICYmIHByZXZpb3VzRHJhZ0V4dGVudC55ID09PSBuZXdZKSB7XG4gICAgICAgIC8vICAgICByZXR1cm47XG4gICAgICAgIC8vIH1cblxuICAgICAgICBncmlkLmNsZWFyTW9zdFJlY2VudFJvd1NlbGVjdGlvbigpO1xuXG4gICAgICAgIGdyaWQuc2VsZWN0Um93KG1vdXNlRG93bi55LCB5KTtcbiAgICAgICAgZ3JpZC5zZXREcmFnRXh0ZW50KGdyaWQubmV3UG9pbnQoMCwgbmV3WSkpO1xuXG4gICAgICAgIGdyaWQucmVwYWludCgpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUm93U2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIHRoaXMgY2hlY2tzIHdoaWxlIHdlcmUgZHJhZ2dpbmcgaWYgd2UgZ28gb3V0c2lkZSB0aGUgdmlzaWJsZSBib3VuZHMsIGlmIHNvLCBraWNrIG9mZiB0aGUgZXh0ZXJuYWwgYXV0b3Njcm9sbCBjaGVjayBmdW5jdGlvbiAoYWJvdmUpXG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gbW91c2UgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGNoZWNrRHJhZ1Njcm9sbDogZnVuY3Rpb24oZ3JpZCwgbW91c2UpIHtcbiAgICAgICAgaWYgKCFncmlkLnJlc29sdmVQcm9wZXJ0eSgnc2Nyb2xsaW5nRW5hYmxlZCcpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGIgPSBncmlkLmdldERhdGFCb3VuZHMoKTtcbiAgICAgICAgdmFyIGluc2lkZSA9IGIuY29udGFpbnMobW91c2UpO1xuICAgICAgICBpZiAoaW5zaWRlKSB7XG4gICAgICAgICAgICBpZiAoZ3JpZC5pc1Njcm9sbGluZ05vdygpKSB7XG4gICAgICAgICAgICAgICAgZ3JpZC5zZXRTY3JvbGxpbmdOb3coZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKCFncmlkLmlzU2Nyb2xsaW5nTm93KCkpIHtcbiAgICAgICAgICAgIGdyaWQuc2V0U2Nyb2xsaW5nTm93KHRydWUpO1xuICAgICAgICAgICAgdGhpcy5zY3JvbGxEcmFnKGdyaWQpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSb3dTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2MgdGhpcyBmdW5jdGlvbiBtYWtlcyBzdXJlIHRoYXQgd2hpbGUgd2UgYXJlIGRyYWdnaW5nIG91dHNpZGUgb2YgdGhlIGdyaWQgdmlzaWJsZSBib3VuZHMsIHdlIHNyY3JvbGwgYWNjb3JkaW5nbHlcbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqL1xuICAgIHNjcm9sbERyYWc6IGZ1bmN0aW9uKGdyaWQpIHtcbiAgICAgICAgaWYgKCFncmlkLmlzU2Nyb2xsaW5nTm93KCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBsYXN0RHJhZ0NlbGwgPSB0aGlzLmxhc3REcmFnQ2VsbDtcbiAgICAgICAgdmFyIGIgPSBncmlkLmdldERhdGFCb3VuZHMoKTtcbiAgICAgICAgdmFyIHhPZmZzZXQgPSAwO1xuICAgICAgICB2YXIgeU9mZnNldCA9IDA7XG5cbiAgICAgICAgdmFyIG51bUZpeGVkQ29sdW1ucyA9IGdyaWQuZ2V0Rml4ZWRDb2x1bW5Db3VudCgpO1xuICAgICAgICB2YXIgbnVtRml4ZWRSb3dzID0gZ3JpZC5nZXRGaXhlZFJvd0NvdW50KCk7XG5cbiAgICAgICAgdmFyIGRyYWdFbmRJbkZpeGVkQXJlYVggPSBsYXN0RHJhZ0NlbGwueCA8IG51bUZpeGVkQ29sdW1ucztcbiAgICAgICAgdmFyIGRyYWdFbmRJbkZpeGVkQXJlYVkgPSBsYXN0RHJhZ0NlbGwueSA8IG51bUZpeGVkUm93cztcblxuICAgICAgICBpZiAodGhpcy5jdXJyZW50RHJhZy55IDwgYi5vcmlnaW4ueSkge1xuICAgICAgICAgICAgeU9mZnNldCA9IC0xO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuY3VycmVudERyYWcueSA+IGIub3JpZ2luLnkgKyBiLmV4dGVudC55KSB7XG4gICAgICAgICAgICB5T2Zmc2V0ID0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBkcmFnQ2VsbE9mZnNldFggPSB4T2Zmc2V0O1xuICAgICAgICB2YXIgZHJhZ0NlbGxPZmZzZXRZID0geU9mZnNldDtcblxuICAgICAgICBpZiAoZHJhZ0VuZEluRml4ZWRBcmVhWCkge1xuICAgICAgICAgICAgZHJhZ0NlbGxPZmZzZXRYID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkcmFnRW5kSW5GaXhlZEFyZWFZKSB7XG4gICAgICAgICAgICBkcmFnQ2VsbE9mZnNldFkgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5sYXN0RHJhZ0NlbGwgPSBsYXN0RHJhZ0NlbGwucGx1c1hZKGRyYWdDZWxsT2Zmc2V0WCwgZHJhZ0NlbGxPZmZzZXRZKTtcbiAgICAgICAgZ3JpZC5zY3JvbGxCeSh4T2Zmc2V0LCB5T2Zmc2V0KTtcbiAgICAgICAgdGhpcy5oYW5kbGVNb3VzZURyYWdDZWxsU2VsZWN0aW9uKGdyaWQsIGxhc3REcmFnQ2VsbCwgW10pOyAvLyB1cGRhdGUgdGhlIHNlbGVjdGlvblxuICAgICAgICBncmlkLnJlcGFpbnQoKTtcbiAgICAgICAgc2V0VGltZW91dCh0aGlzLnNjcm9sbERyYWcuYmluZCh0aGlzLCBncmlkKSwgMjUpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUm93U2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGV4dGVuZCBhIHNlbGVjdGlvbiBvciBjcmVhdGUgb25lIGlmIHRoZXJlIGlzbnQgeWV0XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZ3JpZENlbGwgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqIEBwYXJhbSB7QXJyYXl9IGtleXMgLSBhcnJheSBvZiB0aGUga2V5cyB0aGF0IGFyZSBjdXJyZW50bHkgcHJlc3NlZCBkb3duXG4gICAgICovXG4gICAgZXh0ZW5kU2VsZWN0aW9uOiBmdW5jdGlvbihncmlkLCBncmlkQ2VsbCwga2V5cykge1xuICAgICAgICBncmlkLnN0b3BFZGl0aW5nKCk7XG4gICAgICAgIC8vdmFyIGhhc0NUUkwgPSBrZXlzLmluZGV4T2YoJ0NUUkwnKSAhPT0gLTE7XG4gICAgICAgIHZhciBoYXNTSElGVCA9IGtleXMuaW5kZXhPZignU0hJRlQnKSAhPT0gLTE7XG5cbiAgICAgICAgdmFyIG1vdXNlUG9pbnQgPSBncmlkLmdldE1vdXNlRG93bigpO1xuICAgICAgICB2YXIgeCA9IGdyaWRDZWxsLng7IC8vIC0gbnVtRml4ZWRDb2x1bW5zICsgc2Nyb2xsTGVmdDtcbiAgICAgICAgdmFyIHkgPSBncmlkQ2VsbC55OyAvLyAtIG51bUZpeGVkUm93cyArIHNjcm9sbFRvcDtcblxuICAgICAgICAvL3dlcmUgb3V0c2lkZSBvZiB0aGUgZ3JpZCBkbyBub3RoaW5nXG4gICAgICAgIGlmICh4IDwgMCB8fCB5IDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhhc1NISUZUKSB7XG4gICAgICAgICAgICBncmlkLmNsZWFyTW9zdFJlY2VudFJvd1NlbGVjdGlvbigpO1xuICAgICAgICAgICAgZ3JpZC5zZWxlY3RSb3coeSwgbW91c2VQb2ludC55KTtcbiAgICAgICAgICAgIGdyaWQuc2V0RHJhZ0V4dGVudChncmlkLm5ld1BvaW50KDAsIHkgLSBtb3VzZVBvaW50LnkpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdyaWQudG9nZ2xlU2VsZWN0Um93KHksIGtleXMpO1xuICAgICAgICAgICAgZ3JpZC5zZXRNb3VzZURvd24oZ3JpZC5uZXdQb2ludCh4LCB5KSk7XG4gICAgICAgICAgICBncmlkLnNldERyYWdFeHRlbnQoZ3JpZC5uZXdQb2ludCgwLCAwKSk7XG4gICAgICAgIH1cbiAgICAgICAgZ3JpZC5yZXBhaW50KCk7XG4gICAgfSxcblxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJvd1NlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBoYW5kbGUgdGhpcyBldmVudFxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICovXG4gICAgaGFuZGxlRE9XTlNISUZUOiBmdW5jdGlvbihncmlkKSB7XG4gICAgICAgIHRoaXMubW92ZVNoaWZ0U2VsZWN0KGdyaWQsIDEpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUm93U2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGhhbmRsZSB0aGlzIGV2ZW50XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZVVQU0hJRlQ6IGZ1bmN0aW9uKGdyaWQpIHtcbiAgICAgICAgdGhpcy5tb3ZlU2hpZnRTZWxlY3QoZ3JpZCwgLTEpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUm93U2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGhhbmRsZSB0aGlzIGV2ZW50XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZUxFRlRTSElGVDogZnVuY3Rpb24oZ3JpZCkge30sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUm93U2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGhhbmRsZSB0aGlzIGV2ZW50XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZVJJR0hUU0hJRlQ6IGZ1bmN0aW9uKGdyaWQpIHt9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJvd1NlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBoYW5kbGUgdGhpcyBldmVudFxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVET1dOOiBmdW5jdGlvbihncmlkKSB7XG4gICAgICAgIHRoaXMubW92ZVNpbmdsZVNlbGVjdChncmlkLCAxKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJvd1NlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBoYW5kbGUgdGhpcyBldmVudFxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVVUDogZnVuY3Rpb24oZ3JpZCkge1xuICAgICAgICB0aGlzLm1vdmVTaW5nbGVTZWxlY3QoZ3JpZCwgLTEpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUm93U2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIGhhbmRsZSB0aGlzIGV2ZW50XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZUxFRlQ6IGZ1bmN0aW9uKGdyaWQpIHt9LFxuXG4gICAgLyoqXG4gICAgICogQG1lbWJlck9mIFJvd1NlbGVjdGlvbi5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBoYW5kbGUgdGhpcyBldmVudFxuICAgICAqIEBwYXJhbSB7SHlwZXJncmlkfSBncmlkXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGV2ZW50IGRldGFpbHNcbiAgICAgKi9cbiAgICBoYW5kbGVSSUdIVDogZnVuY3Rpb24oZ3JpZCkge1xuXG4gICAgICAgIHZhciBtb3VzZUNvcm5lciA9IGdyaWQuZ2V0TW91c2VEb3duKCkucGx1cyhncmlkLmdldERyYWdFeHRlbnQoKSk7XG4gICAgICAgIHZhciBtYXhDb2x1bW5zID0gZ3JpZC5nZXRDb2x1bW5Db3VudCgpIC0gMTtcblxuICAgICAgICB2YXIgbmV3WCA9IGdyaWQuZ2V0SGVhZGVyQ29sdW1uQ291bnQoKSArIGdyaWQuZ2V0SFNjcm9sbFZhbHVlKCk7XG4gICAgICAgIHZhciBuZXdZID0gbW91c2VDb3JuZXIueTtcblxuICAgICAgICBuZXdYID0gTWF0aC5taW4obWF4Q29sdW1ucywgbmV3WCk7XG5cbiAgICAgICAgZ3JpZC5jbGVhclNlbGVjdGlvbnMoKTtcbiAgICAgICAgZ3JpZC5zZWxlY3QobmV3WCwgbmV3WSwgMCwgMCk7XG4gICAgICAgIGdyaWQuc2V0TW91c2VEb3duKGdyaWQubmV3UG9pbnQobmV3WCwgbmV3WSkpO1xuICAgICAgICBncmlkLnNldERyYWdFeHRlbnQoZ3JpZC5uZXdQb2ludCgwLCAwKSk7XG5cbiAgICAgICAgZ3JpZC5yZXBhaW50KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSb3dTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2MgSWYgd2UgYXJlIGhvbGRpbmcgZG93biB0aGUgc2FtZSBuYXZpZ2F0aW9uIGtleSwgYWNjZWxlcmF0ZSB0aGUgaW5jcmVtZW50IHdlIHNjcm9sbFxuICAgICAqICMjIyMgcmV0dXJuczogaW50ZWdlclxuICAgICAqL1xuICAgIGdldEF1dG9TY3JvbGxBY2NlbGVyYXRpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgY291bnQgPSAxO1xuICAgICAgICB2YXIgZWxhcHNlZCA9IHRoaXMuZ2V0QXV0b1Njcm9sbER1cmF0aW9uKCkgLyAyMDAwO1xuICAgICAgICBjb3VudCA9IE1hdGgubWF4KDEsIE1hdGguZmxvb3IoZWxhcHNlZCAqIGVsYXBzZWQgKiBlbGFwc2VkICogZWxhcHNlZCkpO1xuICAgICAgICByZXR1cm4gY291bnQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSb3dTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2Mgc2V0IHRoZSBzdGFydCB0aW1lIHRvIHJpZ2h0IG5vdyB3aGVuIHdlIGluaXRpYXRlIGFuIGF1dG8gc2Nyb2xsXG4gICAgICovXG4gICAgc2V0QXV0b1Njcm9sbFN0YXJ0VGltZTogZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuc2JBdXRvU3RhcnQgPSBEYXRlLm5vdygpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUm93U2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIHVwZGF0ZSB0aGUgYXV0b3Njcm9sbCBzdGFydCB0aW1lIGlmIHdlIGhhdmVuJ3QgYXV0b3Njcm9sbGVkIHdpdGhpbiB0aGUgbGFzdCA1MDBtcyBvdGhlcndpc2UgdXBkYXRlIHRoZSBjdXJyZW50IGF1dG9zY3JvbGwgdGltZVxuICAgICAqL1xuICAgIHBpbmdBdXRvU2Nyb2xsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIG5vdyA9IERhdGUubm93KCk7XG4gICAgICAgIGlmIChub3cgLSB0aGlzLnNiTGFzdEF1dG8gPiA1MDApIHtcbiAgICAgICAgICAgIHRoaXMuc2V0QXV0b1Njcm9sbFN0YXJ0VGltZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2JMYXN0QXV0byA9IERhdGUubm93KCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSb3dTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2MgYW5zd2VyIGhvdyBsb25nIHdlIGhhdmUgYmVlbiBhdXRvIHNjcm9sbGluZ1xuICAgICAqICMjIyMgcmV0dXJuczogaW50ZWdlclxuICAgICAqL1xuICAgIGdldEF1dG9TY3JvbGxEdXJhdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChEYXRlLm5vdygpIC0gdGhpcy5zYkxhc3RBdXRvID4gNTAwKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gRGF0ZS5ub3coKSAtIHRoaXMuc2JBdXRvU3RhcnQ7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEBtZW1iZXJPZiBSb3dTZWxlY3Rpb24ucHJvdG90eXBlXG4gICAgICogQGRlc2MgQXVnbWVudCB0aGUgbW9zdCByZWNlbnQgc2VsZWN0aW9uIGV4dGVudCBieSAob2Zmc2V0WCxvZmZzZXRZKSBhbmQgc2Nyb2xsIGlmIG5lY2Vzc2FyeS5cbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRYIC0geCBjb29yZGluYXRlIHRvIHN0YXJ0IGF0XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFkgLSB5IGNvb3JkaW5hdGUgdG8gc3RhcnQgYXRcbiAgICAgKi9cbiAgICBtb3ZlU2hpZnRTZWxlY3Q6IGZ1bmN0aW9uKGdyaWQsIG9mZnNldFkpIHtcblxuICAgICAgICB2YXIgbWF4Um93cyA9IGdyaWQuZ2V0Um93Q291bnQoKSAtIDE7XG5cbiAgICAgICAgdmFyIG1heFZpZXdhYmxlUm93cyA9IGdyaWQuZ2V0VmlzaWJsZVJvd3MoKSAtIDE7XG5cbiAgICAgICAgaWYgKCFncmlkLnJlc29sdmVQcm9wZXJ0eSgnc2Nyb2xsaW5nRW5hYmxlZCcpKSB7XG4gICAgICAgICAgICBtYXhSb3dzID0gTWF0aC5taW4obWF4Um93cywgbWF4Vmlld2FibGVSb3dzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBvcmlnaW4gPSBncmlkLmdldE1vdXNlRG93bigpO1xuICAgICAgICB2YXIgZXh0ZW50ID0gZ3JpZC5nZXREcmFnRXh0ZW50KCk7XG5cbiAgICAgICAgdmFyIG5ld1kgPSBleHRlbnQueSArIG9mZnNldFk7XG4gICAgICAgIC8vdmFyIG5ld1kgPSBncmlkLmdldFJvd0NvdW50KCk7XG5cbiAgICAgICAgbmV3WSA9IE1hdGgubWluKG1heFJvd3MgLSBvcmlnaW4ueSwgTWF0aC5tYXgoLW9yaWdpbi55LCBuZXdZKSk7XG5cbiAgICAgICAgZ3JpZC5jbGVhck1vc3RSZWNlbnRSb3dTZWxlY3Rpb24oKTtcbiAgICAgICAgZ3JpZC5zZWxlY3RSb3cob3JpZ2luLnksIG9yaWdpbi55ICsgbmV3WSk7XG5cbiAgICAgICAgZ3JpZC5zZXREcmFnRXh0ZW50KGdyaWQubmV3UG9pbnQoMCwgbmV3WSkpO1xuXG4gICAgICAgIGlmIChncmlkLmluc3VyZU1vZGVsUm93SXNWaXNpYmxlKG5ld1kgKyBvcmlnaW4ueSwgb2Zmc2V0WSkpIHtcbiAgICAgICAgICAgIHRoaXMucGluZ0F1dG9TY3JvbGwoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGdyaWQuZmlyZVN5bnRoZXRpY1Jvd1NlbGVjdGlvbkNoYW5nZWRFdmVudCgpO1xuICAgICAgICBncmlkLnJlcGFpbnQoKTtcblxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgUm93U2VsZWN0aW9uLnByb3RvdHlwZVxuICAgICAqIEBkZXNjIFJlcGxhY2UgdGhlIG1vc3QgcmVjZW50IHNlbGVjdGlvbiB3aXRoIGEgc2luZ2xlIGNlbGwgc2VsZWN0aW9uIHRoYXQgaXMgbW92ZWQgKG9mZnNldFgsb2Zmc2V0WSkgZnJvbSB0aGUgcHJldmlvdXMgc2VsZWN0aW9uIGV4dGVudC5cbiAgICAgKiBAcGFyYW0ge0h5cGVyZ3JpZH0gZ3JpZFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXRYIC0geCBjb29yZGluYXRlIHRvIHN0YXJ0IGF0XG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG9mZnNldFkgLSB5IGNvb3JkaW5hdGUgdG8gc3RhcnQgYXRcbiAgICAgKi9cbiAgICBtb3ZlU2luZ2xlU2VsZWN0OiBmdW5jdGlvbihncmlkLCBvZmZzZXRZKSB7XG5cbiAgICAgICAgdmFyIG1heFJvd3MgPSBncmlkLmdldFJvd0NvdW50KCkgLSAxO1xuXG4gICAgICAgIHZhciBtYXhWaWV3YWJsZVJvd3MgPSBncmlkLmdldFZpc2libGVSb3dzQ291bnQoKSAtIDE7XG5cbiAgICAgICAgaWYgKCFncmlkLnJlc29sdmVQcm9wZXJ0eSgnc2Nyb2xsaW5nRW5hYmxlZCcpKSB7XG4gICAgICAgICAgICBtYXhSb3dzID0gTWF0aC5taW4obWF4Um93cywgbWF4Vmlld2FibGVSb3dzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBtb3VzZUNvcm5lciA9IGdyaWQuZ2V0TW91c2VEb3duKCkucGx1cyhncmlkLmdldERyYWdFeHRlbnQoKSk7XG5cbiAgICAgICAgdmFyIG5ld1kgPSBtb3VzZUNvcm5lci55ICsgb2Zmc2V0WTtcbiAgICAgICAgLy92YXIgbmV3WSA9IGdyaWQuZ2V0Um93Q291bnQoKTtcblxuICAgICAgICBuZXdZID0gTWF0aC5taW4obWF4Um93cywgTWF0aC5tYXgoMCwgbmV3WSkpO1xuXG4gICAgICAgIGdyaWQuY2xlYXJTZWxlY3Rpb25zKCk7XG4gICAgICAgIGdyaWQuc2VsZWN0Um93KG5ld1kpO1xuICAgICAgICBncmlkLnNldE1vdXNlRG93bihncmlkLm5ld1BvaW50KDAsIG5ld1kpKTtcbiAgICAgICAgZ3JpZC5zZXREcmFnRXh0ZW50KGdyaWQubmV3UG9pbnQoMCwgMCkpO1xuXG4gICAgICAgIGlmIChncmlkLmluc3VyZU1vZGVsUm93SXNWaXNpYmxlKG5ld1ksIG9mZnNldFkpKSB7XG4gICAgICAgICAgICB0aGlzLnBpbmdBdXRvU2Nyb2xsKCk7XG4gICAgICAgIH1cblxuICAgICAgICBncmlkLmZpcmVTeW50aGV0aWNSb3dTZWxlY3Rpb25DaGFuZ2VkRXZlbnQoKTtcbiAgICAgICAgZ3JpZC5yZXBhaW50KCk7XG5cbiAgICB9LFxuXG4gICAgaXNTaW5nbGVSb3dTZWxlY3Rpb246IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJvd1NlbGVjdGlvbjtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEZlYXR1cmUgPSByZXF1aXJlKCcuL0ZlYXR1cmUuanMnKTtcblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIFRodW1id2hlZWxTY3JvbGxpbmcgPSBGZWF0dXJlLmV4dGVuZCgnVGh1bWJ3aGVlbFNjcm9sbGluZycsIHtcblxuICAgIGFsaWFzOiAnVGh1bWJ3aGVlbFNjcm9sbGluZycsXG5cbiAgICAvKipcbiAgICAgKiBAbWVtYmVyT2YgVGh1bWJ3aGVlbFNjcm9sbGluZy5wcm90b3R5cGVcbiAgICAgKiBAZGVzYyBoYW5kbGUgdGhpcyBldmVudCBkb3duIHRoZSBmZWF0dXJlIGNoYWluIG9mIHJlc3BvbnNpYmlsaXR5XG4gICAgICogQHBhcmFtIHtIeXBlcmdyaWR9IGdyaWRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQgLSB0aGUgZXZlbnQgZGV0YWlsc1xuICAgICAqL1xuICAgIGhhbmRsZVdoZWVsTW92ZWQ6IGZ1bmN0aW9uKGdyaWQsIGUpIHtcbiAgICAgICAgaWYgKCFncmlkLnJlc29sdmVQcm9wZXJ0eSgnc2Nyb2xsaW5nRW5hYmxlZCcpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHByaW1FdmVudCA9IGUucHJpbWl0aXZlRXZlbnQ7XG4gICAgICAgIHZhciBkZWx0YVkgPSBwcmltRXZlbnQud2hlZWxEZWx0YVkgfHwgLXByaW1FdmVudC5kZWx0YVk7XG4gICAgICAgIHZhciBkZWx0YVggPSBwcmltRXZlbnQud2hlZWxEZWx0YVggfHwgLXByaW1FdmVudC5kZWx0YVg7XG4gICAgICAgIGlmIChkZWx0YVkgPiAwKSB7XG4gICAgICAgICAgICBncmlkLnNjcm9sbEJ5KDAsIC0xKTtcbiAgICAgICAgfSBlbHNlIGlmIChkZWx0YVkgPCAtMCkge1xuICAgICAgICAgICAgZ3JpZC5zY3JvbGxCeSgwLCAxKTtcbiAgICAgICAgfSBlbHNlIGlmIChkZWx0YVggPiAwKSB7XG4gICAgICAgICAgICBncmlkLnNjcm9sbEJ5KC0xLCAwKTtcbiAgICAgICAgfSBlbHNlIGlmIChkZWx0YVggPCAtMCkge1xuICAgICAgICAgICAgZ3JpZC5zY3JvbGxCeSgxLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxufSk7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBUaHVtYndoZWVsU2Nyb2xsaW5nO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBGZWF0dXJlOiByZXF1aXJlKCcuL0ZlYXR1cmUnKSwgLy8gYWJzdHJhY3QgYmFzZSBjbGFzc1xuICAgIENlbGxDbGljazogcmVxdWlyZSgnLi9DZWxsQ2xpY2snKSxcbiAgICBDZWxsRWRpdGluZzogcmVxdWlyZSgnLi9DZWxsRWRpdGluZycpLFxuICAgIENlbGxTZWxlY3Rpb246IHJlcXVpcmUoJy4vQ2VsbFNlbGVjdGlvbicpLFxuICAgIENvbHVtbkF1dG9zaXppbmc6IHJlcXVpcmUoJy4vQ29sdW1uQXV0b3NpemluZycpLFxuICAgIENvbHVtbk1vdmluZzogcmVxdWlyZSgnLi9Db2x1bW5Nb3ZpbmcnKSxcbiAgICBDb2x1bW5SZXNpemluZzogcmVxdWlyZSgnLi9Db2x1bW5SZXNpemluZycpLFxuICAgIENvbHVtblNlbGVjdGlvbjogcmVxdWlyZSgnLi9Db2x1bW5TZWxlY3Rpb24nKSxcbiAgICBDb2x1bW5Tb3J0aW5nOiByZXF1aXJlKCcuL0NvbHVtblNvcnRpbmcnKSxcbiAgICBGaWx0ZXJzOiByZXF1aXJlKCcuL0ZpbHRlcnMnKSxcbiAgICBLZXlQYWdpbmc6IHJlcXVpcmUoJy4vS2V5UGFnaW5nJyksXG4gICAgT25Ib3ZlcjogcmVxdWlyZSgnLi9PbkhvdmVyJyksXG4gICAgT3ZlcmxheTogcmVxdWlyZSgnLi9PdmVybGF5JyksXG4gICAgUm93UmVzaXppbmc6IHJlcXVpcmUoJy4vUm93UmVzaXppbmcnKSxcbiAgICBSb3dTZWxlY3Rpb246IHJlcXVpcmUoJy4vUm93U2VsZWN0aW9uJyksXG4gICAgVGh1bWJ3aGVlbFNjcm9sbGluZzogcmVxdWlyZSgnLi9UaHVtYndoZWVsU2Nyb2xsaW5nJylcbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgY3NzSW5qZWN0b3IgPSByZXF1aXJlKCdjc3MtaW5qZWN0b3InKTtcblxudmFyIHN0eWxlc2hlZXRzID0ge1xuICAgIGdyaWQ6IFtcbiAgICAgICAgJ2RpdiNncmlkLWNvbnRhaW5lciB7JyxcbiAgICAgICAgJyAgICBwb3NpdGlvbjogcmVsYXRpdmU7JyxcbiAgICAgICAgJyAgICBkaXNwbGF5OiBpbmxpbmUtYmxvY2s7JyxcbiAgICAgICAgJyAgICAtd2Via2l0LXVzZXItc2VsZWN0OiBub25lOycsXG4gICAgICAgICcgICAgLW1vei11c2VyLXNlbGVjdDogbm9uZTsnLFxuICAgICAgICAnICAgIC1tcy11c2VyLXNlbGVjdDogbm9uZTsnLFxuICAgICAgICAnICAgIC1vLXVzZXItc2VsZWN0OiBub25lOycsXG4gICAgICAgICcgICAgdXNlci1zZWxlY3Q6IG5vbmU7JyxcbiAgICAgICAgJyAgICBvdmVyZmxvdzogaGlkZGVuOyB9JyxcbiAgICAgICAgJ3Zpc2libGUgeyBvcGFjaXR5OiAwLjc1OyB9JyxcbiAgICAgICAgJ2hpZGRlbiB7IG9wYWNpdHk6IDAuMDsgfScsXG4gICAgICAgICdlZGl0b3IgeycsXG4gICAgICAgICcgICAgcG9zaXRpb246IGFic29sdXRlOycsXG4gICAgICAgICcgICAgZGlzcGxheTogbm9uZTsnLFxuICAgICAgICAnICAgIGJvcmRlcjogc29saWQgMnB4IGJsYWNrOycsXG4gICAgICAgICcgICAgb3V0bGluZTogMDsnLFxuICAgICAgICAnICAgIHBhZGRpbmc6IDA7JyxcbiAgICAgICAgJyAgICB6LWluZGV4OiAxMDAwOyB9J1xuICAgIF0sXG4gICAgZG5kOiBbXG4gICAgICAgICdkaXYuZHJhZ29uLWxpc3QsIGxpLmRyYWdvbi1wb3AgeycsXG4gICAgICAgICcgICAgZm9udC1mYW1pbHk6IFJvYm90bywgc2Fucy1zZXJpZjsnLFxuICAgICAgICAnICAgIHRleHQtdHJhbnNmb3JtOiBjYXBpdGFsaXplOyB9JyxcbiAgICAgICAgJ2Rpdi5kcmFnb24tbGlzdCB7JyxcbiAgICAgICAgJyAgICBwb3NpdGlvbjogYWJzb2x1dGU7JyxcbiAgICAgICAgJyAgICB0b3A6IDQlOycsXG4gICAgICAgICcgICAgbGVmdDogNCU7JyxcbiAgICAgICAgJyAgICBoZWlnaHQ6IDkyJTsnLFxuICAgICAgICAnICAgIHdpZHRoOiAyMCU7IH0nLFxuICAgICAgICAnZGl2LmRyYWdvbi1saXN0Om50aC1jaGlsZCgyKSB7IGxlZnQ6IDI4JTsgfScsXG4gICAgICAgICdkaXYuZHJhZ29uLWxpc3Q6bnRoLWNoaWxkKDMpIHsgbGVmdDogNTIlOyB9JyxcbiAgICAgICAgJ2Rpdi5kcmFnb24tbGlzdDpudGgtY2hpbGQoNCkgeyBsZWZ0OiA3NiU7IH0nLFxuICAgICAgICAnZGl2LmRyYWdvbi1saXN0ID4gZGl2LCBkaXYuZHJhZ29uLWxpc3QgPiB1bCA+IGxpLCBsaS5kcmFnb24tcG9wIHsgbGluZS1oZWlnaHQ6IDQ2cHg7IH0nLFxuICAgICAgICAnZGl2LmRyYWdvbi1saXN0ID4gdWwgeyB0b3A6IDQ2cHg7IH0nLFxuICAgICAgICAnZGl2LmRyYWdvbi1saXN0ID4gdWwgPiBsaTpub3QoOmxhc3QtY2hpbGQpOjpiZWZvcmUsIGxpLmRyYWdvbi1wb3A6OmJlZm9yZSB7JyxcbiAgICAgICAgJyAgICBjb250ZW50OiBcXCdcXFxcMmIyNFxcJzsnLCAvLyBCTEFDSyBMQVJHRSBDSVJDTEVcbiAgICAgICAgJyAgICBjb2xvcjogI2I2YjZiNjsnLFxuICAgICAgICAnICAgIGZvbnQtc2l6ZTogMzBweDsnLFxuICAgICAgICAnICAgIG1hcmdpbjogOHB4IDE0cHggOHB4IDhweDsgfScsXG4gICAgICAgICdsaS5kcmFnb24tcG9wIHsgb3BhY2l0eTouODsgfSdcbiAgICBdXG59O1xuXG5mdW5jdGlvbiBhZGRTdHlsZXNoZWV0KGtleSwgcmVmZXJlbmNlRWxlbWVudCkge1xuICAgIGNzc0luamVjdG9yKHN0eWxlc2hlZXRzW2tleV0sIGtleSwgcmVmZXJlbmNlRWxlbWVudCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYWRkU3R5bGVzaGVldDtcbiJdfQ==
